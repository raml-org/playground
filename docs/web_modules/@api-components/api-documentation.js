/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = new WeakMap();
/**
 * Brands a function as a directive factory function so that lit-html will call
 * the function during template rendering, rather than passing as a value.
 *
 * A _directive_ is a function that takes a Part as an argument. It has the
 * signature: `(part: Part) => void`.
 *
 * A directive _factory_ is a function that takes arguments for data and
 * configuration and returns a directive. Users of directive usually refer to
 * the directive factory as the directive. For example, "The repeat directive".
 *
 * Usually a template author will invoke a directive factory in their template
 * with relevant arguments, which will then return a directive function.
 *
 * Here's an example of using the `repeat()` directive factory that takes an
 * array and a function to render an item:
 *
 * ```js
 * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
 * ```
 *
 * When `repeat` is invoked, it returns a directive function that closes over
 * `items` and the template function. When the outer template is rendered, the
 * return directive function is called with the Part for the expression.
 * `repeat` then performs it's custom logic to render multiple items.
 *
 * @param f The directive factory function. Must be a function that returns a
 * function of the signature `(part: Part) => void`. The returned function will
 * be called with the part object.
 *
 * @example
 *
 * import {directive, html} from 'lit-html';
 *
 * const immutable = directive((v) => (part) => {
 *   if (part.value !== v) {
 *     part.setValue(v)
 *   }
 * });
 */
const directive = (f) => ((...args) => {
    const d = f(...args);
    directives.set(d, true);
    return d;
});
const isDirective = (o) => {
    return typeof o === 'function' && directives.has(o);
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * True if the custom elements polyfill is in use.
 */
const isCEPolyfill = window.customElements !== undefined &&
    window.customElements.polyfillWrapFlushCallback !==
        undefined;
/**
 * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
 * into another container (could be the same container), before `before`. If
 * `before` is null, it appends the nodes to the container.
 */
const reparentNodes = (container, start, end = null, before = null) => {
    while (start !== end) {
        const n = start.nextSibling;
        container.insertBefore(start, before);
        start = n;
    }
};
/**
 * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
 * `container`.
 */
const removeNodes = (container, start, end = null) => {
    while (start !== end) {
        const n = start.nextSibling;
        container.removeChild(start);
        start = n;
    }
};

/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = {};
/**
 * A sentinel value that signals a NodePart to fully clear its content.
 */
const nothing = {};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
/**
 * An expression marker used text-positions, multi-binding attributes, and
 * attributes with markup-like text values.
 */
const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
/**
 * Suffix appended to all bound attribute names.
 */
const boundAttributeSuffix = '$lit$';
/**
 * An updateable Template that tracks the location of dynamic parts.
 */
class Template {
    constructor(result, element) {
        this.parts = [];
        this.element = element;
        const nodesToRemove = [];
        const stack = [];
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
        // Keeps track of the last index associated with a part. We try to delete
        // unnecessary nodes, but we never want to associate two different parts
        // to the same index. They must have a constant node between.
        let lastPartIndex = 0;
        let index = -1;
        let partIndex = 0;
        const { strings, values: { length } } = result;
        while (partIndex < length) {
            const node = walker.nextNode();
            if (node === null) {
                // We've exhausted the content inside a nested template element.
                // Because we still have parts (the outer for-loop), we know:
                // - There is a template in the stack
                // - The walker will find a nextNode outside the template
                walker.currentNode = stack.pop();
                continue;
            }
            index++;
            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                if (node.hasAttributes()) {
                    const attributes = node.attributes;
                    const { length } = attributes;
                    // Per
                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                    // attributes are not guaranteed to be returned in document order.
                    // In particular, Edge/IE can return them out of order, so we cannot
                    // assume a correspondence between part index and attribute index.
                    let count = 0;
                    for (let i = 0; i < length; i++) {
                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                            count++;
                        }
                    }
                    while (count-- > 0) {
                        // Get the template literal section leading up to the first
                        // expression in this attribute
                        const stringForPart = strings[partIndex];
                        // Find the attribute name
                        const name = lastAttributeNameRegex.exec(stringForPart)[2];
                        // Find the corresponding attribute
                        // All bound attributes have had a suffix added in
                        // TemplateResult#getHTML to opt out of special attribute
                        // handling. To look up the attribute value we also need to add
                        // the suffix.
                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                        const attributeValue = node.getAttribute(attributeLookupName);
                        node.removeAttribute(attributeLookupName);
                        const statics = attributeValue.split(markerRegex);
                        this.parts.push({ type: 'attribute', index, name, strings: statics });
                        partIndex += statics.length - 1;
                    }
                }
                if (node.tagName === 'TEMPLATE') {
                    stack.push(node);
                    walker.currentNode = node.content;
                }
            }
            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                const data = node.data;
                if (data.indexOf(marker) >= 0) {
                    const parent = node.parentNode;
                    const strings = data.split(markerRegex);
                    const lastIndex = strings.length - 1;
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        let insert;
                        let s = strings[i];
                        if (s === '') {
                            insert = createMarker();
                        }
                        else {
                            const match = lastAttributeNameRegex.exec(s);
                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                s = s.slice(0, match.index) + match[1] +
                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                            }
                            insert = document.createTextNode(s);
                        }
                        parent.insertBefore(insert, node);
                        this.parts.push({ type: 'node', index: ++index });
                    }
                    // If there's no text, we must insert a comment to mark our place.
                    // Else, we can trust it will stick around after cloning.
                    if (strings[lastIndex] === '') {
                        parent.insertBefore(createMarker(), node);
                        nodesToRemove.push(node);
                    }
                    else {
                        node.data = strings[lastIndex];
                    }
                    // We have a part for each match found
                    partIndex += lastIndex;
                }
            }
            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                if (node.data === marker) {
                    const parent = node.parentNode;
                    // Add a new marker node to be the startNode of the Part if any of
                    // the following are true:
                    //  * We don't have a previousSibling
                    //  * The previousSibling is already the start of a previous part
                    if (node.previousSibling === null || index === lastPartIndex) {
                        index++;
                        parent.insertBefore(createMarker(), node);
                    }
                    lastPartIndex = index;
                    this.parts.push({ type: 'node', index });
                    // If we don't have a nextSibling, keep this node so we have an end.
                    // Else, we can remove it to save future costs.
                    if (node.nextSibling === null) {
                        node.data = '';
                    }
                    else {
                        nodesToRemove.push(node);
                        index--;
                    }
                    partIndex++;
                }
                else {
                    let i = -1;
                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                        // Comment node has a binding marker inside, make an inactive part
                        // The binding won't work, but subsequent bindings will
                        // TODO (justinfagnani): consider whether it's even worth it to
                        // make bindings in comments work
                        this.parts.push({ type: 'node', index: -1 });
                        partIndex++;
                    }
                }
            }
        }
        // Remove text binding nodes after the walk to not disturb the TreeWalker
        for (const n of nodesToRemove) {
            n.parentNode.removeChild(n);
        }
    }
}
const endsWith = (str, suffix) => {
    const index = str.length - suffix.length;
    return index >= 0 && str.slice(index) === suffix;
};
const isTemplatePartActive = (part) => part.index !== -1;
// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
const createMarker = () => document.createComment('');
/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-characters
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
 * space character except " ".
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */
const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */
class TemplateInstance {
    constructor(template, processor, options) {
        this.__parts = [];
        this.template = template;
        this.processor = processor;
        this.options = options;
    }
    update(values) {
        let i = 0;
        for (const part of this.__parts) {
            if (part !== undefined) {
                part.setValue(values[i]);
            }
            i++;
        }
        for (const part of this.__parts) {
            if (part !== undefined) {
                part.commit();
            }
        }
    }
    _clone() {
        // There are a number of steps in the lifecycle of a template instance's
        // DOM fragment:
        //  1. Clone - create the instance fragment
        //  2. Adopt - adopt into the main document
        //  3. Process - find part markers and create parts
        //  4. Upgrade - upgrade custom elements
        //  5. Update - set node, attribute, property, etc., values
        //  6. Connect - connect to the document. Optional and outside of this
        //     method.
        //
        // We have a few constraints on the ordering of these steps:
        //  * We need to upgrade before updating, so that property values will pass
        //    through any property setters.
        //  * We would like to process before upgrading so that we're sure that the
        //    cloned fragment is inert and not disturbed by self-modifying DOM.
        //  * We want custom elements to upgrade even in disconnected fragments.
        //
        // Given these constraints, with full custom elements support we would
        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
        //
        // But Safari dooes not implement CustomElementRegistry#upgrade, so we
        // can not implement that order and still have upgrade-before-update and
        // upgrade disconnected fragments. So we instead sacrifice the
        // process-before-upgrade constraint, since in Custom Elements v1 elements
        // must not modify their light DOM in the constructor. We still have issues
        // when co-existing with CEv0 elements like Polymer 1, and with polyfills
        // that don't strictly adhere to the no-modification rule because shadow
        // DOM, which may be created in the constructor, is emulated by being placed
        // in the light DOM.
        //
        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
        // in one step.
        //
        // The Custom Elements v1 polyfill supports upgrade(), so the order when
        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
        // Connect.
        const fragment = isCEPolyfill ?
            this.template.element.content.cloneNode(true) :
            document.importNode(this.template.element.content, true);
        const stack = [];
        const parts = this.template.parts;
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
        let partIndex = 0;
        let nodeIndex = 0;
        let part;
        let node = walker.nextNode();
        // Loop through all the nodes and parts of a template
        while (partIndex < parts.length) {
            part = parts[partIndex];
            if (!isTemplatePartActive(part)) {
                this.__parts.push(undefined);
                partIndex++;
                continue;
            }
            // Progress the tree walker until we find our next part's node.
            // Note that multiple parts may share the same node (attribute parts
            // on a single element), so this loop may not run at all.
            while (nodeIndex < part.index) {
                nodeIndex++;
                if (node.nodeName === 'TEMPLATE') {
                    stack.push(node);
                    walker.currentNode = node.content;
                }
                if ((node = walker.nextNode()) === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    node = walker.nextNode();
                }
            }
            // We've arrived at our part's node.
            if (part.type === 'node') {
                const part = this.processor.handleTextExpression(this.options);
                part.insertAfterNode(node.previousSibling);
                this.__parts.push(part);
            }
            else {
                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
            }
            partIndex++;
        }
        if (isCEPolyfill) {
            document.adoptNode(fragment);
            customElements.upgrade(fragment);
        }
        return fragment;
    }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const commentMarker = ` ${marker} `;
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
class TemplateResult {
    constructor(strings, values, type, processor) {
        this.strings = strings;
        this.values = values;
        this.type = type;
        this.processor = processor;
    }
    /**
     * Returns a string of HTML used to create a `<template>` element.
     */
    getHTML() {
        const l = this.strings.length - 1;
        let html = '';
        let isCommentBinding = false;
        for (let i = 0; i < l; i++) {
            const s = this.strings[i];
            // For each binding we want to determine the kind of marker to insert
            // into the template source before it's parsed by the browser's HTML
            // parser. The marker type is based on whether the expression is in an
            // attribute, text, or comment poisition.
            //   * For node-position bindings we insert a comment with the marker
            //     sentinel as its text content, like <!--{{lit-guid}}-->.
            //   * For attribute bindings we insert just the marker sentinel for the
            //     first binding, so that we support unquoted attribute bindings.
            //     Subsequent bindings can use a comment marker because multi-binding
            //     attributes must be quoted.
            //   * For comment bindings we insert just the marker sentinel so we don't
            //     close the comment.
            //
            // The following code scans the template source, but is *not* an HTML
            // parser. We don't need to track the tree structure of the HTML, only
            // whether a binding is inside a comment, and if not, if it appears to be
            // the first binding in an attribute.
            const commentOpen = s.lastIndexOf('<!--');
            // We're in comment position if we have a comment open with no following
            // comment close. Because <-- can appear in an attribute value there can
            // be false positives.
            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                s.indexOf('-->', commentOpen + 1) === -1;
            // Check to see if we have an attribute-like sequence preceeding the
            // expression. This can match "name=value" like structures in text,
            // comments, and attribute values, so there can be false-positives.
            const attributeMatch = lastAttributeNameRegex.exec(s);
            if (attributeMatch === null) {
                // We're only in this branch if we don't have a attribute-like
                // preceeding sequence. For comments, this guards against unusual
                // attribute values like <div foo="<!--${'bar'}">. Cases like
                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                // below.
                html += s + (isCommentBinding ? commentMarker : nodeMarker);
            }
            else {
                // For attributes we use just a marker sentinel, and also append a
                // $lit$ suffix to the name to opt-out of attribute-specific parsing
                // that IE and Edge do for style and certain SVG attributes.
                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                    marker;
            }
        }
        html += this.strings[l];
        return html;
    }
    getTemplateElement() {
        const template = document.createElement('template');
        template.innerHTML = this.getHTML();
        return template;
    }
}
/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the `<svg>` tag so that
 * clones only container the original fragment.
 */
class SVGTemplateResult extends TemplateResult {
    getHTML() {
        return `<svg>${super.getHTML()}</svg>`;
    }
    getTemplateElement() {
        const template = super.getTemplateElement();
        const content = template.content;
        const svgElement = content.firstChild;
        content.removeChild(svgElement);
        reparentNodes(content, svgElement.firstChild);
        return template;
    }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isPrimitive = (value) => {
    return (value === null ||
        !(typeof value === 'object' || typeof value === 'function'));
};
const isIterable = (value) => {
    return Array.isArray(value) ||
        // tslint:disable-next-line:no-any
        !!(value && value[Symbol.iterator]);
};
/**
 * Writes attribute values to the DOM for a group of AttributeParts bound to a
 * single attibute. The value is only set once even if there are multiple parts
 * for an attribute.
 */
class AttributeCommitter {
    constructor(element, name, strings) {
        this.dirty = true;
        this.element = element;
        this.name = name;
        this.strings = strings;
        this.parts = [];
        for (let i = 0; i < strings.length - 1; i++) {
            this.parts[i] = this._createPart();
        }
    }
    /**
     * Creates a single part. Override this to create a differnt type of part.
     */
    _createPart() {
        return new AttributePart(this);
    }
    _getValue() {
        const strings = this.strings;
        const l = strings.length - 1;
        let text = '';
        for (let i = 0; i < l; i++) {
            text += strings[i];
            const part = this.parts[i];
            if (part !== undefined) {
                const v = part.value;
                if (isPrimitive(v) || !isIterable(v)) {
                    text += typeof v === 'string' ? v : String(v);
                }
                else {
                    for (const t of v) {
                        text += typeof t === 'string' ? t : String(t);
                    }
                }
            }
        }
        text += strings[l];
        return text;
    }
    commit() {
        if (this.dirty) {
            this.dirty = false;
            this.element.setAttribute(this.name, this._getValue());
        }
    }
}
/**
 * A Part that controls all or part of an attribute value.
 */
class AttributePart {
    constructor(committer) {
        this.value = undefined;
        this.committer = committer;
    }
    setValue(value) {
        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
            this.value = value;
            // If the value is a not a directive, dirty the committer so that it'll
            // call setAttribute. If the value is a directive, it'll dirty the
            // committer if it calls setValue().
            if (!isDirective(value)) {
                this.committer.dirty = true;
            }
        }
    }
    commit() {
        while (isDirective(this.value)) {
            const directive = this.value;
            this.value = noChange;
            directive(this);
        }
        if (this.value === noChange) {
            return;
        }
        this.committer.commit();
    }
}
/**
 * A Part that controls a location within a Node tree. Like a Range, NodePart
 * has start and end locations and can set and update the Nodes between those
 * locations.
 *
 * NodeParts support several value types: primitives, Nodes, TemplateResults,
 * as well as arrays and iterables of those types.
 */
class NodePart {
    constructor(options) {
        this.value = undefined;
        this.__pendingValue = undefined;
        this.options = options;
    }
    /**
     * Appends this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendInto(container) {
        this.startNode = container.appendChild(createMarker());
        this.endNode = container.appendChild(createMarker());
    }
    /**
     * Inserts this part after the `ref` node (between `ref` and `ref`'s next
     * sibling). Both `ref` and its next sibling must be static, unchanging nodes
     * such as those that appear in a literal section of a template.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterNode(ref) {
        this.startNode = ref;
        this.endNode = ref.nextSibling;
    }
    /**
     * Appends this part into a parent part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendIntoPart(part) {
        part.__insert(this.startNode = createMarker());
        part.__insert(this.endNode = createMarker());
    }
    /**
     * Inserts this part after the `ref` part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterPart(ref) {
        ref.__insert(this.startNode = createMarker());
        this.endNode = ref.endNode;
        ref.endNode = this.startNode;
    }
    setValue(value) {
        this.__pendingValue = value;
    }
    commit() {
        while (isDirective(this.__pendingValue)) {
            const directive = this.__pendingValue;
            this.__pendingValue = noChange;
            directive(this);
        }
        const value = this.__pendingValue;
        if (value === noChange) {
            return;
        }
        if (isPrimitive(value)) {
            if (value !== this.value) {
                this.__commitText(value);
            }
        }
        else if (value instanceof TemplateResult) {
            this.__commitTemplateResult(value);
        }
        else if (value instanceof Node) {
            this.__commitNode(value);
        }
        else if (isIterable(value)) {
            this.__commitIterable(value);
        }
        else if (value === nothing) {
            this.value = nothing;
            this.clear();
        }
        else {
            // Fallback, will render the string representation
            this.__commitText(value);
        }
    }
    __insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    __commitNode(value) {
        if (this.value === value) {
            return;
        }
        this.clear();
        this.__insert(value);
        this.value = value;
    }
    __commitText(value) {
        const node = this.startNode.nextSibling;
        value = value == null ? '' : value;
        // If `value` isn't already a string, we explicitly convert it here in case
        // it can't be implicitly converted - i.e. it's a symbol.
        const valueAsString = typeof value === 'string' ? value : String(value);
        if (node === this.endNode.previousSibling &&
            node.nodeType === 3 /* Node.TEXT_NODE */) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if this.value is primitive?
            node.data = valueAsString;
        }
        else {
            this.__commitNode(document.createTextNode(valueAsString));
        }
        this.value = value;
    }
    __commitTemplateResult(value) {
        const template = this.options.templateFactory(value);
        if (this.value instanceof TemplateInstance &&
            this.value.template === template) {
            this.value.update(value.values);
        }
        else {
            // Make sure we propagate the template processor from the TemplateResult
            // so that we use its syntax extension, etc. The template factory comes
            // from the render function options so that it can control template
            // caching and preprocessing.
            const instance = new TemplateInstance(template, value.processor, this.options);
            const fragment = instance._clone();
            instance.update(value.values);
            this.__commitNode(fragment);
            this.value = instance;
        }
    }
    __commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _value is an array, then the previous render was of an
        // iterable and _value will contain the NodeParts from the previous
        // render. If _value is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this.value)) {
            this.value = [];
            this.clear();
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this.value;
        let partIndex = 0;
        let itemPart;
        for (const item of value) {
            // Try to reuse an existing part
            itemPart = itemParts[partIndex];
            // If no existing part, create a new one
            if (itemPart === undefined) {
                itemPart = new NodePart(this.options);
                itemParts.push(itemPart);
                if (partIndex === 0) {
                    itemPart.appendIntoPart(this);
                }
                else {
                    itemPart.insertAfterPart(itemParts[partIndex - 1]);
                }
            }
            itemPart.setValue(item);
            itemPart.commit();
            partIndex++;
        }
        if (partIndex < itemParts.length) {
            // Truncate the parts array so _value reflects the current state
            itemParts.length = partIndex;
            this.clear(itemPart && itemPart.endNode);
        }
    }
    clear(startNode = this.startNode) {
        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
    }
}
/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */
class BooleanAttributePart {
    constructor(element, name, strings) {
        this.value = undefined;
        this.__pendingValue = undefined;
        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
            throw new Error('Boolean attributes can only contain a single expression');
        }
        this.element = element;
        this.name = name;
        this.strings = strings;
    }
    setValue(value) {
        this.__pendingValue = value;
    }
    commit() {
        while (isDirective(this.__pendingValue)) {
            const directive = this.__pendingValue;
            this.__pendingValue = noChange;
            directive(this);
        }
        if (this.__pendingValue === noChange) {
            return;
        }
        const value = !!this.__pendingValue;
        if (this.value !== value) {
            if (value) {
                this.element.setAttribute(this.name, '');
            }
            else {
                this.element.removeAttribute(this.name);
            }
            this.value = value;
        }
        this.__pendingValue = noChange;
    }
}
/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */
class PropertyCommitter extends AttributeCommitter {
    constructor(element, name, strings) {
        super(element, name, strings);
        this.single =
            (strings.length === 2 && strings[0] === '' && strings[1] === '');
    }
    _createPart() {
        return new PropertyPart(this);
    }
    _getValue() {
        if (this.single) {
            return this.parts[0].value;
        }
        return super._getValue();
    }
    commit() {
        if (this.dirty) {
            this.dirty = false;
            // tslint:disable-next-line:no-any
            this.element[this.name] = this._getValue();
        }
    }
}
class PropertyPart extends AttributePart {
}
// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let eventOptionsSupported = false;
try {
    const options = {
        get capture() {
            eventOptionsSupported = true;
            return false;
        }
    };
    // tslint:disable-next-line:no-any
    window.addEventListener('test', options, options);
    // tslint:disable-next-line:no-any
    window.removeEventListener('test', options, options);
}
catch (_e) {
}
class EventPart {
    constructor(element, eventName, eventContext) {
        this.value = undefined;
        this.__pendingValue = undefined;
        this.element = element;
        this.eventName = eventName;
        this.eventContext = eventContext;
        this.__boundHandleEvent = (e) => this.handleEvent(e);
    }
    setValue(value) {
        this.__pendingValue = value;
    }
    commit() {
        while (isDirective(this.__pendingValue)) {
            const directive = this.__pendingValue;
            this.__pendingValue = noChange;
            directive(this);
        }
        if (this.__pendingValue === noChange) {
            return;
        }
        const newListener = this.__pendingValue;
        const oldListener = this.value;
        const shouldRemoveListener = newListener == null ||
            oldListener != null &&
                (newListener.capture !== oldListener.capture ||
                    newListener.once !== oldListener.once ||
                    newListener.passive !== oldListener.passive);
        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
        if (shouldRemoveListener) {
            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }
        if (shouldAddListener) {
            this.__options = getOptions(newListener);
            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }
        this.value = newListener;
        this.__pendingValue = noChange;
    }
    handleEvent(event) {
        if (typeof this.value === 'function') {
            this.value.call(this.eventContext || this.element, event);
        }
        else {
            this.value.handleEvent(event);
        }
    }
}
// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const getOptions = (o) => o &&
    (eventOptionsSupported ?
        { capture: o.capture, passive: o.passive, once: o.once } :
        o.capture);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Creates Parts when a template is instantiated.
 */
class DefaultTemplateProcessor {
    /**
     * Create parts for an attribute-position binding, given the event, attribute
     * name, and string literals.
     *
     * @param element The element containing the binding
     * @param name  The attribute name
     * @param strings The string literals. There are always at least two strings,
     *   event for fully-controlled bindings with a single expression.
     */
    handleAttributeExpressions(element, name, strings, options) {
        const prefix = name[0];
        if (prefix === '.') {
            const committer = new PropertyCommitter(element, name.slice(1), strings);
            return committer.parts;
        }
        if (prefix === '@') {
            return [new EventPart(element, name.slice(1), options.eventContext)];
        }
        if (prefix === '?') {
            return [new BooleanAttributePart(element, name.slice(1), strings)];
        }
        const committer = new AttributeCommitter(element, name, strings);
        return committer.parts;
    }
    /**
     * Create parts for a text-position binding.
     * @param templateFactory
     */
    handleTextExpression(options) {
        return new NodePart(options);
    }
}
const defaultTemplateProcessor = new DefaultTemplateProcessor();

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */
function templateFactory(result) {
    let templateCache = templateCaches.get(result.type);
    if (templateCache === undefined) {
        templateCache = {
            stringsArray: new WeakMap(),
            keyString: new Map()
        };
        templateCaches.set(result.type, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== undefined) {
        return template;
    }
    // If the TemplateStringsArray is new, generate a key from the strings
    // This key is shared between all templates with identical content
    const key = result.strings.join(marker);
    // Check if we already have a Template for this key
    template = templateCache.keyString.get(key);
    if (template === undefined) {
        // If we have not seen this key before, create a new Template
        template = new Template(result, result.getTemplateElement());
        // Cache the Template for this key
        templateCache.keyString.set(key, template);
    }
    // Cache all future queries for this TemplateStringsArray
    templateCache.stringsArray.set(result.strings, template);
    return template;
}
const templateCaches = new Map();

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const parts = new WeakMap();
/**
 * Renders a template result or other value to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result Any value renderable by NodePart - typically a TemplateResult
 *     created by evaluating a template tag like `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param options RenderOptions for the entire render tree rendered to this
 *     container. Render options must *not* change between renders to the same
 *     container, as those changes will not effect previously rendered DOM.
 */
const render = (result, container, options) => {
    let part = parts.get(container);
    if (part === undefined) {
        removeNodes(container, container.firstChild);
        parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
        part.appendInto(container);
    }
    part.setValue(result);
    part.commit();
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for lit-html usage.
// TODO(justinfagnani): inject version number at build time
(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.1.2');
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;
/**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */
function removeNodesFromTemplate(template, nodesToRemove) {
    const { element: { content }, parts } = template;
    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
    let partIndex = nextActiveIndexInTemplateParts(parts);
    let part = parts[partIndex];
    let nodeIndex = -1;
    let removeCount = 0;
    const nodesToRemoveInTemplate = [];
    let currentRemovingNode = null;
    while (walker.nextNode()) {
        nodeIndex++;
        const node = walker.currentNode;
        // End removal if stepped past the removing node
        if (node.previousSibling === currentRemovingNode) {
            currentRemovingNode = null;
        }
        // A node to remove was found in the template
        if (nodesToRemove.has(node)) {
            nodesToRemoveInTemplate.push(node);
            // Track node we're removing
            if (currentRemovingNode === null) {
                currentRemovingNode = node;
            }
        }
        // When removing, increment count by which to adjust subsequent part indices
        if (currentRemovingNode !== null) {
            removeCount++;
        }
        while (part !== undefined && part.index === nodeIndex) {
            // If part is in a removed node deactivate it by setting index to -1 or
            // adjust the index as needed.
            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
            // go to the next active part.
            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
            part = parts[partIndex];
        }
    }
    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
}
const countNodes = (node) => {
    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;
    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
    while (walker.nextNode()) {
        count++;
    }
    return count;
};
const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
    for (let i = startIndex + 1; i < parts.length; i++) {
        const part = parts[i];
        if (isTemplatePartActive(part)) {
            return i;
        }
    }
    return -1;
};
/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */
function insertNodeIntoTemplate(template, node, refNode = null) {
    const { element: { content }, parts } = template;
    // If there's no refNode, then put node at end of template.
    // No part indices need to be shifted in this case.
    if (refNode === null || refNode === undefined) {
        content.appendChild(node);
        return;
    }
    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
    let partIndex = nextActiveIndexInTemplateParts(parts);
    let insertCount = 0;
    let walkerIndex = -1;
    while (walker.nextNode()) {
        walkerIndex++;
        const walkerNode = walker.currentNode;
        if (walkerNode === refNode) {
            insertCount = countNodes(node);
            refNode.parentNode.insertBefore(node, refNode);
        }
        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
            // If we've inserted the node, simply adjust all subsequent parts
            if (insertCount > 0) {
                while (partIndex !== -1) {
                    parts[partIndex].index += insertCount;
                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                }
                return;
            }
            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
        }
    }
}

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Get a key to lookup in `templateCaches`.
const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
let compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === 'undefined') {
    compatibleShadyCSSVersion = false;
}
else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
    console.warn(`Incompatible ShadyCSS version detected. ` +
        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +
        `@webcomponents/shadycss@1.3.1.`);
    compatibleShadyCSSVersion = false;
}
/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */
const shadyTemplateFactory = (scopeName) => (result) => {
    const cacheKey = getTemplateCacheKey(result.type, scopeName);
    let templateCache = templateCaches.get(cacheKey);
    if (templateCache === undefined) {
        templateCache = {
            stringsArray: new WeakMap(),
            keyString: new Map()
        };
        templateCaches.set(cacheKey, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== undefined) {
        return template;
    }
    const key = result.strings.join(marker);
    template = templateCache.keyString.get(key);
    if (template === undefined) {
        const element = result.getTemplateElement();
        if (compatibleShadyCSSVersion) {
            window.ShadyCSS.prepareTemplateDom(element, scopeName);
        }
        template = new Template(result, element);
        templateCache.keyString.set(key, template);
    }
    templateCache.stringsArray.set(result.strings, template);
    return template;
};
const TEMPLATE_TYPES = ['html', 'svg'];
/**
 * Removes all style elements from Templates for the given scopeName.
 */
const removeStylesFromLitTemplates = (scopeName) => {
    TEMPLATE_TYPES.forEach((type) => {
        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
        if (templates !== undefined) {
            templates.keyString.forEach((template) => {
                const { element: { content } } = template;
                // IE 11 doesn't support the iterable param Set constructor
                const styles = new Set();
                Array.from(content.querySelectorAll('style')).forEach((s) => {
                    styles.add(s);
                });
                removeNodesFromTemplate(template, styles);
            });
        }
    });
};
const shadyRenderSet = new Set();
/**
 * For the given scope name, ensures that ShadyCSS style scoping is performed.
 * This is done just once per scope name so the fragment and template cannot
 * be modified.
 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
 * to be scoped and appended to the document
 * (2) removes style elements from all lit-html Templates for this scope name.
 *
 * Note, <style> elements can only be placed into templates for the
 * initial rendering of the scope. If <style> elements are included in templates
 * dynamically rendered to the scope (after the first scope render), they will
 * not be scoped and the <style> will be left in the template and rendered
 * output.
 */
const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
    shadyRenderSet.add(scopeName);
    // If `renderedDOM` is stamped from a Template, then we need to edit that
    // Template's underlying template element. Otherwise, we create one here
    // to give to ShadyCSS, which still requires one while scoping.
    const templateElement = !!template ? template.element : document.createElement('template');
    // Move styles out of rendered DOM and store.
    const styles = renderedDOM.querySelectorAll('style');
    const { length } = styles;
    // If there are no styles, skip unnecessary work
    if (length === 0) {
        // Ensure prepareTemplateStyles is called to support adding
        // styles via `prepareAdoptedCssText` since that requires that
        // `prepareTemplateStyles` is called.
        //
        // ShadyCSS will only update styles containing @apply in the template
        // given to `prepareTemplateStyles`. If no lit Template was given,
        // ShadyCSS will not be able to update uses of @apply in any relevant
        // template. However, this is not a problem because we only create the
        // template for the purpose of supporting `prepareAdoptedCssText`,
        // which doesn't support @apply at all.
        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
        return;
    }
    const condensedStyle = document.createElement('style');
    // Collect styles into a single style. This helps us make sure ShadyCSS
    // manipulations will not prevent us from being able to fix up template
    // part indices.
    // NOTE: collecting styles is inefficient for browsers but ShadyCSS
    // currently does this anyway. When it does not, this should be changed.
    for (let i = 0; i < length; i++) {
        const style = styles[i];
        style.parentNode.removeChild(style);
        condensedStyle.textContent += style.textContent;
    }
    // Remove styles from nested templates in this scope.
    removeStylesFromLitTemplates(scopeName);
    // And then put the condensed style into the "root" template passed in as
    // `template`.
    const content = templateElement.content;
    if (!!template) {
        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
    }
    else {
        content.insertBefore(condensedStyle, content.firstChild);
    }
    // Note, it's important that ShadyCSS gets the template that `lit-html`
    // will actually render so that it can update the style inside when
    // needed (e.g. @apply native Shadow DOM case).
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    const style = content.querySelector('style');
    if (window.ShadyCSS.nativeShadow && style !== null) {
        // When in native Shadow DOM, ensure the style created by ShadyCSS is
        // included in initially rendered output (`renderedDOM`).
        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
    }
    else if (!!template) {
        // When no style is left in the template, parts will be broken as a
        // result. To fix this, we put back the style node ShadyCSS removed
        // and then tell lit to remove that node from the template.
        // There can be no style in the template in 2 cases (1) when Shady DOM
        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
        // is in use ShadyCSS removes the style if it contains no content.
        // NOTE, ShadyCSS creates its own style so we can safely add/remove
        // `condensedStyle` here.
        content.insertBefore(condensedStyle, content.firstChild);
        const removes = new Set();
        removes.add(condensedStyle);
        removeNodesFromTemplate(template, removes);
    }
};
/**
 * Extension to the standard `render` method which supports rendering
 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
 * or when the webcomponentsjs
 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
 *
 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
 * when native ShadowDOM is unavailable. The `scopeName` will be added to
 * the class attribute of all rendered DOM. In addition, any style elements will
 * be automatically re-written with this `scopeName` selector and moved out
 * of the rendered DOM and into the document `<head>`.
 *
 * It is common to use this render method in conjunction with a custom element
 * which renders a shadowRoot. When this is done, typically the element's
 * `localName` should be used as the `scopeName`.
 *
 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
 * custom properties (needed only on older browsers like IE11) and a shim for
 * a deprecated feature called `@apply` that supports applying a set of css
 * custom properties to a given location.
 *
 * Usage considerations:
 *
 * * Part values in `<style>` elements are only applied the first time a given
 * `scopeName` renders. Subsequent changes to parts in style elements will have
 * no effect. Because of this, parts in style elements should only be used for
 * values that will never change, for example parts that set scope-wide theme
 * values or parts which render shared style elements.
 *
 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
 * custom element's `constructor` is not supported. Instead rendering should
 * either done asynchronously, for example at microtask timing (for example
 * `Promise.resolve()`), or be deferred until the first time the element's
 * `connectedCallback` runs.
 *
 * Usage considerations when using shimmed custom properties or `@apply`:
 *
 * * Whenever any dynamic changes are made which affect
 * css custom properties, `ShadyCSS.styleElement(element)` must be called
 * to update the element. There are two cases when this is needed:
 * (1) the element is connected to a new parent, (2) a class is added to the
 * element that causes it to match different custom properties.
 * To address the first case when rendering a custom element, `styleElement`
 * should be called in the element's `connectedCallback`.
 *
 * * Shimmed custom properties may only be defined either for an entire
 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
 * matches an element with a shadowRoot. In other words, instead of flowing from
 * parent to child as do native css custom properties, shimmed custom properties
 * flow only from shadowRoots to nested shadowRoots.
 *
 * * When using `@apply` mixing css shorthand property names with
 * non-shorthand names (for example `border` and `border-width`) is not
 * supported.
 */
const render$1 = (result, container, options) => {
    if (!options || typeof options !== 'object' || !options.scopeName) {
        throw new Error('The `scopeName` option is required.');
    }
    const scopeName = options.scopeName;
    const hasRendered = parts.has(container);
    const needsScoping = compatibleShadyCSSVersion &&
        container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&
        !!container.host;
    // Handle first render to a scope specially...
    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
    // On first scope render, render into a fragment; this cannot be a single
    // fragment that is reused since nested renders can occur synchronously.
    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
    render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
    // When performing first scope render,
    // (1) We've rendered into a fragment so that there's a chance to
    // `prepareTemplateStyles` before sub-elements hit the DOM
    // (which might cause them to render based on a common pattern of
    // rendering in a custom element's `connectedCallback`);
    // (2) Scope the template with ShadyCSS one time only for this scope.
    // (3) Render the fragment into the container and make sure the
    // container knows its `part` is the one we just rendered. This ensures
    // DOM will be re-used on subsequent renders.
    if (firstScopeRender) {
        const part = parts.get(renderContainer);
        parts.delete(renderContainer);
        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
        // that should apply to `renderContainer` even if the rendered value is
        // not a TemplateInstance. However, it will only insert scoped styles
        // into the document if `prepareTemplateStyles` has already been called
        // for the given scope name.
        const template = part.value instanceof TemplateInstance ?
            part.value.template :
            undefined;
        prepareTemplateStyles(scopeName, renderContainer, template);
        removeNodes(container, container.firstChild);
        container.appendChild(renderContainer);
        parts.set(container, part);
    }
    // After elements have hit the DOM, update styling if this is the
    // initial render to this container.
    // This is needed whenever dynamic changes are made so it would be
    // safest to do every render; however, this would regress performance
    // so we leave it up to the user to call `ShadyCSS.styleElement`
    // for dynamic changes.
    if (!hasRendered && needsScoping) {
        window.ShadyCSS.styleElement(container.host);
    }
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var _a;
/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */
window.JSCompiler_renameProperty =
    (prop, _obj) => prop;
const defaultConverter = {
    toAttribute(value, type) {
        switch (type) {
            case Boolean:
                return value ? '' : null;
            case Object:
            case Array:
                // if the value is `null` or `undefined` pass this through
                // to allow removing/no change behavior.
                return value == null ? value : JSON.stringify(value);
        }
        return value;
    },
    fromAttribute(value, type) {
        switch (type) {
            case Boolean:
                return value !== null;
            case Number:
                return value === null ? null : Number(value);
            case Object:
            case Array:
                return JSON.parse(value);
        }
        return value;
    }
};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */
const notEqual = (value, old) => {
    // This ensures (old==NaN, value==NaN) always returns false
    return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual
};
const microtaskPromise = Promise.resolve(true);
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
const STATE_HAS_CONNECTED = 1 << 5;
/**
 * The Closure JS Compiler doesn't currently have good support for static
 * property semantics where "this" is dynamic (e.g.
 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
 * this hack to bypass any rewriting by the compiler.
 */
const finalized = 'finalized';
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */
class UpdatingElement extends HTMLElement {
    constructor() {
        super();
        this._updateState = 0;
        this._instanceProperties = undefined;
        this._updatePromise = microtaskPromise;
        this._hasConnectedResolver = undefined;
        /**
         * Map with keys for any properties that have changed since the last
         * update cycle with previous values.
         */
        this._changedProperties = new Map();
        /**
         * Map with keys of properties that should be reflected when updated.
         */
        this._reflectingProperties = undefined;
        this.initialize();
    }
    /**
     * Returns a list of attributes corresponding to the registered properties.
     * @nocollapse
     */
    static get observedAttributes() {
        // note: piggy backing on this to ensure we're finalized.
        this.finalize();
        const attributes = [];
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this._classProperties.forEach((v, p) => {
            const attr = this._attributeNameForProperty(p, v);
            if (attr !== undefined) {
                this._attributeToPropertyMap.set(attr, p);
                attributes.push(attr);
            }
        });
        return attributes;
    }
    /**
     * Ensures the private `_classProperties` property metadata is created.
     * In addition to `finalize` this is also called in `createProperty` to
     * ensure the `@property` decorator can add property metadata.
     */
    /** @nocollapse */
    static _ensureClassProperties() {
        // ensure private storage for property declarations.
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
            this._classProperties = new Map();
            // NOTE: Workaround IE11 not supporting Map constructor argument.
            const superProperties = Object.getPrototypeOf(this)._classProperties;
            if (superProperties !== undefined) {
                superProperties.forEach((v, k) => this._classProperties.set(k, v));
            }
        }
    }
    /**
     * Creates a property accessor on the element prototype if one does not exist.
     * The property setter calls the property's `hasChanged` property option
     * or uses a strict identity check to determine whether or not to request
     * an update.
     * @nocollapse
     */
    static createProperty(name, options = defaultPropertyDeclaration) {
        // Note, since this can be called by the `@property` decorator which
        // is called before `finalize`, we ensure storage exists for property
        // metadata.
        this._ensureClassProperties();
        this._classProperties.set(name, options);
        // Do not generate an accessor if the prototype already has one, since
        // it would be lost otherwise and that would never be the user's intention;
        // Instead, we expect users to call `requestUpdate` themselves from
        // user-defined accessors. Note that if the super has an accessor we will
        // still overwrite it
        if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
            return;
        }
        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
        Object.defineProperty(this.prototype, name, {
            // tslint:disable-next-line:no-any no symbol in index
            get() {
                return this[key];
            },
            set(value) {
                const oldValue = this[name];
                this[key] = value;
                this._requestUpdate(name, oldValue);
            },
            configurable: true,
            enumerable: true
        });
    }
    /**
     * Creates property accessors for registered properties and ensures
     * any superclasses are also finalized.
     * @nocollapse
     */
    static finalize() {
        // finalize any superclasses
        const superCtor = Object.getPrototypeOf(this);
        if (!superCtor.hasOwnProperty(finalized)) {
            superCtor.finalize();
        }
        this[finalized] = true;
        this._ensureClassProperties();
        // initialize Map populated in observedAttributes
        this._attributeToPropertyMap = new Map();
        // make any properties
        // Note, only process "own" properties since this element will inherit
        // any properties defined on the superClass, and finalization ensures
        // the entire prototype chain is finalized.
        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
            const props = this.properties;
            // support symbols in properties (IE11 does not support this)
            const propKeys = [
                ...Object.getOwnPropertyNames(props),
                ...(typeof Object.getOwnPropertySymbols === 'function') ?
                    Object.getOwnPropertySymbols(props) :
                    []
            ];
            // This for/of is ok because propKeys is an array
            for (const p of propKeys) {
                // note, use of `any` is due to TypeSript lack of support for symbol in
                // index types
                // tslint:disable-next-line:no-any no symbol in index
                this.createProperty(p, props[p]);
            }
        }
    }
    /**
     * Returns the property name for the given attribute `name`.
     * @nocollapse
     */
    static _attributeNameForProperty(name, options) {
        const attribute = options.attribute;
        return attribute === false ?
            undefined :
            (typeof attribute === 'string' ?
                attribute :
                (typeof name === 'string' ? name.toLowerCase() : undefined));
    }
    /**
     * Returns true if a property should request an update.
     * Called when a property value is set and uses the `hasChanged`
     * option for the property if present or a strict identity check.
     * @nocollapse
     */
    static _valueHasChanged(value, old, hasChanged = notEqual) {
        return hasChanged(value, old);
    }
    /**
     * Returns the property value for the given attribute value.
     * Called via the `attributeChangedCallback` and uses the property's
     * `converter` or `converter.fromAttribute` property option.
     * @nocollapse
     */
    static _propertyValueFromAttribute(value, options) {
        const type = options.type;
        const converter = options.converter || defaultConverter;
        const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);
        return fromAttribute ? fromAttribute(value, type) : value;
    }
    /**
     * Returns the attribute value for the given property value. If this
     * returns undefined, the property will *not* be reflected to an attribute.
     * If this returns null, the attribute will be removed, otherwise the
     * attribute will be set to the value.
     * This uses the property's `reflect` and `type.toAttribute` property options.
     * @nocollapse
     */
    static _propertyValueToAttribute(value, options) {
        if (options.reflect === undefined) {
            return;
        }
        const type = options.type;
        const converter = options.converter;
        const toAttribute = converter && converter.toAttribute ||
            defaultConverter.toAttribute;
        return toAttribute(value, type);
    }
    /**
     * Performs element initialization. By default captures any pre-set values for
     * registered properties.
     */
    initialize() {
        this._saveInstanceProperties();
        // ensures first update will be caught by an early access of
        // `updateComplete`
        this._requestUpdate();
    }
    /**
     * Fixes any properties set on the instance before upgrade time.
     * Otherwise these would shadow the accessor and break these properties.
     * The properties are stored in a Map which is played back after the
     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
     * (<=41), properties created for native platform properties like (`id` or
     * `name`) may not have default values set in the element constructor. On
     * these browsers native properties appear on instances and therefore their
     * default value will overwrite any element default (e.g. if the element sets
     * this.id = 'id' in the constructor, the 'id' will become '' since this is
     * the native platform default).
     */
    _saveInstanceProperties() {
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this.constructor
            ._classProperties.forEach((_v, p) => {
            if (this.hasOwnProperty(p)) {
                const value = this[p];
                delete this[p];
                if (!this._instanceProperties) {
                    this._instanceProperties = new Map();
                }
                this._instanceProperties.set(p, value);
            }
        });
    }
    /**
     * Applies previously saved instance properties.
     */
    _applyInstanceProperties() {
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        // tslint:disable-next-line:no-any
        this._instanceProperties.forEach((v, p) => this[p] = v);
        this._instanceProperties = undefined;
    }
    connectedCallback() {
        this._updateState = this._updateState | STATE_HAS_CONNECTED;
        // Ensure first connection completes an update. Updates cannot complete
        // before connection and if one is pending connection the
        // `_hasConnectionResolver` will exist. If so, resolve it to complete the
        // update, otherwise requestUpdate.
        if (this._hasConnectedResolver) {
            this._hasConnectedResolver();
            this._hasConnectedResolver = undefined;
        }
    }
    /**
     * Allows for `super.disconnectedCallback()` in extensions while
     * reserving the possibility of making non-breaking feature additions
     * when disconnecting at some point in the future.
     */
    disconnectedCallback() {
    }
    /**
     * Synchronizes property values when attributes change.
     */
    attributeChangedCallback(name, old, value) {
        if (old !== value) {
            this._attributeToProperty(name, value);
        }
    }
    _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
        const ctor = this.constructor;
        const attr = ctor._attributeNameForProperty(name, options);
        if (attr !== undefined) {
            const attrValue = ctor._propertyValueToAttribute(value, options);
            // an undefined value does not change the attribute.
            if (attrValue === undefined) {
                return;
            }
            // Track if the property is being reflected to avoid
            // setting the property again via `attributeChangedCallback`. Note:
            // 1. this takes advantage of the fact that the callback is synchronous.
            // 2. will behave incorrectly if multiple attributes are in the reaction
            // stack at time of calling. However, since we process attributes
            // in `update` this should not be possible (or an extreme corner case
            // that we'd like to discover).
            // mark state reflecting
            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
            if (attrValue == null) {
                this.removeAttribute(attr);
            }
            else {
                this.setAttribute(attr, attrValue);
            }
            // mark state not reflecting
            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
        }
    }
    _attributeToProperty(name, value) {
        // Use tracking info to avoid deserializing attribute value if it was
        // just set from a property setter.
        if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
            return;
        }
        const ctor = this.constructor;
        const propName = ctor._attributeToPropertyMap.get(name);
        if (propName !== undefined) {
            const options = ctor._classProperties.get(propName) || defaultPropertyDeclaration;
            // mark state reflecting
            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
            this[propName] =
                // tslint:disable-next-line:no-any
                ctor._propertyValueFromAttribute(value, options);
            // mark state not reflecting
            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
        }
    }
    /**
     * This private version of `requestUpdate` does not access or return the
     * `updateComplete` promise. This promise can be overridden and is therefore
     * not free to access.
     */
    _requestUpdate(name, oldValue) {
        let shouldRequestUpdate = true;
        // If we have a property key, perform property update steps.
        if (name !== undefined) {
            const ctor = this.constructor;
            const options = ctor._classProperties.get(name) || defaultPropertyDeclaration;
            if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                if (!this._changedProperties.has(name)) {
                    this._changedProperties.set(name, oldValue);
                }
                // Add to reflecting properties set.
                // Note, it's important that every change has a chance to add the
                // property to `_reflectingProperties`. This ensures setting
                // attribute + property reflects correctly.
                if (options.reflect === true &&
                    !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                    if (this._reflectingProperties === undefined) {
                        this._reflectingProperties = new Map();
                    }
                    this._reflectingProperties.set(name, options);
                }
            }
            else {
                // Abort the request if the property should not be considered changed.
                shouldRequestUpdate = false;
            }
        }
        if (!this._hasRequestedUpdate && shouldRequestUpdate) {
            this._enqueueUpdate();
        }
    }
    /**
     * Requests an update which is processed asynchronously. This should
     * be called when an element should update based on some state not triggered
     * by setting a property. In this case, pass no arguments. It should also be
     * called when manually implementing a property setter. In this case, pass the
     * property `name` and `oldValue` to ensure that any configured property
     * options are honored. Returns the `updateComplete` Promise which is resolved
     * when the update completes.
     *
     * @param name {PropertyKey} (optional) name of requesting property
     * @param oldValue {any} (optional) old value of requesting property
     * @returns {Promise} A Promise that is resolved when the update completes.
     */
    requestUpdate(name, oldValue) {
        this._requestUpdate(name, oldValue);
        return this.updateComplete;
    }
    /**
     * Sets up the element to asynchronously update.
     */
    async _enqueueUpdate() {
        // Mark state updating...
        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
        let resolve;
        let reject;
        const previousUpdatePromise = this._updatePromise;
        this._updatePromise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        try {
            // Ensure any previous update has resolved before updating.
            // This `await` also ensures that property changes are batched.
            await previousUpdatePromise;
        }
        catch (e) {
            // Ignore any previous errors. We only care that the previous cycle is
            // done. Any error should have been handled in the previous update.
        }
        // Make sure the element has connected before updating.
        if (!this._hasConnected) {
            await new Promise((res) => this._hasConnectedResolver = res);
        }
        try {
            const result = this.performUpdate();
            // If `performUpdate` returns a Promise, we await it. This is done to
            // enable coordinating updates with a scheduler. Note, the result is
            // checked to avoid delaying an additional microtask unless we need to.
            if (result != null) {
                await result;
            }
        }
        catch (e) {
            reject(e);
        }
        resolve(!this._hasRequestedUpdate);
    }
    get _hasConnected() {
        return (this._updateState & STATE_HAS_CONNECTED);
    }
    get _hasRequestedUpdate() {
        return (this._updateState & STATE_UPDATE_REQUESTED);
    }
    get hasUpdated() {
        return (this._updateState & STATE_HAS_UPDATED);
    }
    /**
     * Performs an element update. Note, if an exception is thrown during the
     * update, `firstUpdated` and `updated` will not be called.
     *
     * You can override this method to change the timing of updates. If this
     * method is overridden, `super.performUpdate()` must be called.
     *
     * For instance, to schedule updates to occur just before the next frame:
     *
     * ```
     * protected async performUpdate(): Promise<unknown> {
     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
     *   super.performUpdate();
     * }
     * ```
     */
    performUpdate() {
        // Mixin instance properties once, if they exist.
        if (this._instanceProperties) {
            this._applyInstanceProperties();
        }
        let shouldUpdate = false;
        const changedProperties = this._changedProperties;
        try {
            shouldUpdate = this.shouldUpdate(changedProperties);
            if (shouldUpdate) {
                this.update(changedProperties);
            }
        }
        catch (e) {
            // Prevent `firstUpdated` and `updated` from running when there's an
            // update exception.
            shouldUpdate = false;
            throw e;
        }
        finally {
            // Ensure element can accept additional updates after an exception.
            this._markUpdated();
        }
        if (shouldUpdate) {
            if (!(this._updateState & STATE_HAS_UPDATED)) {
                this._updateState = this._updateState | STATE_HAS_UPDATED;
                this.firstUpdated(changedProperties);
            }
            this.updated(changedProperties);
        }
    }
    _markUpdated() {
        this._changedProperties = new Map();
        this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
    }
    /**
     * Returns a Promise that resolves when the element has completed updating.
     * The Promise value is a boolean that is `true` if the element completed the
     * update without triggering another update. The Promise result is `false` if
     * a property was set inside `updated()`. If the Promise is rejected, an
     * exception was thrown during the update.
     *
     * To await additional asynchronous work, override the `_getUpdateComplete`
     * method. For example, it is sometimes useful to await a rendered element
     * before fulfilling this Promise. To do this, first await
     * `super._getUpdateComplete()`, then any subsequent state.
     *
     * @returns {Promise} The Promise returns a boolean that indicates if the
     * update resolved without triggering another update.
     */
    get updateComplete() {
        return this._getUpdateComplete();
    }
    /**
     * Override point for the `updateComplete` promise.
     *
     * It is not safe to override the `updateComplete` getter directly due to a
     * limitation in TypeScript which means it is not possible to call a
     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
     * This method should be overridden instead. For example:
     *
     *   class MyElement extends LitElement {
     *     async _getUpdateComplete() {
     *       await super._getUpdateComplete();
     *       await this._myChild.updateComplete;
     *     }
     *   }
     */
    _getUpdateComplete() {
        return this._updatePromise;
    }
    /**
     * Controls whether or not `update` should be called when the element requests
     * an update. By default, this method always returns `true`, but this can be
     * customized to control when to update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */
    shouldUpdate(_changedProperties) {
        return true;
    }
    /**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */
    update(_changedProperties) {
        if (this._reflectingProperties !== undefined &&
            this._reflectingProperties.size > 0) {
            // Use forEach so this works even if for/of loops are compiled to for
            // loops expecting arrays
            this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
            this._reflectingProperties = undefined;
        }
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param _changedProperties Map of changed properties with old values
     */
    updated(_changedProperties) {
    }
    /**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param _changedProperties Map of changed properties with old values
     */
    firstUpdated(_changedProperties) {
    }
}
_a = finalized;
/**
 * Marks class as having finished creating properties.
 */
UpdatingElement[_a] = true;

/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = ('adoptedStyleSheets' in Document.prototype) &&
    ('replace' in CSSStyleSheet.prototype);
const constructionToken = Symbol();
class CSSResult {
    constructor(cssText, safeToken) {
        if (safeToken !== constructionToken) {
            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
        }
        this.cssText = cssText;
    }
    // Note, this is a getter so that it's lazy. In practice, this means
    // stylesheets are not created until the first element instance is made.
    get styleSheet() {
        if (this._styleSheet === undefined) {
            // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet
            // is constructable.
            if (supportsAdoptingStyleSheets) {
                this._styleSheet = new CSSStyleSheet();
                this._styleSheet.replaceSync(this.cssText);
            }
            else {
                this._styleSheet = null;
            }
        }
        return this._styleSheet;
    }
    toString() {
        return this.cssText;
    }
}
/**
 * Wrap a value for interpolation in a css tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */
const unsafeCSS = (value) => {
    return new CSSResult(String(value), constructionToken);
};
const textFromCSSResult = (value) => {
    if (value instanceof CSSResult) {
        return value.cssText;
    }
    else if (typeof value === 'number') {
        return value;
    }
    else {
        throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
    }
};
/**
 * Template tag which which can be used with LitElement's `style` property to
 * set element styles. For security reasons, only literal string values may be
 * used. To incorporate non-literal values `unsafeCSS` may be used inside a
 * template string part.
 */
const css = (strings, ...values) => {
    const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, constructionToken);
};

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for LitElement usage.
// TODO(justinfagnani): inject version number at build time
(window['litElementVersions'] || (window['litElementVersions'] = []))
    .push('2.2.1');
/**
 * Minimal implementation of Array.prototype.flat
 * @param arr the array to flatten
 * @param result the accumlated result
 */
function arrayFlat(styles, result = []) {
    for (let i = 0, length = styles.length; i < length; i++) {
        const value = styles[i];
        if (Array.isArray(value)) {
            arrayFlat(value, result);
        }
        else {
            result.push(value);
        }
    }
    return result;
}
/** Deeply flattens styles array. Uses native flat if available. */
const flattenStyles = (styles) => styles.flat ? styles.flat(Infinity) : arrayFlat(styles);
class LitElement extends UpdatingElement {
    /** @nocollapse */
    static finalize() {
        // The Closure JS Compiler does not always preserve the correct "this"
        // when calling static super methods (b/137460243), so explicitly bind.
        super.finalize.call(this);
        // Prepare styling that is stamped at first render time. Styling
        // is built from user provided `styles` or is inherited from the superclass.
        this._styles =
            this.hasOwnProperty(JSCompiler_renameProperty('styles', this)) ?
                this._getUniqueStyles() :
                this._styles || [];
    }
    /** @nocollapse */
    static _getUniqueStyles() {
        // Take care not to call `this.styles` multiple times since this generates
        // new CSSResults each time.
        // TODO(sorvell): Since we do not cache CSSResults by input, any
        // shared styles will generate new stylesheet objects, which is wasteful.
        // This should be addressed when a browser ships constructable
        // stylesheets.
        const userStyles = this.styles;
        const styles = [];
        if (Array.isArray(userStyles)) {
            const flatStyles = flattenStyles(userStyles);
            // As a performance optimization to avoid duplicated styling that can
            // occur especially when composing via subclassing, de-duplicate styles
            // preserving the last item in the list. The last item is kept to
            // try to preserve cascade order with the assumption that it's most
            // important that last added styles override previous styles.
            const styleSet = flatStyles.reduceRight((set, s) => {
                set.add(s);
                // on IE set.add does not return the set.
                return set;
            }, new Set());
            // Array.from does not work on Set in IE
            styleSet.forEach((v) => styles.unshift(v));
        }
        else if (userStyles) {
            styles.push(userStyles);
        }
        return styles;
    }
    /**
     * Performs element initialization. By default this calls `createRenderRoot`
     * to create the element `renderRoot` node and captures any pre-set values for
     * registered properties.
     */
    initialize() {
        super.initialize();
        this.renderRoot =
            this.createRenderRoot();
        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
        // element's getRootNode(). While this could be done, we're choosing not to
        // support this now since it would require different logic around de-duping.
        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
            this.adoptStyles();
        }
    }
    /**
     * Returns the node into which the element should render and by default
     * creates and returns an open shadowRoot. Implement to customize where the
     * element's DOM is rendered. For example, to render into the element's
     * childNodes, return `this`.
     * @returns {Element|DocumentFragment} Returns a node into which to render.
     */
    createRenderRoot() {
        return this.attachShadow({ mode: 'open' });
    }
    /**
     * Applies styling to the element shadowRoot using the `static get styles`
     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
     * available and will fallback otherwise. When Shadow DOM is polyfilled,
     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
     * is available but `adoptedStyleSheets` is not, styles are appended to the
     * end of the `shadowRoot` to [mimic spec
     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
     */
    adoptStyles() {
        const styles = this.constructor._styles;
        if (styles.length === 0) {
            return;
        }
        // There are three separate cases here based on Shadow DOM support.
        // (1) shadowRoot polyfilled: use ShadyCSS
        // (2) shadowRoot.adoptedStyleSheets available: use it.
        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
        // rendering
        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
        }
        else if (supportsAdoptingStyleSheets) {
            this.renderRoot.adoptedStyleSheets =
                styles.map((s) => s.styleSheet);
        }
        else {
            // This must be done after rendering so the actual style insertion is done
            // in `update`.
            this._needsShimAdoptedStyleSheets = true;
        }
    }
    connectedCallback() {
        super.connectedCallback();
        // Note, first update/render handles styleElement so we only call this if
        // connected after first update.
        if (this.hasUpdated && window.ShadyCSS !== undefined) {
            window.ShadyCSS.styleElement(this);
        }
    }
    /**
     * Updates the element. This method reflects property values to attributes
     * and calls `render` to render DOM via lit-html. Setting properties inside
     * this method will *not* trigger another update.
     * * @param _changedProperties Map of changed properties with old values
     */
    update(changedProperties) {
        super.update(changedProperties);
        const templateResult = this.render();
        if (templateResult instanceof TemplateResult) {
            this.constructor
                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
        }
        // When native Shadow DOM is used but adoptedStyles are not supported,
        // insert styling after rendering to ensure adoptedStyles have highest
        // priority.
        if (this._needsShimAdoptedStyleSheets) {
            this._needsShimAdoptedStyleSheets = false;
            this.constructor._styles.forEach((s) => {
                const style = document.createElement('style');
                style.textContent = s.cssText;
                this.renderRoot.appendChild(style);
            });
        }
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */
    render() {
    }
}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 *
 * Note this property name is a string to prevent breaking Closure JS Compiler
 * optimizations. See updating-element.ts for more information.
 */
LitElement['finalized'] = true;
/**
 * Render method used to render the lit-html TemplateResult to the element's
 * DOM.
 * @param {TemplateResult} Template to render.
 * @param {Element|DocumentFragment} Node into which to render.
 * @param {String} Element name.
 * @nocollapse
 */
LitElement.render = render$1;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/* eslint-disable no-unused-vars */
/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
 * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
 *
 * @param {string} prop Property name
 * @param {?Object} obj Reference object
 * @return {string} Potentially renamed property name
 */
window.JSCompiler_renameProperty = function(prop, obj) {
  return prop;
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// unique global id for deduping mixins.
let dedupeId = 0;

/* eslint-disable valid-jsdoc */
/**
 * Wraps an ES6 class expression mixin such that the mixin is only applied
 * if it has not already been applied its base argument. Also memoizes mixin
 * applications.
 *
 * @template T
 * @param {T} mixin ES6 class expression mixin to wrap
 * @return {T}
 * @suppress {invalidCasts}
 */
const dedupingMixin = function(mixin) {
  let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  let mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */(mixin)(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};
/* eslint-enable valid-jsdoc */

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables_;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    nativeCssVariables_ = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables_ = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) &&
      window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

/** @type {string | undefined} */
let cssBuild;
if (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {
  cssBuild = window.ShadyCSS.cssBuild;
}

/** @type {boolean} */
const disableRuntime = Boolean(window.ShadyCSS && window.ShadyCSS.disableRuntime);

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables_ = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

// Hack for type error under new type inference which doesn't like that
// nativeCssVariables is updated in a function and assigns the type
// `function(): ?` instead of `boolean`.
const nativeCssVariables = /** @type {boolean} */(nativeCssVariables_);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @unrestricted */
class StyleNode {
  constructor() {
    /** @type {number} */
    this['start'] = 0;
    /** @type {number} */
    this['end'] = 0;
    /** @type {StyleNode} */
    this['previous'] = null;
    /** @type {StyleNode} */
    this['parent'] = null;
    /** @type {Array<StyleNode>} */
    this['rules'] = null;
    /** @type {string} */
    this['parsedCssText'] = '';
    /** @type {string} */
    this['cssText'] = '';
    /** @type {boolean} */
    this['atRule'] = false;
    /** @type {number} */
    this['type'] = 0;
    /** @type {string} */
    this['keyframesName'] = '';
    /** @type {string} */
    this['selector'] = '';
    /** @type {string} */
    this['parsedSelector'] = '';
  }
}

// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    let s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = (s.indexOf(AT_START) === 0);
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] =
          node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node['rules'];
  if (r$) {
    for (let i = 0, l = r$.length, r;
      (i < l) && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
    let code = arguments[1],
      repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties, text = '') {
  // calc rule cssText
  let cssText = '';
  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r;
        (i < l) && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] :
        removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText
    .replace(RX.customProp, '')
    .replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText
    .replace(RX.mixinApply, '')
    .replace(RX.varApply, '');
}

/** @enum {number} */
const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
};

const OPEN_BRACE = '{';
const CLOSE_BRACE = '}';

// helper regexp's
const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};

const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
const MEDIA_MATCH = /@media\s(.*)/;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {!Set<string>} */
const styleTextSet = new Set();

const scopingAttribute = 'shady-unscoped';

/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = style.cloneNode(true);
    document.head.appendChild(newStyle);
  }
}

/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText (rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = parse(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return stringify(rules, nativeCssVariables);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = parse(style.textContent);
  }
  return style['__cssRules'] || null;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node['type'];
  if (onlyActiveRules) {
    if (type === types.MEDIA_RULE) {
      let matchMedia = node['selector'].match(MEDIA_MATCH);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback &&
    type === types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === types.MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node['rules'];
  if (r$ && !skipRules) {
    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  let level = 0;
  for (let i=start, l=text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  let start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  // suffix may have other variables
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @type {function(*):*}
 */
const wrap = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || ((node) => node);

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  let localName = element['localName'];
  let is = '', typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = (element.getAttribute && element.getAttribute('is')) || '';
    }
  } else {
    is = /** @type {?} */(element).is;
    typeExtension = /** @type {?} */(element).extends;
  }
  return {is, typeExtension};
}

/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */
function gatherStyleText(element) {
  /** @type {!Array<string>} */
  const styleTextParts = [];
  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (isUnscopedStyle(style)) {
      if (!nativeShadow) {
        processUnscopedStyle(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join('').trim();
}

const CSS_BUILD_ATTR = 'css-build';

/**
 * Return the polymer-css-build "build type" applied to this element
 *
 * @param {!HTMLElement} element
 * @return {string} Can be "", "shady", or "shadow"
 */
function getCssBuild(element) {
  if (cssBuild !== undefined) {
    return /** @type {string} */(cssBuild);
  }
  if (element.__cssBuild === undefined) {
    // try attribute first, as it is the common case
    const attrValue = element.getAttribute(CSS_BUILD_ATTR);
    if (attrValue) {
      element.__cssBuild = attrValue;
    } else {
      const buildComment = getBuildComment(element);
      if (buildComment !== '') {
        // remove build comment so it is not needlessly copied into every element instance
        removeBuildComment(element);
      }
      element.__cssBuild = buildComment;
    }
  }
  return element.__cssBuild || '';
}

/**
 * Check if the given element, either a <template> or <style>, has been processed
 * by polymer-css-build.
 *
 * If so, then we can make a number of optimizations:
 * - polymer-css-build will decompose mixins into individual CSS Custom Properties,
 * so the ApplyShim can be skipped entirely.
 * - Under native ShadowDOM, the style text can just be copied into each instance
 * without modification
 * - If the build is "shady" and ShadyDOM is in use, the styling does not need
 * scoping beyond the shimming of CSS Custom Properties
 *
 * @param {!HTMLElement} element
 * @return {boolean}
 */
function elementHasBuiltCss(element) {
  return getCssBuild(element) !== '';
}

/**
 * For templates made with tagged template literals, polymer-css-build will
 * insert a comment of the form `<!--css-build:shadow-->`
 *
 * @param {!HTMLElement} element
 * @return {string}
 */
function getBuildComment(element) {
  const buildComment = element.localName === 'template' ?
      /** @type {!HTMLTemplateElement} */ (element).content.firstChild :
      element.firstChild;
  if (buildComment instanceof Comment) {
    const commentParts = buildComment.textContent.trim().split(':');
    if (commentParts[0] === CSS_BUILD_ATTR) {
      return commentParts[1];
    }
  }
  return '';
}

/**
 * @param {!HTMLElement} element
 */
function removeBuildComment(element) {
  const buildComment = element.localName === 'template' ?
      /** @type {!HTMLTemplateElement} */ (element).content.firstChild :
      element.firstChild;
  buildComment.parentNode.removeChild(buildComment);
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  const value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);
  // reset state of the regexes
  MIXIN_MATCH.lastIndex = 0;
  VAR_ASSIGN.lastIndex = 0;
  return has;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const APPLY_NAME_CLEAN = /;\s*/m;
const INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
const IMPORTANT = /\s*!important/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
const MIXIN_VAR_SEP = '_-_';

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}
class MixinMap {
  constructor() {
    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {}
    };
  }
  /**
   * @param {string} name
   * @return {MixinMapEntry}
   */
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
}

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */
let invalidCallback = null;

/** @unrestricted */
class ApplyShim {
  constructor() {
    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */
  detectMixin(cssText) {
    return detectMixin(cssText);
  }

  /**
   * Gather styles into one style for easier processing
   * @param {!HTMLTemplateElement} template
   * @return {HTMLStyleElement}
   */
  gatherStyles(template) {
    const styleText = gatherStyleText(template.content);
    if (styleText) {
      const style = /** @type {!HTMLStyleElement} */(document.createElement('style'));
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === undefined) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    /** @type {HTMLStyleElement} */
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformStyle(style, elementName = '') {
    let ast = rulesForStyle(style);
    this.transformRules(ast, elementName);
    style.textContent = toCssText(ast);
    return ast;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @return {StyleNode}
   */
  transformCustomStyle(style) {
    let ast = rulesForStyle(style);
    forEachRule(ast, (rule) => {
      if (rule['selector'] === ':root') {
        rule['selector'] = 'html';
      }
      this.transformRule(rule);
    });
    style.textContent = toCssText(ast);
    return ast;
  }
  /**
   * @param {StyleNode} rules
   * @param {string} elementName
   */
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    forEachRule(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  /**
   * @param {!StyleNode} rule
   */
  transformRule(rule) {
    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);
    // :root was only used for variable assignment in property shim,
    // but generates invalid selectors with real properties.
    // replace with `:host > *`, which serves the same effect
    if (rule['selector'] === ':root') {
      rule['selector'] = ':host > *';
    }
  }
  /**
   * @param {string} cssText
   * @param {!StyleNode} rule
   * @return {string}
   */
  transformCssText(cssText, rule) {
    // produce variables
    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) =>
      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule));
    // consume mixins
    return this._consumeCssProperties(cssText, rule);
  }
  /**
   * @param {string} property
   * @return {string}
   */
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));
      this._measureElement.setAttribute('apply-shim-measure', '');
      this._measureElement.style.all = 'initial';
      document.head.appendChild(this._measureElement);
    }
    return window.getComputedStyle(this._measureElement).getPropertyValue(property);
  }
  /**
   * Walk over all rules before this rule to find fallbacks for mixins
   *
   * @param {!StyleNode} startRule
   * @return {!Object}
   */
  _fallbacksFromPreviousRules(startRule) {
    // find the "top" rule
    let topRule = startRule;
    while (topRule['parent']) {
      topRule = topRule['parent'];
    }
    const fallbacks = {};
    let seenStartRule = false;
    forEachRule(topRule, (r) => {
      // stop when we hit the input rule
      seenStartRule = seenStartRule || r === startRule;
      if (seenStartRule) {
        return;
      }
      // NOTE: Only matching selectors are "safe" for this fallback processing
      // It would be prohibitive to run `matchesSelector()` on each selector,
      // so we cheat and only check if the same selector string is used, which
      // guarantees things like specificity matching
      if (r['selector'] === startRule['selector']) {
        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));
      }
    });
    return fallbacks;
  }
  /**
   * replace mixin consumption with variable consumption
   * @param {string} text
   * @param {!StyleNode=} rule
   * @return {string}
   */
  _consumeCssProperties(text, rule) {
    /** @type {Array} */
    let m = null;
    // loop over text until all mixins with defintions have been applied
    while((m = MIXIN_MATCH.exec(text))) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      // collect properties before apply to be "defaults" if mixin might override them
      // match includes a "prefix", so find the start and end positions of @apply
      let applyPos = idx + matchText.indexOf('@apply');
      let afterApplyPos = idx + matchText.length;
      // find props defined before this @apply
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};
      Object.assign(defaults, this._cssTextToMap(textBeforeApply));
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      // use regex match position to replace mixin, keep linear processing time
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      // move regex search to _after_ replacement
      MIXIN_MATCH.lastIndex = idx + replacement.length;
    }
    return text;
  }
  /**
   * produce variable consumption at the site of mixin consumption
   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
   * Example:
   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
   *
   * @param {string} mixinName
   * @param {Object} fallbacks
   * @return {string}
   */
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    // if we depend on a mixin before it is created
    // make a sentinel entry in the map to add this element as a dependency for when it is defined.
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p, parts, f;
      const properties = mixinEntry.properties;
      for (p in properties) {
        f = fallbacks && fallbacks[p];
        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
        if (f) {
          parts.push(',', f.replace(IMPORTANT, ''));
        }
        parts.push(')');
        if (IMPORTANT.test(properties[p])) {
          parts.push(' !important');
        }
        vars.push(parts.join(''));
      }
    }
    return vars.join('; ');
  }

  /**
   * @param {string} property
   * @param {string} value
   * @return {string}
   */
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        // initial
        // replace `initial` with the concrete initial value for this property
        value = this._getInitialValueForProperty(property);
      } else {
        // inherit
        // with this purposfully illegal value, the variable will be invalid at
        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
        // and for inheriting values, will behave similarly
        // we cannot support the same behavior for non inheriting values like 'border'
        value = 'apply-shim-inherit';
      }
    }
    return value;
  }

  /**
   * "parse" a mixin definition into a map of properties and values
   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
   * @param {string} text
   * @param {boolean=} replaceInitialOrInherit
   * @return {!Object<string, string>}
   */
  _cssTextToMap(text, replaceInitialOrInherit = false) {
    let props = text.split(';');
    let property, value;
    let out = {};
    for (let i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        // ignore lines that aren't definitions like @media
        if (sp.length > 1) {
          property = sp[0].trim();
          // some properties may have ':' in the value, like data urls
          value = sp.slice(1).join(':');
          if (replaceInitialOrInherit) {
            value = this._replaceInitialOrInherit(property, value);
          }
          out[property] = value;
        }
      }
    }
    return out;
  }

  /**
   * @param {MixinMapEntry} mixinEntry
   */
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }

  /**
   * @param {string} matchText
   * @param {string} propertyName
   * @param {?string} valueProperty
   * @param {?string} valueMixin
   * @param {!StyleNode} rule
   * @return {string}
   */
  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {
    // handle case where property value is a mixin
    if (valueProperty) {
      // form: --mixin2: var(--mixin1), where --mixin1 is in the map
      processVariableAndFallback(valueProperty, (prefix, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`;
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);
    let prefix = matchText.slice(0, matchText.indexOf('--'));
    // `initial` and `inherit` as properties in a map should be replaced because
    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,
    // and would set the variable value, rather than carry the keyword to the `var()` usage.
    let mixinValues = this._cssTextToMap(mixinAsProperties, true);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      // NOTE: since we use mixin, the map of properties is updated here
      // and this is what we want.
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p, v;
    // set variables defined by current mixin
    let needToInvalidate = false;
    for (p in combinedProps) {
      v = mixinValues[p];
      // if property not defined by current mixin, set initial
      if (v === undefined) {
        v = 'initial';
      }
      if (oldProps && !(p in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    // because the mixinMap is global, the mixin might conflict with
    // a different scope's simple variable definition:
    // Example:
    // some style somewhere:
    // --mixin1:{ ... }
    // --mixin2: var(--mixin1);
    // some other element:
    // --mixin1: 10px solid red;
    // --foo: var(--mixin1);
    // In this case, we leave the original variable definition in place.
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join('; ')};`;
  }
}

/* exports */
/* eslint-disable no-self-assign */
ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
/* eslint-enable no-self-assign */
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get() {
    return invalidCallback;
  },
  /** @param {?function(string)} cb */
  set(cb) {
    invalidCallback = cb;
  }
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */
const templateMap = {};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
const CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
const NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
const VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
const promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName){
  let template = templateMap[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {Promise<void>} */
let readyPromise = null;

/** @type {?function(?function())} */
let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
let resolveFn;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function() {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise((resolve) => {resolveFn = resolve;});
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function(){ callback && callback(); });
    }
  });
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
let transformFn = null;

/** @type {?function()} */
let validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/
class CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
    // NOTE(dfreedm): use quotes here to prevent closure inlining to `function(){}`;
    documentWait(() => {
      if (window['ShadyCSS']['flushCustomStyles']) {
        window['ShadyCSS']['flushCustomStyles']();
      }
    });
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */
  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }
    this['enqueued'] = true;
    documentWait(validateFn);
  }
  /**
   * @param {!HTMLStyleElement} style
   */
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */
  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }
    let style;
    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }
    return style;
  }
  /**
   * @return {!Array<!CustomStyleProvider>}
   */
  processStyles() {
    const cs = this['customStyles'];
    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];
      if (customStyle[CACHED_STYLE]) {
        continue;
      }
      const style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        const styleToTransform = /** @type {!HTMLStyleElement} */(style['__appliedElement'] || style);
        if (transformFn) {
          transformFn(styleToTransform);
        }
        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }
    return cs;
  }
}

/* eslint-disable no-self-assign */
CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;
/* eslint-enable no-self-assign */

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },
    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },
    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set(fn) {
      let needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    },
  }
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @const {ApplyShim} */
const applyShim = new ApplyShim();

class ApplyShimInterface {
  constructor() {
    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    applyShim['invalidCallback'] = invalidate;
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    if (window.ShadyCSS.CustomStyleInterface) {
      this.customStyleInterface =
          /** @type {!CustomStyleInterfaceInterface} */ (
              window.ShadyCSS.CustomStyleInterface);
      this.customStyleInterface['transformCallback'] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface['enqueued']) {
            this.flushCustomStyles();
          }
        });
      };
    }
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */
  prepareTemplate(template, elementName) {
    this.ensure();
    if (elementHasBuiltCss(template)) {
      return;
    }
    templateMap[elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    // save original style ast to use for revalidating instances
    template['_styleAst'] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface['processStyles']();
    if (!this.customStyleInterface['enqueued']) {
      return;
    }
    for (let i = 0; i < styles.length; i++ ) {
      let cs = styles[i];
      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface['enqueued'] = false;
  }
  /**
   * @param {HTMLElement} element
   * @param {Object=} properties
   */
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      updateNativeProperties(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren =
          /** @type {!ParentNode} */ (element.shadowRoot).children ||
          element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(shadowChildren[i]));
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(children[i]));
      }
    }
  }
  /**
   * @param {HTMLElement} element
   */
  styleElement(element) {
    this.ensure();
    let {is} = getIsExtends(element);
    let template = templateMap[is];
    if (template && elementHasBuiltCss(template)) {
      return;
    }
    if (template && !templateIsValid(template)) {
      // only revalidate template once
      if (!templateIsValidating(template)) {
        this.prepareTemplate(template, is);
        startValidatingTemplate(template);
      }
      // update this element instance
      let root = element.shadowRoot;
      if (root) {
        let style = /** @type {HTMLStyleElement} */(root.querySelector('style'));
        if (style) {
          // reuse the template's style ast, it has all the original css text
          style['__cssRules'] = template['_styleAst'];
          style.textContent = toCssText(template['_styleAst']);
        }
      }
    }
  }
  /**
   * @param {Object=} properties
   */
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
}

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  /** @suppress {duplicate} */
  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) { // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },

    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplateStyles(template, elementName, elementExtends) {
      window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);
    },

    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */
    prepareTemplateDom(template, elementName) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },

    /**
     * @param {!HTMLElement} element
     */
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },

    flushCustomStyles() {
      applyShimInterface.flushCustomStyles();
    },

    nativeCss: nativeCssVariables,
    nativeShadow: nativeShadow,
    cssBuild: cssBuild,
    disableRuntime: disableRuntime,
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * Note that this function performs no resolution for URLs that start
 * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
 * URL resolution, use `window.URL`.
 *
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  if (url === '//') {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = (u.href === 'http://a/c%20d');
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    try {
      return (new URL(url, baseURI)).href;
    } catch (e) {
      // Bad url or baseURI structure. Do not attempt to resolve.
      return url;
    }
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;

}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
    return pre + '\'' +
      resolveUrl(url.replace(/["']/g, ''), baseURI) +
      '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const useShadow = !(window.ShadyDOM);
const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);


/**
 * Globally settable property that is automatically assigned to
 * `ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `rootPath` to provide a stable application mount path when
 * using client side routing.
 */
let rootPath = pathFromUrl(document.baseURI || window.location.href);

/**
 * A global callback used to sanitize any value before inserting it into the DOM.
 * The callback signature is:
 *
 *  function sanitizeDOMValue(value, name, type, node) { ... }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 */
let sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;

/**
 * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.
 * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother
 * scrolling performance.
 * Defaults to `false` for backwards compatibility.
 */
let passiveTouchGestures = false;

/**
 * Setting to ensure Polymer template evaluation only occurs based on tempates
 * defined in trusted script.  When true, `<dom-module>` re-registration is
 * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`
 * templates will only evaluate in the context of a trusted element template.
 */
let strictTemplatePolicy = false;

/**
 * Setting to enable dom-module lookup from Polymer.Element.  By default,
 * templates must be defined in script using the `static get template()`
 * getter and the `html` tag function.  To enable legacy loading of templates
 * via dom-module, set this flag to true.
 */
let allowTemplateFromDomModule = false;

/**
 * Setting to skip processing style includes and re-writing urls in css styles.
 * Normally "included" styles are pulled into the element and all urls in styles
 * are re-written to be relative to the containing script url.
 * If no includes or relative urls are used in styles, these steps can be
 * skipped as an optimization.
 */
let legacyOptimizations = false;

/**
 * Setting to perform initial rendering synchronously when running under ShadyDOM.
 * This matches the behavior of Polymer 1.
 */
let syncInitialRender = false;

/**
 * Setting to cancel synthetic click events fired by older mobile browsers. Modern browsers
 * no longer fire synthetic click events, and the cancellation behavior can interfere
 * when programmatically clicking on elements.
 */
let cancelSyntheticClickEvents = true;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let modules = {};
let lcModules = {};
/**
 * Sets a dom-module into the global registry by id.
 *
 * @param {string} id dom-module id
 * @param {DomModule} module dom-module instance
 * @return {void}
 */
function setModule(id, module) {
  // store id separate from lowercased id so that
  // in all cases mixedCase id will stored distinctly
  // and lowercase version is a fallback
  modules[id] = lcModules[id.toLowerCase()] = module;
}
/**
 * Retrieves a dom-module from the global registry by id.
 *
 * @param {string} id dom-module id
 * @return {DomModule!} dom-module instance
 */
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */
class DomModule extends HTMLElement {

  /** @override */
  static get observedAttributes() { return ['id']; }

  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }

  /* eslint-disable no-unused-vars */
  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */
  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  /* eslint-enable no-unused-args */

  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ?
        HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(
        this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = pathFromUrl(url);
    }
    return this.__assetpath;
  }

  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */
  register(id) {
    id = id || this.id;
    if (id) {
      // Under strictTemplatePolicy, reject and null out any re-registered
      // dom-module since it is ambiguous whether first-in or last-in is trusted
      if (strictTemplatePolicy && findModule(id) !== undefined) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }
      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }
}

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';
const SHADY_UNSCOPED_ATTR = 'shady-unscoped';

/**
 * @param {string} moduleId .
 * @return {?DomModule} .
 */
function importModule(moduleId) {
  return /** @type {?DomModule} */(DomModule.import(moduleId));
}

function styleForImport(importDoc) {
  // NOTE: polyfill affordance.
  // under the HTMLImports polyfill, there will be no 'body',
  // but the import pseudo-doc can be used directly.
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(container.textContent,
    importDoc.baseURI);
  const style = document.createElement('style');
  style.textContent = importCss;
  return style;
}


/**
 * Returns a list of <style> elements in a space-separated list of `dom-module`s.
 *
 * @function
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements
 */
function stylesFromModules(moduleIds) {
 const modules = moduleIds.trim().split(/\s+/);
 const styles = [];
 for (let i=0; i < modules.length; i++) {
   styles.push(...stylesFromModule(modules[i]));
 }
 return styles;
}

/**
 * Returns a list of <style> elements in a given `dom-module`.
 * Styles in a `dom-module` can come either from `<style>`s within the
 * first `<template>`, or else from one or more
 * `<link rel="import" type="css">` links outside the template.
 *
 * @param {string} moduleId dom-module id to gather styles from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */
function stylesFromModule(moduleId) {
  const m = importModule(moduleId);

  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
    return [];
  }

  if (m._styles === undefined) {
    const styles = [];
    // module imports: <link rel="import" type="css">
    styles.push(..._stylesFromModuleImports(m));
    // include css from the first template in the module
    const template = /** @type {?HTMLTemplateElement} */(
        m.querySelector('template'));
    if (template) {
      styles.push(...stylesFromTemplate(template,
        /** @type {templateWithAssetPath} */(m).assetpath));
    }

    m._styles = styles;
  }

  return m._styles;
}

/**
 * Returns the `<style>` elements within a given template.
 *
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string=} baseURI baseURI for style content
 * @return {!Array<!HTMLStyleElement>} Array of styles
 */
function stylesFromTemplate(template, baseURI) {
  if (!template._styles) {
    const styles = [];
    // if element is a template, get content from its .content
    const e$ = template.content.querySelectorAll('style');
    for (let i=0; i < e$.length; i++) {
      let e = e$[i];
      // support style sharing by allowing styles to "include"
      // other dom-modules that contain styling
      let include = e.getAttribute(INCLUDE_ATTR);
      if (include) {
        styles.push(...stylesFromModules(include).filter(function(item, index, self) {
          return self.indexOf(item) === index;
        }));
      }
      if (baseURI) {
        e.textContent =
            resolveCss(e.textContent, /** @type {string} */ (baseURI));
      }
      styles.push(e);
    }
    template._styles = styles;
  }
  return template._styles;
}

/**
 * Returns a list of <style> elements  from stylesheets loaded via `<link rel="import" type="css">` links within the specified `dom-module`.
 *
 * @param {string} moduleId Id of `dom-module` to gather CSS from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */
function stylesFromModuleImports(moduleId) {
 let m = importModule(moduleId);
 return m ? _stylesFromModuleImports(m) : [];
}

/**
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {!Array<!HTMLStyleElement>} Array of contained styles
 */
function _stylesFromModuleImports(module) {
  const styles = [];
  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i=0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, '');
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }
      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }
  return styles;
}

/**
 *
 * Returns CSS text of styles in a space-separated list of `dom-module`s.
 * Note: This method is deprecated, use `stylesFromModules` instead.
 *
 * @deprecated
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {string} Concatenated CSS content from specified `dom-module`s
 */
function cssFromModules(moduleIds) {
 let modules = moduleIds.trim().split(/\s+/);
 let cssText = '';
 for (let i=0; i < modules.length; i++) {
   cssText += cssFromModule(modules[i]);
 }
 return cssText;
}

/**
 * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
 * can come either from `<style>`s within the first `<template>`, or else
 * from one or more `<link rel="import" type="css">` links outside the
 * template.
 *
 * Any `<styles>` processed are removed from their original location.
 * Note: This method is deprecated, use `styleFromModule` instead.
 *
 * @deprecated
 * @param {string} moduleId dom-module id to gather styles from
 * @return {string} Concatenated CSS content from specified `dom-module`
 */
function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    let cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    let t = /** @type {?HTMLTemplateElement} */(m.querySelector('template'));
    if (t) {
      cssText += cssFromTemplate(t,
        /** @type {templateWithAssetPath} */(m).assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

/**
 * Returns CSS text of `<styles>` within a given template.
 *
 * Any `<styles>` processed are removed from their original location.
 * Note: This method is deprecated, use `styleFromTemplate` instead.
 *
 * @deprecated
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Concatenated CSS content from specified template
 */
function cssFromTemplate(template, baseURI) {
  let cssText = '';
  const e$ = stylesFromTemplate(template, baseURI);
  // if element is a template, get content from its .content
  for (let i=0; i < e$.length; i++) {
    let e = e$[i];
    if (e.parentNode) {
      e.parentNode.removeChild(e);
    }
    cssText += e.textContent;
  }
  return cssText;
}

/**
 * @deprecated
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {string} Concatenated CSS content from links in the dom-module
 */
function _cssFromModuleImports(module) {
  let cssText = '';
  let styles = _stylesFromModuleImports(module);
  for (let i=0; i < styles.length; i++) {
    cssText += styles[i].textContent;
  }
  return cssText;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/* eslint-disable valid-jsdoc */
/**
 * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill
 * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,
 * a node wrapper must be used to access ShadowDOM API.
 * This is similar to using `Polymer.dom` but relies exclusively
 * on the presence of the ShadyDOM polyfill rather than requiring the loading
 * of legacy (Polymer.dom) API.
 * @type {function(Node):Node}
 */
const wrap$1 = (window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap']) ?
  window['ShadyDOM']['wrap'] :
  (window['ShadyDOM'] ? (n) => ShadyDOM['patch'](n) : (n) => n);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Module with utilities for manipulating structured data path strings.
 *
 * @summary Module with utilities for manipulating structured data path strings.
 */

/**
 * Returns true if the given string is a structured data path (has dots).
 *
 * Example:
 *
 * ```
 * isPath('foo.bar.baz') // true
 * isPath('foo')         // false
 * ```
 *
 * @param {string} path Path string
 * @return {boolean} True if the string contained one or more dots
 */
function isPath(path) {
  return path.indexOf('.') >= 0;
}

/**
 * Returns the root property name for the given path.
 *
 * Example:
 *
 * ```
 * root('foo.bar.baz') // 'foo'
 * root('foo')         // 'foo'
 * ```
 *
 * @param {string} path Path string
 * @return {string} Root property name
 */
function root(path) {
  let dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

/**
 * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
 * Returns true if the given path is an ancestor of the base path.
 *
 * Example:
 *
 * ```
 * isAncestor('foo.bar', 'foo')         // true
 * isAncestor('foo.bar', 'foo.bar')     // false
 * isAncestor('foo.bar', 'foo.bar.baz') // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is an ancestor of `base`.
 */
function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

/**
 * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
 *
 * Example:
 *
 * ```
 * isDescendant('foo.bar', 'foo.bar.baz') // true
 * isDescendant('foo.bar', 'foo.bar')     // false
 * isDescendant('foo.bar', 'foo')         // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is a descendant of `base`.
 */
function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

/**
 * Replaces a previous base path with a new base path, preserving the
 * remainder of the path.
 *
 * User must ensure `path` has a prefix of `base`.
 *
 * Example:
 *
 * ```
 * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'
 * ```
 *
 * @param {string} base Current base string to remove
 * @param {string} newBase New base string to replace with
 * @param {string} path Path to translate
 * @return {string} Translated string
 */
function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

/**
 * @param {string} base Path string to test against
 * @param {string} path Path string to test
 * @return {boolean} True if `path` is equal to `base`
 */
function matches(base, path) {
  return (base === path) ||
         isAncestor(base, path) ||
         isDescendant(base, path);
}

/**
 * Converts array-based paths to flattened path.  String-based paths
 * are returned as-is.
 *
 * Example:
 *
 * ```
 * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
 * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {string} Flattened path
 */
function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i=0; i<path.length; i++) {
      let args = path[i].toString().split('.');
      for (let j=0; j<args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

/**
 * Splits a path into an array of property names. Accepts either arrays
 * of path parts or strings.
 *
 * Example:
 *
 * ```
 * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
 * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {!Array<string>} Array of path parts
 * @suppress {checkTypes}
 */
function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

/**
 * Reads a value from a path.  If any sub-property in the path is `undefined`,
 * this method returns `undefined` (will never throw.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to read
 * @param {Object=} info If an object is provided to `info`, the normalized
 *  (flattened) path will be set to `info.path`.
 * @return {*} Value at path, or `undefined` if the path could not be
 *  fully dereferenced.
 */
function get(root, path, info) {
  let prop = root;
  let parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (let i=0; i<parts.length; i++) {
    if (!prop) {
      return;
    }
    let part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

/**
 * Sets a value to a path.  If any sub-property in the path is `undefined`,
 * this method will no-op.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to set
 * @param {*} value Value to set to path
 * @return {string | undefined} The normalized version of the input path
 */
function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length-1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i=0; i<parts.length-1; i++) {
      let part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;

/**
 * @fileoverview Module with utilities for converting between "dash-case" and
 * "camelCase" identifiers.
 */

/**
 * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
 * (e.g. `fooBarBaz`).
 *
 * @param {string} dash Dash-case identifier
 * @return {string} Camel-case representation of the identifier
 */
function dashToCamelCase(dash) {
  return caseMap[dash] || (
    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,
      (m) => m[1].toUpperCase()
    )
  );
}

/**
 * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
 * (e.g. `foo-bar-baz`).
 *
 * @param {string} camel Camel-case identifier
 * @return {string} Dash-case representation of the identifier
 */
function camelToDashCase(camel) {
  return caseMap[camel] || (
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()
  );
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// Microtask implemented using Mutation Observer
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});

function microtaskFlush() {
  const len = microtaskCallbacks.length;
  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => { throw e; });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

/**
 * Async interface wrapper around `setTimeout`.
 *
 * @namespace
 * @summary Async interface wrapper around `setTimeout`.
 */
const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) { return window.setTimeout(fn, delay); },
      cancel(handle) {
        window.clearTimeout(handle);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.clearTimeout(handle);
  }
};

/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */
const microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }

};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @const {!AsyncInterface} */
const microtask = microTask;

/**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin, call `MyClass.createProperties(props)`
 * once at class definition time to create property accessors for properties
 * named in props, implement `_propertiesChanged` to react as desired to
 * property changes, and implement `static get observedAttributes()` and
 * include lowercase versions of any property names that should be set from
 * attributes. Last, call `this._enableProperties()` in the element's
 * `connectedCallback` to enable the accessors.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const PropertiesChanged = dedupingMixin(
    /**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */
    (superClass) => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   */
  class PropertiesChanged extends superClass {

    /**
     * Creates property accessors for the given property names.
     * @param {!Object} props Object whose keys are names of accessors.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(props) {
      const proto = this.prototype;
      for (let prop in props) {
        // don't stomp an existing accessor
        if (!(prop in proto)) {
          proto._createPropertyAccessor(prop);
        }
      }
    }

    /**
     * Returns an attribute name that corresponds to the given property.
     * The attribute name is the lowercased property name. Override to
     * customize this mapping.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(property) {
      return property.toLowerCase();
    }

    /**
     * Override point to provide a type to which to deserialize a value to
     * a given property.
     * @param {string} name Name of property
     *
     * @protected
     * @nocollapse
     */
    static typeForProperty(name) { } //eslint-disable-line no-unused-vars

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @return {void}
     * @protected
     * @override
     */
    _createPropertyAccessor(property, readOnly) {
      this._addPropertyToAttributeMap(property);
      if (!this.hasOwnProperty('__dataHasAccessor')) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }
      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;
        this._definePropertyAccessor(property, readOnly);
      }
    }

    /**
     * Adds the given `property` to a map matching attribute names
     * to property names, using `attributeNameForProperty`. This map is
     * used when deserializing attribute values to properties.
     *
     * @param {string} property Name of the property
     * @override
     */
    _addPropertyToAttributeMap(property) {
      if (!this.hasOwnProperty('__dataAttributes')) {
        this.__dataAttributes = Object.assign({}, this.__dataAttributes);
      }
      if (!this.__dataAttributes[property]) {
        const attr = this.constructor.attributeNameForProperty(property);
        this.__dataAttributes[attr] = property;
      }
    }

    /**
     * Defines a property accessor for the given property.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     * @return {void}
     * @override
     */
     _definePropertyAccessor(property, readOnly) {
      Object.defineProperty(this, property, {
        /* eslint-disable valid-jsdoc */
        /** @this {PropertiesChanged} */
        get() {
          return this._getProperty(property);
        },
        /** @this {PropertiesChanged} */
        set: readOnly ? function () {} : function (value) {
          this._setProperty(property, value);
        }
        /* eslint-enable */
      });
    }

    constructor() {
      super();
      /** @type {boolean} */
      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      this.__dataInstanceProps = null;
      this.__serializing = false;
      this._initializeProperties();
    }

    /**
     * Lifecycle callback called when properties are enabled via
     * `_enableProperties`.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its property data initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @return {void}
     * @public
     * @override
     */
    ready() {
      this.__dataReady = true;
      this._flushProperties();
    }

    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }

    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }

    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     * @protected
     * @override
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }

    /**
     * Returns the value for the given property.
     * @param {string} property Name of property
     * @return {*} Value for the given property
     * @protected
     * @override
     */
    _getProperty(property) {
      return this.__data[property];
    }

    /* eslint-disable no-unused-vars */
    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} ext Not used here; affordance for closure
     * @return {boolean} Returns true if the property changed
     * @protected
     * @override
     */
    _setPendingProperty(property, value, ext) {
      let old = this.__data[property];
      let changed = this._shouldPropertyChange(property, value, old);
      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }
        this.__data[property] = value;
        this.__dataPending[property] = value;
      }
      return changed;
    }
    /* eslint-enable */

    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @return {void}
     * @protected
     * @override
     */
    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;
            this._flushProperties();
          }
        });
      }
    }

    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     *
     * @return {void}
     * @protected
     * @override
     */
    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;
        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);
          this.__dataInstanceProps = null;
        }
        this.ready();
      }
    }

    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     * @return {void}
     * @protected
     * @override
     */
    _flushProperties() {
      const props = this.__data;
      const changedProps = this.__dataPending;
      const old = this.__dataOld;
      if (this._shouldPropertiesChange(props, changedProps, old)) {
        this.__dataPending = null;
        this.__dataOld = null;
        this._propertiesChanged(props, changedProps, old);
      }
    }

    /**
     * Called in `_flushProperties` to determine if `_propertiesChanged`
     * should be called. The default implementation returns true if
     * properties are pending. Override to customize when
     * `_propertiesChanged` is called.
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {boolean} true if changedProps is truthy
     * @override
     */
    _shouldPropertiesChange(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
      return Boolean(changedProps);
    }

    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     * @protected
     * @override
     */
    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
    }

    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` if a strict equality
     * check fails. The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     * @override
     */
    _shouldPropertyChange(property, value, old) {
      return (
        // Strict equality check
        (old !== value &&
          // This ensures (old==NaN, value==NaN) always returns false
          (old === old || value === value))
      );
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @suppress {missingProperties} Super may or may not implement the callback
     * @override
     */
    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }
      if (super.attributeChangedCallback) {
        super.attributeChangedCallback(name, old, value, namespace);
      }
    }

    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to, defaults to the value
     * returned from `typeForProperty`
     * @return {void}
     * @override
     */
    _attributeToProperty(attribute, value, type) {
      if (!this.__serializing) {
        const map = this.__dataAttributes;
        const property = map && map[attribute] || attribute;
        this[property] = this._deserializeValue(value, type ||
          this.constructor.typeForProperty(property));
      }
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is an element.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect to.
     * @param {*=} value Property value to refect.
     * @return {void}
     * @override
     */
    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = (arguments.length < 3) ? this[property] : value;
      this._valueToNodeAttribute(/** @type {!HTMLElement} */(this), value,
        attribute || this.constructor.attributeNameForProperty(property));
      this.__serializing = false;
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @return {void}
     * @override
     */
    _valueToNodeAttribute(node, value, attribute) {
      const str = this._serializeValue(value);
      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {
        node = /** @type {?Element} */(wrap$1(node));
      }
      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(attribute, str);
      }
    }

    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called when setting JS property values to
     * HTML attributes.  Users may override this method to provide
     * serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided
     * property  value.
     * @override
     */
    _serializeValue(value) {
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;
        default:
          return value != null ? value.toString() : undefined;
      }
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called when reading HTML attribute values to
     * JS properties.  Users may override this method to provide
     * deserialization for custom `type`s. Types for `Boolean`, `String`,
     * and `Number` convert attributes to the expected types.
     *
     * @param {?string} value Value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(value, type) {
      switch (type) {
        case Boolean:
          return (value !== null);
        case Number:
          return Number(value);
        default:
          return value;
      }
    }

  }

  return PropertiesChanged;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i=0; i<props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @return {void}
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

/**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin:
 *
 * -   Declare attributes to observe via the standard `static get
 *     observedAttributes()`. Use `dash-case` attribute names to represent
 *     `camelCase` property names.
 * -   Implement the `_propertiesChanged` callback on the class.
 * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to
 *     generate property accessors for each observed attribute. This must be
 *     called before the first instance is created, for example, by calling it
 *     before calling `customElements.define`. It can also be called lazily from
 *     the element's `constructor`, as long as it's guarded so that the call is
 *     only made once, when the first instance is created.
 * -   Call `this._enableProperties()` in the element's `connectedCallback` to
 *     enable the accessors.
 *
 * Any `observedAttributes` will automatically be
 * deserialized via `attributeChangedCallback` and set to the associated
 * property using `dash-case`-to-`camelCase` convention.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const PropertyAccessors = dedupingMixin(superClass => {

  /**
   * @constructor
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   * @private
   */
   const base = PropertiesChanged(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends {base}
   * @unrestricted
   */
  class PropertyAccessors extends base {

    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let a$ =  /** @type {?} */ (this).observedAttributes;
      for (let i=0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));
      }
    }

    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(property) {
      return camelToDashCase(property);
    }

    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      super._initializeProperties();
    }

    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }

    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */
    _ensureAttribute(attribute, value) {
      const el = /** @type {!HTMLElement} */(this);
      if (!el.hasAttribute(attribute)) {
        this._valueToNodeAttribute(el, value, attribute);
      }
    }

    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */
    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch(x) {
              return '';
            }
          }

        default:
          return super._serializeValue(value);
      }
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;
      switch (type) {
        case Object:
          try {
            outValue = JSON.parse(/** @type {string} */(value));
          } catch(x) {
            // allow non-JSON literals like Strings and Numbers
            outValue = value;
          }
          break;
        case Array:
          try {
            outValue = JSON.parse(/** @type {string} */(value));
          } catch(x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;
        case Date:
          outValue = isNaN(value) ? String(value) : Number(value);
          outValue = new Date(outValue);
          break;
        default:
          outValue = super._deserializeValue(value, type);
          break;
      }
      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */
    _definePropertyAccessor(property, readOnly) {
      saveAccessorValue(this, property);
      super._definePropertyAccessor(property, readOnly);
    }

    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }

    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && (prop in this.__dataPending));
    }

  }

  return PropertyAccessors;

});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while(t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  let handler = function(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

/**
 * Element mixin that provides basic template parsing and stamping, including
 * the following template-related features for stamped templates:
 *
 * - Declarative event listeners (`on-eventname="listener"`)
 * - Map of node id's to stamped node instances (`this.$.id`)
 * - Nested template content caching/removal and re-installation (performance
 *   optimization)
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin that provides basic template parsing and stamping
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const TemplateStamp = dedupingMixin(
    /**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */
    (superClass) => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {

    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     * @nocollapse
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        // TODO(rictic): fix typing
        let /** ? */ templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.stripWhiteSpace =
          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
          template.hasAttribute('strip-whitespace');
         // TODO(rictic): fix typing
         this._parseTemplateContent(
             template, templateInfo, /** @type {?} */ ({parent: null}));
      }
      return template._templateInfo;
    }

    /**
     * See docs for _parseTemplateNode.
     *
     * @param {!HTMLTemplateElement} template .
     * @param {!TemplateInfo} templateInfo .
     * @param {!NodeInfo} nodeInfo .
     * @return {boolean} .
     * @nocollapse
     */
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }

    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = false;
      let element = /** @type {!HTMLTemplateElement} */ (node);
      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }
      if (element.firstChild) {
        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);
      }
      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }
      return noted;
    }

    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {void}
     */
    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      if (root.localName === 'script' || root.localName === 'style') {
        return;
      }
      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        }
        // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.
        next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let /** Node */ n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          // optionally strip whitespace
          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }
        let childInfo =
            /** @type {!NodeInfo} */ ({parentIndex, parentInfo: nodeInfo});
        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;
        }
        // Increment if not removed
        if (node.parentNode) {
          parentIndex++;
        }
      }
    }

    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      // TODO(rictic): the type of node should be non-null
      let element = /** @type {!HTMLTemplateElement} */ (node);
      let templateInfo = this._parseTemplate(element, outerTemplateInfo);
      let content = templateInfo.content =
          element.content.ownerDocument.createDocumentFragment();
      content.appendChild(element.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }

    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current
     *     template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */
    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);
      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }
      return noted;
    }

    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      }
      // static id
      else if (name === 'id') {
        nodeInfo.id = value;
        return true;
      }
      return false;
    }

    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     * @nocollapse
     */
    static _contentForTemplate(template) {
      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;
      return (templateInfo && templateInfo.content) || template.content;
    }

    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     */
    _stampTemplate(template) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content &&
          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }
      let templateInfo = this.constructor._parseTemplate(template);
      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));
      // NOTE: ShadyDom optimization indicating there is an insertion point
      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};
      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateContent(this, node, info);
        applyEventListener(this, node, info);
      }
      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign
      return dom;
    }

    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {!EventTarget} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     * @override
     */
    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);
      this._addEventListenerToNode(node, eventName, handler);
      return handler;
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */
    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */
    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;

});

/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
let dedupeId$1 = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/** @const {!RegExp} */
const capitalAttributeRegex = /[A-Z]/;

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (let p in effects) {
      let protoFx = effects[p];
      let instFx = effects[p] = Array(protoFx.length);
      for (let i=0; i<protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {?Object} effects Object map of property-to-Array of effects
 * @param {?Object} props Bag of current property changes
 * @param {?Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    let id = dedupeId$1++;
    for (let prop in props) {
      if (runEffectsForProperty(
              inst, /** @type {!Object} */ (effects), id, prop, props, oldProps,
              hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {!Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? root(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) &&
          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {?DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = /** @type {string} */ (trigger.name);
    return (triggerPath == path) ||
        !!(trigger.structured && isAncestor(triggerPath, path)) ||
        !!(trigger.wildcard && isDescendant(triggerPath, path));
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = typeof info.method === "string" ? inst[info.method] : info.method;
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.method + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId$1++;
  // Try normal notify effects; if none, fall back to try path notification
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  let rootProperty = root(path);
  if (rootProperty !== path) {
    let eventName = camelToDashCase(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} eventName The name of the event to send
 *     ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property
 *     changed, the path that changed (optional).
 * @return {void}
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  wrap$1(/** @type {!HTMLElement} */(inst)).dispatchEvent(new CustomEvent(eventName, { detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? root(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? get(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property];  // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!Polymer_PropertyEffects} inst Host element instance handling the
 *     notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @return {void}
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = /** @type {Object} */(event.detail);
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = translate(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.currentTarget[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))
      && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */(inst));
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {?Object} changedProps Bag of changed properties
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    let inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);
      Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {?Object} props Bag of current property changes
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  let result = runMethodEffect(inst, property, props, oldProps, info);
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!Polymer_PropertyEffects} inst The instance whose props are changing
 * @param {string} path Path that has changed
 * @param {*} value Value of changed path
 * @return {void}
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a in links) {
      let b = links[a];
      if (isDescendant(a, path)) {
        link = translate(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (isDescendant(b, path)) {
        link = translate(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @return {void}
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    let {event, negate} = binding.parts[0];
    binding.listenerEvent = event || (camelToDashCase(target) + '-changed');
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  let index = templateInfo.nodeInfoList.length;
  for (let i=0; i<binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 * @return {void}
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target +
        ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j=0; j<dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info, trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @return {void}
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && (path.length > part.source.length) &&
      (binding.kind == 'property') && !binding.isCompound &&
      node.__isPropertyEffectsClient &&
      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = translate(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @return {void}
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;
    if (node.__isPropertyEffectsClient &&
        node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else  {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' ||
        (binding.target === 'value' &&
          (node.localName === 'input' || node.localName === 'textarea'))) {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) &&
         binding.kind != 'attribute' &&
         binding.kind != 'text' &&
         !binding.isCompound &&
         binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!Polymer_PropertyEffects} inst Instance that bas been previously
 *     bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @return {void}
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {nodeList, nodeInfoList} = templateInfo;
  if (nodeInfoList.length) {
    for (let i=0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;
      if (bindings) {
        for (let i=0; i<bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage ||
      (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    // Copy literals from parts into storage for this binding
    let literals = new Array(parts.length);
    for (let j=0; j<parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      // Note, className needs style scoping so this needs wrapping.
      // We may also want to consider doing this for `textContent` and
      // `innerHTML`.
      if (target === 'className') {
        node = wrap$1(node);
      }
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!Polymer_PropertyEffects} inst Host element instance to handle
 *     notification event
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @return {void}
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || (dynamicFn &&
    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = inst._marshalArgs(info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = [];

// Regular expressions used for binding
const IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                              '(?:' + ARGUMENTS + '?' + ')' +
                            '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  let s = '';
  for (let i=0; i<parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    let methodName = m[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1')
    ;
  // basic argument descriptor
  let a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  let fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch(fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = root(arg);
    // detect structured path (has dots)
    a.structured = isPath(arg);
    if (a.structured) {
      a.wildcard = (arg.slice(-2) == '.*');
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

function getArgValue(data, props, path) {
  let value = get(data, path);
  // when data is not stored e.g. `splices`, get the value from changedProps
  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard
  // info.value could pull a stale value out of changedProps during a reentrant
  // change that sets the value back to undefined.
  // https://github.com/Polymer/polymer/issues/5479
  if (value === undefined) {
    value = props[path];
  }
  return value;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @return {void}
 * @private
 */
function notifySplices(inst, array, path, splices) {
  inst.notifyPath(path + '.splices', { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @return {void}
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

/**
 * Element class mixin that provides meta-programming for Polymer's template
 * binding and data observation (collectively, "property effects") system.
 *
 * This mixin uses provides the following key static methods for adding
 * property effects to an element class:
 * - `addPropertyEffect`
 * - `createPropertyObserver`
 * - `createMethodObserver`
 * - `createNotifyingProperty`
 * - `createReadOnlyProperty`
 * - `createReflectedProperty`
 * - `createComputedProperty`
 * - `bindTemplate`
 *
 * Each method creates one or more property accessors, along with metadata
 * used by this mixin's implementation of `_propertiesChanged` to perform
 * the property effects.
 *
 * Underscored versions of the above methods also exist on the element
 * prototype for adding property effects on instances at runtime.
 *
 * Note that this mixin overrides several `PropertyAccessors` methods, in
 * many cases to maintain guarantees provided by the Polymer 1.x features;
 * notably it changes property accessors to be synchronous by default
 * whereas the default when using `PropertyAccessors` standalone is to be
 * async by default.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin TemplateStamp
 * @appliesMixin PropertyAccessors
 * @summary Element class mixin that provides meta-programming for Polymer's
 * template binding and data observation system.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const PropertyEffects = dedupingMixin(superClass => {

  /**
   * @constructor
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   * @private
   */
  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */
  class PropertyEffects extends propertyEffectsBase {

    constructor() {
      super();
      /** @type {boolean} */
      // Used to identify users of this mixin, ala instanceof
      this.__isPropertyEffectsClient = true;
      /** @type {number} */
      // NOTE: used to track re-entrant calls to `_flushProperties`
      // path changes dirty check against `__dataTemp` only during one "turn"
      // and are cleared when `__dataCounter` returns to 0.
      this.__dataCounter = 0;
      /** @type {boolean} */
      this.__dataClientsReady;
      /** @type {Array} */
      this.__dataPendingClients;
      /** @type {Object} */
      this.__dataToNotify;
      /** @type {Object} */
      this.__dataLinkedPaths;
      /** @type {boolean} */
      this.__dataHasPaths;
      /** @type {Object} */
      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      this.__dataHost;
      /** @type {!Object} */
      this.__dataTemp;
      /** @type {boolean} */
      this.__dataClientsInitialized;
      /** @type {!Object} */
      this.__data;
      /** @type {!Object|null} */
      this.__dataPending;
      /** @type {!Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__computeEffects;
      /** @type {Object} */
      this.__reflectEffects;
      /** @type {Object} */
      this.__notifyEffects;
      /** @type {Object} */
      this.__propagateEffects;
      /** @type {Object} */
      this.__observeEffects;
      /** @type {Object} */
      this.__readOnly;
      /** @type {!TemplateInfo} */
      this.__templateInfo;
    }

    /**
     * @return {!Object<string, string>} Effect prototype property name map.
     */
    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }

    /**
     * @override
     * @return {void}
     */
    _initializeProperties() {
      super._initializeProperties();
      hostStack.registerHost(this);
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      // May be set on instance prior to upgrade
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }

    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }

    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }

    // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      // effects are accumulated into arrays per property based on type
      let effects = ensureOwnEffectMap(this, type)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }

    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }

    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }

    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }

    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }

    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }

    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }

    // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification ||
          root(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = get(this, path);
          path = /** @type {string} */ (set(this, path, value));
          // Use property-accessor's simpler dirty check
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {
          computeLinkedPaths(this, /**@type{string}*/ (path), value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);
        } else {
          this[path] = value;
        }
      }
      return false;
    }

    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        // Note, className needs style scoping so this needs wrapping.
        if (prop === 'className') {
          node = /** @type {!Node} */(wrap$1(node));
        }
        node[prop] = value;
      }
    }

    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */
    _setPendingProperty(property, value, shouldNotify) {
      let propIsPath = this.__dataHasPaths && isPath(property);
      let prevProps = propIsPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data
        if (propIsPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        // All changes go into pending property bag, passed to _propertiesChanged
        this.__dataPending[property] = value;
        // Track properties that should notify separately
        if (propIsPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }

    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }

    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }

    /**
     * Overrides superclass implementation.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushProperties() {
      this.__dataCounter++;
      super._flushProperties();
      this.__dataCounter--;
    }

    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }

    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i=0; i < clients.length; i++) {
          let client = clients[i];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }

    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }

    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }

    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */
    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties();
      // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.
      if (this.__dataPending) {
        this._flushProperties();
      }
    }

    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */
    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      // Compute properties
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them
      let notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      // Propagate properties to clients
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      // Flush clients
      this._flushClients();
      // Reflect properties
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      // Observe properties
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      // Notify properties to host
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      // Clear temporary cache at end of turn
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
      // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------
    }

    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      let templateInfo = this.__templateInfo;
      while (templateInfo) {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,
          hasPaths, templateInfo.nodeList);
        templateInfo = templateInfo.nextTemplateInfo;
      }
    }

    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */
    linkPaths(to, from) {
      to = normalize(to);
      from = normalize(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }

    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */
    unlinkPaths(path) {
      path = normalize(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }

    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */
    notifySplices(path, splices) {
      let info = {path: ''};
      let array = /** @type {Array} */(get(this, path, info));
      notifySplices(this, array, info.path, splices);
    }

    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(path, root) {
      return get(root || this, path);
    }

    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */
    set(path, value, root) {
      if (root) {
        set(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }

    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array}*/(get(this, path, info));
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }

    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(get(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }

    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {Array} Array of removed items.
     * @public
     */
    splice(path, start, deleteCount, ...items) {
      let info = {path : ''};
      let array = /** @type {Array} */(get(this, path, info));
      // Normalize fancy native splice handling of crazy start values
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else if (start) {
        start = Math.floor(start);
      }
      // array.splice does different things based on the number of arguments
      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)
      // do different things. In the former, the whole array is cleared. In the
      // latter, no items are removed.
      // This means that we need to detect whether 1. one of the arguments
      // is actually passed in and then 2. determine how many arguments
      // we should pass on to the native array.splice
      //
      let ret;
      // Omit any additional arguments if they were not passed in
      if (arguments.length === 2) {
        ret = array.splice(start);
      // Either start was undefined and the others were defined, but in this
      // case we can safely pass on all arguments
      //
      // Note: this includes the case where none of the arguments were passed in,
      // e.g. this.splice('array'). However, if both start and deleteCount
      // are undefined, array.splice will not modify the array (as expected)
      } else {
        ret = array.splice(start, deleteCount, ...items);
      }
      // At the end, check whether any items were passed in (e.g. insertions)
      // or if the return array contains items (e.g. deletions).
      // Only notify if items were added or deleted.
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }

    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(get(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }

    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array} */(get(this, path, info));
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }

    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */
    notifyPath(path, value) {
      /** @type {string} */
      let propPath;
      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {path: ''};
        value = get(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = normalize(path);
      } else {
        propPath = /** @type{string} */(path);
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {
          this._setProperty(property, value);
        };
      }
    }

    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createPropertyObserver(property, method, dynamicFn) {
      let info = { property, method, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect, info, trigger: {name: property}
      });
      if (dynamicFn) {
        this._addPropertyEffect(/** @type {string} */(method), TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: {name: method}
        });
      }
    }

    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }

    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }

    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _createReflectedProperty(property) {
      let attr = this.constructor.attributeNameForProperty(property);
      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' +
          attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }

    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
    }

    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {Array<*>} Array of argument values
     * @private
     */
    _marshalArgs(args, path, props) {
      const data = this.__data;
      const values = [];
      for (let i=0, l=args.length; i<l; i++) {
        let {name, structured, wildcard, value, literal} = args[i];
        if (!literal) {
          if (wildcard) {
            const matches = isDescendant(name, path);
            const pathValue = getArgValue(data, props, matches ? path : name);
            value = {
              path: matches ? path : name,
              value: pathValue,
              base: matches ? get(data, name) : pathValue
            };
          } else {
            value = structured ? getArgValue(data, props, name) : data[name];
          }
        }
        values[i] = value;
      }
      return values;
    }

    // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }

    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createPropertyObserver(property, method, dynamicFn) {
      this.prototype._createPropertyObserver(property, method, dynamicFn);
    }

    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }

    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }

    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }

    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }

    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }

    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */
    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    }

    // -- binding ----------------------------------------------

    /**
     * Equivalent to static `bindTemplate` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @param {boolean=} instanceBinding When false (default), performs
     *   "prototypical" binding of the template and overwrites any previously
     *   bound template for the class. When true (as passed from
     *   `_stampTemplate`), the template info is instanced and linked into
     *   the list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     *   this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);
      let wasPreBound = this.__templateInfo == templateInfo;
      // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into list of templates if necessary
        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));
        templateInfo.wasPreBound = wasPreBound;
        if (!wasPreBound && this.__templateInfo) {
          let last = this.__templateInfoLast || this.__templateInfo;
          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
          templateInfo.previousTemplateInfo = last;
          return templateInfo;
        }
      }
      return this.__templateInfo = templateInfo;
    }

    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }

    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(template) {
      // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`
      hostStack.beginHosting(this);
      let dom = super._stampTemplate(template);
      hostStack.endHosting(this);
      let templateInfo = /** @type {!TemplateInfo} */(this._bindTemplate(template, true));
      // Add template-instance-specific data to instanced templateInfo
      templateInfo.nodeList = dom.nodeList;
      // Capture child nodes to allow unstamping of non-prototypical templates
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n=dom.firstChild; n; n=n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      // Setup compound storage, 2-way listeners, and dataHost for bindings
      setupBindings(this, templateInfo);
      // Flush properties into template nodes if already booted
      if (this.__dataReady) {
        runEffects(this, templateInfo.propertyEffects, this.__data, null,
          false, templateInfo.nodeList);
      }
      return dom;
    }

    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */
    _removeBoundDom(dom) {
      // Unlink template info
      let templateInfo = dom.templateInfo;
      if (templateInfo.previousTemplateInfo) {
        templateInfo.previousTemplateInfo.nextTemplateInfo =
          templateInfo.nextTemplateInfo;
      }
      if (templateInfo.nextTemplateInfo) {
        templateInfo.nextTemplateInfo.previousTemplateInfo =
          templateInfo.previousTemplateInfo;
      }
      if (this.__templateInfoLast == templateInfo) {
        this.__templateInfoLast = templateInfo.previousTemplateInfo;
      }
      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
      // Remove stamped nodes
      let nodes = templateInfo.childNodes;
      for (let i=0; i<nodes.length; i++) {
        let node = nodes[i];
        node.parentNode.removeChild(node);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      let noted = propertyEffectsBase._parseTemplateNode.call(
        this, node, templateInfo, nodeInfo);
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) omit an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }
      return noted;
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property';
        // The only way we see a capital letter here is if the attr has
        // a capital letter in it per spec. In this case, to make sure
        // this binding works, we go ahead and make the binding to the attribute.
        if (capitalAttributeRegex.test(name)) {
          kind = 'attribute';
        } else if (name[name.length-1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        }
        // Initialize attribute bindings with any literal parts
        let literal = literalFromParts(parts);
        if (literal && kind == 'attribute') {
          // Ensure a ShadyCSS template scoped style is not removed
          // when a class$ binding's initial literal value is set.
          if (name == 'class' && node.hasAttribute('class')) {
            literal += ' ' + node.getAttribute(name);
          }
          node.setAttribute(name, literal);
        }
        // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)
        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        }
        // Remove annotation
        node.removeAttribute(origName);
        // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.
        if (kind === 'property') {
          name = dashToCamelCase(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        // TODO(https://github.com/google/closure-compiler/issues/3240):
        //     Change back to just super.methodCall()
        return propertyEffectsBase._parseTemplateNodeAttribute.call(
          this, node, templateInfo, nodeInfo, name, value);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(
        this, node, templateInfo, nodeInfo);
      // Merge host props into outer template and add bindings
      let hostProps = nodeInfo.templateInfo.hostProps;
      let mode = '{';
      for (let source in hostProps) {
        let parts = [{ mode, source, dependencies: [source] }];
        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
      }
      return noted;
    }

    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m;
      // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'
      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({literal: text.slice(lastIndex, m.index)});
        }
        // Add binding part
        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false, notifyEvent = '', colon = -1;
        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          // Inline computed function
          let {args, methodName} = signature;
          for (let i=0; i<args.length; i++) {
            let arg = args[i];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }
        parts.push({
          source, mode, negate, customEvent, signature, dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      // Add a final literal part
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }

    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = get(inst, part.source);
      } else {
        if (hasPaths && isPath(path)) {
          value = get(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }

  }

  return PropertyEffects;
});

/**
 * Helper api for enqueuing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
class HostStack {
  constructor() {
    this.stack = [];
  }

  /**
   * @param {*} inst Instance to add to hostStack
   * @return {void}
   */
  registerHost(inst) {
    if (this.stack.length) {
      let host = this.stack[this.stack.length-1];
      host._enqueueClient(inst);
    }
  }

  /**
   * @param {*} inst Instance to begin hosting
   * @return {void}
   */
  beginHosting(inst) {
    this.stack.push(inst);
  }

  /**
   * @param {*} inst Instance to end hosting
   * @return {void}
   */
  endHosting(inst) {
    let stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen-1] == inst) {
      this.stack.pop();
    }
  }
}
const hostStack = new HostStack();

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Registers a class prototype for telemetry purposes.
 * @param {!PolymerElementConstructor} prototype Element prototype to register
 * @protected
 */
function register(prototype) {
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Creates a copy of `props` with each property normalized such that
 * upgraded it is an object with at least a type property { type: Type}.
 *
 * @param {Object} props Properties to normalize
 * @return {Object} Copy of input `props` with normalized properties that
 * are in the form {type: Type}
 * @private
 */
function normalizeProperties(props) {
  const output = {};
  for (let p in props) {
    const o = props[p];
    output[p] = (typeof o === 'function') ? {type: o} : o;
  }
  return output;
}

/**
 * Mixin that provides a minimal starting point to using the PropertiesChanged
 * mixin by providing a mechanism to declare properties in a static
 * getter (e.g. static get properties() { return { foo: String } }). Changes
 * are reported via the `_propertiesChanged` method.
 *
 * This mixin provides no specific support for rendering. Users are expected
 * to create a ShadowRoot and put content into it and update it in whatever
 * way makes sense. This can be done in reaction to properties changing by
 * implementing `_propertiesChanged`.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Mixin that provides a minimal starting point for using
 * the PropertiesChanged mixin by providing a declarative `properties` object.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const PropertiesMixin = dedupingMixin(superClass => {

 /**
  * @constructor
  * @implements {Polymer_PropertiesChanged}
  * @private
  */
 const base = PropertiesChanged(superClass);

 /**
  * Returns the super class constructor for the given class, if it is an
  * instance of the PropertiesMixin.
  *
  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {?PropertiesMixinConstructor} Super class constructor
  */
 function superPropertiesClass(constructor) {
   const superCtor = Object.getPrototypeOf(constructor);

   // Note, the `PropertiesMixin` class below only refers to the class
   // generated by this call to the mixin; the instanceof test only works
   // because the mixin is deduped and guaranteed only to apply once, hence
   // all constructors in a proto chain will see the same `PropertiesMixin`
   return (superCtor.prototype instanceof PropertiesMixin) ?
     /** @type {!PropertiesMixinConstructor} */ (superCtor) : null;
 }

 /**
  * Returns a memoized version of the `properties` object for the
  * given class. Properties not in object format are converted to at
  * least {type}.
  *
  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {Object} Memoized properties object
  */
 function ownProperties(constructor) {
   if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
     let props = null;

     if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {
       const properties = constructor.properties;

       if (properties) {
        props = normalizeProperties(properties);
       }
     }

     constructor.__ownProperties = props;
   }
   return constructor.__ownProperties;
 }

 /**
  * @polymer
  * @mixinClass
  * @extends {base}
  * @implements {Polymer_PropertiesMixin}
  * @unrestricted
  */
 class PropertiesMixin extends base {

   /**
    * Implements standard custom elements getter to observes the attributes
    * listed in `properties`.
    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
    * @nocollapse
    */
   static get observedAttributes() {
     if (!this.hasOwnProperty('__observedAttributes')) {
       register(this.prototype);
       const props = this._properties;
       this.__observedAttributes = props ? Object.keys(props).map(p => this.attributeNameForProperty(p)) : [];
     }
     return this.__observedAttributes;
   }

   /**
    * Finalizes an element definition, including ensuring any super classes
    * are also finalized. This includes ensuring property
    * accessors exist on the element prototype. This method calls
    * `_finalizeClass` to finalize each constructor in the prototype chain.
    * @return {void}
    * @nocollapse
    */
   static finalize() {
     if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
       const superCtor = superPropertiesClass(/** @type {!PropertiesMixinConstructor} */(this));
       if (superCtor) {
         superCtor.finalize();
       }
       this.__finalized = true;
       this._finalizeClass();
     }
   }

   /**
    * Finalize an element class. This includes ensuring property
    * accessors exist on the element prototype. This method is called by
    * `finalize` and finalizes the class constructor.
    *
    * @protected
    * @nocollapse
    */
   static _finalizeClass() {
     const props = ownProperties(/** @type {!PropertiesMixinConstructor} */(this));
     if (props) {
       /** @type {?} */ (this).createProperties(props);
     }
   }

   /**
    * Returns a memoized version of all properties, including those inherited
    * from super classes. Properties not in object format are converted to
    * at least {type}.
    *
    * @return {Object} Object containing properties for this class
    * @protected
    * @nocollapse
    */
   static get _properties() {
     if (!this.hasOwnProperty(
       JSCompiler_renameProperty('__properties', this))) {
       const superCtor = superPropertiesClass(/** @type {!PropertiesMixinConstructor} */(this));
       this.__properties = Object.assign({},
         superCtor && superCtor._properties,
         ownProperties(/** @type {PropertiesMixinConstructor} */(this)));
     }
     return this.__properties;
   }

   /**
    * Overrides `PropertiesChanged` method to return type specified in the
    * static `properties` object for the given property.
    * @param {string} name Name of property
    * @return {*} Type to which to deserialize attribute
    *
    * @protected
    * @nocollapse
    */
   static typeForProperty(name) {
     const info = this._properties[name];
     return info && info.type;
   }

   /**
    * Overrides `PropertiesChanged` method and adds a call to
    * `finalize` which lazily configures the element's property accessors.
    * @override
    * @return {void}
    */
   _initializeProperties() {
     this.constructor.finalize();
     super._initializeProperties();
   }

   /**
    * Called when the element is added to a document.
    * Calls `_enableProperties` to turn on property system from
    * `PropertiesChanged`.
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    * @override
    */
   connectedCallback() {
     if (super.connectedCallback) {
       super.connectedCallback();
     }
     this._enableProperties();
   }

   /**
    * Called when the element is removed from a document
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    * @override
    */
   disconnectedCallback() {
     if (super.disconnectedCallback) {
       super.disconnectedCallback();
     }
   }

 }

 return PropertiesMixin;

});

/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * Current Polymer version in Semver notation.
 * @type {string} Semver notation of the current version of Polymer.
 */
const version = '3.3.0';

const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];

/**
 * Element class mixin that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * Subclassers may provide the following static getters to return metadata
 * used to configure Polymer's features for the class:
 *
 * - `static get is()`: When the template is provided via a `dom-module`,
 *   users should return the `dom-module` id from a static `is` getter.  If
 *   no template is needed or the template is provided directly via the
 *   `template` getter, there is no need to define `is` for the element.
 *
 * - `static get template()`: Users may provide the template directly (as
 *   opposed to via `dom-module`) by implementing a static `template` getter.
 *   The getter must return an `HTMLTemplateElement`.
 *
 * - `static get properties()`: Should return an object describing
 *   property-related metadata used by Polymer features (key: property name
 *   value: object containing property metadata). Valid keys in per-property
 *   metadata include:
 *   - `type` (String|Number|Object|Array|...): Used by
 *     `attributeChangedCallback` to determine how string-based attributes
 *     are deserialized to JavaScript property values.
 *   - `notify` (boolean): Causes a change in the property to fire a
 *     non-bubbling event called `<property>-changed`. Elements that have
 *     enabled two-way binding to the property use this event to observe changes.
 *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
 *     To set a read-only property, use the private setter method
 *     `_setProperty(property, value)`.
 *   - `observer` (string): Observer method name that will be called when
 *     the property changes. The arguments of the method are
 *     `(value, previousValue)`.
 *   - `computed` (string): String describing method and dependent properties
 *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
 *     Computed properties are read-only by default and can only be changed
 *     via the return value of the computing method.
 *
 * - `static get observers()`: Array of strings describing multi-property
 *   observer methods and their dependent properties (e.g.
 *   `'observeABC(a, b, c)'`).
 *
 * The base class provides default implementations for the following standard
 * custom element lifecycle callbacks; users may override these, but should
 * call the super method to ensure
 * - `constructor`: Run when the element is created or upgraded
 * - `connectedCallback`: Run each time the element is connected to the
 *   document
 * - `disconnectedCallback`: Run each time the element is disconnected from
 *   the document
 * - `attributeChangedCallback`: Run each time an attribute in
 *   `observedAttributes` is set or removed (note: this element's default
 *   `observedAttributes` implementation will automatically return an array
 *   of dash-cased attributes based on `properties`)
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertyEffects
 * @appliesMixin PropertiesMixin
 * @property rootPath {string} Set to the value of `rootPath`,
 *   which defaults to the main document path
 * @property importPath {string} Set to the value of the class's static
 *   `importPath` property, which defaults to the path of this element's
 *   `dom-module` (when `is` is used), but can be overridden for other
 *   import strategies.
 * @summary Element class mixin that provides the core API for Polymer's
 * meta-programming features.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const ElementMixin = dedupingMixin(base => {
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_PropertiesMixin}
   * @extends {HTMLElement}
   * @private
   */
  const polymerElementBase = PropertiesMixin(PropertyEffects(base));

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `_properties`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} constructor Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaults(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty('__propertyDefaults', constructor))) {
      constructor.__propertyDefaults = null;
      let props = constructor._properties;
      for (let p in props) {
        let info = props[p];
        if ('value' in info) {
          constructor.__propertyDefaults = constructor.__propertyDefaults || {};
          constructor.__propertyDefaults[p] = info;
        }
      }
    }
    return constructor.__propertyDefaults;
  }

  /**
   * Returns a memoized version of the `observers` array.
   * @param {PolymerElementConstructor} constructor Element class
   * @return {Array} Array containing own observers for the given class
   * @protected
   */
  function ownObservers(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty('__ownObservers', constructor))) {
      constructor.__ownObservers =
          constructor.hasOwnProperty(
              JSCompiler_renameProperty('observers', constructor)) ?
          /** @type {PolymerElementConstructor} */ (constructor).observers :
          null;
    }
    return constructor.__ownObservers;
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is deserialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * is also automatically set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttribute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   *
   * @param {!PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @return {void}
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed) {
      if (proto._hasReadOnlyEffect(name)) {
        console.warn(`Cannot redefine computed property '${name}'.`);
      } else {
        proto._createComputedProperty(name, info.computed, allProps);
      }
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {
      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {
      console.warn(`Cannot make reflected property '${name}' non-reflected.`);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    } else if (info.notify === false && proto._hasNotifyEffect(name)) {
      console.warn(`Cannot make notify property '${name}' non-notify.`);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
    // always create the mapping from attribute back to property for deserialization.
    proto._addPropertyToAttributeMap(name);
  }

  /**
   * Process all style elements in the element template. Styles with the
   * `include` attribute are processed such that any styles in
   * the associated "style modules" are included in the element template.
   * @param {PolymerElementConstructor} klass Element class
   * @param {!HTMLTemplateElement} template Template to process
   * @param {string} is Name of element
   * @param {string} baseURI Base URI for element
   * @private
   */
  function processElementStyles(klass, template, is, baseURI) {
    if (!builtCSS) {
      const templateStyles = template.content.querySelectorAll('style');
      const stylesWithImports = stylesFromTemplate(template);
      // insert styles from <link rel="import" type="css"> at the top of the template
      const linkedStyles = stylesFromModuleImports(is);
      const firstTemplateChild = template.content.firstElementChild;
      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s = linkedStyles[idx];
        s.textContent = klass._processStyleText(s.textContent, baseURI);
        template.content.insertBefore(s, firstTemplateChild);
      }
      // keep track of the last "concrete" style in the template we have encountered
      let templateStyleIndex = 0;
      // ensure all gathered styles are actually in this template.
      for (let i = 0; i < stylesWithImports.length; i++) {
        let s = stylesWithImports[i];
        let templateStyle = templateStyles[templateStyleIndex];
        // if the style is not in this template, it's been "included" and
        // we put a clone of it in the template before the style that included it
        if (templateStyle !== s) {
          s = s.cloneNode(true);
          templateStyle.parentNode.insertBefore(s, templateStyle);
        } else {
          templateStyleIndex++;
        }
        s.textContent = klass._processStyleText(s.textContent, baseURI);
      }
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is);
    }
  }

  /**
   * Look up template from dom-module for element
   *
   * @param {string} is Element name to look up
   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or
   *   undefined if not found
   * @protected
   */
  function getTemplateFromDomModule(is) {
    let template = null;
    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed
    // when opted-in via allowTemplateFromDomModule
    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {
      template = /** @type {?HTMLTemplateElement} */ (
          DomModule.import(is, 'template'));
      // Under strictTemplatePolicy, require any element with an `is`
      // specified to have a dom-module
      if (strictTemplatePolicy && !template) {
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
      }
    }
    return template;
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   * @extends {polymerElementBase}
   */
  class PolymerElement extends polymerElementBase {

    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return version;
    }

    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _finalizeClass() {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      polymerElementBase._finalizeClass.call(this);
      const observers = ownObservers(this);
      if (observers) {
        this.createObservers(observers, this._properties);
      }
      this._prepareTemplate();
    }

    /** @nocollapse */
    static _prepareTemplate() {
      // note: create "working" template that is finalized at instance time
      let template = /** @type {PolymerElementConstructor} */ (this).template;
      if (template) {
        if (typeof template === 'string') {
          console.error('template getter must return HTMLTemplateElement');
          template = null;
        } else if (!legacyOptimizations) {
          template = template.cloneNode(true);
        }
      }

      /** @override */
      this.prototype._template = template;
    }

    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(props) {
      for (let p in props) {
        createPropertyFromConfig(
            /** @type {?} */ (this.prototype), p, props[p], props);
      }
    }

    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createObservers(observers, dynamicFns) {
      const proto = this.prototype;
      for (let i=0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }

    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation
     * will return the first `<template>` in a `dom-module` whose `id`
     * matches this element's `is`.
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */
    static get template() {
      // Explanation of template-related properties:
      // - constructor.template (this getter): the template for the class.
      //     This can come from the prototype (for legacy elements), from a
      //     dom-module, or from the super class's template (or can be overridden
      //     altogether by the user)
      // - constructor._template: memoized version of constructor.template
      // - prototype._template: working template for the element, which will be
      //     parsed and modified in place. It is a cloned version of
      //     constructor.template, saved in _finalizeClass(). Note that before
      //     this getter is called, for legacy elements this could be from a
      //     _template field on the info object passed to Polymer(), a behavior,
      //     or set in registered(); once the static getter runs, a clone of it
      //     will overwrite it on the prototype as the working template.
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        this._template =
          // If user has put template on prototype (e.g. in legacy via registered
          // callback or info object), prefer that first
          this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ?
          this.prototype._template :
          // Look in dom-module associated with this element's is
          (getTemplateFromDomModule(/** @type {PolymerElementConstructor}*/ (this).is) ||
          // Next look for superclass template (call the super impl this
          // way so that `this` points to the superclass)
          Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.template);
      }
      return this._template;
    }

    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */
    static set template(value) {
      this._template = value;
    }

    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
        const meta = this.importMeta;
        if (meta) {
          this._importPath = pathFromUrl(meta.url);
        } else {
          const module = DomModule.import(/** @type {PolymerElementConstructor} */ (this).is);
          this._importPath = (module && module.assetpath) ||
            Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ (this).prototype).constructor.importPath;
        }
      }
      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */
      this._template;
      /** @type {string} */
      this._importPath;
      /** @type {string} */
      this.rootPath;
      /** @type {string} */
      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      this.root;
      /** @type {!Object<string, !Element>} */
      this.$;
    }

    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */
    _initializeProperties() {
      this.constructor.finalize();
      // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.
      this.constructor._finalizeTemplate(/** @type {!HTMLElement} */(this).localName);
      super._initializeProperties();
      // set path defaults
      this.rootPath = rootPath;
      this.importPath = this.constructor.importPath;
      // apply property defaults...
      let p$ = propertyDefaults(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        // Don't set default value if there is already an own property, which
        // happens when a `properties` property with default but no effects had
        // a property set (e.g. bound) by its host before upgrade
        if (!this.hasOwnProperty(p)) {
          let value = typeof info.value == 'function' ?
            info.value.call(this) :
            info.value;
          // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }

    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */
    static _processStyleText(cssText, baseURI) {
      return resolveCss(cssText, baseURI);
    }

    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */
    static _finalizeTemplate(is) {
      /** @const {HTMLTemplateElement} */
      const template = this.prototype._template;
      if (template && !template.__polymerFinalized) {
        template.__polymerFinalized = true;
        const importPath = this.importPath;
        const baseURI = importPath ? resolveUrl(importPath) : '';
        // e.g. support `include="module-name"`, and ShadyCSS
        processElementStyles(this, template, is, baseURI);
        this.prototype._bindTemplate(template);
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));
      }
      super.connectedCallback();
    }

    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }

    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));
      }
      // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.
      super._readyClients();
    }


    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(dom) {
      const n = wrap$1(this);
      if (n.attachShadow) {
        if (dom) {
          if (!n.shadowRoot) {
            n.attachShadow({mode: 'open', shadyUpgradeFragment: dom});
            n.shadowRoot.appendChild(dom);
          }
          if (syncInitialRender && window.ShadyDOM) {
            ShadyDOM.flushInitial(n.shadowRoot);
          }
          return n.shadowRoot;
        }
        return null;
      } else {
        throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
        'PolymerElement can create dom as children instead of in ' +
        'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }

    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);
      }
    }

    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = resolveUrl(this.importPath);
      }
      return resolveUrl(url, base);
    }

    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      return polymerElementBase._parseTemplateContent.call(
        this, template, templateInfo, nodeInfo);
    }

    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      // Warn if properties are used in template without being declared.
      // Properties must be listed in `properties` to be included in
      // `observedAttributes` since CE V1 reads that at registration time, and
      // since we want to keep template parsing lazy, we can't automatically
      // add undeclared properties used in templates to `observedAttributes`.
      // The warning is only enabled in `legacyOptimizations` mode, since
      // we don't want to spam existing users who might have adopted the
      // shorthand when attribute deserialization is not important.
      if (legacyOptimizations && !(prop in this._properties)) {
        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` +
          `attribute will not be observed.`);
      }
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      return polymerElementBase._addTemplatePropertyEffect.call(
        this, templateInfo, prop, effect);
    }

  }

  return PolymerElement;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 */
class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue.delete(this);
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    if (this.isActive()) {
      this._cancelAsync();
      // Canceling a debouncer removes its spot from the flush queue,
      // so if a debouncer is manually canceled and re-debounced, it
      // will reset its flush order (this is a very minor difference from 1.x)
      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order
      debouncerQueue.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(/** @type {number} */(this._timer));
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      // Cancel the async callback, but leave in debouncerQueue if it was
      // enqueued, to maintain 1.x flush order
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}

let debouncerQueue = new Set();

/**
 * Adds a `Debouncer` to a list of globally flushable tasks.
 *
 * @param {!Debouncer} debouncer Debouncer to enqueue
 * @return {void}
 */
const enqueueDebouncer = function(debouncer) {
  debouncerQueue.add(debouncer);
};

/**
 * Flushes any enqueued debouncers
 *
 * @return {boolean} Returns whether any debouncers were flushed
 */
const flushDebouncers = function() {
  const didFlush = Boolean(debouncerQueue.size);
  // If new debouncers are added while flushing, Set.forEach will ensure
  // newly added ones are also flushed
  debouncerQueue.forEach(debouncer => {
    try {
      debouncer.flush();
    } catch(e) {
      setTimeout(() => {
        throw e;
      });
    }
  });
  return didFlush;
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// detect native touch action support
let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
// number of last N track positions to keep
let TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
let MOUSE_HAS_BUTTONS = (function() {
  try {
    return new MouseEvent('test', {buttons: 1}).buttons === 1;
  } catch (e) {
    return false;
  }
})();

/**
 * @param {string} name Possible mouse event name
 * @return {boolean} true if mouse event, false if not
 */
function isMouseEvent(name) {
  return MOUSE_EVENTS.indexOf(name) > -1;
}

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
let SUPPORTS_PASSIVE = false;
(function() {
  try {
    let opts = Object.defineProperty({}, 'passive', {get() {SUPPORTS_PASSIVE = true;}});
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch(e) {}
})();

/**
 * Generate settings for event listeners, dependant on `passiveTouchGestures`
 *
 * @param {string} eventName Event name to determine if `{passive}` option is
 *   needed
 * @return {{passive: boolean} | undefined} Options to use for addEventListener
 *   and removeEventListener
 */
function PASSIVE_TOUCH(eventName) {
  if (isMouseEvent(eventName) || eventName === 'touchend') {
    return;
  }
  if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {
    return {passive: true};
  } else {
    return;
  }
}

// Check for touch-only devices
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

// keep track of any labels hit by the mouseCanceller
/** @type {!Array<!HTMLLabelElement>} */
const clickedLabels = [];

/** @type {!Object<boolean>} */
const labellable = {
  'button': true,
  'input': true,
  'keygen': true,
  'meter': true,
  'output': true,
  'textarea': true,
  'progress': true,
  'select': true
};

// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute
/** @type {!Object<boolean>} */
const canBeDisabled = {
  'button': true,
  'command': true,
  'fieldset': true,
  'input': true,
  'keygen': true,
  'optgroup': true,
  'option': true,
  'select': true,
  'textarea': true
};

/**
 * @param {HTMLElement} el Element to check labelling status
 * @return {boolean} element can have labels
 */
function canBeLabelled(el) {
  return labellable[el.localName] || false;
}

/**
 * @param {HTMLElement} el Element that may be labelled.
 * @return {!Array<!HTMLLabelElement>} Relevant label for `el`
 */
function matchingLabels(el) {
  let labels = Array.prototype.slice.call(/** @type {HTMLInputElement} */(el).labels || []);
  // IE doesn't have `labels` and Safari doesn't populate `labels`
  // if element is in a shadowroot.
  // In this instance, finding the non-ancestor labels is enough,
  // as the mouseCancellor code will handle ancstor labels
  if (!labels.length) {
    labels = [];
    let root = el.getRootNode();
    // if there is an id on `el`, check for all labels with a matching `for` attribute
    if (el.id) {
      let matching = root.querySelectorAll(`label[for = ${el.id}]`);
      for (let i = 0; i < matching.length; i++) {
        labels.push(/** @type {!HTMLLabelElement} */(matching[i]));
      }
    }
  }
  return labels;
}

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
let mouseCanceller = function(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  let sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = {skip: true};
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    let clickFromLabel = false;
    let path = getComposedPath(mouseEvent);
    for (let i = 0; i < path.length; i++) {
      if (path[i].nodeType === Node.ELEMENT_NODE) {
        if (path[i].localName === 'label') {
          clickedLabels.push(/** @type {!HTMLLabelElement} */ (path[i]));
        } else if (canBeLabelled(/** @type {!HTMLElement} */ (path[i]))) {
          let ownerLabels =
              matchingLabels(/** @type {!HTMLElement} */ (path[i]));
          // check if one of the clicked labels is labelling this element
          for (let j = 0; j < ownerLabels.length; j++) {
            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
          }
        }
      }
      if (path[i] === POINTERSTATE.mouse.target) {
        return;
      }
    }
    // if one of the clicked labels was labelling the target element,
    // this is not a ghost click
    if (clickFromLabel) {
      return;
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 * @return {void}
 */
function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (let i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      // reset clickLabels array
      clickedLabels.length = 0;
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!cancelSyntheticClickEvents) {
    return;
  }
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  let unset = function() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = getComposedPath(e)[0];
  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(
        POINTERSTATE.mouse.mouseIgnoreJob
      , timeOut.after(MOUSE_TIMEOUT)
      , unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  let type = ev.type;
  // exit early if the event is not a mouse event
  if (!isMouseEvent(type)) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    let buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    let button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    let t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    let bcr = /** @type {Element} */(t).getBoundingClientRect();
    // use page x/y to account for scrolling
    let x = ev.pageX, y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
  }
  return false;
}

let POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  let ta = 'auto';
  let path = getComposedPath(ev);
  for (let i = 0, n; i < path.length; i++) {
    n = path[i];
    if (n[TOUCH_ACTION]) {
      ta = n[TOUCH_ACTION];
      break;
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

if (cancelSyntheticClickEvents) {
  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);
}

/**
 * Returns the composedPath for the given event.
 * @param {Event} event to process
 * @return {!Array<!EventTarget>} Path of the event
 */
const getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ?
  window.ShadyDOM.composedPath :
  (event) => event.composedPath && event.composedPath() || [];

/** @type {!Object<string, !GestureRecognizer>} */
const gestures = {};

/** @type {!Array<!GestureRecognizer>} */
const recognizers = [];

/**
 * Finds the element rendered on the screen at the provided coordinates.
 *
 * Similar to `document.elementFromPoint`, but pierces through
 * shadow roots.
 *
 * @param {number} x Horizontal pixel coordinate
 * @param {number} y Vertical pixel coordinate
 * @return {Element} Returns the deepest shadowRoot inclusive element
 * found at the screen position given.
 */
function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

/**
 * a cheaper check than ev.composedPath()[0];
 *
 * @private
 * @param {Event|Touch} ev Event.
 * @return {EventTarget} Returns the event target.
 */
function _findOriginalTarget(ev) {
  const path = getComposedPath(/** @type {?Event} */ (ev));
  // It shouldn't be, but sometimes path is empty (window on Safari).
  return path.length > 0 ? path[0] : ev.target;
}

/**
 * @private
 * @param {Event} ev Event.
 * @return {void}
 */
function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  let gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign
      let t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}

/**
 * @private
 * @param {TouchEvent} ev Event.
 * @return {void}
 */
function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let shouldPrevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) ; else if (ta === 'none') {
      shouldPrevent = true;
    } else if (ta === 'pan-x') {
      shouldPrevent = dy > dx;
    } else if (ta === 'pan-y') {
      shouldPrevent = dx > dy;
    }
    if (shouldPrevent) {
      ev.preventDefault();
    } else {
      prevent('track');
    }
  }
}

/**
 * Adds an event listener to a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to add listener on
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function to call
 * @return {boolean} Returns true if a gesture event listener was added.
 */
function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

/**
 * Removes an event listener from a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to remove listener from
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function previously passed to
 *  `addListener`.
 * @return {boolean} Returns true if a gesture event listener was removed.
 */
function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

/**
 * automate the event listeners for the native events
 *
 * @private
 * @param {!EventTarget} node Node on which to add the event.
 * @param {string} evType Event type to add.
 * @param {function(!Event)} handler Event handler function.
 * @return {void}
 */
function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = {_count: 0};
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

/**
 * automate event listener removal for native events
 *
 * @private
 * @param {!EventTarget} node Node on which to remove the event.
 * @param {string} evType Event type to remove.
 * @param {function(!Event): void} handler Event handler function.
 * @return {void}
 */
function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

/**
 * Registers a new gesture event recognizer for adding new custom
 * gesture event types.
 *
 * @param {!GestureRecognizer} recog Gesture recognizer descriptor
 * @return {void}
 */
function register$1(recog) {
  recognizers.push(recog);
  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

/**
 * @private
 * @param {string} evName Event name.
 * @return {Object} Returns the gesture for the given event name.
 */
function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

/**
 * Sets scrolling direction on node.
 *
 * This value is checked on first move, thus it should be called prior to
 * adding event listeners.
 *
 * @param {!EventTarget} node Node to set touch action setting on
 * @param {string} value Touch action value
 * @return {void}
 */
function setTouchAction(node, value) {
  if (HAS_NATIVE_TA && node instanceof HTMLElement) {
    // NOTE: add touchAction async so that events can be added in
    // custom element constructors. Otherwise we run afoul of custom
    // elements restriction against settings attributes (style) in the
    // constructor.
    microTask.run(() => {
      node.style.touchAction = value;
    });
  }
  node[TOUCH_ACTION] = value;
}

/**
 * Dispatches an event on the `target` element of `type` with the given
 * `detail`.
 * @private
 * @param {!EventTarget} target The element on which to fire an event.
 * @param {string} type The type of event to fire.
 * @param {!Object=} detail The detail object to populate on the event.
 * @return {void}
 */
function _fire(target, type, detail) {
  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  wrap$1(/** @type {!Node} */(target)).dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

/**
 * Prevents the dispatch and default action of the given event name.
 *
 * @param {string} evName Event name.
 * @return {void}
 */
function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

/* eslint-disable valid-jsdoc */

register$1({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset: function() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        downupFire('up', t, e);
        untrackDocument(self.info);
      }
    };
    let upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        downupFire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    downupFire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart: function(e) {
    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend: function(e) {
    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  }
});

/**
 * @param {string} type
 * @param {EventTarget} target
 * @param {Event|Touch} event
 * @param {Event=} preventer
 * @return {void}
 */
function downupFire(type, target, event, preventer) {
  if (!target) {
    return;
  }
  _fire(target, type, {
    x: event.clientX,
    y: event.clientY,
    sourceEvent: event,
    preventer: preventer,
    prevent: function(e) {
      return prevent(e);
    }
  });
}

register$1({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureInfo} */
    addMove: function(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset: function() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      let x = e.clientX, y = e.clientY;
      if (trackHasMovedEnough(self.info, x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          prevent('tap');
        }
        self.info.addMove({x: x, y: y});
        if (!hasLeftMouseButton(e)) {
          // always fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        if (t) {
          trackFire(self.info, t, e);
        }
        self.info.started = true;
      }
    };
    let upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart: function(e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    let x = ct.clientX, y = ct.clientY;
    if (trackHasMovedEnough(this.info, x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        prevent('tap');
      }
      this.info.addMove({x: x, y: y});
      trackFire(this.info, t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({x: ct.clientX, y: ct.clientY});
      trackFire(this.info, t, ct);
    }
  }
});

/**
 * @param {!GestureInfo} info
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
function trackHasMovedEnough(info, x, y) {
  if (info.prevent) {
    return false;
  }
  if (info.started) {
    return true;
  }
  let dx = Math.abs(info.x - x);
  let dy = Math.abs(info.y - y);
  return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
}

/**
 * @param {!GestureInfo} info
 * @param {?EventTarget} target
 * @param {Touch} touch
 * @return {void}
 */
function trackFire(info, target, touch) {
  if (!target) {
    return;
  }
  let secondlast = info.moves[info.moves.length - 2];
  let lastmove = info.moves[info.moves.length - 1];
  let dx = lastmove.x - info.x;
  let dy = lastmove.y - info.y;
  let ddx, ddy = 0;
  if (secondlast) {
    ddx = lastmove.x - secondlast.x;
    ddy = lastmove.y - secondlast.y;
  }
  _fire(target, 'track', {
    state: info.state,
    x: touch.clientX,
    y: touch.clientY,
    dx: dx,
    dy: dy,
    ddx: ddx,
    ddy: ddy,
    sourceEvent: touch,
    hover: function() {
      return deepTargetFind(touch.clientX, touch.clientY);
    }
  });
}

register$1({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset: function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown: function(e) {
    if (hasLeftMouseButton(e)) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click: function(e) {
    if (hasLeftMouseButton(e)) {
      trackForward(this.info, e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart: function(e) {
    const touch = e.changedTouches[0];
    this.info.x = touch.clientX;
    this.info.y = touch.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend: function(e) {
    trackForward(this.info, e.changedTouches[0], e);
  }
});

/**
 * @param {!GestureInfo} info
 * @param {Event | Touch} e
 * @param {Event=} preventer
 * @return {void}
 */
function trackForward(info, e, preventer) {
  let dx = Math.abs(e.clientX - info.x);
  let dy = Math.abs(e.clientY - info.y);
  // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
  let t = _findOriginalTarget((preventer || e));
  if (!t || (canBeDisabled[/** @type {!HTMLElement} */(t).localName] && t.hasAttribute('disabled'))) {
    return;
  }
  // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
  if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
    // prevent taps from being generated if an event has canceled them
    if (!info.prevent) {
      _fire(t, 'tap', {
        x: e.clientX,
        y: e.clientY,
        sourceEvent: e,
        preventer: preventer
      });
    }
  }
}

/** @deprecated */
const add = addListener;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Element class mixin that provides API for adding Polymer's cross-platform
 * gesture events to nodes.
 *
 * The API is designed to be compatible with override points implemented
 * in `TemplateStamp` such that declarative event listeners in
 * templates will support gesture events when this mixin is applied along with
 * `TemplateStamp`.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin that provides API for adding Polymer's
 *   cross-platform gesture events to nodes
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const GestureEventListeners = dedupingMixin((superClass) => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  class GestureEventListeners extends superClass {
    /**
     * Add the event listener to the node if it is a gestures event.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */
    _addEventListenerToNode(node, eventName, handler) {
      if (!addListener(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }

    /**
     * Remove the event listener to the node if it is a gestures event.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */
    _removeEventListenerFromNode(node, eventName, handler) {
      if (!removeListener(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }
  }

  return GestureEventListeners;
});

/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */

const HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
const HOST_DIR_REPLACMENT = ':host([dir="$1"])';

const EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
const EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';

const DIR_CHECK = /:dir\((?:ltr|rtl)\)/;

const SHIM_SHADOW = Boolean(window['ShadyDOM'] && window['ShadyDOM']['inUse']);

/**
 * @type {!Array<!Polymer_DirMixin>}
 */
const DIR_INSTANCES = [];

/** @type {?MutationObserver} */
let observer = null;

let DOCUMENT_DIR = '';

function getRTL() {
  DOCUMENT_DIR = document.documentElement.getAttribute('dir');
}

/**
 * @param {!Polymer_DirMixin} instance Instance to set RTL status on
 */
function setRTL(instance) {
  if (!instance.__autoDirOptOut) {
    const el = /** @type {!HTMLElement} */(instance);
    el.setAttribute('dir', DOCUMENT_DIR);
  }
}

function updateDirection() {
  getRTL();
  DOCUMENT_DIR = document.documentElement.getAttribute('dir');
  for (let i = 0; i < DIR_INSTANCES.length; i++) {
    setRTL(DIR_INSTANCES[i]);
  }
}

function takeRecords() {
  if (observer && observer.takeRecords().length) {
    updateDirection();
  }
}

/**
 * Element class mixin that allows elements to use the `:dir` CSS Selector to
 * have text direction specific styling.
 *
 * With this mixin, any stylesheet provided in the template will transform
 * `:dir` into `:host([dir])` and sync direction with the page via the
 * element's `dir` attribute.
 *
 * Elements can opt out of the global page text direction by setting the `dir`
 * attribute directly in `ready()` or in HTML.
 *
 * Caveats:
 * - Applications must set `<html dir="ltr">` or `<html dir="rtl">` to sync
 *   direction
 * - Automatic left-to-right or right-to-left styling is sync'd with the
 *   `<html>` element only.
 * - Changing `dir` at runtime is supported.
 * - Opting out of the global direction styling is permanent
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertyAccessors
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const DirMixin = dedupingMixin((base) => {

  if (!SHIM_SHADOW) {
    if (!observer) {
      getRTL();
      observer = new MutationObserver(updateDirection);
      observer.observe(document.documentElement, {attributes: true, attributeFilter: ['dir']});
    }
  }

  /**
   * @constructor
   * @implements {Polymer_PropertyAccessors}
   * @private
   */
  const elementBase = PropertyAccessors(base);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_DirMixin}
   */
  class Dir extends elementBase {

    /**
     * @param {string} cssText .
     * @param {string} baseURI .
     * @return {string} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _processStyleText(cssText, baseURI) {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      cssText = elementBase._processStyleText.call(this, cssText, baseURI);
      if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {
        cssText = this._replaceDirInCssText(cssText);
        this.__activateDir = true;
      }
      return cssText;
    }

    /**
     * Replace `:dir` in the given CSS text
     *
     * @param {string} text CSS text to replace DIR
     * @return {string} Modified CSS
     * @nocollapse
     */
    static _replaceDirInCssText(text) {
      let replacedText = text;
      replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
      replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
      return replacedText;
    }

    constructor() {
      super();
      /** @type {boolean} */
      this.__autoDirOptOut = false;
    }

    /**
     * @override
     * @suppress {invalidCasts} Closure doesn't understand that `this` is an
     *     HTMLElement
     * @return {void}
     */
    ready() {
      super.ready();
      this.__autoDirOptOut = /** @type {!HTMLElement} */(this).hasAttribute('dir');
    }

    /**
     * @override
     * @suppress {missingProperties} If it exists on elementBase, it can be
     *   super'd
     * @return {void}
     */
    connectedCallback() {
      if (elementBase.prototype.connectedCallback) {
        super.connectedCallback();
      }
      if (this.constructor.__activateDir) {
        takeRecords();
        DIR_INSTANCES.push(this);
        setRTL(this);
      }
    }

    /**
     * @override
     * @suppress {missingProperties} If it exists on elementBase, it can be
     *   super'd
     * @return {void}
     */
    disconnectedCallback() {
      if (elementBase.prototype.disconnectedCallback) {
        super.disconnectedCallback();
      }
      if (this.constructor.__activateDir) {
        const idx = DIR_INSTANCES.indexOf(this);
        if (idx > -1) {
          DIR_INSTANCES.splice(idx, 1);
        }
      }
    }
  }

  Dir.__activateDir = false;

  return Dir;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd,
                            old, oldStart, oldEnd) {
  // "Deletion" columns
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (let j = 0; j < columnCount; j++)
    distances[0][j] = j;

  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))
        distances[i][j] = distances[i - 1][j - 1];
      else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];

    let min;
    if (west < north)
      min = west < northWest ? west : northWest;
    else
      min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {!Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {!Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {!Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd,
                      old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;

  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0)
    prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length)
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
    return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd)
      splice.removed.push(old[oldStart++]);

    return [ splice ];
  } else if (oldStart == oldEnd)
    return [ newSplice(currentStart, [], currentEnd - currentStart) ];

  let ops = spliceOperationsFromEditDistances(
      calcEditDistances(current, currentStart, currentEnd,
                             old, oldStart, oldEnd));

  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; i++) {
    switch(ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++)
    if (!equals(current[i], old[i]))
      return i;
  return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2]))
    count++;

  return count;
}

/**
 * Returns an array of splice records indicating the minimum edits required
 * to transform the `previous` array into the `current` array.
 *
 * Splice records are ordered by index and contain the following fields:
 * - `index`: index where edit started
 * - `removed`: array of removed items from this index
 * - `addedCount`: number of items added at this index
 *
 * This function is based on the Levenshtein "minimum edit distance"
 * algorithm. Note that updates are treated as removal followed by addition.
 *
 * The worst-case time complexity of this algorithm is `O(l * p)`
 *   l: The length of the current array
 *   p: The length of the previous array
 *
 * However, the worst-case complexity is reduced by an `O(n)` optimization
 * to detect any shared prefix & suffix between the two arrays and only
 * perform the more expensive minimum edit distance calculation over the
 * non-shared portions of the arrays.
 *
 * @function
 * @param {!Array} current The "changed" array for which splices will be
 * calculated.
 * @param {!Array} previous The "unchanged" original array to compare
 * `current` against to determine the splices.
 * @return {!Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0,
                          previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Returns true if `node` is a slot element
 * @param {!Node} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return (node.localName === 'slot');
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * An example:
 * ```js
 * class TestSelfObserve extends PolymerElement {
 *   static get is() { return 'test-self-observe';}
 *   connectedCallback() {
 *     super.connectedCallback();
 *     this._observer = new FlattenedNodesObserver(this, (info) => {
 *       this.info = info;
 *     });
 *   }
 *   disconnectedCallback() {
 *     super.disconnectedCallback();
 *     this._observer.disconnect();
 *   }
 * }
 * customElements.define(TestSelfObserve.is, TestSelfObserve);
 * ```
 *
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 * @implements {PolymerDomApi.ObserveHandle}
 */
let FlattenedNodesObserver = class {

  /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to
   *      return the list of flattened nodes.
   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.
   * @nocollapse See https://github.com/google/closure-compiler/issues/2763
   */
  // eslint-disable-next-line
  static getFlattenedNodes(node) {
    const wrapped = wrap$1(node);
    if (isSlot(node)) {
      node = /** @type {!HTMLSlotElement} */(node); // eslint-disable-line no-self-assign
      return wrapped.assignedNodes({flatten: true});
    } else {
      return Array.from(wrapped.childNodes).map((node) => {
        if (isSlot(node)) {
          node = /** @type {!HTMLSlotElement} */(node); // eslint-disable-line no-self-assign
          return wrap$1(node).assignedNodes({flatten: true});
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }

  /**
   * @param {!HTMLElement} target Node on which to listen for changes.
   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
   */
  // eslint-disable-next-line
  constructor(target, callback) {
    /**
     * @type {MutationObserver}
     * @private
     */
    this._shadyChildrenObserver = null;
    /**
     * @type {MutationObserver}
     * @private
     */
    this._nativeChildrenObserver = null;
    this._connected = false;
    /**
     * @type {!HTMLElement}
     * @private
     */
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /**
     * @type {function()}
     * @private
     */
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   *
   * @return {void}
   */
  connect() {
    if (isSlot(this._target)) {
      this._listenSlots([this._target]);
    } else if (wrap$1(this._target).children) {
      this._listenSlots(
          /** @type {!NodeList<!Node>} */ (wrap$1(this._target).children));
      if (window.ShadyDOM) {
        this._shadyChildrenObserver =
          ShadyDOM.observeChildren(this._target, (mutations) => {
            this._processMutations(mutations);
          });
      } else {
        this._nativeChildrenObserver =
          new MutationObserver((mutations) => {
            this._processMutations(mutations);
          });
        this._nativeChildrenObserver.observe(this._target, {childList: true});
      }
    }
    this._connected = true;
  }

  /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   *
   * @return {void}
   * @override
   */
  disconnect() {
    if (isSlot(this._target)) {
      this._unlistenSlots([this._target]);
    } else if (wrap$1(this._target).children) {
      this._unlistenSlots(
          /** @type {!NodeList<!Node>} */ (wrap$1(this._target).children));
      if (window.ShadyDOM && this._shadyChildrenObserver) {
        ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
        this._shadyChildrenObserver = null;
      } else if (this._nativeChildrenObserver) {
        this._nativeChildrenObserver.disconnect();
        this._nativeChildrenObserver = null;
      }
    }
    this._connected = false;
  }

  /**
   * @return {void}
   * @private
   */
  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      microTask.run(() => this.flush());
    }
  }

  /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */
  _processMutations(mutations) {
    this._processSlotMutations(mutations);
    this.flush();
  }

  /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */
  _processSlotMutations(mutations) {
    if (mutations) {
      for (let i=0; i < mutations.length; i++) {
        let mutation = mutations[i];
        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }
        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
    }
  }

  /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */
  flush() {
    if (!this._connected) {
      return false;
    }
    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }
    if (this._nativeChildrenObserver) {
      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
    } else if (this._shadyChildrenObserver) {
      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
    }
    this._scheduled = false;
    let info = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    };
    let newNodes = this.constructor.getFlattenedNodes(this._target);
    let splices = calculateSplices(newNodes,
      this._effectiveNodes);
    // process removals
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    }
    // process adds
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    }
    // update cache
    this._effectiveNodes = newNodes;
    let didFlush = false;
    if (info.addedNodes.length || info.removedNodes.length) {
      didFlush = true;
      this.callback.call(this._target, info);
    }
    return didFlush;
  }

  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */
  _listenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }

  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */
  _unlistenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }

};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Forces several classes of asynchronously queued tasks to flush:
 * - Debouncers added via `enqueueDebouncer`
 * - ShadyDOM distribution
 *
 * @return {void}
 */
const flush = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/* eslint-enable no-unused-vars */

const p = Element.prototype;
/**
 * @const {function(this:Node, string): boolean}
 */
const normalizedMatchesSelector = p.matches || p.matchesSelector ||
  p.mozMatchesSelector || p.msMatchesSelector ||
  p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @param {!Node} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
const matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 * @implements {PolymerDomApi}
 * @unrestricted
 */
class DomApiNative {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  constructor(node) {
    if (window['ShadyDOM'] && window['ShadyDOM']['inUse']) {
      window['ShadyDOM']['patch'](node);
    }
    this.node = node;
  }

  /**
   * Returns an instance of `FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {function(this:HTMLElement, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Called when direct or distributed children
   *   of this element changes
   * @return {!PolymerDomApi.ObserveHandle} Observer instance
   * @override
   */
  observeNodes(callback) {
    return new FlattenedNodesObserver(
        /** @type {!HTMLElement} */(this.node), callback);
  }

  /**
   * Disconnects an observer previously created via `observeNodes`
   *
   * @param {!PolymerDomApi.ObserveHandle} observerHandle Observer instance
   *   to disconnect.
   * @return {void}
   * @override
   */
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }

  /**
   * Provided as a backwards-compatible API only.  This method does nothing.
   * @return {void}
   */
  notifyObserver() {}

  /**
   * Returns true if the provided node is contained with this element's
   * light-DOM children or shadow root, including any nested shadow roots
   * of children therein.
   *
   * @param {Node} node Node to test
   * @return {boolean} Returns true if the given `node` is contained within
   *   this element's light or shadow DOM.
   * @override
   */
  deepContains(node) {
    if (wrap$1(this.node).contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    // walk from node to `this` or `document`
    while (n && n !== doc && n !== this.node) {
      // use logical parentnode, or native ShadowRoot host
      n = wrap$1(n).parentNode || wrap$1(n).host;
    }
    return n === this.node;
  }

  /**
   * Returns the root node of this node.  Equivalent to `getRootNode()`.
   *
   * @return {Node} Top most element in the dom tree in which the node
   * exists. If the node is connected to a document this is either a
   * shadowRoot or the document; otherwise, it may be the node
   * itself or a node or document fragment containing it.
   * @override
   */
  getOwnerRoot() {
    return wrap$1(this.node).getRootNode();
  }

  /**
   * For slot elements, returns the nodes assigned to the slot; otherwise
   * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
   *
   * @return {!Array<!Node>} Array of assigned nodes
   * @override
   */
  getDistributedNodes() {
    return (this.node.localName === 'slot') ?
      wrap$1(this.node).assignedNodes({flatten: true}) :
      [];
  }

  /**
   * Returns an array of all slots this element was distributed to.
   *
   * @return {!Array<!HTMLSlotElement>} Description
   * @override
   */
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = wrap$1(this.node).assignedSlot;
    while (n) {
      ip$.push(n);
      n = wrap$1(n).assignedSlot;
    }
    return ip$;
  }

  /**
   * Calls `importNode` on the `ownerDocument` for this node.
   *
   * @param {!Node} node Node to import
   * @param {boolean} deep True if the node should be cloned deeply during
   *   import
   * @return {Node} Clone of given node imported to this owner document
   */
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node :
      this.node.ownerDocument;
    return wrap$1(doc).importNode(node, deep);
  }

  /**
   * @return {!Array<!Node>} Returns a flattened list of all child nodes and
   * nodes assigned to child slots.
   * @override
   */
  getEffectiveChildNodes() {
    return FlattenedNodesObserver.getFlattenedNodes(
        /** @type {!HTMLElement} */ (this.node));
  }

  /**
   * Returns a filtered list of flattened child elements for this element based
   * on the given selector.
   *
   * @param {string} selector Selector to filter nodes against
   * @return {!Array<!HTMLElement>} List of flattened child elements
   * @override
   */
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
      if ((c.nodeType === Node.ELEMENT_NODE) &&
          matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }

  /**
   * For shadow roots, returns the currently focused element within this
   * shadow root.
   *
   * return {Node|undefined} Currently focused element
   * @override
   */
  get activeElement() {
    let node = this.node;
    return node._activeElement !== undefined ? node._activeElement : node.activeElement;
  }
}

function forwardMethods(proto, methods) {
  for (let i=0; i < methods.length; i++) {
    let method = methods[i];
    /* eslint-disable valid-jsdoc */
    proto[method] = /** @this {DomApiNative} */ function() {
      return this.node[method].apply(this.node, arguments);
    };
    /* eslint-enable */
  }
}

function forwardReadOnlyProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        const domApi = /** @type {DomApiNative} */(this);
        return domApi.node[name];
      },
      configurable: true
    });
  }
}

function forwardProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      /**
       * @this {DomApiNative}
       * @return {*} .
       */
      get: function() {
        return this.node[name];
      },
      /**
       * @this {DomApiNative}
       * @param {*} value .
       */
      set: function(value) {
        this.node[name] = value;
      },
      configurable: true
    });
  }
}


/**
 * Event API wrapper class returned from `dom.(target)` when
 * `target` is an `Event`.
 */
class EventApi {
  constructor(event) {
    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {!EventTarget} The node this event was dispatched to
   */
  get rootTarget() {
    return this.path[0];
  }

  /**
   * Returns the local (re-targeted) target for this event.
   *
   * @return {!EventTarget} The local (re-targeted) target for this event.
   */
  get localTarget() {
    return this.event.target;
  }

  /**
   * Returns the `composedPath` for this event.
   * @return {!Array<!EventTarget>} The nodes this event propagated through
   */
  get path() {
    return this.event.composedPath();
  }
}

/**
 * @function
 * @param {boolean=} deep
 * @return {!Node}
 */
DomApiNative.prototype.cloneNode;
/**
 * @function
 * @param {!Node} node
 * @return {!Node}
 */
DomApiNative.prototype.appendChild;
/**
 * @function
 * @param {!Node} newChild
 * @param {Node} refChild
 * @return {!Node}
 */
DomApiNative.prototype.insertBefore;
/**
 * @function
 * @param {!Node} node
 * @return {!Node}
 */
DomApiNative.prototype.removeChild;
/**
 * @function
 * @param {!Node} oldChild
 * @param {!Node} newChild
 * @return {!Node}
 */
DomApiNative.prototype.replaceChild;
/**
 * @function
 * @param {string} name
 * @param {string} value
 * @return {void}
 */
DomApiNative.prototype.setAttribute;
/**
 * @function
 * @param {string} name
 * @return {void}
 */
DomApiNative.prototype.removeAttribute;
/**
 * @function
 * @param {string} selector
 * @return {?Element}
 */
DomApiNative.prototype.querySelector;
/**
 * @function
 * @param {string} selector
 * @return {!NodeList<!Element>}
 */
DomApiNative.prototype.querySelectorAll;

/** @type {?Node} */
DomApiNative.prototype.parentNode;
/** @type {?Node} */
DomApiNative.prototype.firstChild;
/** @type {?Node} */
DomApiNative.prototype.lastChild;
/** @type {?Node} */
DomApiNative.prototype.nextSibling;
/** @type {?Node} */
DomApiNative.prototype.previousSibling;
/** @type {?HTMLElement} */
DomApiNative.prototype.firstElementChild;
/** @type {?HTMLElement} */
DomApiNative.prototype.lastElementChild;
/** @type {?HTMLElement} */
DomApiNative.prototype.nextElementSibling;
/** @type {?HTMLElement} */
DomApiNative.prototype.previousElementSibling;
/** @type {!Array<!Node>} */
DomApiNative.prototype.childNodes;
/** @type {!Array<!HTMLElement>} */
DomApiNative.prototype.children;
/** @type {?DOMTokenList} */
DomApiNative.prototype.classList;

/** @type {string} */
DomApiNative.prototype.textContent;
/** @type {string} */
DomApiNative.prototype.innerHTML;

let DomApiImpl = DomApiNative;

if (window['ShadyDOM'] && window['ShadyDOM']['inUse'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['Wrapper']) {

  /**
   * @private
   * @extends {HTMLElement}
   */
  class Wrapper extends window['ShadyDOM']['Wrapper'] {}

  // copy bespoke API onto wrapper
  Object.getOwnPropertyNames(DomApiNative.prototype).forEach((prop) => {
    if (prop != 'activeElement') {
      Wrapper.prototype[prop] = DomApiNative.prototype[prop];
    }
  });

  // Note, `classList` is here only for legacy compatibility since it does not
  // trigger distribution in v1 Shadow DOM.
  forwardReadOnlyProperties(Wrapper.prototype, [
    'classList'
  ]);

  DomApiImpl = Wrapper;

  Object.defineProperties(EventApi.prototype, {

    // Returns the "lowest" node in the same root as the event's currentTarget.
    // When in `noPatch` mode, this must be calculated by walking the event's
    // path.
    localTarget: {
      get() {
        const current = this.event.currentTarget;
        const currentRoot = current && dom(current).getOwnerRoot();
        const p$ = this.path;
        for (let i = 0; i < p$.length; i++) {
          const e = p$[i];
          if (dom(e).getOwnerRoot() === currentRoot) {
            return e;
          }
        }
      },
      configurable: true
    },

    path: {
      get() {
        return window['ShadyDOM']['composedPath'](this.event);
      },
      configurable: true
    }
  });

} else {

  // Methods that can provoke distribution or must return the logical, not
  // composed tree.
  forwardMethods(DomApiNative.prototype, [
    'cloneNode', 'appendChild', 'insertBefore', 'removeChild',
    'replaceChild', 'setAttribute', 'removeAttribute',
    'querySelector', 'querySelectorAll'
  ]);

  // Properties that should return the logical, not composed tree. Note, `classList`
  // is here only for legacy compatibility since it does not trigger distribution
  // in v1 Shadow DOM.
  forwardReadOnlyProperties(DomApiNative.prototype, [
    'parentNode', 'firstChild', 'lastChild',
    'nextSibling', 'previousSibling', 'firstElementChild',
    'lastElementChild', 'nextElementSibling', 'previousElementSibling',
    'childNodes', 'children', 'classList'
  ]);

  forwardProperties(DomApiNative.prototype, [
    'textContent', 'innerHTML', 'className'
  ]);
}

/**
 * Legacy DOM and Event manipulation API wrapper factory used to abstract
 * differences between native Shadow DOM and "Shady DOM" when polyfilling on
 * older browsers.
 *
 * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
 * in the majority of cases simply facades directly to the standard native
 * API.
 *
 * @summary Legacy DOM and Event manipulation API wrapper factory used to
 * abstract differences between native Shadow DOM and "Shady DOM."
 * @param {(Node|Event|DomApiNative|EventApi)=} obj Node or event to operate on
 * @return {!DomApiNative|!EventApi} Wrapper providing either node API or event API
 */
const dom = function(obj) {
  obj = obj || document;
  if (obj instanceof DomApiImpl) {
    return /** @type {!DomApi} */(obj);
  }
  if (obj instanceof EventApi) {
    return /** @type {!EventApi} */(obj);
  }
  let helper = obj['__domApi'];
  if (!helper) {
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApiImpl(/** @type {Node} */(obj));
    }
    obj['__domApi'] = helper;
  }
  return helper;
};

/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const ShadyDOM$1 = window.ShadyDOM;
const ShadyCSS = window.ShadyCSS;

/**
 * Return true if node scope is correct.
 *
 * @param {!Element} node Node to check scope
 * @param {!Node} scope Scope reference
 * @return {boolean} True if node is in scope
 */
function sameScope(node, scope) {
  return wrap$1(node).getRootNode() === scope;
}

/**
 * Ensure that elements in a ShadowDOM container are scoped correctly.
 * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.
 * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.
 *
 * @param  {!Element} container Container element to scope
 * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container
 * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.
 */
function scopeSubtree(container, shouldObserve = false) {
  // If using native ShadowDOM, abort
  if (!ShadyDOM$1 || !ShadyCSS) {
    return null;
  }
  // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself
  if (!ShadyDOM$1['handlesDynamicScoping']) {
    return null;
  }
  const ScopingShim = ShadyCSS['ScopingShim'];
  // if ScopingShim is not available, abort
  if (!ScopingShim) {
    return null;
  }
  // capture correct scope for container
  const containerScope = ScopingShim['scopeForNode'](container);
  const root = wrap$1(container).getRootNode();

  const scopify = (node) => {
    if (!sameScope(node, root)) {
      return;
    }
    // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1
    const elements = Array.from(ShadyDOM$1['nativeMethods']['querySelectorAll'].call(node, '*'));
    elements.push(node);
    for (let i = 0; i < elements.length; i++) {
      const el = elements[i];
      if (!sameScope(el, root)) {
        continue;
      }
      const currentScope = ScopingShim['currentScopeForNode'](el);
      if (currentScope !== containerScope) {
        if (currentScope !== '') {
          ScopingShim['unscopeNode'](el, currentScope);
        }
        ScopingShim['scopeNode'](el, containerScope);
      }
    }
  };

  // scope everything in container
  scopify(container);

  if (shouldObserve) {
    const mo = new MutationObserver((mxns) => {
      for (let i = 0; i < mxns.length; i++) {
        const mxn = mxns[i];
        for (let j = 0; j < mxn.addedNodes.length; j++) {
          const addedNode = mxn.addedNodes[j];
          if (addedNode.nodeType === Node.ELEMENT_NODE) {
            scopify(addedNode);
          }
        }
      }
    });
    mo.observe(container, {childList: true, subtree: true});
    return mo;
  } else {
    return null;
  }
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let styleInterface = window.ShadyCSS;

/**
 * Element class mixin that provides Polymer's "legacy" API intended to be
 * backward-compatible to the greatest extent possible with the API
 * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
 * defined using the `Polymer({...})` function.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin ElementMixin
 * @appliesMixin GestureEventListeners
 * @property isAttached {boolean} Set to `true` in this element's
 *   `connectedCallback` and `false` in `disconnectedCallback`
 * @summary Element class mixin that provides Polymer's "legacy" API
 */
const LegacyElementMixin = dedupingMixin((base) => {
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   * @implements {Polymer_DirMixin}
   * @extends {HTMLElement}
   * @private
   */
  const legacyElementBase = DirMixin(GestureEventListeners(ElementMixin(base)));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  const DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */
  class LegacyElement extends legacyElementBase {

    constructor() {
      super();
      /** @type {boolean} */
      this.isAttached;
      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */
      this.__boundListeners;
      /** @type {?Object<string, ?Function>} */
      this._debouncers;
    }

    /**
     * Forwards `importMeta` from the prototype (i.e. from the info object
     * passed to `Polymer({...})`) to the static API.
     *
     * @return {!Object} The `import.meta` object set on the prototype
     * @suppress {missingProperties} `this` is always in the instance in
     *  closure for some reason even in a static method, rather than the class
     * @nocollapse
     */
    static get importMeta() {
      return this.prototype.importMeta;
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     * @override
     * @return {void}
     */
    created() {}

    /**
     * Provides an implementation of `connectedCallback`
     * which adds Polymer legacy API's `attached` method.
     * @return {void}
     * @override
     */
    connectedCallback() {
      super.connectedCallback();
      this.isAttached = true;
      this.attached();
    }

    /**
     * Legacy callback called during `connectedCallback`, for overriding
     * by the user.
     * @override
     * @return {void}
     */
    attached() {}

    /**
     * Provides an implementation of `disconnectedCallback`
     * which adds Polymer legacy API's `detached` method.
     * @return {void}
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.isAttached = false;
      this.detached();
    }

    /**
     * Legacy callback called during `disconnectedCallback`, for overriding
     * by the user.
     * @override
     * @return {void}
     */
    detached() {}

    /**
     * Provides an override implementation of `attributeChangedCallback`
     * which adds the Polymer legacy API's `attributeChanged` method.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @override
     */
    attributeChangedCallback(name, old, value, namespace) {
      if (old !== value) {
        super.attributeChangedCallback(name, old, value, namespace);
        this.attributeChanged(name, old, value);
      }
    }

    /**
     * Legacy callback called during `attributeChangedChallback`, for overriding
     * by the user.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @return {void}
     * @override
     */
    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for class initialization via the `_registered` callback.
     * This is called only when the first instance of the element is created.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts}
     */
    _initializeProperties() {
      let proto = Object.getPrototypeOf(this);
      if (!proto.hasOwnProperty('__hasRegisterFinished')) {
        this._registered();
        // backstop in case the `_registered` implementation does not set this
        proto.__hasRegisterFinished = true;
      }
      super._initializeProperties();
      this.root = /** @type {HTMLElement} */(this);
      this.created();
      // Ensure listeners are applied immediately so that they are
      // added before declarative event listeners. This allows an element to
      // decorate itself via an event prior to any declarative listeners
      // seeing the event. Note, this ensures compatibility with 1.x ordering.
      this._applyListeners();
    }

    /**
     * Called automatically when an element is initializing.
     * Users may override this method to perform class registration time
     * work. The implementation should ensure the work is performed
     * only once for the class.
     * @protected
     * @return {void}
     * @override
     */
    _registered() {}

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for installing `hostAttributes` and `listeners`.
     *
     * @return {void}
     * @override
     */
    ready() {
      this._ensureAttributes();
      super.ready();
    }

    /**
     * Ensures an element has required attributes. Called when the element
     * is being readied via `ready`. Users should override to set the
     * element's required attributes. The implementation should be sure
     * to check and not override existing attributes added by
     * the user of the element. Typically, setting attributes should be left
     * to the element user and not done here; reasonable exceptions include
     * setting aria roles and focusability.
     * @protected
     * @return {void}
     * @override
     */
    _ensureAttributes() {}

    /**
     * Adds element event listeners. Called when the element
     * is being readied via `ready`. Users should override to
     * add any required element event listeners.
     * In performance critical elements, the work done here should be kept
     * to a minimum since it is done before the element is rendered. In
     * these elements, consider adding listeners asynchronously so as not to
     * block render.
     * @protected
     * @return {void}
     * @override
     */
    _applyListeners() {}

    /**
     * Converts a typed JavaScript value to a string.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features. To customize
     * how properties are serialized to attributes for attribute bindings and
     * `reflectToAttribute: true` properties as well as this method, override
     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
     *
     * @param {*} value Value to deserialize
     * @return {string | undefined} Serialized value
     * @override
     */
    serialize(value) {
      return this._serializeValue(value);
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.  To customize
     * how attributes are deserialized to properties for in
     * `attributeChangedCallback`, override `_deserializeValue` method
     * provided by `Polymer.PropertyAccessors`.
     *
     * @param {string} value String to deserialize
     * @param {*} type Type to deserialize the string to
     * @return {*} Returns the deserialized value in the `type` given.
     * @override
     */
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to reflect.
     * @return {void}
     * @override
     */
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @param {Element} node Element to set attribute to.
     * @return {void}
     * @override
     */
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);
    }

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     * @override
     */
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @param {!Object} target Target object to copy properties to.
     * @param {!Object} source Source object to copy properties from.
     * @return {!Object} Target object that was passed as first argument.
     * @override
     */
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }

    /**
     * Sets the prototype of an object.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     * @param {Object} object The object on which to set the prototype.
     * @param {Object} prototype The prototype that will be set on the given
     * `object`.
     * @return {Object} Returns the given `object` with its prototype set
     * to the given `prototype` object.
     * @override
     */
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }

    /* **** Begin Template **** */

    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {!DocumentFragment} Document fragment containing the imported
     *   template content.
     * @override
     * @suppress {missingProperties} go/missingfnprops
     */
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom = /** @type {!DocumentFragment} */
        (document.importNode(content, true));
      return dom;
    }

    /* **** Begin Events **** */



    /**
     * Dispatches a custom event with an optional detail value.
     *
     * @param {string} type Name of event type.
     * @param {*=} detail Detail value containing event-specific
     *   payload.
     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),
     *     composed: (boolean|undefined) }=}
     *  options Object specifying options.  These may include:
     *  `bubbles` (boolean, defaults to `true`),
     *  `cancelable` (boolean, defaults to false), and
     *  `node` on which to fire the event (HTMLElement, defaults to `this`).
     * @return {!Event} The new event that was fired.
     * @override
     */
    fire(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === undefined ? true: options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      wrap$1(node).dispatchEvent(event);
      return event;
    }

    /**
     * Convenience method to add an event listener on a given element,
     * late bound to a named method on this element.
     *
     * @param {?EventTarget} node Element to add event listener to.
     * @param {string} eventName Name of event to listen for.
     * @param {string} methodName Name of handler method on `this` to call.
     * @return {void}
     * @override
     */
    listen(node, eventName, methodName) {
      node = /** @type {!EventTarget} */ (node || this);
      let hbl = this.__boundListeners ||
        (this.__boundListeners = new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(
            /** @type {!Node} */ (node), eventName, methodName, this);
      }
    }

    /**
     * Convenience method to remove an event listener from a given element,
     * late bound to a named method on this element.
     *
     * @param {?EventTarget} node Element to remove event listener from.
     * @param {string} eventName Name of event to stop listening to.
     * @param {string} methodName Name of handler method on `this` to not call
     anymore.
     * @return {void}
     * @override
     */
    unlisten(node, eventName, methodName) {
      node = /** @type {!EventTarget} */ (node || this);
      let bl = this.__boundListeners &&
          this.__boundListeners.get(/** @type {!Element} */ (node));
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(
            /** @type {!Node} */ (node), eventName, handler);
        bl[key] = /** @type {?} */ (null);
      }
    }

    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @param {string=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {Element=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     * @return {void}
     * @override
     */
    setScrollDirection(direction, node) {
      setTouchAction(
          /** @type {!Element} */ (node || this),
          DIRECTION_MAP[direction] || 'auto');
    }
    /* **** End Events **** */

    /**
     * Convenience method to run `querySelector` on this local DOM scope.
     *
     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
     *
     * @param {string} slctr Selector to run on this local DOM scope
     * @return {Element} Element found by the selector, or null if not found.
     * @override
     */
    $$(slctr) {
      // Note, no need to `wrap` this because root is always patched
      return this.root.querySelector(slctr);
    }

    /**
     * Return the element whose local dom within which this element
     * is contained. This is a shorthand for
     * `this.getRootNode().host`.
     * @this {Element}
     * @return {?Node} The element whose local dom within which this element is
     * contained.
     * @override
     */
    get domHost() {
      let root = wrap$1(this).getRootNode();
      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;
    }

    /**
     * Force this element to distribute its children to its local dom.
     * This should not be necessary as of Polymer 2.0.2 and is provided only
     * for backwards compatibility.
     * @return {void}
     * @override
     */
    distributeContent() {
      const thisEl = /** @type {Element} */ (this);
      const domApi = /** @type {PolymerDomApi} */(dom(thisEl));
      if (window.ShadyDOM && domApi.shadowRoot) {
        ShadyDOM.flush();
      }
    }

    /**
     * Returns a list of nodes that are the effective childNodes. The effective
     * childNodes list is the same as the element's childNodes except that
     * any `<content>` elements are replaced with the list of nodes distributed
     * to the `<content>`, the result of its `getDistributedNodes` method.
     * @return {!Array<!Node>} List of effective child nodes.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     *     HTMLElement
     * @override
     */
    getEffectiveChildNodes() {
      const thisEl = /** @type {Element} */ (this);
      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));
      return domApi.getEffectiveChildNodes();
    }

    /**
     * Returns a list of nodes distributed within this element that match
     * `selector`. These can be dom children or elements distributed to
     * children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {!Array<!Node>} List of distributed elements that match selector.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     * HTMLElement
     * @override
     */
    queryDistributedElements(selector) {
      const thisEl = /** @type {Element} */ (this);
      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));
      return domApi.queryDistributedElements(selector);
    }

    /**
     * Returns a list of elements that are the effective children. The effective
     * children list is the same as the element's children except that
     * any `<content>` elements are replaced with the list of elements
     * distributed to the `<content>`.
     *
     * @return {!Array<!Node>} List of effective children.
     * @override
     */
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function(/** @type {!Node} */ n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      });
    }

    /**
     * Returns a string of text content that is the concatenation of the
     * text content's of the element's effective childNodes (the elements
     * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
     *
     * @return {string} List of effective children.
     * @override
     */
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i=0, c; (c = cn[i]); i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join('');
    }

    /**
     * Returns the first effective childNode within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Node} First effective child node that matches selector.
     * @override
     */
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }

    /**
     * Returns a list of effective childNodes within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {!Array<!Node>} List of effective child nodes that match
     *     selector.
     * @override
     */
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }

    /**
     * Returns a list of nodes distributed to this element's `<slot>`.
     *
     * If this element contains more than one `<slot>` in its local DOM,
     * an optional selector may be passed to choose the desired content.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<slot>`.  Defaults to `content`.
     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.
     * @override
     */
    getContentChildNodes(slctr) {
      // Note, no need to `wrap` this because root is always
      let content = this.root.querySelector(slctr || 'slot');
      return content ?
          /** @type {PolymerDomApi} */ (dom(content)).getDistributedNodes() :
          [];
    }

    /**
     * Returns a list of element children distributed to this element's
     * `<slot>`.
     *
     * If this element contains more than one `<slot>` in its
     * local DOM, an optional selector may be passed to choose the desired
     * content.  This method differs from `getContentChildNodes` in that only
     * elements are returned.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<content>`.  Defaults to `content`.
     * @return {!Array<!HTMLElement>} List of distributed nodes for the
     *   `<slot>`.
     * @suppress {invalidCasts}
     * @override
     */
    getContentChildren(slctr) {
      let children = /** @type {!Array<!HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      }));
      return children;
    }

    /**
     * Checks whether an element is in this element's light DOM tree.
     *
     * @param {?Node} node The element to be checked.
     * @return {boolean} true if node is in this element's light DOM tree.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     * HTMLElement
     * @override
     */
    isLightDescendant(node) {
      const thisNode = /** @type {Node} */ (this);
      return thisNode !== node && wrap$1(thisNode).contains(node) &&
        wrap$1(thisNode).getRootNode() === wrap$1(node).getRootNode();
    }

    /**
     * Checks whether an element is in this element's local DOM tree.
     *
     * @param {!Element} node The element to be checked.
     * @return {boolean} true if node is in this element's local DOM tree.
     * @override
     */
    isLocalDescendant(node) {
      return this.root === wrap$1(node).getRootNode();
    }

    /**
     * No-op for backwards compatibility. This should now be handled by
     * ShadyCss library.
     * @param  {!Element} container Container element to scope
     * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container
     * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.
     * @override
     */
    scopeSubtree(container, shouldObserve = false) {
      return scopeSubtree(container, shouldObserve);
    }

    /**
     * Returns the computed style value for the given property.
     * @param {string} property The css property name.
     * @return {string} Returns the computed css property value for the given
     * `property`.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     *     HTMLElement
     * @override
     */
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue(/** @type {!Element} */(this), property);
    }

    // debounce

    /**
     * Call `debounce` to collapse multiple requests for a named task into
     * one invocation which is made after the wait time has elapsed with
     * no new request.  If no wait time is given, the callback will be called
     * at microtask timing (guaranteed before paint).
     *
     *     debouncedClickAction(e) {
     *       // will not call `processClick` more than once per 100ms
     *       this.debounce('click', function() {
     *        this.processClick();
     *       } 100);
     *     }
     *
     * @param {string} jobName String to identify the debounce job.
     * @param {function():void} callback Function that is called (with `this`
     *   context) when the wait time elapses.
     * @param {number=} wait Optional wait time in milliseconds (ms) after the
     *   last signal that must elapse before invoking `callback`
     * @return {!Object} Returns a debouncer object on which exists the
     * following methods: `isActive()` returns true if the debouncer is
     * active; `cancel()` cancels the debouncer if it is active;
     * `flush()` immediately invokes the debounced callback if the debouncer
     * is active.
     * @override
     */
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = Debouncer.debounce(
            this._debouncers[jobName]
          , wait > 0 ? timeOut.after(wait) : microTask
          , callback.bind(this));
    }

    /**
     * Returns whether a named debouncer is active.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {boolean} Whether the debouncer is active (has not yet fired).
     * @override
     */
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }

    /**
     * Immediately calls the debouncer `callback` and inactivates it.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {void}
     * @override
     */
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }

    /**
     * Cancels an active debouncer.  The `callback` will not be called.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {void}
     * @override
     */
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }

    /**
     * Runs a callback function asynchronously.
     *
     * By default (if no waitTime is specified), async callbacks are run at
     * microtask timing, which will occur before paint.
     *
     * @param {!Function} callback The callback function to run, bound to
     *     `this`.
     * @param {number=} waitTime Time to wait before calling the
     *   `callback`.  If unspecified or 0, the callback will be run at microtask
     *   timing (before paint).
     * @return {number} Handle that may be used to cancel the async job.
     * @override
     */
    async(callback, waitTime) {
      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) :
          ~microTask.run(callback.bind(this));
    }

    /**
     * Cancels an async operation started with `async`.
     *
     * @param {number} handle Handle returned from original `async` call to
     *   cancel.
     * @return {void}
     * @override
     */
    cancelAsync(handle) {
      handle < 0 ? microTask.cancel(~handle) :
          timeOut.cancel(handle);
    }

    // other

    /**
     * Convenience method for creating an element and configuring it.
     *
     * @param {string} tag HTML element tag to create.
     * @param {Object=} props Object of properties to configure on the
     *    instance.
     * @return {!Element} Newly created and configured element.
     * @override
     */
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }

    /**
     * Polyfill for Element.prototype.matches, which is sometimes still
     * prefixed.
     *
     * @param {string} selector Selector to test.
     * @param {!Element=} node Element to test the selector against.
     * @return {boolean} Whether the element matches the selector.
     * @override
     */
    elementMatches(selector, node) {
      return matchesSelector( (node || this), selector);
    }

    /**
     * Toggles an HTML attribute on or off.
     *
     * @param {string} name HTML attribute name
     * @param {boolean=} bool Boolean to force the attribute on or off.
     *    When unspecified, the state of the attribute will be reversed.
     * @return {boolean} true if the attribute now exists
     * @override
     */
    toggleAttribute(name, bool) {
      let node = /** @type {Element} */(this);
      if (arguments.length === 3) {
        node = /** @type {Element} */(arguments[2]);
      }
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        wrap$1(node).setAttribute(name, '');
        return true;
      } else {
        wrap$1(node).removeAttribute(name);
        return false;
      }
    }


    /**
     * Toggles a CSS class on or off.
     *
     * @param {string} name CSS class name
     * @param {boolean=} bool Boolean to force the class on or off.
     *    When unspecified, the state of the class will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     * @return {void}
     * @override
     */
    toggleClass(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }

    /**
     * Cross-platform helper for setting an element's CSS `transform` property.
     *
     * @param {string} transformText Transform setting.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`
     * @return {void}
     * @override
     */
    transform(transformText, node) {
      node = /** @type {Element} */ (node || this);
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }

    /**
     * Cross-platform helper for setting an element's CSS `translate3d`
     * property.
     *
     * @param {number|string} x X offset.
     * @param {number|string} y Y offset.
     * @param {number|string} z Z offset.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`.
     * @return {void}
     * @override
     */
    translate3d(x, y, z, node) {
      node = /** @type {Element} */ (node || this);
      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
    }

    /**
     * Removes an item from an array, if it exists.
     *
     * If the array is specified by path, a change notification is
     * generated, so that observers, data bindings and computed
     * properties watching that path can update.
     *
     * If the array is passed directly, **no change
     * notification is generated**.
     *
     * @param {string | !Array<number|string>} arrayOrPath Path to array from
     *     which to remove the item
     *   (or the array itself).
     * @param {*} item Item to remove.
     * @return {Array} Array containing item removed.
     * @override
     */
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = get(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }

    // logging

    /**
     * Facades `console.log`/`warn`/`error` as override point.
     *
     * @param {string} level One of 'log', 'warn', 'error'
     * @param {Array} args Array of strings or objects to log
     * @return {void}
     * @override
     */
    _logger(level, args) {
      // accept ['foo', 'bar'] and [['foo', 'bar']]
      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      switch(level) {
        case 'log':
        case 'warn':
        case 'error':
          console[level](...args);
      }
    }

    /**
     * Facades `console.log` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     * @return {void}
     * @override
     */
    _log(...args) {
      this._logger('log', args);
    }

    /**
     * Facades `console.warn` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     * @return {void}
     * @override
     */
    _warn(...args) {
      this._logger('warn', args);
    }

    /**
     * Facades `console.error` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     * @return {void}
     * @override
     */
    _error(...args) {
      this._logger('error', args);
    }

    /**
     * Formats a message using the element type an a method name.
     *
     * @param {string} methodName Method name to associate with message
     * @param {...*} args Array of strings or objects to log
     * @return {Array} Array with formatting information for `console`
     *   logging.
     * @override
     */
    _logf(methodName, ...args) {
      return ['[%s::%s]', this.is, methodName, ...args];
    }

  }

  LegacyElement.prototype.is = '';

  return LegacyElement;
});

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const lifecycleProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  listeners: true,
  hostAttributes: true
};

const excludeOnInfo = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  behaviors: true,
  _noAccessors: true
};

const excludeOnBehaviors = Object.assign({
  listeners: true,
  hostAttributes: true,
  properties: true,
  observers: true,
}, excludeOnInfo);

function copyProperties(source, target, excludeProps) {
  const noAccessors = source._noAccessors;
  const propertyNames = Object.getOwnPropertyNames(source);
  for (let i = 0; i < propertyNames.length; i++) {
    let p = propertyNames[i];
    if (p in excludeProps) {
      continue;
    }
    if (noAccessors) {
      target[p] = source[p];
    } else {
      let pd = Object.getOwnPropertyDescriptor(source, p);
      if (pd) {
        // ensure property is configurable so that a later behavior can
        // re-configure it.
        pd.configurable = true;
        Object.defineProperty(target, p, pd);
      }
    }
  }
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) PolymerElement, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function applyBehaviors(proto, behaviors, lifecycle) {
  for (let i=0; i<behaviors.length; i++) {
    applyInfo(proto, behaviors[i], lifecycle, excludeOnBehaviors);
  }
}

function applyInfo(proto, info, lifecycle, excludeProps) {
  copyProperties(info, proto, excludeProps);
  for (let p in lifecycleProps) {
    if (info[p]) {
      lifecycle[p] = lifecycle[p] || [];
      lifecycle[p].push(info[p]);
    }
  }
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i=behaviors.length-1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * Copies property descriptors from source to target, overwriting all fields
 * of any previous descriptor for a property *except* for `value`, which is
 * merged in from the target if it does not exist on the source.
 *
 * @param {*} target Target properties object
 * @param {*} source Source properties object
 */
function mergeProperties(target, source) {
  for (const p in source) {
    const targetInfo = target[p];
    const sourceInfo = source[p];
    if (!('value' in sourceInfo) && targetInfo && ('value' in targetInfo)) {
      target[p] = Object.assign({value: targetInfo.value}, sourceInfo);
    } else {
      target[p] = sourceInfo;
    }
  }
}

/* Note about construction and extension of legacy classes.
  [Changed in Q4 2018 to optimize performance.]

  When calling `Polymer` or `mixinBehaviors`, the generated class below is
  made. The list of behaviors was previously made into one generated class per
  behavior, but this is no longer the case as behaviors are now called
  manually. Note, there may *still* be multiple generated classes in the
  element's prototype chain if extension is used with `mixinBehaviors`.

  The generated class is directly tied to the info object and behaviors
  used to create it. That list of behaviors is filtered so it's only the
  behaviors not active on the superclass. In order to call through to the
  entire list of lifecycle methods, it's important to call `super`.

  The element's `properties` and `observers` are controlled via the finalization
  mechanism provided by `PropertiesMixin`. `Properties` and `observers` are
  collected by manually traversing the prototype chain and merging.

  To limit changes, the `_registered` method is called via `_initializeProperties`
  and not `_finalizeClass`.

*/
/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @param {Object=} behaviors behaviors to copy into the element
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base, behaviors) {

  // manages behavior and lifecycle processing (filled in after class definition)
  let behaviorList;
  const lifecycle = {};

  /** @private */
  class PolymerGenerated extends Base {

    // explicitly not calling super._finalizeClass
    /** @nocollapse */
    static _finalizeClass() {
      // if calling via a subclass that hasn't been generated, pass through to super
      if (!this.hasOwnProperty(JSCompiler_renameProperty('generatedFrom', this))) {
        // TODO(https://github.com/google/closure-compiler/issues/3240):
        //     Change back to just super.methodCall()
        Base._finalizeClass.call(this);
      } else {
        // interleave properties and observers per behavior and `info`
        if (behaviorList) {
          for (let i=0, b; i < behaviorList.length; i++) {
            b = behaviorList[i];
            if (b.properties) {
              this.createProperties(b.properties);
            }
            if (b.observers) {
              this.createObservers(b.observers, b.properties);
            }
          }
        }
        if (info.properties) {
          this.createProperties(info.properties);
        }
        if (info.observers) {
          this.createObservers(info.observers, info.properties);
        }
        // make sure to prepare the element template
        this._prepareTemplate();
      }
    }

    /** @nocollapse */
    static get properties() {
      const properties = {};
      if (behaviorList) {
        for (let i=0; i < behaviorList.length; i++) {
          mergeProperties(properties, behaviorList[i].properties);
        }
      }
      mergeProperties(properties, info.properties);
      return properties;
    }

    /** @nocollapse */
    static get observers() {
      let observers = [];
      if (behaviorList) {
        for (let i=0, b; i < behaviorList.length; i++) {
          b = behaviorList[i];
          if (b.observers) {
            observers = observers.concat(b.observers);
          }
        }
      }
      if (info.observers) {
        observers = observers.concat(info.observers);
      }
      return observers;
    }

    /**
     * @return {void}
     */
    created() {
      super.created();
      const list = lifecycle.created;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }

    /**
     * @return {void}
     */
    _registered() {
      /* NOTE: `beforeRegister` is called here for bc, but the behavior
        is different than in 1.x. In 1.0, the method was called *after*
        mixing prototypes together but *before* processing of meta-objects.
        However, dynamic effects can still be set here and can be done either
        in `beforeRegister` or `registered`. It is no longer possible to set
        `is` in `beforeRegister` as you could in 1.x.
      */
      // only proceed if the generated class' prototype has not been registered.
      const generatedProto = PolymerGenerated.prototype;
      if (!generatedProto.hasOwnProperty('__hasRegisterFinished')) {
        generatedProto.__hasRegisterFinished = true;
        // ensure superclass is registered first.
        super._registered();
        // copy properties onto the generated class lazily if we're optimizing,
        if (legacyOptimizations) {
          copyPropertiesToProto(generatedProto);
        }
        // make sure legacy lifecycle is called on the *element*'s prototype
        // and not the generated class prototype; if the element has been
        // extended, these are *not* the same.
        const proto = Object.getPrototypeOf(this);
        let list = lifecycle.beforeRegister;
        if (list) {
          for (let i=0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
        list = lifecycle.registered;
        if (list) {
          for (let i=0; i < list.length; i++) {
            list[i].call(proto);
          }
        }
      }
    }

    /**
     * @return {void}
     */
    _applyListeners() {
      super._applyListeners();
      const list = lifecycle.listeners;
      if (list) {
        for (let i=0; i < list.length; i++) {
          const listeners = list[i];
          if (listeners) {
            for (let l in listeners) {
              this._addMethodEventListenerToNode(this, l, listeners[l]);
            }
          }
        }
      }
    }

    // note: exception to "super then me" rule;
    // do work before calling super so that super attributes
    // only apply if not already set.
    /**
     * @return {void}
     */
    _ensureAttributes() {
      const list = lifecycle.hostAttributes;
      if (list) {
        for (let i=list.length-1; i >= 0; i--) {
          const hostAttributes = list[i];
          for (let a in hostAttributes) {
              this._ensureAttribute(a, hostAttributes[a]);
            }
        }
      }
      super._ensureAttributes();
    }

    /**
     * @return {void}
     */
    ready() {
      super.ready();
      let list = lifecycle.ready;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }

    /**
     * @return {void}
     */
    attached() {
      super.attached();
      let list = lifecycle.attached;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }

    /**
     * @return {void}
     */
    detached() {
      super.detached();
      let list = lifecycle.detached;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this);
        }
      }
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @return {void}
     */
    attributeChanged(name, old, value) {
      super.attributeChanged();
      let list = lifecycle.attributeChanged;
      if (list) {
        for (let i=0; i < list.length; i++) {
          list[i].call(this, name, old, value);
        }
      }
    }
  }

  // apply behaviors, note actual copying is done lazily at first instance creation
  if (behaviors) {
    // NOTE: ensure the behavior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    let superBehaviors = Base.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviorList = flattenBehaviors(behaviors, null, superBehaviors);
    PolymerGenerated.prototype.behaviors = superBehaviors ?
      superBehaviors.concat(behaviors) : behaviorList;
  }

  const copyPropertiesToProto = (proto) => {
    if (behaviorList) {
      applyBehaviors(proto, behaviorList, lifecycle);
    }
    applyInfo(proto, info, lifecycle, excludeOnInfo);
  };

  // copy properties if we're not optimizing
  if (!legacyOptimizations) {
    copyPropertiesToProto(PolymerGenerated.prototype);
  }

  PolymerGenerated.generatedFrom = info;

  return PolymerGenerated;
}

/**
 * Generates a class that extends `LegacyElement` based on the
 * provided info object.  Metadata objects on the `info` object
 * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
 * for Polymer's meta-programming systems, and any functions are copied
 * to the generated class.
 *
 * Valid "metadata" values are as follows:
 *
 * `is`: String providing the tag name to register the element under. In
 * addition, if a `dom-module` with the same id exists, the first template
 * in that `dom-module` will be stamped into the shadow root of this element,
 * with support for declarative event listeners (`on-...`), Polymer data
 * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
 * `this.$`.
 *
 * `properties`: Object describing property-related metadata used by Polymer
 * features (key: property names, value: object containing property metadata).
 * Valid keys in per-property metadata include:
 * - `type` (String|Number|Object|Array|...): Used by
 *   `attributeChangedCallback` to determine how string-based attributes
 *   are deserialized to JavaScript property values.
 * - `notify` (boolean): Causes a change in the property to fire a
 *   non-bubbling event called `<property>-changed`. Elements that have
 *   enabled two-way binding to the property use this event to observe changes.
 * - `readOnly` (boolean): Creates a getter for the property, but no setter.
 *   To set a read-only property, use the private setter method
 *   `_setProperty(property, value)`.
 * - `observer` (string): Observer method name that will be called when
 *   the property changes. The arguments of the method are
 *   `(value, previousValue)`.
 * - `computed` (string): String describing method and dependent properties
 *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
 *   Computed properties are read-only by default and can only be changed
 *   via the return value of the computing method.
 *
 * `observers`: Array of strings describing multi-property observer methods
 *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
 *
 * `listeners`: Object describing event listeners to be added to each
 *  instance of this element (key: event name, value: method name).
 *
 * `behaviors`: Array of additional `info` objects containing metadata
 * and callbacks in the same format as the `info` object here which are
 * merged into this element.
 *
 * `hostAttributes`: Object listing attributes to be applied to the host
 *  once created (key: attribute name, value: attribute value).  Values
 *  are serialized based on the type of the value.  Host attributes should
 *  generally be limited to attributes such as `tabIndex` and `aria-...`.
 *  Attributes in `hostAttributes` are only applied if a user-supplied
 *  attribute is not already present (attributes in markup override
 *  `hostAttributes`).
 *
 * In addition, the following Polymer-specific callbacks may be provided:
 * - `registered`: called after first instance of this element,
 * - `created`: called during `constructor`
 * - `attached`: called during `connectedCallback`
 * - `detached`: called during `disconnectedCallback`
 * - `ready`: called before first `attached`, after all properties of
 *   this element have been propagated to its template and all observers
 *   have run
 *
 * @param {!PolymerInit} info Object containing Polymer metadata and functions
 *   to become class methods.
 * @template T
 * @param {function(T):T} mixin Optional mixin to apply to legacy base class
 *   before extending with Polymer metaprogramming.
 * @return {function(new:HTMLElement)} Generated class
 */
const Class = function(info, mixin) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  let klass = mixin ? mixin(LegacyElementMixin(HTMLElement)) :
      LegacyElementMixin(HTMLElement);
  klass = GenerateClassFromInfo(info, klass, info.behaviors);
  // decorate klass with registration info
  klass.is = klass.prototype.is = info.is;
  return klass;
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Legacy class factory and registration helper for defining Polymer
 * elements.
 *
 * This method is equivalent to
 *
 *     import {Class} from '@polymer/polymer/lib/legacy/class.js';
 *     customElements.define(info.is, Class(info));
 *
 * See `Class` for details on valid legacy metadata format for `info`.
 *
 * @global
 * @override
 * @function
 * @param {!PolymerInit} info Object containing Polymer metadata and functions
 *   to become class methods.
 * @return {function(new: HTMLElement)} Generated class
 * @suppress {duplicate, invalidCasts, checkTypes}
 */
const Polymer = function(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  let klass;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = Polymer.Class(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */(klass));
  return klass;
};

Polymer.Class = Class;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = (typeof value === 'object' && value !== null);
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  let shouldChange = (old !== value && (old === old || value === value));
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

/**
 * Element class mixin to skip strict dirty-checking for objects and arrays
 * (always consider them to be "dirty"), for use on elements utilizing
 * `PropertyEffects`
 *
 * By default, `PropertyEffects` performs strict dirty checking on
 * objects, which means that any deep modifications to an object or array will
 * not be propagated unless "immutable" data patterns are used (i.e. all object
 * references from the root to the mutation were changed).
 *
 * Polymer also provides a proprietary data mutation and path notification API
 * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
 * mutation and notification of deep changes in an object graph to all elements
 * bound to the same object graph.
 *
 * In cases where neither immutable patterns nor the data mutation API can be
 * used, applying this mixin will cause Polymer to skip dirty checking for
 * objects and arrays (always consider them to be "dirty").  This allows a
 * user to make a deep modification to a bound object graph, and then either
 * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
 * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
 * elements that wish to be updated based on deep mutations must apply this
 * mixin or otherwise skip strict dirty checking for objects/arrays.
 * Specifically, any elements in the binding tree between the source of a
 * mutation and the consumption of it must apply this mixin or enable the
 * `OptionalMutableData` mixin.
 *
 * In order to make the dirty check strategy configurable, see
 * `OptionalMutableData`.
 *
 * Note, the performance characteristics of propagating large object graphs
 * will be worse as opposed to using strict dirty checking with immutable
 * patterns or Polymer's path notification API.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin to skip strict dirty-checking for objects
 *   and arrays
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
const MutableData = dedupingMixin(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  class MutableData extends superClass {
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }

  }

  return MutableData;

});

/**
 * Element class mixin to add the optional ability to skip strict
 * dirty-checking for objects and arrays (always consider them to be
 * "dirty") by setting a `mutable-data` attribute on an element instance.
 *
 * By default, `PropertyEffects` performs strict dirty checking on
 * objects, which means that any deep modifications to an object or array will
 * not be propagated unless "immutable" data patterns are used (i.e. all object
 * references from the root to the mutation were changed).
 *
 * Polymer also provides a proprietary data mutation and path notification API
 * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
 * mutation and notification of deep changes in an object graph to all elements
 * bound to the same object graph.
 *
 * In cases where neither immutable patterns nor the data mutation API can be
 * used, applying this mixin will allow Polymer to skip dirty checking for
 * objects and arrays (always consider them to be "dirty").  This allows a
 * user to make a deep modification to a bound object graph, and then either
 * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
 * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
 * elements that wish to be updated based on deep mutations must apply this
 * mixin or otherwise skip strict dirty checking for objects/arrays.
 * Specifically, any elements in the binding tree between the source of a
 * mutation and the consumption of it must enable this mixin or apply the
 * `MutableData` mixin.
 *
 * While this mixin adds the ability to forgo Object/Array dirty checking,
 * the `mutableData` flag defaults to false and must be set on the instance.
 *
 * Note, the performance characteristics of propagating large object graphs
 * will be worse by relying on `mutableData: true` as opposed to using
 * strict dirty checking with immutable patterns or Polymer's path notification
 * API.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin to optionally skip strict dirty-checking
 *   for objects and arrays
 */
const OptionalMutableData = dedupingMixin(superClass => {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  class OptionalMutableData extends superClass {

    /** @nocollapse */
    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }

    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  }

  return OptionalMutableData;

});

// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
let newInstance = null;

/**
 * @constructor
 * @extends {HTMLTemplateElement}
 * @private
 */
function HTMLTemplateElementExtension() { return newInstance; }
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});

/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 * @private
 */
const DataTemplate = PropertyEffects(HTMLTemplateElementExtension);

/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 * @private
 */
const MutableDataTemplate = MutableData(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

/**
 * Base class for TemplateInstance.
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @private
 */
const templateInstanceBase = PropertyEffects(
    // This cast shouldn't be neccessary, but Closure doesn't understand that
    // "class {}" is a constructor function.
    /** @type {function(new:Object)} */(class {}));

/**
 * @polymer
 * @customElement
 * @appliesMixin PropertyEffects
 * @unrestricted
 */
class TemplateInstanceBase extends templateInstanceBase {
  constructor(props) {
    super();
    this._configureProperties(props);
    /** @type {!StampedTemplate} */
    this.root = this._stampTemplate(this.__dataHost);
    // Save list of stamped children
    let children = [];
    /** @suppress {invalidCasts} */
    this.children = /** @type {!NodeList} */ (children);
    // Polymer 1.x did not use `Polymer.dom` here so not bothering.
    for (let n = this.root.firstChild; n; n=n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner &&
      this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    let options = this.__templatizeOptions;
    if ((props && options.instanceProps) || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   * @return {void}
   */
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (options.forwardHostProp) {
      for (let hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
      }
    }
    // Any instance props passed in the constructor will overwrite host props;
    // normally this would be a user error but we don't specifically filter them
    for (let iprop in props) {
      this._setPendingProperty(iprop, props[iprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   * @return {void}
   */
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }

  /**
   * Override point for adding custom or simulated event handling.
   *
   * @override
   * @param {!Node} node Node to add event listener to
   * @param {string} eventName Name of event
   * @param {function(!Event):void} handler Listener function to add
   * @return {void}
   */
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      // If this instance should be considered a parent model, decorate
      // events this template instance as `model`
      this._methodHost._addEventListenerToNode(node, eventName, (e) => {
        e.model = this;
        handler(e);
      });
    } else {
      // Otherwise delegate to the template's host (which could be)
      // another template instance
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(hide) {
    let c = this.children;
    for (let i=0; i<c.length; i++) {
      let n = c[i];
      // Ignore non-changes
      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
        if (n.nodeType === Node.TEXT_NODE) {
          if (hide) {
            n.__polymerTextContent__ = n.textContent;
            n.textContent = '';
          } else {
            n.textContent = n.__polymerTextContent__;
          }
        // remove and replace slot
        } else if (n.localName === 'slot') {
          if (hide) {
            n.__polymerReplaced__ = document.createComment('hidden-slot');
            wrap$1(wrap$1(n).parentNode).replaceChild(n.__polymerReplaced__, n);
          } else {
            const replace = n.__polymerReplaced__;
            if (replace) {
              wrap$1(wrap$1(replace).parentNode).replaceChild(n, replace);
            }
          }
        }

        else if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = 'none';
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
      }
      n.__hideTemplateChildren__ = hide;
      if (n._showHideChildren) {
        n._showHideChildren(hide);
      }
    }
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   * @param {!Node} node The node to set a property on
   * @param {string} prop The property to set
   * @param {*} value The value to set
   * @return {void}
   * @protected
   */
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ &&
        node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {!Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        // A template instance's `__dataHost` is a <template>
        // `model.__dataHost.__dataHost` is the template's host
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }

  /**
   * Stub of HTMLElement's `dispatchEvent`, so that effects that may
   * dispatch events safely no-op.
   *
   * @param {Event} event Event to dispatch
   * @return {boolean} Always true.
   * @override
   */
   dispatchEvent(event) { // eslint-disable-line no-unused-vars
     return true;
  }
}

/** @type {!DataTemplate} */
TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 * @private
 */
const MutableTemplateInstanceBase = MutableData(
    // This cast shouldn't be necessary, but Closure doesn't seem to understand
    // this constructor.
    /** @type {function(new:TemplateInstanceBase)} */(TemplateInstanceBase));

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  let templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   */
  let templatizerBase = options.mutableData ?
    MutableTemplateInstanceBase : TemplateInstanceBase;

  // Affordance for global mixins onto TemplatizeInstance
  if (templatize.mixin) {
    templatizerBase = templatize.mixin(templatizerBase);
  }

  /**
   * Anonymous class created by the templatize
   * @constructor
   * @private
   */
  let klass = class extends templatizerBase { };
  /** @override */
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * Adds propagate effects from the template to the template instance for
 * properties that the host binds to the template using the `_host_` prefix.
 * 
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp && templateInfo.hasHostProps) {
    // Provide data API and property effects on memoized template class
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      /**
       * @constructor
       * @extends {DataTemplate}
       */
      let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;
      /** @private */
      klass = templateInfo.templatizeTemplateClass =
        class TemplatizedTemplate extends templatizedBase {};
      // Add template - >instances effects
      // and host <- template effects
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          {fn: createForwardHostPropEffect(prop, userForwardHostProp)});
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner,
      prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (let hprop in hostProps) {
      // As we're iterating hostProps in this function, note whether
      // there were any, for an optimization in addPropagateEffects
      if (!templateInfo.hasHostProps) {
        templateInfo.hasHostProps = true;
      }
      klass.prototype._addPropertyEffect(hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyHostPropEffect()});
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner,
      inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}


/**
 * Returns an anonymous `PropertyEffects` class bound to the
 * `<template>` provided.  Instancing the class will result in the
 * template being stamped into a document fragment stored as the instance's
 * `root` property, after which it can be appended to the DOM.
 *
 * Templates may utilize all Polymer data-binding features as well as
 * declarative event listeners.  Event listeners and inline computing
 * functions in the template will be called on the host of the template.
 *
 * The constructor returned takes a single argument dictionary of initial
 * property values to propagate into template bindings.  Additionally
 * host properties can be forwarded in, and instance properties can be
 * notified out by providing optional callbacks in the `options` dictionary.
 *
 * Valid configuration in `options` are as follows:
 *
 * - `forwardHostProp(property, value)`: Called when a property referenced
 *   in the template changed on the template's host. As this library does
 *   not retain references to templates instanced by the user, it is the
 *   templatize owner's responsibility to forward host property changes into
 *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
 *    method on the generated class should be called to forward host
 *   properties into the template to prevent unnecessary property-changed
 *   notifications. Any properties referenced in the template that are not
 *   defined in `instanceProps` will be notified up to the template's host
 *   automatically.
 * - `instanceProps`: Dictionary of property names that will be added
 *   to the instance by the templatize owner.  These properties shadow any
 *   host properties, and changes within the template to these properties
 *   will result in `notifyInstanceProp` being called.
 * - `mutableData`: When `true`, the generated class will skip strict
 *   dirty-checking for objects and arrays (always consider them to be
 *   "dirty").
 * - `notifyInstanceProp(instance, property, value)`: Called when
 *   an instance property changes.  Users may choose to call `notifyPath`
 *   on e.g. the owner to notify the change.
 * - `parentModel`: When `true`, events handled by declarative event listeners
 *   (`on-event="handler"`) will be decorated with a `model` property pointing
 *   to the template instance that stamped it.  It will also be returned
 *   from `instance.parentModel` in cases where template instance nesting
 *   causes an inner model to shadow an outer model.
 *
 * All callbacks are called bound to the `owner`. Any context
 * needed for the callbacks (such as references to `instances` stamped)
 * should be stored on the `owner` such that they can be retrieved via
 * `this`.
 *
 * When `options.forwardHostProp` is declared as an option, any properties
 * referenced in the template will be automatically forwarded from the host of
 * the `<template>` to instances, with the exception of any properties listed in
 * the `options.instanceProps` object.  `instanceProps` are assumed to be
 * managed by the owner of the instances, either passed into the constructor
 * or set after the fact.  Note, any properties passed into the constructor will
 * always be set to the instance (regardless of whether they would normally
 * be forwarded from the host).
 *
 * Note that `templatize()` can be run only once for a given `<template>`.
 * Further calls will result in an error. Also, there is a special
 * behavior if the template was duplicated through a mechanism such as
 * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to
 * `templatize()` return the same class for all duplicates of a template.
 * The class returned from `templatize()` is generated only once using
 * the `options` from the first call. This means that any `options`
 * provided to subsequent calls will be ignored. Therefore, it is very
 * important not to close over any variables inside the callbacks. Also,
 * arrow functions must be avoided because they bind the outer `this`.
 * Inside the callbacks, any contextual information can be accessed
 * through `this`, which points to the `owner`.
 *
 * @param {!HTMLTemplateElement} template Template to templatize
 * @param {Polymer_PropertyEffects=} owner Owner of the template instances;
 *   any optional callbacks will be bound to this owner.
 * @param {Object=} options Options dictionary (see summary for details)
 * @return {function(new:TemplateInstanceBase, Object=)} Generated class bound
 *   to the template provided
 * @suppress {invalidCasts}
 */
function templatize(template, owner, options) {
  // Under strictTemplatePolicy, the templatized element must be owned
  // by a (trusted) Polymer element, indicated by existence of _methodHost;
  // e.g. for dom-if & dom-repeat in main document, _methodHost is null
  if (strictTemplatePolicy && !findMethodHost(template)) {
    throw new Error('strictTemplatePolicy: template owner not trusted');
  }
  options = /** @type {!TemplatizeOptions} */(options || {});
  if (template.__templatizeOwner) {
    throw new Error('A <template> can only be templatized once');
  }
  template.__templatizeOwner = owner;
  const ctor = owner ? owner.constructor : TemplateInstanceBase;
  let templateInfo = ctor._parseTemplate(template);
  // Get memoized base class for the prototypical template, which
  // includes property effects for binding template & forwarding
  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   */
  let baseClass = templateInfo.templatizeInstanceClass;
  if (!baseClass) {
    baseClass = createTemplatizerClass(template, templateInfo, options);
    templateInfo.templatizeInstanceClass = baseClass;
  }
  // Host property forwarding must be installed onto template instance
  addPropagateEffects(template, templateInfo, options);
  // Subclass base class and add reference for this specific template
  /** @private */
  let klass = class TemplateInstance extends baseClass {};
  /** @override */
  klass.prototype._methodHost = findMethodHost(template);
  /** @override */
  klass.prototype.__dataHost = /** @type {!DataTemplate} */ (template);
  /** @override */
  klass.prototype.__templatizeOwner = /** @type {!Object} */ (owner);
  /** @override */
  klass.prototype.__hostProps = templateInfo.hostProps;
  klass = /** @type {function(new:TemplateInstanceBase)} */(klass); //eslint-disable-line no-self-assign
  return klass;
}

/**
 * Returns the template "model" associated with a given element, which
 * serves as the binding scope for the template instance the element is
 * contained in. A template model is an instance of
 * `TemplateInstanceBase`, and should be used to manipulate data
 * associated with this template instance.
 *
 * Example:
 *
 *   let model = modelForElement(el);
 *   if (model.index < 10) {
 *     model.set('item.checked', true);
 *   }
 *
 * @param {HTMLTemplateElement} template The model will be returned for
 *   elements stamped from this template
 * @param {Node=} node Node for which to return a template model.
 * @return {TemplateInstanceBase} Template instance representing the
 *   binding scope for the element
 */
function modelForElement(template, node) {
  let model;
  while (node) {
    // An element with a __templatizeInstance marks the top boundary
    // of a scope; walk up until we find one, and then ensure that
    // its __dataHost matches `this`, meaning this dom-repeat stamped it
    if ((model = node.__templatizeInstance)) {
      // Found an element stamped by another template; keep walking up
      // from its __dataHost
      if (model.__dataHost != template) {
        node = model.__dataHost;
      } else {
        return model;
      }
    } else {
      // Still in a template scope, keep going up until
      // a __templatizeInstance is found
      node = wrap$1(node).parentNode;
    }
  }
  return null;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let elementsHidden = false;

/**
 * @return {boolean} True if elements will be hidden globally
 */
function hideElementsGlobally() {
  if (legacyOptimizations && !useShadow) {
    if (!elementsHidden) {
      elementsHidden = true;
      const style = document.createElement('style');
      style.textContent = 'dom-bind,dom-if,dom-repeat{display:none;}';
      document.head.appendChild(style);
    }
    return true;
  }
  return false;
}

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 * @private
 */
const domBindBase =
  GestureEventListeners(
    OptionalMutableData(
      PropertyEffects(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin PropertyEffects
 * @appliesMixin OptionalMutableData
 * @appliesMixin GestureEventListeners
 * @extends {domBindBase}
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */
class DomBind extends domBindBase {

  static get observedAttributes() { return ['mutable-data']; }

  constructor() {
    super();
    if (strictTemplatePolicy) {
      throw new Error(`strictTemplatePolicy: dom-bind not allowed`);
    }
    this.root = null;
    this.$ = null;
    this.__children = null;
  }

  /* eslint-disable no-unused-vars */
  /**
   * @override
   * @param {string} name Name of attribute that changed
   * @param {?string} old Old attribute value
   * @param {?string} value New attribute value
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   */
  attributeChangedCallback(name, old, value, namespace) {
    // assumes only one observed attribute
    this.mutableData = true;
  }

  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    if (!hideElementsGlobally()) {
      this.style.display = 'none';
    }
    this.render();
  }

  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    this.__removeChildren();
  }

  __insertChildren() {
    wrap$1(wrap$1(this).parentNode).insertBefore(this.root, this);
  }

  __removeChildren() {
    if (this.__children) {
      for (let i=0; i<this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }

  /**
   * Forces the element to render its content. This is typically only
   * necessary to call if HTMLImports with the async attribute are used.
   * @return {void}
   */
  render() {
    let template;
    if (!this.__children) {
      template = /** @type {HTMLTemplateElement} */(template || this.querySelector('template'));
      if (!template) {
        // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          template = /** @type {HTMLTemplateElement} */(this.querySelector('template'));
          if (template) {
            observer.disconnect();
            this.render();
          } else {
            throw new Error('dom-bind requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return;
      }
      this.root = this._stampTemplate(
        /** @type {!HTMLTemplateElement} */(template));
      this.$ = this.root.$;
      this.__children = [];
      for (let n=this.root.firstChild; n; n=n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
  }

}

customElements.define('dom-bind', DomBind);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Class representing a static string value which can be used to filter
 * strings by asseting that they have been created via this class. The
 * `value` property returns the string passed to the constructor.
 */
class LiteralString {
  constructor(string) {
    /** @type {string} */
    this.value = string.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */
  toString() {
    return this.value;
  }
}

/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */
function literalValue(value) {
  if (value instanceof LiteralString) {
    return /** @type {!LiteralString} */(value).value;
  } else {
    throw new Error(
        `non-literal value passed to Polymer's htmlLiteral function: ${value}`
    );
  }
}

/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */
function htmlValue(value) {
  if (value instanceof HTMLTemplateElement) {
    return /** @type {!HTMLTemplateElement } */(value).innerHTML;
  } else if (value instanceof LiteralString) {
    return literalValue(value);
  } else {
    throw new Error(
        `non-template value passed to Polymer's html function: ${value}`);
  }
}

/**
 * A template literal tag that creates an HTML <template> element from the
 * contents of the string.
 *
 * This allows you to write a Polymer Template in JavaScript.
 *
 * Templates can be composed by interpolating `HTMLTemplateElement`s in
 * expressions in the JavaScript template literal. The nested template's
 * `innerHTML` is included in the containing template.  The only other
 * values allowed in expressions are those returned from `htmlLiteral`
 * which ensures only literal values from JS source ever reach the HTML, to
 * guard against XSS risks.
 *
 * All other values are disallowed in expressions to help prevent XSS
 * attacks; however, `htmlLiteral` can be used to compose static
 * string values into templates. This is useful to compose strings into
 * places that do not accept html, like the css text of a `style`
 * element.
 *
 * Example:
 *
 *     static get template() {
 *       return html`
 *         <style>:host{ content:"..." }</style>
 *         <div class="shadowed">${this.partialTemplate}</div>
 *         ${super.template}
 *       `;
 *     }
 *     static get partialTemplate() { return html`<span>Partial!</span>`; }
 *
 * @param {!ITemplateArray} strings Constant parts of tagged template literal
 * @param {...*} values Variable parts of tagged template literal
 * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement
 */
const html$1 = function html(strings, ...values) {
  const template = /** @type {!HTMLTemplateElement} */(document.createElement('template'));
  template.innerHTML = values.reduce((acc, v, idx) =>
      acc + htmlValue(v) + strings[idx + 1], strings[0]);
  return template;
};

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
const PolymerElement = ElementMixin(HTMLElement);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {PolymerElement}
 * @private
 */
const domRepeatBase = OptionalMutableData(PolymerElement);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <dom-repeat items="{{employees}}">
 *       <template>
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *       </template>
 *     </dom-repeat>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * With the following custom element definition:
 *
 * ```js
 * class EmployeeList extends PolymerElement {
 *   static get is() { return 'employee-list'; }
 *   static get properties() {
 *     return {
 *       employees: {
 *         value() {
 *           return [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *           ];
 *         }
 *       }
 *     };
 *   }
 * }
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,
 * `shift`, `unshift`), and template instances will be kept in sync with the
 * data in the array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model should be used to manipulate data on the
 * instance, for example `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer(item) {
 *   return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <dom-repeat items="{{employees}}" filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @extends {domRepeatBase}
 * @appliesMixin OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */
class DomRepeat extends domRepeatBase {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-repeat'; }

  static get template() { return null; }

  static get properties() {

    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */
    return {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: 'itemsIndex'
      },

      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: '__sortChanged'
      },

      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: '__filterChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: '__observeChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time in ms after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffling of the view when
       * item changes may be frequent.
       */
      delay: Number,

      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: true,
        readOnly: true
      },

      /**
       * Defines an initial count of template instances to render after setting
       * the `items` array, before the next paint, and puts the `dom-repeat`
       * into "chunking mode".  The remaining items will be created and rendered
       * incrementally at each animation frame therof until all instances have
       * been rendered.
       */
      initialCount: {
        type: Number,
        observer: '__initializeChunking'
      },

      /**
       * When `initialCount` is used, this property defines a frame rate (in
       * fps) to target by throttling the number of instances rendered each
       * frame to not exceed the budget for the target frame rate.  The
       * framerate is effectively the number of `requestAnimationFrame`s that
       * it tries to allow to actually fire in a given second. It does this
       * by measuring the time between `rAF`s and continuously adjusting the
       * number of items created each `rAF` to maintain the target framerate.
       * Setting this to a higher number allows lower latency and higher
       * throughput for event handlers and other tasks, but results in a
       * longer time for the remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },

      _targetFrameTime: {
        type: Number,
        computed: '__computeFrameTime(targetFramerate)'
      }

    };

  }

  static get observers() {
    return [ '__itemsChanged(items.*)' ];
  }

  constructor() {
    super();
    this.__instances = [];
    this.__limit = Infinity;
    this.__pool = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__lastChunkTime = null;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    /** @type {?function(new:TemplateInstanceBase, Object=)} */
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
  }

  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i=0; i<this.__instances.length; i++) {
      this.__detachInstance(i);
    }
  }

  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = 'none';
    }
    // only perform attachment if the element was previously detached.
    if (this.__isDetached) {
      this.__isDetached = false;
      let wrappedParent = wrap$1(wrap$1(this).parentNode);
      for (let i=0; i<this.__instances.length; i++) {
        this.__attachInstance(i, wrappedParent);
      }
    }
  }

  __ensureTemplatized() {
    // Templatizing (generating the instance constructor) needs to wait
    // until ready, since won't have its template content handed back to
    // it until then
    if (!this.__ctor) {
      let template = this.template = /** @type {HTMLTemplateElement} */(this.querySelector('template'));
      if (!template) {
        // // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          if (this.querySelector('template')) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error('dom-repeat requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return false;
      }
      // Template instance props that should be excluded from forwarding
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = templatize(template, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps: instanceProps,
        /**
         * @this {DomRepeat}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
            inst.forwardHostProp(prop, value);
          }
        },
        /**
         * @this {DomRepeat}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(inst, prop, value) {
          if (matches(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }

  __getMethodHost() {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    return this.__dataHost._methodHost || this.__dataHost;
  }

  __functionFromPropertyValue(functionOrMethodName) {
    if (typeof functionOrMethodName === 'string') {
      let methodName = functionOrMethodName;
      let obj = this.__getMethodHost();
      return function() { return obj[methodName].apply(obj, arguments); };
    }

    return functionOrMethodName;
  }

  __sortChanged(sort) {
    this.__sortFn = this.__functionFromPropertyValue(sort);
    if (this.items) { this.__debounceRender(this.__render); }
  }

  __filterChanged(filter) {
    this.__filterFn = this.__functionFromPropertyValue(filter);
    if (this.items) { this.__debounceRender(this.__render); }
  }

  __computeFrameTime(rate) {
    return Math.ceil(1000/rate);
  }

  __initializeChunking() {
    if (this.initialCount) {
      this.__limit = this.initialCount;
      this.__chunkCount = this.initialCount;
      this.__lastChunkTime = performance.now();
    }
  }

  __tryRenderChunk() {
    // Debounced so that multiple calls through `_render` between animation
    // frames only queue one new rAF (e.g. array mutation & chunked render)
    if (this.items && this.__limit < this.items.length) {
      this.__debounceRender(this.__requestRenderChunk);
    }
  }

  __requestRenderChunk() {
    requestAnimationFrame(()=>this.__renderChunk());
  }

  __renderChunk() {
    // Simple auto chunkSize throttling algorithm based on feedback loop:
    // measure actual time between frames and scale chunk count by ratio
    // of target/actual frame time
    let currChunkTime = performance.now();
    let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    this.__limit += this.__chunkCount;
    this.__lastChunkTime = currChunkTime;
    this.__debounceRender(this.__render);
  }

  __observeChanged() {
    this.__observePaths = this.observe &&
      this.observe.replace('.*', '.').split(' ');
  }

  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn('dom-repeat expected array for `items`, found', this.items);
    }
    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
    // path to that instance synchronously (returns false for non-item paths)
    if (!this.__handleItemPath(change.path, change.value)) {
      // Otherwise, the array was reset ('items') or spliced ('items.splices'),
      // so queue a full refresh
      this.__initializeChunking();
      this.__debounceRender(this.__render);
    }
  }

  __handleObservedPaths(path) {
    // Handle cases where path changes should cause a re-sort/filter
    if (this.__sortFn || this.__filterFn) {
      if (!path) {
        // Always re-render if the item itself changed
        this.__debounceRender(this.__render, this.delay);
      } else if (this.__observePaths) {
        // Otherwise, re-render if the path changed matches an observed path
        let paths = this.__observePaths;
        for (let i=0; i<paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__debounceRender(this.__render, this.delay);
          }
        }
      }
    }
  }

  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = Debouncer.debounce(
          this.__renderDebouncer
        , delay > 0 ? timeOut.after(delay) : microTask
        , fn.bind(this));
    enqueueDebouncer(this.__renderDebouncer);
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */
  render() {
    // Queue this repeater, then flush all in order
    this.__debounceRender(this.__render);
    flush();
  }

  __render() {
    if (!this.__ensureTemplatized()) {
      // No template found yet
      return;
    }
    this.__applyFullRefresh();
    // Reset the pool
    // TODO(kschaaf): Reuse pool across turns and nested templates
    // Now that objects/arrays are re-evaluated when set, we can safely
    // reuse pooled instances across turns, however we still need to decide
    // semantics regarding how long to hold, how many to hold, etc.
    this.__pool.length = 0;
    // Set rendered item count
    this._setRenderedItemCount(this.__instances.length);
    // Notify users
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
    // Check to see if we need to render more items
    this.__tryRenderChunk();
  }

  __applyFullRefresh() {
    let items = this.items || [];
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i=0; i<items.length; i++) {
      isntIdxToItemsIdx[i] = i;
    }
    // Apply user filter
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>
        this.__filterFn(items[i], idx, array));
    }
    // Apply user sort
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
    }
    // items->inst map kept for item path forwarding
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx = 0;
    // Generate instances and assign items
    const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
    for (; instIdx<limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst) {
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item, instIdx, itemIdx);
      }
    }
    // Remove any extra instances from previous state
    for (let i=this.__instances.length-1; i>=instIdx; i--) {
      this.__detachAndRemoveInstance(i);
    }
  }

  __detachInstance(idx) {
    let inst = this.__instances[idx];
    const wrappedRoot = wrap$1(inst.root);
    for (let i=0; i<inst.children.length; i++) {
      let el = inst.children[i];
      wrappedRoot.appendChild(el);
    }
    return inst;
  }

  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    // Note, this is pre-wrapped as an optimization
    parent.insertBefore(inst.root, this);
  }

  __detachAndRemoveInstance(idx) {
    let inst = this.__detachInstance(idx);
    if (inst) {
      this.__pool.push(inst);
    }
    this.__instances.splice(idx, 1);
  }

  __stampInstance(item, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }

  __insertInstance(item, instIdx, itemIdx) {
    let inst = this.__pool.pop();
    if (inst) {
      // TODO(kschaaf): If the pool is shared across turns, hostProps
      // need to be re-set to reused instances in addition to item
      inst._setPendingProperty(this.as, item);
      inst._setPendingProperty(this.indexAs, instIdx);
      inst._setPendingProperty(this.itemsIndexAs, itemIdx);
      inst._flushProperties();
    } else {
      inst = this.__stampInstance(item, instIdx, itemIdx);
    }
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    wrap$1(wrap$1(this).parentNode).insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }

  // Implements extension point from Templatize mixin
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hidden Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(hidden) {
    for (let i=0; i<this.__instances.length; i++) {
      this.__instances[i]._showHideChildren(hidden);
    }
  }

  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6); // 'items.'.length == 6
    let dot = itemsPath.indexOf('.');
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    // If path was index into array...
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);
      // If the path is observed, it will trigger a full refresh
      this.__handleObservedPaths(itemSubPath);
      // Note, even if a rull refresh is triggered, always do the path
      // notification because unless mutableData is used for dom-repeat
      // and all elements in the instance subtree, a full refresh may
      // not trigger the proper update.
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
        // This is effectively `notifyPath`, but avoids some of the overhead
        // of the public API
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }

  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {!HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }

  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {!HTMLElement} el Element for which to return the index.
   * @return {?number} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {!HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(el) {
    return modelForElement(this.template, el);
  }

}

customElements.define(DomRepeat.is, DomRepeat);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsy, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends PolymerElement
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
class DomIf extends PolymerElement {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-if'; }

  static get template() { return null; }

  static get properties() {

    return {

      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */

      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: '__debounceRender'
      },

      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: '__debounceRender'
      }

    };

  }

  constructor() {
    super();
    this.__renderDebouncer = null;
    this.__invalidProps = null;
    this.__instance = null;
    this._lastIf = false;
    this.__ctor = null;
    this.__hideTemplateChildren__ = false;
  }

  __debounceRender() {
    // Render is async for 2 reasons:
    // 1. To eliminate dom creation trashing if user code thrashes `if` in the
    //    same turn. This was more common in 1.x where a compound computed
    //    property could result in the result changing multiple times, but is
    //    mitigated to a large extent by batched property processing in 2.x.
    // 2. To avoid double object propagation when a bag including values bound
    //    to the `if` property as well as one or more hostProps could enqueue
    //    the <dom-if> to flush before the <template>'s host property
    //    forwarding. In that scenario creating an instance would result in
    //    the host props being set once, and then the enqueued changes on the
    //    template would set properties a second time, potentially causing an
    //    object to be set to an instance more than once.  Creating the
    //    instance async from flushing data ensures this doesn't happen. If
    //    we wanted a sync option in the future, simply having <dom-if> flush
    //    (or clear) its template's pending host properties before creating
    //    the instance would also avoid the problem.
    this.__renderDebouncer = Debouncer.debounce(
          this.__renderDebouncer
        , microTask
        , () => this.__render());
    enqueueDebouncer(this.__renderDebouncer);
  }

  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = wrap$1(this).parentNode;
    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
        !wrap$1(parent).host)) {
      this.__teardownInstance();
    }
  }

  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = 'none';
    }
    if (this.if) {
      this.__debounceRender();
    }
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */
  render() {
    flush();
  }

  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        // No template found yet
        return;
      }
      this._showHideChildren();
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    if (!this.restamp && this.__instance) {
      this._showHideChildren();
    }
    if (this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }

  __ensureInstance() {
    let parentNode = wrap$1(this).parentNode;
    // Guard against element being detached while render was queued
    if (parentNode) {
      if (!this.__ctor) {
        let template = /** @type {HTMLTemplateElement} */(wrap$1(this).querySelector('template'));
        if (!template) {
          // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            if (wrap$1(this).querySelector('template')) {
              observer.disconnect();
              this.__render();
            } else {
              throw new Error('dom-if requires a <template> child');
            }
          });
          observer.observe(this, {childList: true});
          return false;
        }
        this.__ctor = templatize(template, this, {
          // dom-if templatizer instances require `mutable: true`, as
          // `__syncHostProperties` relies on that behavior to sync objects
          mutableData: true,
          /**
           * @param {string} prop Property to forward
           * @param {*} value Value of property
           * @this {DomIf}
           */
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                // If we have an instance but are squelching host property
                // forwarding due to if being false, note the invalidated
                // properties so `__syncHostProperties` can sync them the next
                // time `if` becomes true
                this.__invalidProps = this.__invalidProps || Object.create(null);
                this.__invalidProps[root(prop)] = true;
              }
            }
          }
        });
      }
      if (!this.__instance) {
        this.__instance = new this.__ctor();
        wrap$1(parentNode).insertBefore(this.__instance.root, this);
      } else {
        this.__syncHostProperties();
        let c$ = this.__instance.children;
        if (c$ && c$.length) {
          // Detect case where dom-if was re-attached in new position
          let lastChild = wrap$1(this).previousSibling;
          if (lastChild !== c$[c$.length-1]) {
            for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
              wrap$1(parentNode).insertBefore(n, this);
            }
          }
        }
      }
    }
    return true;
  }

  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__invalidProps = null;
      this.__instance._flushProperties();
    }
  }

  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        // use first child parent, for case when dom-if may have been detached
        let parent = wrap$1(c$[0]).parentNode;
        // Instance children may be disconnected from parents when dom-if
        // detaches if a tree was innerHTML'ed
        if (parent) {
          parent = wrap$1(parent);
          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
            parent.removeChild(n);
          }
        }
      }
      this.__instance = null;
      this.__invalidProps = null;
    }
  }

  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @return {void}
   * @protected
   * @suppress {visibility}
   */
  _showHideChildren() {
    let hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance) {
      this.__instance._showHideChildren(hidden);
    }
  }

}

customElements.define(DomIf.is, DomIf);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin ElementMixin
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
let ArraySelectorMixin = dedupingMixin(superClass => {

  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @private
   */
  let elementBase = ElementMixin(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */
  class ArraySelectorMixin extends elementBase {

    static get properties() {
      return {

        /**
         * An array containing items from which selection will be made.
         */
        items: {
          type: Array,
        },

        /**
         * When `true`, multiple items may be selected at once (in this case,
         * `selected` is an array of currently selected items).  When `false`,
         * only one item may be selected at a time.
         */
        multi: {
          type: Boolean,
          value: false,
        },

        /**
         * When `multi` is true, this is an array that contains any selected.
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object|?Array<!Object>}
         */
        selected: {type: Object, notify: true},

        /**
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object}
         */
        selectedItem: {type: Object, notify: true},

        /**
         * When `true`, calling `select` on an item that is already selected
         * will deselect the item.
         */
        toggle: {type: Boolean, value: false}

      };
    }

    static get observers() {
      return ['__updateSelection(multi, items.*)'];
    }

    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }

    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == JSCompiler_renameProperty('items', this)) {
        // Case 1 - items array changed, so diff against previous array and
        // deselect any removed items and adjust selected indices
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = calculateSplices(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == `${JSCompiler_renameProperty('items', this)}.splices`) {
        // Case 2 - got specific splice information describing the array mutation:
        // deselect any removed items and adjust selected indices
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        // Case 3 - an array element was changed, so deselect the previous
        // item for that index if it was previously selected
        let part = path.slice(`${JSCompiler_renameProperty('items', this)}.`.length);
        let idx = parseInt(part, 10);
        if ((part.indexOf('.') < 0) && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }

    __applySplices(splices) {
      let selected = this.__selectedMap;
      // Adjust selected indices and mark removals
      for (let i=0; i<splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) ; else if (idx >= s.index + s.removed.length) {
            // adjust index
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            // remove index
            selected.set(item, -1);
          }
        });
        for (let j=0; j<s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      // Update linked paths
      this.__updateLinks();
      // Remove selected items that were removed from the items array
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }

    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach(idx => {
          if (idx >= 0) {
            this.linkPaths(
                `${JSCompiler_renameProperty('items', this)}.${idx}`,
                `${JSCompiler_renameProperty('selected', this)}.${sidx++}`);
          }
        });
      } else {
        this.__selectedMap.forEach(idx => {
          this.linkPaths(
              JSCompiler_renameProperty('selected', this),
              `${JSCompiler_renameProperty('items', this)}.${idx}`);
          this.linkPaths(
              JSCompiler_renameProperty('selectedItem', this),
              `${JSCompiler_renameProperty('items', this)}.${idx}`);
        });
      }
    }

    /**
     * Clears the selection state.
     * @override
     * @return {void}
     */
    clearSelection() {
      // Unbind previous selection
      this.__dataLinkedPaths = {};
      // The selected map stores 3 pieces of information:
      // key: items array object
      // value: items array index
      // order: selected array index
      this.__selectedMap = new Map();
      // Initialize selection
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @override
     * @param {*} item Item from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isSelected(item) {
      return this.__selectedMap.has(item);
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @override
     * @param {number} idx Index from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }

    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }

    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths[`${JSCompiler_renameProperty('items', this)}.${idx}`];
      if (selected) {
        return parseInt(selected.slice(`${JSCompiler_renameProperty('selected', this)}.`.length), 10);
      }
    }

    /**
     * Deselects the given item if it is already selected.
     *
     * @override
     * @param {*} item Item from `items` array to deselect
     * @return {void}
     */
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }

    /**
     * Deselects the given index if it is already selected.
     *
     * @override
     * @param {number} idx Index from `items` array to deselect
     * @return {void}
     */
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }

    /**
     * Selects the given item.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @override
     * @param {*} item Item from `items` array to select
     * @return {void}
     */
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }

    /**
     * Selects the given index.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @override
     * @param {number} idx Index from `items` array to select
     * @return {void}
     */
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push(JSCompiler_renameProperty('selected', this), item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }

  }

  return ArraySelectorMixin;

});

/**
 * @constructor
 * @extends {PolymerElement}
 * @implements {Polymer_ArraySelectorMixin}
 * @private
 */
let baseArraySelector = ArraySelectorMixin(PolymerElement);

/**
 * Element implementing the `ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```js
 * import {PolymerElement} from '@polymer/polymer';
 * import '@polymer/polymer/lib/elements/array-selector.js';
 *
 * class EmployeeList extends PolymerElement {
 *   static get _template() {
 *     return html`
 *         <div> Employee list: </div>
 *         <dom-repeat id="employeeList" items="{{employees}}">
 *           <template>
 *             <div>First name: <span>{{item.first}}</span></div>
 *               <div>Last name: <span>{{item.last}}</span></div>
 *               <button on-click="toggleSelection">Select</button>
 *           </template>
 *         </dom-repeat>
 *
 *         <array-selector id="selector"
 *                         items="{{employees}}"
 *                         selected="{{selected}}"
 *                         multi toggle></array-selector>
 *
 *         <div> Selected employees: </div>
 *         <dom-repeat items="{{selected}}">
 *           <template>
 *             <div>First name: <span>{{item.first}}</span></div>
 *             <div>Last name: <span>{{item.last}}</span></div>
 *           </template>
 *         </dom-repeat>`;
 *   }
 *   static get is() { return 'employee-list'; }
 *   static get properties() {
 *     return {
 *       employees: {
 *         value() {
 *           return [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *           ];
 *         }
 *       }
 *     };
 *   }
 *   toggleSelection(e) {
 *     const item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * }
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin ArraySelectorMixin
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */
class ArraySelector extends baseArraySelector {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'array-selector'; }
  static get template() { return null; }
}
customElements.define(ArraySelector.is, ArraySelector);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const customStyleInterface = new CustomStyleInterface();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */
    prepareTemplateDom(template, elementName) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplateStyles(template, elementName, elementExtends) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      updateNativeProperties(element, properties);
    },

    /**
     * @param {Element} element
     */
    styleElement(element) { // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      customStyleInterface.processStyles();
      updateNativeProperties(document.body, properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return getComputedStyleValue(element, property);
    },

    flushCustomStyles() {},
    nativeCss: nativeCssVariables,
    nativeShadow: nativeShadow,
    cssBuild: cssBuild,
    disableRuntime: disableRuntime,
  };
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const attr = 'include';

const CustomStyleInterface$1 = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```html
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import" href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 *
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */
class CustomStyle extends HTMLElement {
  constructor() {
    super();
    this._style = null;
    CustomStyleInterface$1.addCustomStyle(this);
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @export
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */
  getStyle() {
    if (this._style) {
      return this._style;
    }
    const style = /** @type {HTMLStyleElement} */(this.querySelector('style'));
    if (!style) {
      return null;
    }
    this._style = style;
    const include = style.getAttribute(attr);
    if (include) {
      style.removeAttribute(attr);
      /** @suppress {deprecated} */
      style.textContent = cssFromModules(include) + style.textContent;
    }
    /*
    HTML Imports styling the main document are deprecated in Chrome
    https://crbug.com/523952

    If this element is not in the main document, then it must be in an HTML Import document.
    In that case, move the custom style to the main document.

    The ordering of `<custom-style>` should stay the same as when loaded by HTML Imports, but there may be odd
    cases of ordering w.r.t the main document styles.
    */
    if (this.ownerDocument !== window.document) {
      window.document.head.appendChild(this);
    }
    return this._style;
  }
}

window.customElements.define('custom-style', CustomStyle);

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

// bc
const Base = LegacyElementMixin(HTMLElement).prototype;

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

class IronMeta {
  /**
   * @param {{
   *   type: (string|null|undefined),
   *   key: (string|null|undefined),
   *   value: *,
   * }=} options
   */
  constructor(options) {
    IronMeta[' '](options);

    /** @type {string} */
    this.type = (options && options.type) || 'default';
    /** @type {string|null|undefined} */
    this.key = options && options.key;
    if (options && 'value' in options) {
      /** @type {*} */
      this.value = options.value;
    }
  }

  /** @return {*} */
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  }

  /** @param {*} value */
  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  }

  /** @return {!Array<*>} */
  get list() {
    var type = this.type;

    if (type) {
      var items = IronMeta.types[this.type];
      if (!items) {
        return [];
      }

      return Object.keys(items).map(function(key) {
        return metaDatas[this.type][key];
      }, this);
    }
  }

  /**
   * @param {string} key
   * @return {*}
   */
  byKey(key) {
    this.key = key;
    return this.value;
  }
}
// This function is used to convince Closure not to remove constructor calls
// for instances that are not held anywhere. For example, when
// `new IronMeta({...})` is used only for the side effect of adding a value.
IronMeta[' '] = function() {};

IronMeta.types = {};

var metaDatas = IronMeta.types;

/**
`iron-meta` is a generic element you can use for sharing information across the
DOM tree. It uses [monostate pattern](http://c2.com/cgi/wiki?MonostatePattern)
such that any instance of iron-meta has access to the shared information. You
can use `iron-meta` to share whatever you want (or create an extension [like
x-meta] for enhancements).

The `iron-meta` instances containing your actual data can be loaded in an
import, or constructed in any way you see fit. The only requirement is that you
create them before you try to access them.

Examples:

If I create an instance like this:

    <iron-meta key="info" value="foo/bar"></iron-meta>

Note that value="foo/bar" is the metadata I've defined. I could define more
attributes or use child nodes to define additional metadata.

Now I can access that element (and it's metadata) from any iron-meta instance
via the byKey method, e.g.

    meta.byKey('info');

Pure imperative form would be like:

    document.createElement('iron-meta').byKey('info');

Or, in a Polymer element, you can include a meta in your template:

    <iron-meta id="meta"></iron-meta>
    ...
    this.$.meta.byKey('info');

@group Iron Elements
@demo demo/index.html
@element iron-meta
*/
Polymer({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default',
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String,
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true,
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
    self: {type: Boolean, observer: '_selfChanged'},

    __meta: {type: Boolean, computed: '__computeMeta(type, key, value)'}
  },

  hostAttributes: {hidden: true},

  __computeMeta: function(type, key, value) {
    var meta = new IronMeta({type: type, key: key});

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function(key) {
    return new IronMeta({type: this.type, key: key}).value;
  }
});

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

// This URL is common to both models
// used in the autodetection process
const webApiDocumentType = 'http://a.ml/vocabularies/document#Document';

// Version 1 of the model: old version
const ns1 = {};
// RAML namespace
ns1.raml = {};
ns1.raml.name = 'http://a.ml/';
ns1.raml.vocabularies = {};
ns1.raml.vocabularies.name = ns1.raml.name + 'vocabularies/';
ns1.raml.vocabularies.document = ns1.raml.vocabularies.name + 'document#';
ns1.raml.vocabularies.http = ns1.raml.vocabularies.name + 'http#';
ns1.raml.vocabularies.security = ns1.raml.vocabularies.name + 'security#';
ns1.raml.vocabularies.shapes = ns1.raml.vocabularies.name + 'shapes#';
ns1.raml.vocabularies.data = ns1.raml.vocabularies.name + 'data#';
ns1.raml.vocabularies.docSourceMaps = ns1.raml.vocabularies.name + 'document-source-maps#';
// mapping to aml namespace
ns1.aml = ns1.raml;
// W3 namespace
ns1.w3 = {};
ns1.w3.name = 'http://www.w3.org/';
ns1.w3.hydra = {};
ns1.w3.hydra.name = ns1.w3.name + 'ns/hydra/';
ns1.w3.hydra.core = ns1.w3.hydra.name + 'core#';
ns1.w3.xmlSchema = ns1.w3.name + '2001/XMLSchema#';
// w3 types
ns1.w3.shacl = {};
ns1.w3.shacl.name = ns1.w3.name + 'ns/shacl#';
ns1.w3.shacl.in = ns1.w3.shacl.name + 'in';
ns1.w3.shacl.defaultValueStr = ns1.w3.shacl.name + 'defaultValueStr';
ns1.w3.shacl.pattern = ns1.w3.shacl.name + 'pattern';
ns1.w3.shacl.minInclusive = ns1.w3.shacl.name + 'minInclusive';
ns1.w3.shacl.maxInclusive = ns1.w3.shacl.name + 'maxInclusive';
ns1.w3.shacl.multipleOf = ns1.w3.shacl.name + 'multipleOf';
ns1.w3.shacl.minLength = ns1.w3.shacl.name + 'minLength';
ns1.w3.shacl.maxLength = ns1.w3.shacl.name + 'maxLength';
ns1.w3.shacl.fileType = ns1.w3.shacl.name + 'fileType';
ns1.w3.shacl.shape = ns1.w3.shacl.name + 'Shape';
// Hydra shortcuts
ns1.w3.hydra.supportedOperation = ns1.w3.hydra.core + 'supportedOperation';
// Schema org namespace
ns1.schema = {};
ns1.schema.name = 'http://schema.org/';
ns1.schema.schemaName = ns1.schema.name + 'name';
ns1.schema.desc = ns1.schema.name + 'description';
ns1.schema.doc = ns1.schema.name + 'documentation';
ns1.schema.webApi = ns1.schema.name + 'WebAPI';
ns1.schema.creativeWork = ns1.schema.name + 'CreativeWork';
ns1.schema.displayName = ns1.schema.name + 'displayName';
ns1.schema.title = ns1.schema.name + 'title';

Object.freeze(ns1.raml);
Object.freeze(ns1.raml.vocabularies);
Object.freeze(ns1.aml.vocabularies);
Object.freeze(ns1.aml);
Object.freeze(ns1.w3);
Object.freeze(ns1.w3.hydra);
Object.freeze(ns1.w3.shacl);
Object.freeze(ns1.schema);
Object.freeze(ns1);

// version 2 of the model: new model
const ns2 = {};
// RAML namespace
ns2.raml = {};
ns2.raml.name = 'http://a.ml/';
ns2.raml.vocabularies = {};
ns2.raml.vocabularies.name = ns2.raml.name + 'vocabularies/';
ns2.raml.vocabularies.document = ns2.raml.vocabularies.name + 'document#';
ns2.raml.vocabularies.core = ns2.raml.vocabularies.name + 'core#';
ns2.raml.vocabularies.apiContract = ns2.raml.vocabularies.name + 'apiContract#';
ns2.raml.vocabularies.http = ns2.raml.vocabularies.apiContract;
ns2.raml.vocabularies.security = ns2.raml.vocabularies.name + 'security#';
ns2.raml.vocabularies.shapes = ns2.raml.vocabularies.name + 'shapes#';
ns2.raml.vocabularies.data = ns2.raml.vocabularies.name + 'data#';
ns2.raml.vocabularies.docSourceMaps = ns2.raml.vocabularies.name + 'document-source-maps#';
// mapping to aml namespace
ns2.aml = ns2.raml;
// W3 namespace
ns2.w3 = {};
ns2.w3.name = 'http://www.w3.org/';
ns2.w3.hydra = {};
ns2.w3.hydra.name = ns2.w3.name + 'ns/hydra/';
ns2.w3.hydra.core = ns2.raml.vocabularies.apiContract;
ns2.w3.xmlSchema = ns2.w3.name + '2001/XMLSchema#';
// w3 types
ns2.w3.shacl = {};
ns2.w3.shacl.name = ns2.w3.name + 'ns/shacl#';
ns2.w3.shacl.in = ns2.w3.shacl.name + 'in';
ns2.w3.shacl.defaultValueStr = ns2.w3.shacl.name + 'defaultValueStr';
ns2.w3.shacl.pattern = ns2.w3.shacl.name + 'pattern';
ns2.w3.shacl.minInclusive = ns2.w3.shacl.name + 'minInclusive';
ns2.w3.shacl.maxInclusive = ns2.w3.shacl.name + 'maxInclusive';
ns2.w3.shacl.multipleOf = ns2.w3.shacl.name + 'multipleOf';
ns2.w3.shacl.minLength = ns2.w3.shacl.name + 'minLength';
ns2.w3.shacl.maxLength = ns2.w3.shacl.name + 'maxLength';
ns2.w3.shacl.fileType = ns2.w3.shacl.name + 'fileType';
ns2.w3.shacl.shape = ns2.w3.shacl.name + 'Shape';
// ApiContracts
ns2.apiContract = {};
ns2.apiContract.supportedOperation = ns2.raml.vocabularies.apiContract + 'supportedOperation';
// Hydra shortcuts
ns2.w3.hydra.supportedOperation = ns2.raml.vocabularies.apiContract + 'supportedOperation';
// Schema org namespace
ns2.schema = {};
ns2.schema.name = ns2.raml.vocabularies.core;
ns2.schema.schemaName = ns2.schema.name + 'name';
ns2.schema.desc = ns2.schema.name + 'description';
ns2.schema.doc = ns2.schema.name + 'documentation';
ns2.schema.webApi = ns2.raml.vocabularies.apiContract + 'WebAPI';
ns2.schema.creativeWork = ns2.raml.vocabularies.core + 'CreativeWork';
ns2.schema.displayName = ns2.raml.vocabularies.core + 'displayName';
ns2.schema.title = ns2.raml.vocabularies.core + 'title';

Object.freeze(ns2.raml);
Object.freeze(ns2.raml.vocabularies);
Object.freeze(ns2.aml.vocabularies);
Object.freeze(ns2.aml);
Object.freeze(ns2.w3);
Object.freeze(ns2.w3.hydra);
Object.freeze(ns2.w3.shacl);
Object.freeze(ns2.schema);
Object.freeze(ns2);
/**
 * Common functions used by AMF components to compute AMF values.
 *
 * ## Updating API's base URI
 *
 * (Only applies when using `_computeEndpointUri()` function)
 *
 * By default the component render the documentation as it is defined
 * in the AMF model. Sometimes, however, you may need to replace the base URI
 * of the API with something else. It is useful when the API does not
 * have base URI property defined (therefore this component render relative
 * paths instead of URIs) or when you want to manage different environments.
 *
 * To update base URI value either update `baseUri` property or use
 * `iron-meta` with key `ApiBaseUri`. First method is easier but the second
 * gives much more flexibility since it use a
 * [monostate pattern](http://wiki.c2.com/?MonostatePattern)
 * to manage base URI property.
 *
 * When the component constructs the final URI for the endpoint it does the following:
 * - if `baseUri` is set it uses this value as a base uri for the endpoint
 * - else if `iron-meta` with key `ApiBaseUri` exists and contains a value
 * it uses it uses this value as a base uri for the endpoint
 * - else if `amf` is set then it computes base uri value from main
 * model document
 * Then it concatenates computed base URI with `endpoint`'s path property.
 *
 * @polymer
 * @mixinFunction
 * @memberof ApiElements
 */
const AmfHelperMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class AHmixin extends base {
    static get properties() {
      return {
        /**
         * Generated AMF json/ld model form the API spec.
         * The element assumes the object of the first array item to be a
         * type of `"http://raml.org/vocabularies/document#Document`
         * on AMF vocabulary.
         *
         * It is only usefult for the element to resolve references.
         *
         * @type {Object|Array}
         */
        amf: { type: Object }
      };
    }

    get amfModel() {
      return this.amf;
    }

    set amfModel(value) {
      // console.warn(this.nodeName + `: "amfModel" property is deprecated. Use "amf" instead.`);
      this.amf = value;
    }

    /**
     * A namespace for AMF model.
     * @return {Object}
     */
    get ns() {
      return this.__modelVersion === 2 ? ns2 : ns1;
    }

    get amf() {
      return this._amf;
    }

    set amf(value) {
      const old = this._amf;
      if (old === value) {
        return;
      }
      this._amf = value;
      this.__modelVersion = this.__detectModelVersion(value);
      this.__amfChanged(value);
      if (this.requestUpdate) {
        this.requestUpdate('amf', old);
      }
    }

    get _modelVersion() {
      return this.__modelVersion;
    }
    /**
     * This is an abstract method to be implemented by the components.
     * If, instead, the component uses `amf` setter you must use `super.amf` to
     * set the value.
     * @param {?Array} amf Current AMF model. Can be undefined.
     * @abstract
     */
    __amfChanged() {}
    /**
     * Checks for AMF model version.
     * @param {[type]} model [description]
     * @return {Number} Model major version when defined, `1` when version is
     * not defined, and `0` when the model is not valid or not set.
     */
    __detectModelVersion(model) {
      if (model instanceof Array) {
        model = model[0];
      }
      if (!model) {
        return 0;
      }
      const ctx = model['@context'];
      let versionString;
      if (ctx) {
        versionString = this._getValue(model, 'doc:version');
      } else {
        versionString = this._getValue(model, 'http://a.ml/vocabularies/document#version');
      }
      if (versionString) {
        const major = versionString.split('.')[0];
        return major === '2' ? 2 : 1;
      }
      return 1;
    }

    /**
     * Returns compact model key for given value.
     * @param {String} property AMF orioginal property
     * @return {String} Compact model property name or the same value if
     * value not found in the context.
     */
    _getAmfKey(property) {
      if (!property) {
        return;
      }
      let amf = this.amf;
      if (!amf) {
        return property;
      }
      if (amf instanceof Array) {
        amf = amf[0];
      }
      const ctx = amf['@context'];
      if (!ctx || !property) {
        return property;
      }
      property = String(property);
      const hashIndex = property.indexOf('#');
      const hashProperty = property.substr(0, hashIndex + 1);
      const keys = Object.keys(ctx);
      for (let i = 0, len = keys.length; i < len; i++) {
        const k = keys[i];
        if (ctx[k] === property) {
          return k;
        } else if (hashIndex === -1 && property.indexOf(ctx[k]) === 0) {
          const result = property.replace(ctx[k], k + ':');
          return result;
        } else if (ctx[k] === hashProperty) {
          const result = k + ':' + property.substr(hashIndex + 1);
          return result;
        }
      }
      return property;
    }
    /**
     * Ensures that the model is AMF object.
     *
     * @param {Object|Array} amf AMF json/ld model
     * @return {Object|undefined} API spec
     */
    _ensureAmfModel(amf) {
      if (!amf) {
        return;
      }
      if (amf instanceof Array) {
        amf = amf[0];
      }
      if (this._hasType(amf, webApiDocumentType)) {
        return amf;
      }
    }
    /**
     * Ensures that the value is an array.
     * It returns undefined when there's no value.
     * It returns the same array if the value is already an array.
     * It returns new array of the item is not an array.
     *
     * @param {Array|any} value An item to test
     * @return {Array|undefined}
     */
    _ensureArray(value) {
      if (!value) {
        return;
      }
      if (value instanceof Array) {
        return value;
      }
      return [value];
    }
    /**
     * Gets a signle scalar value from a model.
     * @param {Object} model Amf model to extract the value from.
     * @param {String} key Model key to search for the value
     * @return {any} Value for key
     */
    _getValue(model, key) {
      key = this._getAmfKey(key);
      let data = model && model[key];
      if (!data) {
        // This includes "undefined", "false", "null" and "0"
        return data;
      }
      if (data instanceof Array) {
        data = data[0];
      }
      if (!data) {
        return;
      }
      const type = typeof data;
      if (['string', 'number', 'boolean', 'undefined'].indexOf(type) !== -1) {
        return data;
      }
      return data['@value'];
    }
    /**
     * Gets values from a model as an array of `@value` properties.
     * @param {Object} model Amf model to extract the value from.
     * @param {String} key Model key to search for the value
     * @return {Array<any>} Value for key
     */
    _getValueArray(model, key) {
      key = this._getAmfKey(key);
      const data = model && this._ensureArray(model[key]);
      if (!data || !(data instanceof Array)) {
        return;
      }
      return data.map((item) => item['@value'] || item);
    }
    /**
     * Checks if a model has a type.
     * @param {Object} model Model to test
     * @param {String} type Type name
     * @return {Boolean} True if model has a type.
     */
    _hasType(model, type) {
      const types = this._ensureArray(model && model['@type']);
      if (!types || !types.length) {
        return false;
      }
      const key = this._getAmfKey(type);
      for (let i = 0; i < types.length; i++) {
        if (types[i] === key) {
          return true;
        }
      }
      return false;
    }
    /**
     * Checks if a shape has a property.
     * @param {?Object} shape The shape to test
     * @param {?String} key Property name to test
     * @return {Boolean}
     */
    _hasProperty(shape, key) {
      key = this._getAmfKey(key);
      return !!(shape && key && key in shape);
    }
    /**
     * Computes array value of a property in a model (shape).
     *
     * @param {Object} shape AMF shape object
     * @param {String} key Property name
     * @return {Array<any>|undefined}
     */
    _computePropertyArray(shape, key) {
      if (!shape) {
        return;
      }
      key = this._getAmfKey(key);
      const data = this._ensureArray(shape && shape[key]);
      if (!data || !(data instanceof Array)) {
        return;
      }
      return data;
    }
    /**
     * Computes a value of a property in a model (shape).
     * It takes first value of a property, if exists.
     *
     * @param {Object} shape AMF shape object
     * @param {String} key Property name
     * @return {any|undefined}
     */
    _computePropertyObject(shape, key) {
      key = this._getAmfKey(key);
      const data = this._computePropertyArray(shape, key);
      return data && data[0];
    }
    /**
     * Tests if a passed argumet exists.
     *
     * @param {String|Object|Number} value A value to test
     * @return {Boolean}
     */
    _computeHasStringValue(value) {
      return !!value || value === 0;
    }
    /**
     * Computes if passed argument is an array and has a value.
     * It does not check for type or value of the array items.
     * @param {Array} value Value to test
     * @return {Boolean}
     */
    _computeHasArrayValue(value) {
      return !!(value instanceof Array && value.length);
    }
    /**
     * Computes description for a shape.
     * @param {Object} shape AMF shape
     * @return {String} Description value.
     */
    _computeDescription(shape) {
      return this._getValue(shape, this.ns.schema.desc);
    }

    _computeHeaders(shape) {
      if (this._modelVersion !== 2) {
        return this._computePropertyArray(shape, this.ns.raml.vocabularies.http + 'header');
      } else {
        return this._computePropertyArray(shape, this.ns.raml.vocabularies.apiContract + 'header');
      }
    }

    _computeQueryParameters(shape) {
      if (this._modelVersion !== 2) {
        return this._computePropertyArray(shape, this.ns.raml.vocabularies.http + 'parameter');
      } else {
        return this._computePropertyArray(shape, this.ns.raml.vocabularies.apiContract + 'parameter');
      }
    }
    /**
     * In OAS URI parmaeters can be defined on an operation level under `uriParameter` proeprty.
     * Normally `_computeQueryParameters()` function would be used to extract parameters from an endpoint.
     * This is a fallback option to test when an API is OAS.
     * @param {Object} shape Method or Expects model
     * @return {Array<Object>}
     */
    _computeUriParameters(shape) {
      if (!shape) {
        return;
      }
      let operationKey;
      let parameterKey;
      if (this._modelVersion !== 2) {
        operationKey = this.ns.w3.hydra.core + 'Operation';
        parameterKey = this.ns.raml.vocabularies.http + 'uriParameter';
      } else {
        operationKey = this.ns.raml.vocabularies.apiContract + 'Operation';
        parameterKey = this.ns.raml.vocabularies.apiContract + 'uriParameter';
      }
      if (this._hasType(shape, operationKey)) {
        shape = this._computeExpects(shape);
      }
      return this._computePropertyArray(shape, parameterKey);
    }

    _computeResponses(shape) {
      if (this._modelVersion !== 2) {
        return this._computePropertyArray(shape, this.ns.w3.hydra.core + 'response');
      } else {
        return this._computePropertyArray(shape, this.ns.raml.vocabularies.apiContract + 'response');
      }
    }
    /**
     * Computes value for `serverVariables` property.
     *
     * @param {Object} server AMF API model for Server.
     * @return {Array<Object>|undefined} Variables if defined.
     */
    _computeServerVariables(server) {
      if (this._modelVersion !== 2) {
        return this._computePropertyArray(server, this.ns.raml.vocabularies.http + 'variable');
      } else {
        return this._computePropertyArray(server, this.ns.raml.vocabularies.apiContract + 'variable');
      }
    }
    /**
     * Computes value for `endpointVariables` property.
     *
     * @param {Object} endpoint Endpoint model
     * @param {?Object} method Optional method to be used to llokup the parameters from
     * This is used for OAS model which can defined path parameters on a method level.
     * @return {Array<Object>|undefined} Parameters if defined.
     */
    _computeEndpointVariables(endpoint, method) {
      let result = this._computeQueryParameters(endpoint);
      if (!result && method) {
        result = this._computeUriParameters(method);
      }
      return result;
    }
    /**
     * Computes value for the `payload` property
     *
     * @param {Object} expects Current value of `expects` property.
     * @return {Array<Object>|undefined} Payload model if defined.
     */
    _computePayload(expects) {
      if (this._modelVersion !== 2) {
        return this._computePropertyArray(expects, this.ns.raml.vocabularies.http + 'payload');
      } else {
        return this._computePropertyArray(expects, this.ns.raml.vocabularies.apiContract + 'payload');
      }
    }
    /**
     * Computes value for `returns` property
     *
     * @param {Object} method AMF `supportedOperation` model
     * @return {Array<Object>|undefined}
     */
    _computeReturns(method) {
      if (this._modelVersion !== 2) {
        return this._computePropertyArray(method, this.ns.w3.hydra.core + 'returns');
      } else {
        return this._computePropertyArray(method, this.ns.raml.vocabularies.apiContract + 'returns');
      }
    }
    /**
     * Computes value for `security` property
     *
     * @param {Object} method AMF `supportedOperation` model
     * @return {Array<Object>|undefined}
     */
    _computeSecurity(method) {
      return this._computePropertyArray(method, this.ns.raml.vocabularies.security + 'security');
    }
    /**
     * Computes value for `hasCustomProperties` property.
     *
     * @param {Object} shape AMF `supportedOperation` model
     * @return {Boolean}
     */
    _computeHasCustomProperties(shape) {
      return this._hasProperty(shape, this.ns.raml.vocabularies.document + 'customDomainProperties');
    }
    /**
     * Computes API version from the AMF model.
     *
     * @param {Object|Array<Object>} amf
     * @return {String|undefined}
     */
    _computeApiVersion(amf) {
      const api = this._computeWebApi(amf);
      if (!api) {
        return;
      }
      if (this._modelVersion !== 2) {
        return this._getValue(api, this.ns.schema.name + 'version');
      } else {
        return this._getValue(api, this.ns.raml.vocabularies.core + 'version');
      }
    }
    /**
     * Computes model's `encodes` property.
     *
     * @param {?Object} model AMF data model
     * @return {Array<Object>} List of encodes
     */
    _computeEncodes(model) {
      if (!model) {
        return;
      }
      if (model instanceof Array) {
        model = model[0];
      }
      const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'encodes');
      const data = model[key];
      if (data) {
        return data instanceof Array ? data[0] : data;
      }
    }
    /**
     * Computes list of declarations in the AMF api model.
     *
     * @param {Array|Object} model AMF json/ld model for an API
     * @return {Array<Object>} List of declarations
     */
    _computeDeclares(model) {
      if (!model) {
        return;
      }
      if (model instanceof Array) {
        model = model[0];
      }
      if (!model) {
        return;
      }
      const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'declares');
      const data = this._ensureArray(model[key]);
      return data instanceof Array ? data : undefined;
    }
    /**
     * Computes list of references in the AMF api model.
     *
     * @param {Array|Object} model AMF json/ld model for an API
     * @return {Array<Object>} List of declarations
     */
    _computeReferences(model) {
      if (!model) {
        return;
      }
      if (model instanceof Array) {
        model = model[0];
      }
      if (!model) {
        return;
      }
      const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'references');
      const data = this._ensureArray(model[key]);
      return data instanceof Array ? data : undefined;
    }
    /**
     * Computes AMF's `http://schema.org/WebAPI` model
     *
     * @param {Array|Object} model AMF json/ld model for an API
     * @return {Object} Web API declaration.
     */
    _computeWebApi(model) {
      const enc = this._computeEncodes(model);
      if (!enc) {
        return;
      }
      if (this._hasType(enc, this.ns.schema.webApi)) {
        return enc;
      }
    }
    /**
     * Computes value for `server` property that is later used with other computations.
     *
     * @param {Array|Object} model AMF model for an API
     * @return {Object} The server model
     */
    _computeServer(model) {
      const api = this._computeWebApi(model);
      if (!api) {
        return;
      }
      let key;
      if (this._modelVersion !== 2) {
        key = this._getAmfKey(this.ns.raml.vocabularies.http + 'server');
      } else {
        key = this._getAmfKey(this.ns.raml.vocabularies.apiContract + 'server');
      }
      const srv = this._ensureArray(api[key]);
      return srv ? srv[0] : undefined;
    }
    /**
     * Computes endpoint's URI based on `amf` and `endpoint` models.
     *
     * @param {Object} server Server model of AMF API.
     * @param {Object} endpoint Endpoint model
     * @param {?String} baseUri Current value of `baseUri` property
     * @param {?String} version API current version
     * @return {String} Endpoint's URI
     */
    _computeEndpointUri(server, endpoint, baseUri, version) {
      let base = this._getBaseUri(baseUri, server) || '';
      if (base && base[base.length - 1] === '/') {
        base = base.substr(0, base.length - 1);
      }
      base = this._ensureUrlScheme(base);
      let path;
      if (this._modelVersion !== 2) {
        path = this._getValue(endpoint, this.ns.raml.vocabularies.http + 'path');
      } else {
        path = this._getValue(endpoint, this.ns.raml.vocabularies.apiContract + 'path');
      }
      let result = base + (path || '');
      if (version && result) {
        result = result.replace('{version}', version);
      }
      return result;
    }
    /**
     * Computes base URI value from either `baseUri`, `iron-meta` with
     * `ApiBaseUri` key or `amf` value (in this order).
     *
     * @param {String} baseUri Value of `baseUri` property
     * @param {Object} server AMF API model for Server.
     * @param {?Array<String>} protocols List of supported protocols
     * @return {String} Base uri value. Can be empty string.
     */
    _getBaseUri(baseUri, server, protocols) {
      if (baseUri) {
        return baseUri;
      }
      if (IronMeta) {
        const value = new IronMeta({ key: 'ApiBaseUri' }).value;
        if (value) {
          return value;
        }
      }
      return this._getAmfBaseUri(server, protocols) || '';
    }
    /**
     * Computes base URI from AMF model.
     *
     * @param {Object} server AMF API model for Server.
     * @param {?Array<String>} protocols Listy of supporte dprotocols. If not
     * provided and required to compute the url it uses `amf` to compute
     * protocols
     * @return {String|undefined} Base uri value if exists.
     */
    _getAmfBaseUri(server, protocols) {
      let key;
      if (this._modelVersion !== 2) {
        key = this.ns.raml.vocabularies.http + 'url';
      } else {
        key = this.ns.raml.vocabularies.core + 'urlTemplate';
      }
      let value = this._getValue(server, key);
      value = this._ensureUrlScheme(value, protocols);
      return value;
    }
    /**
     * A function that makes sure that the URL has a scheme definition.
     * If no supported protocols information is available it assumes `http`.
     *
     * @param {String} value A url value
     * @param {?Array<String>} protocols List of supported by the API protocols
     * An array of string like: `['HTTP', 'HTTPS']`. It lowercase the value.
     * If not set it tries to read supported protocols value from `amf`
     * property.
     * @return {String} Url with scheme.
     */
    _ensureUrlScheme(value, protocols) {
      if (value && typeof value === 'string') {
        if (value.indexOf('http') !== 0) {
          if (!protocols || !protocols.length) {
            protocols = this._computeProtocols(this.amf);
          }
          if (protocols && protocols.length) {
            value = protocols[0].toLowerCase() + '://' + value;
          } else {
            value = 'http://' + value;
          }
        }
      }
      return value;
    }
    /**
     * Computes supported protocols by the API.
     *
     * @param {Object|Array} model AMF data model
     * @return {Array<String>|undefined}
     */
    _computeProtocols(model) {
      const api = this._computeWebApi(model);
      if (!api) {
        return;
      }
      if (this._modelVersion !== 2) {
        return this._getValueArray(api, this.ns.raml.vocabularies.http + 'scheme');
      } else {
        return this._getValueArray(api, this.ns.raml.vocabularies.apiContract + 'scheme');
      }
    }
    /**
     * Computes value for the `expects` property.
     *
     * @param {Object} method AMF `supportedOperation` model
     * @return {Object}
     */
    _computeExpects(method) {
      let operationKey;
      let expectsKey;
      if (this._modelVersion !== 2) {
        operationKey = this.ns.w3.hydra.core + 'Operation';
        expectsKey = this.ns.w3.hydra.core + 'expects';
      } else {
        operationKey = this.ns.raml.vocabularies.apiContract + 'Operation';
        expectsKey = this.ns.raml.vocabularies.apiContract + 'expects';
      }
      if (this._hasType(method, operationKey)) {
        const key = this._getAmfKey(expectsKey);
        const expects = this._ensureArray(method[key]);
        if (expects) {
          return expects instanceof Array ? expects[0] : expects;
        }
      }
    }
    /**
     * Tries to find an example value (whether it's default value or from an
     * example) to put it into snippet's values.
     *
     * @param {Object} item A http://raml.org/vocabularies/http#Parameter property
     * @return {String|undefined}
     */
    _computePropertyValue(item) {
      let exKey;
      if (this._modelVersion !== 2) {
        exKey = this.ns.raml.vocabularies.document + 'examples';
      } else {
        exKey = this.ns.raml.vocabularies.apiContract + 'examples';
      }

      let schemaKey;
      if (this._modelVersion !== 2) {
        schemaKey = this.ns.raml.vocabularies.http + 'schema';
      } else {
        schemaKey = this.ns.raml.vocabularies.shapes + 'schema';
      }

      let rawKey;
      if (this._modelVersion !== 2) {
        rawKey = this.ns.w3.shacl.name + 'raw';
      } else {
        rawKey = this.ns.raml.vocabularies.document + 'raw';
      }

      const skey = this._getAmfKey(schemaKey);
      let schema = item && item[skey];
      if (!schema) {
        return;
      }
      if (schema instanceof Array) {
        schema = schema[0];
      }
      let value = this._getValue(schema, this.ns.w3.shacl.name + 'defaultValue');
      if (!value) {
        const examplesKey = this._getAmfKey(exKey);
        let example = schema[examplesKey];
        if (example) {
          if (example instanceof Array) {
            example = example[0];
          }
          value = this._getValue(example, rawKey);
        }
      }
      return value;
    }
    /**
     * Computes list of endpoints from a WebApi model.
     * @param {Object} webApi
     * @return {Array} Always returns an array of endpoints.
     */
    _computeEndpoints(webApi) {
      if (!webApi) {
        return [];
      }
      let endpointKey;

      if (this._modelVersion !== 2) {
        endpointKey = this.ns.raml.vocabularies.http + 'endpoint';
      } else {
        endpointKey = this.ns.raml.vocabularies.apiContract + 'endpoint';
      }

      const key = this._getAmfKey(endpointKey);
      return this._ensureArray(webApi[key]);
    }
    /**
     * Computes model for an endpoint documentation.
     *
     * @param {Object} webApi Current value of `webApi` property
     * @param {String} id Selected shape ID
     * @return {Object} An endponit definition
     */
    _computeEndpointModel(webApi, id) {
      const endpoints = this._computeEndpoints(webApi);
      if (!endpoints) {
        return;
      }
      return endpoints.find((item) => item['@id'] === id);
    }
    /**
     * Computes model for an endpoint documentation using it's path.
     *
     * @param {Object} webApi Current value of `webApi` property
     * @param {String} path Endpoint path
     * @return {Object|undefined} An endponit definition
     */
    _computeEndpointByPath(webApi, path) {
      if (!path || !webApi) {
        return;
      }
      const endpoints = this._computeEndpoints(webApi);
      if (!endpoints) {
        return;
      }

      let pathKey;
      if (this._modelVersion !== 2) {
        pathKey = this.ns.raml.vocabularies.http + 'path';
      } else {
        pathKey = this.ns.raml.vocabularies.apiContract + 'path';
      }

      for (let i = 0; i < endpoints.length; i++) {
        const ePath = this._getValue(endpoints[i], pathKey);
        if (ePath === path) {
          return endpoints[i];
        }
      }
    }
    /**
     * Computes method for the method documentation.
     *
     * @param {Object} webApi Current value of `webApi` property
     * @param {String} selected Selected shape
     * @return {Object} A method definition
     */
    _computeMethodModel(webApi, selected) {
      const methods = this.__computeMethodsListForMethod(webApi, selected);
      if (!methods) {
        return;
      }
      return methods.find((item) => item['@id'] === selected);
    }
    /**
     * Computes list of operations in an endpoint
     * @param {Object} webApi The WebApi AMF model
     * @param {String} id Endpoint ID
     * @return {Array<Object>} List of SupportedOperation objects
     */
    _computeOperations(webApi, id) {
      const endpoint = this._computeEndpointModel(webApi, id);
      if (!endpoint) {
        return [];
      }

      let supportedOperationKey;
      if (this._modelVersion !== 2) {
        supportedOperationKey = this.ns.w3.hydra.supportedOperation;
      } else {
        supportedOperationKey = this.ns.apiContract.supportedOperation;
      }

      const opKey = this._getAmfKey(supportedOperationKey);
      return this._ensureArray(endpoint[opKey]);
    }
    /**
     * Computes an endpoint for a method.
     * @param {Object} webApi The WebApi AMF model
     * @param {String} methodId Method id
     * @return {Object|undefined} An endpoint model of undefined.
     */
    _computeMethodEndpoint(webApi, methodId) {
      if (!webApi || !methodId) {
        return;
      }
      const endpoints = this._computeEndpoints(webApi);
      if (!endpoints) {
        return;
      }

      let supportedOperationKey;
      if (this._modelVersion !== 2) {
        supportedOperationKey = this.ns.w3.hydra.supportedOperation;
      } else {
        supportedOperationKey = this.ns.apiContract.supportedOperation;
      }

      const opKey = this._getAmfKey(supportedOperationKey);
      for (let i = 0, len = endpoints.length; i < len; i++) {
        const endpoint = endpoints[i];
        let methods = endpoint[opKey];
        if (!methods) {
          continue;
        }
        if (!(methods instanceof Array)) {
          methods = [methods];
        }
        for (let j = 0, jLen = methods.length; j < jLen; j++) {
          if (methods[j]['@id'] === methodId) {
            return endpoint;
          }
        }
      }
    }
    /**
     * Computes a list of methods for an endpoint that contains a method with
     * given id.
     *
     * @param {Object} webApi WebApi model
     * @param {String} methodId Method id.
     * @return {Array<Object>|undefined} A list of sibling methods or undefined.
     */
    __computeMethodsListForMethod(webApi, methodId) {
      const endpoint = this._computeMethodEndpoint(webApi, methodId);
      if (!endpoint) {
        return;
      }

      let supportedOperationKey;
      if (this._modelVersion !== 2) {
        supportedOperationKey = this.ns.w3.hydra.supportedOperation;
      } else {
        supportedOperationKey = this.ns.apiContract.supportedOperation;
      }

      const opKey = this._getAmfKey(supportedOperationKey);
      return this._ensureArray(endpoint[opKey]);
    }
    /**
     * Computes a type documentation model.
     *
     * @param {Array} declares Current value of `declares` property
     * @param {?Array} references Current value of `references` property
     * @param {String} selected Selected shape
     * @return {Object} A type definition
     */
    _computeType(declares, references, selected) {
      if (!declares || !selected) {
        return;
      }
      // In compact model some IDs are presented in long version (in source maps for examples)
      // This must test for this case as well.
      const compactId = selected.replace('amf://id', '');
      let type = declares.find((item) => item['@id'] === selected || item['@id'] === compactId);
      if (!type && references && references.length) {
        for (let i = 0, len = references.length; i < len; i++) {
          if (!this._hasType(references[i], this.ns.raml.vocabularies.document + 'Module')) {
            continue;
          }
          type = this._computeReferenceType(references[i], selected);
          if (type) {
            break;
          }
        }
      }
      return type;
    }
    /**
     * Computes a type model from a reference (library for example).
     * @param {Object|Array} reference AMF model for a reference to extract the data from
     * @param {String} selected Node ID to look for
     * @return {Object|undefined} Type definition or undefined if not found.
     */
    _computeReferenceType(reference, selected) {
      const declare = this._computeDeclares(reference);
      if (!declare) {
        return;
      }
      // In compact model some IDs are presented in long version (in source maps for examples)
      // This must test for this case as well.
      const compactId = selected.replace('amf://id#', '');
      let result = declare.find((item) => {
        if (item instanceof Array) {
          item = item[0];
        }
        return item['@id'] === selected || item['@id'] === compactId;
      });
      if (result instanceof Array) {
        result = result[0];
      }
      return this._resolve(result);
    }
    /**
     * Computes model for selected security definition.
     *
     * @param {Array} declares Current value of `declares` property
     * @param {String} selected Selected shape
     * @return {Object} A security definition
     */
    _computeSecurityModel(declares, selected) {
      if (!declares || !selected) {
        return;
      }
      return declares.find((item) => item['@id'] === selected);
    }
    /**
     * Computes a documentation model.
     *
     * @param {Object} webApi Current value of `webApi` property
     * @param {String} selected Selected shape
     * @return {Object} A method definition
     */
    _computeDocument(webApi, selected) {
      if (!webApi || !selected) {
        return;
      }
      const key = this._getAmfKey(this.ns.schema.doc);
      const docs = this._ensureArray(webApi[key]);
      return docs && docs.find((item) => item['@id'] === selected);
    }
    /**
     * Resolves a reference to an external fragment.
     *
     * @param {Object} shape A shape to resolve
     * @return {Object} Resolved shape.
     */
    _resolve(shape) {
      const amf = this.amf;
      if (typeof shape !== 'object' || shape instanceof Array || !amf || shape.__apicResolved) {
        return shape;
      }
      let refKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'link-target');
      let refValue = this._ensureArray(shape[refKey]);
      let refData;
      if (refValue) {
        const refKey = refValue[0]['@id'];
        if (refKey === shape['@id']) {
          // recursive shape.
          shape.__apicResolved = true;
          return shape;
        }
        refData = this._getLinkTarget(amf, refKey);
      } else {
        refKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'reference-id');
        refValue = this._ensureArray(shape[refKey]);
        if (refValue) {
          const refKey = refValue[0]['@id'];
          if (refKey === shape['@id']) {
            // recursive shape.
            shape.__apicResolved = true;
            return shape;
          }
          refData = this._getReferenceId(amf, refKey);
        }
      }
      if (!refData) {
        this._resolveRecursive(shape);
        shape.__apicResolved = true;
        return shape;
      }
      const copy = Object.assign({}, refData);
      delete copy['@id'];
      const types = copy['@type'];
      if (types) {
        if (shape['@type']) {
          shape['@type'] = shape['@type'].concat(types);
        } else {
          shape['@type'] = types;
        }
        delete copy['@type'];
      }
      Object.assign(shape, copy);
      shape.__apicResolved = true;
      this._resolveRecursive(shape);
      return shape;
    }

    _getLinkTarget(amf, id) {
      if (!amf || !id) {
        return;
      }
      const declares = this._computeDeclares(amf);
      if (!declares) {
        return;
      }
      let target;
      for (let i = 0; i < declares.length; i++) {
        const _ref = declares[i];
        if (_ref && _ref['@id'] === id) {
          target = _ref;
          break;
        }
      }
      if (!target) {
        return;
      }
      // Declaration may contain references
      target = this._resolve(target);
      return target;
    }

    _getSchemaKey(element) {
      if (element._modelVersion === 1) {
        return element._getAmfKey(element.ns.raml.vocabularies.http + 'schema');
      } else {
        return element._getAmfKey(element.ns.raml.vocabularies.shapes + 'schema');
      }
    }

    _getReferenceId(amf, id) {
      if (!amf || !id) {
        return;
      }
      const refs = this._computeReferences(amf);
      if (!refs) {
        return;
      }
      for (let i = 0; i < refs.length; i++) {
        const _ref = refs[i];
        const enc = this._computeEncodes(_ref);
        if (enc) {
          if (enc['@id'] === id) {
            return enc;
          }
        }
      }
    }

    _resolveRecursive(shape) {
      Object.keys(shape).forEach((key) => {
        const currentShape = shape[key];
        if (currentShape instanceof Array) {
          for (let i = 0, len = currentShape.length; i < len; i++) {
            currentShape[i] = this._resolve(currentShape[i]);
          }
        } else if (typeof currentShape === 'object') {
          shape[key] = this._resolve(currentShape);
        }
      });
    }
    /**
     * Gets string value for an example data model.
     *
     * @param {Object} item Example item model
     * @param {Boolean} isJson If set it checks if the `raw` value is valid JSON.
     * If it isn't then it parses structured value.
     * @return {String}
     * @deprecated Use `amf-excample-generator` for examples generation.
     */
    _getExampleValue(item, isJson) {
      item = this._resolve(item);
      let data = this._getValue(item, this.ns.w3.shacl.name + 'raw');
      // This suppose to be a JSON data so lets test it.
      if (!data || (isJson && !(data[0] === '{' || data[0] === '['))) {
        const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'structuredValue');
        const structured = this._ensureArray(item[key]);
        if (structured) {
          data = this._computeExampleFromStructuredValue(structured[0]);
          data = JSON.stringify(data, null, 2);
        }
      }
      return data;
    }
    /**
     * Computes an example from example structured value.
     *
     * @param {Object} model `structuredValue` item model.
     * @return {Object|Array} Javascript object or array with structured value.
     * @deprecated Use `amf-excample-generator` for examples generation.
     */
    _computeExampleFromStructuredValue(model) {
      if (this._hasType(model, this.ns.raml.vocabularies.data + 'Scalar')) {
        return this._computeStructuredExampleValue(this._getValue(model, this.ns.raml.vocabularies.data + 'value'));
      }
      const isObject = this._hasType(model, this.ns.raml.vocabularies.data + 'Object');
      const result = isObject ? {} : [];
      const modelKeys = ['@id', '@type'];
      Object.keys(model).forEach((key) => {
        if (modelKeys.indexOf(key) !== -1) {
          return;
        }
        const value = this._computeStructuredExampleValue(model[key][0]);
        if (isObject) {
          const name = key.substr(key.indexOf('#') + 1);
          result[name] = value;
        } else {
          result.push(value);
        }
      });
      return result;
    }
    /**
     * Computes value with propert data type for a structured example.
     * @param {Object} model Structured example item model.
     * @return {String|Boolean|Number} Value for the example.
     * @deprecated Use `amf-excample-generator` for examples generation.
     */
    _computeStructuredExampleValue(model) {
      if (!model) {
        return;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (this._hasType(model, this.ns.raml.vocabularies.data + 'Scalar')) {
        const key = this._getAmfKey(this.ns.raml.vocabularies.data + 'value');
        const mValue = this._ensureArray(model[key])[0];
        const type = mValue['@type'];
        const value = mValue['@value'];
        switch (type) {
          case this.ns.w3.xmlSchema + 'boolean':
            return value === 'true' ? true : false;
          case this.ns.w3.xmlSchema + 'integer':
          case this.ns.w3.xmlSchema + 'long':
          case this.ns.w3.xmlSchema + 'double':
          case this.ns.w3.xmlSchema + 'float':
          case this.ns.raml.vocabularies.shapes + 'number':
            return Number(value);
          default:
            return value;
        }
      }
      return this._computeExampleFromStructuredValue(model);
    }
  }
  return AHmixin;
});

/**
@license
Copyright 2018 The Advanced REST client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
const ApiAware = {
  defaultScope: 'default',
  /**
   * List of registered awares
   * @type {Array}
   */
  awares: [],
  /**
   * Store for RAML definitions.
   * @type {Object<String, Object>} The key is a scope (`default` by default)
   * and the value is the API definition for this scope.
   */
  apis: {},
  /**
   * Attaches new RAML aware to the system. Added aware element will get
   * updates about new content.
   *
   * @param {RamlAware} aware The aware instance.
   */
  attachAware: function(aware) {
    if (this.awares.indexOf(aware) === -1) {
      this.awares.push(aware);
      if (!aware.scope) {
        aware.scope = this.defaultScope;
      } else {
        this.scopeChanged(aware);
      }
    }
  },
  /**
   * Removes avare from the map.
   * @param {RamlAware} aware Instance of the aware
   */
  detachAware: function(aware) {
    const index = this.awares.indexOf(aware);
    if (index !== -1) {
      this.awares.splice(index, 1);
      this.cleanUpData(aware.scope);
    } else {
      console.warn('The aware wasn\'t attached!');
    }
  },
  /**
   * Registers API data and aware.
   * @param {HTMLElement} srcAware The aware that notified about the change
   */
  setApi: function(srcAware) {
    const scope = srcAware.scope || this.defaultScope;
    const raml = srcAware.raml || undefined;
    this.apis[scope] = raml;
    const defaultScope = this.defaultScope;
    this.awares.forEach(function(aware) {
      if (aware === srcAware) {
        return;
      }
      const localScope = aware.scope || defaultScope;
      if (localScope !== scope) {
        return;
      }
      aware.raml = raml;
    });
  },

  scopeChanged: function(aware) {
    const scope = aware.scope || this.defaultScope;
    if (this.apis[scope]) {
      aware.raml = this.apis[scope];
    }
  },
  /**
   * Checks if
   * @param {String} scope
   */
  cleanUpData: function(scope) {
    const awares = this.awares;
    for (let i = 0, len = awares.length; i < len; i++) {
      if (awares[i].scope === scope) {
        return;
      }
    }
    delete this.apis[scope];
  }
};
/**
 *
 * Element that is aware of the AMF (RAML, OAS) content.
 *
 * The element contains the same RAML data as other elements whenever their
 * location in the document. The RAML data are encapsulated in `scope` attribute.
 * By default the `scope` is `default`. If you create two `<raml-aware>`s with
 * different scopes then changing one raml will not affect the other.
 *
 * Setting a RAML data on a `<raml-aware>` will notify other awares with the same
 * scopes about the change and update their RAML data so it can be transfered
 * between different parts of application on even different web components.
 *
 * ### Example
 *
 * ```html
 * <raml-aware raml="{{raml}}" scope="request"></raml-aware>
 * <raml-aware raml="{{importRaml}}" scope="import"></raml-aware>
 * ```
 *
 * ```javascript
 * const r1 = document.querySelector('raml-aware[scope="request"]');
 * const r2 = document.querySelector('raml-aware[scope="import"]');
 * r1.raml = {};
 * r2.raml = null;
 * assert(r1.raml !== r2.raml);
 * ```
 *
 * ## Limitations
 *
 * `RamlAware` has to be attached to DOM for it to work. This element uses
 * web components callback methods to initialize value. If the component is
 * never attached it will never initialize it's values.
 *
 * @customElement
 * @polymer
 * @memberof ApiElements
 * @demo demo/index.html
 */
class RamlAware extends HTMLElement {
  static get observedAttributes() {
    return [
      'scope'
    ];
  }
  /**
   * @return {Array|Object} Previously set API data
   * @deprecated Use `api` property instead
   */
  get raml() {
    return this.api;
  }
  /**
   * The RAML/AMF definition.
   * @param {Array|Object} value
   * @deprecated Use `api` property instead
   */
  set raml(value) {
    if (this._api === value) {
      return;
    }
    this.api = value;
    this.dispatchEvent(new CustomEvent('raml-changed', {
      composed: true,
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Array|Object} Previously set API data
   */
  get api() {
    return this._api;
  }
  /**
   * The RAML/AMF definition.
   * @param {Array|Object} value
   */
  set api(value) {
    if (this._api === value) {
      return;
    }
    this._api = value;
    ApiAware.setApi(this);
    this.dispatchEvent(new CustomEvent('api-changed', {
      composed: true,
      detail: {
        value
      }
    }));
  }
  /**
   * @return {String} Scope for the RAML file.
   */
  get scope() {
    return this._scope;
  }
  /**
   * Scope for the RAML file.
   * Different awares may have different scope and keep different RAML objects.
   * It can be useful when one aware supports request panel and another
   * RAML import for example. In this case first one may have scope not set
   * (`default` scope) and second one `import` scope. Then both RAMLs are
   * encapsulated to the scope.
   *
   * @type {String}
   * @param {String} value
   */
  set scope(value) {
    if (this._scope === value) {
      return;
    }
    this._scope = value;
    ApiAware.scopeChanged(this);
    if (value) {
      this.setAttribute('scope', value);
    } else {
      this.removeAttribute('scope');
    }
  }

  connectedCallback() {
    ApiAware.attachAware(this);
  }

  disconnectedCallback() {
    ApiAware.detachAware(this);
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // currently only "scope" is supported
    this.scope = newValue;
  }
}
window.customElements.define('raml-aware', RamlAware);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
var markdownStyles = css`[slot="markdown-html"] {
  -webkit-font-smoothing: var(--arc-font-font-smoothing);
  font-size: var(--arc-font-body1-font-size, 14px);
  font-weight: var(--arc-font-body1-font-weight, 400);
  line-height: var(--arc-font-body1-line-height, 20px);
}

[slot="markdown-html"] h1,
[slot="markdown-html"] h2,
[slot="markdown-html"] h3,
[slot="markdown-html"] h4,
[slot="markdown-html"] h5,
[slot="markdown-html"] h6 {
  font-size: var(--arc-font-title-font-size, 20px);
  font-weight: var(--arc-font-title-font-weight, 500);
  line-height: var(--arc-font-title-line-height, 28px);
}

[slot="markdown-html"] h1 tt,
[slot="markdown-html"] h1 code,
[slot="markdown-html"] h2 tt,
[slot="markdown-html"] h2 code,
[slot="markdown-html"] h3 tt,
[slot="markdown-html"] h3 code,
[slot="markdown-html"] h4 tt,
[slot="markdown-html"] h4 code,
[slot="markdown-html"] h5 tt,
[slot="markdown-html"] h5 code,
[slot="markdown-html"] h6 tt,
[slot="markdown-html"] h6 code {
  font-size: inherit
}

[slot="markdown-html"] h1 {
  font-size: var(--arc-font-display1-font-size, 34px);
  font-weight: var(--arc-font-display1-font-weight, 400);
  letter-spacing: var(--arc-font-display1-letter-spacing, -.01em);
  line-height: var(--arc-font-display1-line-height, 40px);
  border-bottom: 1px solid var(--markdown-styles-title-border-bottom-color, #eee);
  padding-top: 1rem;
  padding-bottom: 0.5rem;
}

[slot="markdown-html"] h2 {
  font-size: var(--arc-font-title-font-size, 20px);
  font-weight: var(--arc-font-title-font-weight, 500);
  line-height: var(--arc-font-title-line-height, 28px);
  border-bottom: 1px solid var(--markdown-styles-title-border-bottom-color, #eee);
}

[slot="markdown-html"] h3 {
  font-weight: var(--arc-font-subhead-font-weight, 400);
  font-size: 1.5em;
  line-height: 1.43
}

[slot="markdown-html"] h4 {
  font-weight: var(--arc-font-subhead-font-weight, 400);
  line-height: var(--arc-font-subhead-line-height, 24px);
  font-size: 1.25em
}

[slot="markdown-html"] h5 {
  font-weight: var(--arc-font-subhead-font-weight, 400);
  line-height: var(--arc-font-subhead-line-height, 24px);
  font-size: 1em
}

[slot="markdown-html"] h6 {
  font-weight: var(--arc-font-subhead-font-weight, 400);
  line-height: var(--arc-font-subhead-line-height, 24px);
  font-size: 1em;
  color: #777;
}

[slot="markdown-html"] p,
[slot="markdown-html"] blockquote,
[slot="markdown-html"] ul,
[slot="markdown-html"] ol,
[slot="markdown-html"] dl,
[slot="markdown-html"] table,
[slot="markdown-html"] pre {
  -webkit-font-smoothing: var(--arc-font-font-smoothing);
  font-size: var(--arc-font-body1-font-size, 14px);
  font-weight: var(--arc-font-body1-font-weight, 400);
  line-height: var(--arc-font-body1-line-height, 20px);
  margin-top: 0;
  margin-bottom: 16px;
}

[slot="markdown-html"] > *:last-child {
  margin-bottom: 0;
}

[slot="markdown-html"] hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: var(--markdown-styles-hr-color, #e7e7e7);
  border: 0 none;
}

[slot="markdown-html"] ul,
[slot="markdown-html"] ol {
  padding-left: 2em;
}

[slot="markdown-html"] ul.no-list,
[slot="markdown-html"] ol.no-list {
  padding: 0;
  list-style-type: none;
}

[slot="markdown-html"] ul ul,
[slot="markdown-html"] ul ol,
[slot="markdown-html"] ol ol,
[slot="markdown-html"] ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

[slot="markdown-html"] li>p {
  margin-top: 16px;
}

[slot="markdown-html"] dl {
  padding: 0;
}

[slot="markdown-html"] dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

[slot="markdown-html"] dl dd {
  padding: 0 16px;
  margin-bottom: 16px
}

[slot="markdown-html"] blockquote {
  padding: 0 15px;
  color: var(--markdown-styles-blockquote-color, #777);
  border-left: 4px solid var(--markdown-styles-blockquote-border-left-color, #ddd);
}

[slot="markdown-html"] blockquote>:first-child {
  margin-top: 0
}

[slot="markdown-html"] blockquote>:last-child {
  margin-bottom: 0
}

[slot="markdown-html"] table {
  -webkit-font-smoothing: var(--arc-font-font-smoothing);
  font-size: var(--arc-font-body1-font-size, 14px);
  font-weight: var(--arc-font-body1-font-weight, 400);
  line-height: var(--arc-font-body1-line-height, 20px);
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
  border-collapse: collapse;
}

[slot="markdown-html"] table th {
  font-weight: bold
}

[slot="markdown-html"] table th,
[slot="markdown-html"] table td {
  padding: 6px 13px;
  border: 1px solid var(--markdown-styles-table-header-border-color, #ddd);
}

[slot="markdown-html"] table tr {
  background-color: #fff;
  border-top: 1px solid #ccc
}

[slot="markdown-html"] table tr:nth-child(2n) {
  background-color: var(--markdown-styles-table-row-background-color, #f8f8f8);
}

[slot="markdown-html"] img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--markdown-styles-image-background-color, #fff);
}

[slot="markdown-html"] img[align=right] {
  padding-left: 20px
}

[slot="markdown-html"] img[align=left] {
  padding-right: 20px
}

[slot="markdown-html"] code,
[slot="markdown-html"] tt {
  font-family: var(--arc-font-code-family, 'Roboto Mono', 'Consolas', 'Menlo', monospace;);
  -webkit-font-smoothing: var(--arc-font-font-smoothing);
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  background-color: var(--markdown-styles-code-background-color, rgba(0, 0, 0, 0.04));
  border-radius: 2px
}

[slot="markdown-html"] pre {
  word-wrap: normal
}

/**
* prism.js default theme for JavaScript, CSS and HTML
* Based on dabblet (http://dabblet.com)
* @author Lea Verou
*/
[slot="markdown-html"] code,
[slot="markdown-html"] pre {
  font-family: var(--arc-font-code-family, 'Roboto Mono', 'Consolas', 'Menlo', monospace;);
  -webkit-font-smoothing: var(--arc-font-font-smoothing);
  color: var(--code-color, black);
  background-color: var(--code-background-color);
  text-shadow: var(--markdown-styles-code-text-shadow, 0 1px white);
  text-align: left;
  word-break: break-all;
  white-space: pre-wrap;
  word-spacing: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

[slot="markdown-html"] pre::-moz-selection,
[slot="markdown-html"] pre ::-moz-selection,
[slot="markdown-html"] code::-moz-selection,
[slot="markdown-html"] code ::-moz-selection {
  text-shadow: none;
  background: var(--markdown-styles-code-selection-background-color, #b3d4fc);
}

[slot="markdown-html"] pre::selection,
[slot="markdown-html"] pre ::selection,
[slot="markdown-html"] code::selection,
[slot="markdown-html"] code ::selection {
  text-shadow: none;
  background: var(--markdown-styles-code-selection-background-color, #b3d4fc);
}

@media print {
  [slot="markdown-html"] code,
  [slot="markdown-html"] pre {
    text-shadow: none;
  }
}

/* Code blocks */
[slot="markdown-html"] pre {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
}

[slot="markdown-html"] :not(pre) > code,
[slot="markdown-html"] pre,
pre[slot="markdown-html"] {
  background: var(--code-background-color, #f5f2f0);
}

/* Inline code */
[slot="markdown-html"] :not(pre) > code {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
}

[slot="markdown-html"] .token.comment,
[slot="markdown-html"] .token.prolog,
[slot="markdown-html"] .token.doctype,
[slot="markdown-html"] .token.cdata {
  color: var(--markdown-styles-code-cdata-color, slategray);
}

[slot="markdown-html"] .token.punctuation {
  color: var(--code-punctuation-value-color, #999);
}

[slot="markdown-html"] .namespace {
  opacity: .7;
}

[slot="markdown-html"] .token.property,
[slot="markdown-html"] .token.tag,
[slot="markdown-html"] .token.boolean,
[slot="markdown-html"] .token.number,
[slot="markdown-html"] .token.constant,
[slot="markdown-html"] .token.symbol,
[slot="markdown-html"] .token.deleted {
  color: var(--code-type-number-value-color, #905);
}

[slot="markdown-html"] .token.selector,
[slot="markdown-html"] .token.attr-name,
[slot="markdown-html"] .token.string,
[slot="markdown-html"] .token.char,
[slot="markdown-html"] .token.builtin,
[slot="markdown-html"] .token.inserted {
  color: var(--code-type-text-value-color, #690);
}

[slot="markdown-html"] .token.operator,
[slot="markdown-html"] .token.entity,
[slot="markdown-html"] .token.url,
[slot="markdown-html"] .language-css .token.string,
[slot="markdown-html"] .style .token.string {
  color: var(--code-punctuation-value-color, #a67f59);
  background: hsla(0, 0%, 100%, .5);
}

[slot="markdown-html"] .token.atrule,
[slot="markdown-html"] .token.attr-value,
[slot="markdown-html"] .token.keyword {
  color: var(--markdown-styles-code-keyword-color, #07a);
}

[slot="markdown-html"] .token.function {
  color: var(--markdown-styles-code-function-color, #DD4A68);
}

[slot="markdown-html"] .token.regex,
[slot="markdown-html"] .token.important,
[slot="markdown-html"] .token.variable {
  color: var(--markdown-styles-variable-color, #e90);
}

[slot="markdown-html"] .token.important,
[slot="markdown-html"] .token.bold {
  font-weight: bold;
}
[slot="markdown-html"] .token.italic {
  font-style: italic;
}

[slot="markdown-html"] .token.entity {
  cursor: help;
}`;

const hostDefaultStyles = css`
--method-label-default-background-color: rgba(128, 128, 128, 0.12);
--method-label-default-color: rgb(128, 128, 128);
`;

const labelCommon = css`
display: inline-block;
margin: var(--http-method-label-margin, 0px 8px 8px 0px);
padding: var(--http-method-label-padding, 2px 6px);
background-color: var(--http-method-label-background-color, var(--method-label-default-background-color));
color: var(--http-method-label-color, var(--method-label-default-color));
text-transform: uppercase;
border-radius: var(--http-method-label-border-radius, 3px);
font-weight: var(--http-method-label-font-weigth, 400);
font: inherit;
font-size: inherit;
`;

const labelGet = css`
background-color: var(--http-method-label-get-background-color, rgba(0, 128, 0, 0.12));
color: var(--http-method-label-get-color, rgb(0, 128, 0));
`;

const labelPost = css`
background-color: var(--http-method-label-post-background-color, rgba(33, 150, 243, 0.12));
color: var(--http-method-label-post-color, rgb(33, 150, 243));
`;

const labelPut = css`
background-color: var(--http-method-label-put-background-color, rgba(255, 165, 0, 0.12));
color: var(--http-method-label-put-color, rgb(255, 165, 0));
`;

const labelDelete = css`
background-color: var(--http-method-label-delete-background-color, rgba(244, 67, 54, 0.12));
color: var(--http-method-label-delete-color, rgb(244, 67, 54));
`;

const labelPatch = css`
background-color: var(--http-method-label-patch-background-color, rgba(156, 39, 176, 0.12));
color: var(--http-method-label-patch-color, rgb(156, 39, 176));
`;

const labelOptions = css`
background-color: var(--http-method-label-options-background-color, var(--method-label-default-background-color));
color: var(--http-method-label-options-color, var(--method-label-default-color));
`;

const labelHead = css`
background-color: var(--http-method-label-head-background-color, var(--method-label-default-background-color));
color: var(--http-method-label-head-color, var(--method-label-default-color));
`;

const labelTrace = css`
background-color: var(--http-method-label-trace-background-color, var(--method-label-default-background-color));
color: var(--http-method-label-trace-color, var(--method-label-default-color));
`;

const labelConnect = css`
background-color: var(--http-method-label-connect-background-color, var(--method-label-default-background-color));
color: var(--http-method-label-connect-color, var(--method-label-default-color));
`;

var labelStyles = css`
:host {
  ${hostDefaultStyles}
}

.method-label {
  ${labelCommon}
}

.method-label[data-method="get"],
.method-label[data-method="GET"] {
  ${labelGet}
}

.method-label[data-method="post"],
.method-label[data-method="POST"] {
  ${labelPost}
}

.method-label[data-method="put"],
.method-label[data-method="PUT"] {
  ${labelPut}
}

.method-label[data-method="delete"],
.method-label[data-method="DELETE"] {
  ${labelDelete}
}

.method-label[data-method="patch"],
.method-label[data-method="PATCH"] {
  ${labelPatch}
}

.method-label[data-method="options"],
.method-label[data-method="OPTIONS"] {
  ${labelOptions}
}

.method-label[data-method="head"],
.method-label[data-method="HEAD"] {
  ${labelHead}
}

.method-label[data-method="trace"],
.method-label[data-method="TRACE"] {
  ${labelTrace}
}

.method-label[data-method="connect"],
.method-label[data-method="CONNECT"] {
  ${labelConnect}
}
`;

/* eslint-disable max-len */
const iconWrapper = (tpl) => svg`<svg viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" focusable="false" style="pointer-events: none; display: block; width: 100%; height: 100%;">${tpl}</svg>`;
const chevronLeft = iconWrapper(svg`<path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>`);
const chevronRight = iconWrapper(svg`<path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>`);
const expandMore = iconWrapper(svg`<path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path>`);

/**
 * `api-annotation-document`
 *
 * An element to render annotations (also known as custom properties)
 * from AMF model.
 *
 * Anotations are part of RAML language and API console supports it.
 * The element looks for annotations in model and renders them.
 *
 * It hides itself from the view if there's no annotations.
 *
 * ## Styling
 *
 * `<api-annotation-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-annotation-document` | Mixin applied to this elment | `{}`
 * `--api-annotation-document-color` | Color of the custom property (annotation) documentation | `#616161`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiAnnotationDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
      color: var(--api-annotation-document-color, #616161);
    }

    :host([hidden]) {
      display: none;
    }

    .custom-prtoperty {
      margin: 12px 0;
    }

    .custom-prtoperty > span {
      display: block;
    }

    .name {
      font-weight: 500;
    }

    .scalar-value {
      display: block;
    }

    .custom-list {
      padding: 0;
      list-style: none;
    }`;
  }

  static get properties() {
    return {
      /**
       * A property shape definition of AMF.
       * The element looks for `http://raml.org/vocabularies/document#customDomainProperties`
       * key in the property and renders custom properties view if any
       * property is defined.
       */
      shape: { type: Object },
      /**
       * Computed value, true if any custom property has been found.
       */
      hasCustomProperties: { type: Boolean },
      /**
       * List of custom properties in the shape.
       *
       * @type {Array<Object>}
       */
      customList: { type: Array }
    };
  }

  get shape() {
    return this._shape;
  }

  set shape(value) {
    const oldValue = this._shape;
    if (oldValue === value) {
      return;
    }
    this._shape = value;
    this.requestUpdate('shape', oldValue);
    this._shapeChanged(value);
  }

  get hasCustomProperties() {
    return this.__hasCustomProperties;
  }

  get _hasCustomProperties() {
    return this.__hasCustomProperties;
  }

  set _hasCustomProperties(value) {
    const oldValue = this.__hasCustomProperties;
    if (oldValue === value) {
      return;
    }
    this.__hasCustomProperties = value;
    this._hasCustomChanged(value);
    this.dispatchEvent(new CustomEvent('has-custom-properties-changed', {
      composed: true,
      detail: {
        value
      }
    }));
  }

  get customList() {
    return this.__customList;
  }

  get _customList() {
    return this.__customList;
  }

  set _customList(value) {
    const oldValue = this.__customList;
    if (oldValue === value) {
      return;
    }
    this.__customList = value;
    this.requestUpdate('customList', oldValue);
  }

  constructor() {
    super();
    this._hasCustomProperties = false;
  }

  /**
   * Called when the shape property change.
   * Sets `hasCustomProperties` and `customList` properties.
   *
   * Note that for performance reasons, if the element determine that there's
   * no custom properties wit will not clear `customList`.
   * It will be updated only if tha vlue actually change.
   *
   * @param {Object} shape AMF shape or range property.
   */
  _shapeChanged(shape) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'customDomainProperties');
    const custom = this._ensureArray(shape && shape[key]);
    const has = !!(custom && custom.length);
    this._hasCustomProperties = has;
    if (!has) {
      return;
    }
    const keys = custom.map((item) => item['@id']);
    const properties = keys.map((key) => shape[key] || shape['amf://id' + key]);
    this._customList = properties;
  }
  /**
   * Hiddes/shows the element depending on the state
   *
   * @param {Boolean} has True if has ay property
   */
  _hasCustomChanged(has) {
    this.setAttribute('aria-hidden', !has);
    if (has) {
      if (this.hasAttribute('hidden')) {
        this.removeAttribute('hidden');
      }
    } else {
      if (!this.hasAttribute('hidden')) {
        this.setAttribute('hidden', true);
      }
    }
  }

  _computeName(item) {
    return this._getValue(item, this.ns.raml.vocabularies.document + 'name');
  }
  /**
   * Tests if custom propery can have value.
   *
   * @param {Object} item AMF custom property definition
   * @return {Boolean}
   */
  _hasValue(item) {
    if (!this._isScalar(item)) {
      return true;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.data + 'value');
    let value = item && item[key];
    if (!value) {
      return false;
    }
    if (value instanceof Array) {
      value = value[0];
    }
    return !this._hasType(value, this.ns.w3.xmlSchema + 'nil');
  }
  /**
   * Tests if value is a scalar value
   *
   * @param {Object} item AMF custom property definition
   * @return {Boolean}
   */
  _isScalar(item) {
    return this._hasType(item, this.ns.raml.vocabularies.data + 'Scalar');
  }
  /**
   * Computes scalar value for the item.
   *
   * @param {Object} item AMF custom property definition
   * @return {String}
   */
  _scalarValue(item) {
    if (item instanceof Array) {
      item = item[0];
    }
    return this._getValue(item, this.ns.raml.vocabularies.data + 'value');
  }
  /**
   * Computes complex (object) value for the custom property
   *
   * @param {Object} item AMF custom property definition
   * @return {Object}
   */
  _complexValue(item) {
    if (!item) {
      return;
    }
    const data = [];
    const dataKey = this._getAmfKey(this.ns.raml.vocabularies.data);
    const len = dataKey.length;
    Object.keys(item).forEach((key) => {
      if (key.indexOf(dataKey) === -1) {
        return;
      }
      let label = key.substr(len);
      if (label[0] === ':') {
        // compact model does that
        label = label.substr(1);
      }
      data.push({
        value: this._scalarValue(item[key]),
        label
      });
    });
    return data;
  }

  _renderItemValue(item) {
    return html`<span class="value">
      ${this._isScalar(item) ?
        html`<span class="scalar-value">${this._scalarValue(item)}</span>` :
        this._renderItemComplexValue(item)}
    </span>`;
  }

  _renderItemComplexValue(item) {
    const items = this._complexValue(item);
    if (!items || !items.length) {
      return;
    }
    return items.map((item) => html`<span class="scalar-value">${item.label}: ${item.value}</span>`);
  }

  _renderItem(item) {
    return html`
    <li class="custom-prtoperty">
      <span class="name">${this._computeName(item)}</span>
      ${this._hasValue(item) ? this._renderItemValue(item) : undefined}
    </li>`;
  }

  render() {
    const list = this.customList;
    if (!list || !list.length) {
      return;
    }
    return html`
    <ul class="custom-list">
      ${list.map((item) => this._renderItem(item))}
    </ul>`;
  }
}
window.customElements.define('api-annotation-document', ApiAnnotationDocument);

/**
@license
Copyright 2017 Mulesoft.

All rights reserved.
*/
/**
 * Use `HoverableMixin` to implement an element that can be hovered.
 * The control gets a `hovered` attribute when it's hovered by the pointing devide.
 *
 * Be aware that mobile devices will not support hovering as desktop devices and behavior
 * may vary depending on platform. You should use this as little as possible.
 *
 * @mixinFunction
 * @memberof AnypointBasics
 */
const HoverableMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class HoverableMixin extends base {
    /**
     * @return {Boolean} True when the element is currently hovered by a pointing device.
     */
    get hovered() {
      return this._hovered;
    }

    get _hovered() {
      return this.__hovered || false;
    }

    set _hovered(value) {
      const old = this.__hovered;
      if (value === old) {
        return;
      }
      this.__hovered = value;
      if (this.requestUpdate) {
        this.requestUpdate('hovered', old);
      }
      if (value) {
        this.setAttribute('hovered', '');
      } else {
        this.removeAttribute('hovered');
      }
      this.dispatchEvent(new CustomEvent('hovered-changed', {
        composed: true,
        detail: {
          value
        }
      }));
    }

    /**
     * @constructor
     */
    constructor() {
      super();
      this._hoverCallback = this._hoverCallback.bind(this);
      this._leaveCallback = this._leaveCallback.bind(this);
    }
    /**
     * Registers hover listeners
     */
    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }
      this.addEventListener('mouseover', this._hoverCallback);
      this.addEventListener('mouseleave', this._leaveCallback);
    }
    /**
     * Removes hover listeners
     */
    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      this.removeEventListener('mouseover', this._hoverCallback);
      this.removeEventListener('mouseleave', this._leaveCallback);
    }
    /**
     * Set's the `hovered` attribute to true when handled.
     */
    _hoverCallback() {
      this._hovered = true;
    }
    /**
     * Updates `hovered` if the control is not hovered anymore.
     */
    _leaveCallback() {
      this._hovered = false;
    }
  }
  return HoverableMixin;
});

/**
@license
Copyright 2017 Mulesoft.

All rights reserved.
*/
/**
 * Use `ButtonStateMixin` to implement an element that can be pressed and active when toggles.
 *
 * @mixinFunction
 * @memberof AnypointBasics
 */
const ButtonStateMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class ButtonStateMixin extends base {
    static get properties() {
      // This properties won't be set on native WC.
      // Use `observedAttributes` and `attributeChangedCallback` to set properties
      // on a web component
      return {
        /**
         * If true, the button toggles the active state with each click or press
         * of the spacebar.
         */
        toggles: { type: Boolean, reflect: true },
        /**
         * If true, the button is a toggle and is currently in the active state.
         */
        active: { type: Boolean },
        /**
         * The aria attribute to be set if the button is a toggle and in the
         * active state.
         */
        ariaActiveAttribute: { type: String }
      };
    }
    /**
     * @return {Boolean} True when the element is currently being pressed as
     * the user is holding down the button on the element.
     */
    get pressed() {
      return this._pressed;
    }

    get _pressed() {
      return this.__pressed || false;
    }

    set _pressed(value) {
      if (this._setChanged('_pressed', value)) {
        if (value) {
          this.setAttribute('pressed', '');
        } else {
          this.removeAttribute('pressed');
        }
        this.dispatchEvent(new CustomEvent('pressed-changed', {
          composed: true,
          detail: {
            value
          }
        }));
        this._pressedChanged(value);
      }
    }

    get active() {
      return this._active || false;
    }

    set active(value) {
      if (this._setChanged('active', value)) {
        if (value) {
          this.setAttribute('active', '');
        } else {
          this.removeAttribute('active');
        }
        this.dispatchEvent(new CustomEvent('active-changed', {
          composed: true,
          detail: {
            value
          }
        }));
        this._activeChanged();
      }
    }

    get pointerDown() {
      return this._pointerDown;
    }

    get _pointerDown() {
      return this.__pointerDown || false;
    }

    set _pointerDown(value) {
      this._setChanged('_pointerDown', value);
    }

    get receivedFocusFromKeyboard() {
      return this._receivedFocusFromKeyboard || false;
    }

    get _receivedFocusFromKeyboard() {
      return this.__receivedFocusFromKeyboard || false;
    }

    set _receivedFocusFromKeyboard(value) {
      this._setChanged('_receivedFocusFromKeyboard', value);
    }

    get ariaActiveAttribute() {
      return this._ariaActiveAttribute;
    }

    set ariaActiveAttribute(value) {
      const old = this._ariaActiveAttribute;
      if (this._setChanged('ariaActiveAttribute', value)) {
        if (old && this.hasAttribute(old)) {
          this.removeAttribute(old);
        }
        this._activeChanged();
      }
    }

    _setChanged(prop, value) {
      const key = `_${prop}`;
      const old = this[key];
      if (value === old) {
        return false;
      }
      this[key] = value;
      if (this.requestUpdate) {
        this.requestUpdate(prop, old);
      }
      return true;
    }

    /**
     * @constructor
     */
    constructor() {
      super();
      this.ariaActiveAttribute = 'aria-pressed';
      this._downHandler = this._downHandler.bind(this);
      this._upHandler = this._upHandler.bind(this);
      this._clickHandler = this._clickHandler.bind(this);
      this._keyDownHandler = this._keyDownHandler.bind(this);
      this._keyUpHandler = this._keyUpHandler.bind(this);
      this._blurHandler = this._blurHandler.bind(this);
      this._focusHandler = this._focusHandler.bind(this);
    }
    /**
     * Registers hover listeners
     */
    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }
      this.addEventListener('mousedown', this._downHandler);
      this.addEventListener('mouseup', this._upHandler);
      this.addEventListener('click', this._clickHandler);
      this.addEventListener('keydown', this._keyDownHandler);
      this.addEventListener('keyup', this._keyUpHandler);
      this.addEventListener('blur', this._blurHandler);
      this.addEventListener('focus', this._focusHandler);
      if (!this.hasAttribute('role')) {
        this.setAttribute('role', 'button');
      }
    }
    /**
     * Removes hover listeners
     */
    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      this.removeEventListener('mousedown', this._downHandler);
      this.removeEventListener('mouseup', this._upHandler);
      this.removeEventListener('click', this._clickHandler);
      this.removeEventListener('keydown', this._keyDownHandler);
      this.removeEventListener('keyup', this._keyUpHandler);
      this.removeEventListener('blur', this._blurHandler);
      this.removeEventListener('focus', this._focusHandler);
    }
    /**
     * Handler for pointer down event
     * @param {MouseEvent} e
     */
    _downHandler() {
      this._pointerDown = true;
      this._pressed = true;
      this._receivedFocusFromKeyboard = false;
    }
    /**
     * Handler for pointer up event
     * @param {MouseEvent} e
     */
    _upHandler() {
      this._pointerDown = false;
      this._pressed = false;
    }
    /**
     * Handler for pointer click event
     * @param {MouseEvent} e
     */
    _clickHandler() {
      if (this.toggles) {
        // a click is needed to toggle the active state
        this.active = !this.active;
      } else {
        this.active = false;
      }
    }
    /**
     * Handler for keyboard down event
     * @param {KeyboardEvent} e
     */
    _keyDownHandler(e) {
      if (e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
        this._asyncClick(e);
      } else if (e.code === 'Space' || e.keyCode === 32) {
        this._spaceKeyDownHandler(e);
      }
    }
    /**
     * Handler for keyboard up event
     * @param {KeyboardEvent} e
     */
    _keyUpHandler(e) {
      if (e.code === 'Space' || e.keyCode === 32) {
        this._spaceKeyUpHandler(e);
      }
    }

    _blurHandler() {
      this._detectKeyboardFocus(false);
      this._pressed = false;
    }

    _focusHandler() {
      this._detectKeyboardFocus(true);
    }

    _detectKeyboardFocus(focused) {
      this._receivedFocusFromKeyboard = !this.pointerDown && focused;
    }

    _isLightDescendant(node) {
      return node !== this && this.contains(node);
    }

    _spaceKeyDownHandler(e) {
      const target = e.target;
      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (!target || this._isLightDescendant(/** @type {Node} */ (target))) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
      this._pressed = true;
    }

    _spaceKeyUpHandler(e) {
      const target = e.target;
      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (!target || this._isLightDescendant(/** @type {Node} */ (target))) {
        return;
      }
      if (this.pressed) {
        this._asyncClick();
      }
      this._pressed = false;
    }

    _asyncClick() {
      setTimeout(() => this.click(), 1);
    }

    _pressedChanged() {
      this._changedButtonState();
    }

    _changedButtonState() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

    _activeChanged() {
      const { active, ariaActiveAttribute } = this;
      if (this.toggles) {
        this.setAttribute(ariaActiveAttribute, active ? 'true' : 'false');
      } else {
        this.removeAttribute(ariaActiveAttribute);
      }
      this._changedButtonState();
    }
    /**
     * This function is called when `ControlStateMixin` is also applied to the element.
     */
    _controlStateChanged() {
      if (this.disabled) {
        this._pressed = false;
      } else {
        this._changedButtonState();
      }
    }
  }
  return ButtonStateMixin;
});

/**
@license
Copyright 2017 Mulesoft.

All rights reserved.
*/
/**
 * Use `ButtonStateMixin` to implement an element that can be pressed and active when toggles.
 *
 * @mixinFunction
 * @memberof AnypointBasics
 */
const ControlStateMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class ControlStateMixin extends base {
    static get properties() {
      // This properties won't be set on native WC.
      // Use `observedAttributes` and `attributeChangedCallback` to set properties
      // on a web component
      return {
        /**
         * If true, the button is a toggle and is currently in the active state.
         */
        disabled: { type: Boolean },
        /**
         * If true, the element currently has focus.
         */
        focused: { type: Boolean }
      };
    }
    /**
     * @return {Boolean} True when the element is currently being pressed as
     * the user is holding down the button on the element.
     */
    get focused() {
      return this._focused;
    }

    set focused(value) {
      if (this._setChanged('focused', value)) {
        if (value) {
          this.setAttribute('focused', '');
        } else {
          this.removeAttribute('focused');
        }
        this.dispatchEvent(new CustomEvent('focused-changed', {
          composed: true,
          detail: {
            value
          }
        }));
        this._changedControlState();
      }
    }

    get disabled() {
      return this._disabled;
    }

    set disabled(value) {
      if (this._setChanged('disabled', value)) {
        if (value) {
          this.setAttribute('disabled', '');
        } else {
          this.removeAttribute('disabled');
        }
        this.dispatchEvent(new CustomEvent('disabled-changed', {
          composed: true,
          detail: {
            value
          }
        }));
        this._disabledChanged(value);
        this._changedControlState();
      }
    }

    _setChanged(prop, value) {
      const key = `_${prop}`;
      const old = this[key];
      if (value === old) {
        return false;
      }
      this[key] = value;
      if (this.requestUpdate) {
        this.requestUpdate(prop, old);
      }
      return true;
    }

    /**
     * @constructor
     */
    constructor() {
      super();
      this._focusBlurHandler = this._focusBlurHandler.bind(this);
    }
    /**
     * Registers hover listeners
     */
    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }
      this.addEventListener('focus', this._focusBlurHandler);
      this.addEventListener('blur', this._focusBlurHandler);
    }
    /**
     * Removes hover listeners
     */
    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      this.removeEventListener('focus', this._focusBlurHandler);
      this.removeEventListener('blur', this._focusBlurHandler);
    }

    _focusBlurHandler(e) {
      if (this.disabled) {
        if (this.focused) {
          this.focused = false;
          this.blur();
        }
        return;
      }
      this.focused = e.type === 'focus';
    }

    _disabledChanged(disabled) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        // Read the `tabindex` attribute instead of the `tabIndex` property.
        // The property returns `-1` if there is no `tabindex` attribute.
        // This distinction is important when restoring the value because
        // leaving `-1` hides shadow root children from the tab order.
        this._oldTabIndex = this.getAttribute('tabindex');
        this.focused = false;
        this.setAttribute('tabindex', '-1');
        this.blur();
      } else if (this._oldTabIndex !== undefined) {
        if (this._oldTabIndex === null) {
          this.removeAttribute('tabindex');
        } else {
          this.setAttribute('tabindex', this._oldTabIndex);
        }
      }
    }

    _changedControlState() {
      // _controlStateChanged is abstract, follow-on mixins may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }
  }
  return ControlStateMixin;
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from:
 * http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from:
 * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
 * Calculates the normalized key for a KeyboardEvent.
 * @param {KeyboardEvent} keyEvent
 * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
 * transformation to alpha-numeric chars. This is useful with key
 * combinations like shift + 2, which on FF for MacOS produces
 * keyEvent.key = @
 * To get 2 returned, set noSpecialChars = true
 * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) ||
      transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key &&
      (!keyCombo.hasModifiers ||
       (!!event.shiftKey === !!keyCombo.shiftKey &&
        !!event.ctrlKey === !!keyCombo.ctrlKey &&
        !!event.altKey === !!keyCombo.altKey &&
        !!event.metaKey === !!keyCombo.metaKey));
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {combo: keyComboString, key: keyComboString, event: 'keydown'};
  }
  return keyComboString.split('+')
      .reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];

        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
          parsedKeyCombo.hasModifiers = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }

        return parsedKeyCombo;
      }, {combo: keyComboString.split(':').shift()});
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function(keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

/**
 * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
 * keyboard commands that pertain to [WAI-ARIA best
 * practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding). The
 * element takes care of browser differences with respect to Keyboard events and
 * uses an expressive syntax to filter key presses.
 *
 * Use the `keyBindings` prototype property to express what combination of keys
 * will trigger the callback. A key binding has the format
 * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
 * `"KEY:EVENT": "callback"` are valid as well). Some examples:
 *
 *      keyBindings: {
 *        'space': '_onKeydown', // same as 'space:keydown'
 *        'shift+tab': '_onKeydown',
 *        'enter:keypress': '_onKeypress',
 *        'esc:keyup': '_onKeyup'
 *      }
 *
 * The callback will receive with an event containing the following information
 * in `event.detail`:
 *
 *      _onKeydown: function(event) {
 *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
 *        console.log(event.detail.key); // KEY only, e.g. "tab"
 *        console.log(event.detail.event); // EVENT, e.g. "keydown"
 *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
 *      }
 *
 * Use the `keyEventTarget` attribute to set up event handlers on a specific
 * node.
 *
 * See the [demo source
 * code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
 * for an example.
 *
 * @demo demo/index.html
 * @polymerBehavior
 */
const IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {type: Boolean, value: false},

    _boundKeyHandlers: {
      type: Array,
      value: function() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function() {
        return {};
      }
    }
  },

  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],


  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function() {
    this._prepKeyBindings();
  },

  attached: function() {
    this._listenKeyEventListeners();
  },

  detached: function() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function() {
    var keyBindings = this.behaviors.map(function(behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function(keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(
          eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function(kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return (b1 === b2) ? 0 : b1 ? -1 : 1;
      });
    }
  },

  _addKeyBinding: function(eventString, handlerName) {
    parseEventString(eventString).forEach(function(keyCombo) {
      this._keyBindings[keyCombo.event] =
          this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
    }, this);
  },

  _resetKeyEventListeners: function() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function(eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push(
          [this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event =
        new CustomEvent(keyCombo.event, {detail: detail, cancelable: true});
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};

/**
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

var Utility = {
  distance: function(x1, y1, x2, y2) {
    var xDelta = (x1 - x2);
    var yDelta = (y1 - y2);

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ?
      window.performance.now.bind(window.performance) :
      Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect() {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  dom(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius =
        Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(
        0,
        this.initialOpacity -
            this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(0, Math.min(outerOpacity, waveOpacity));
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 &&
        this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity &&
        this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ? this.isOpacityFullyDecayed :
                               this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(
        1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function() {
    var scale;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - (this.containerMetrics.width / 2);
    dy = this.yNow - (this.containerMetrics.height / 2);


    // 2d transform for safari because of border-radius and overflow:hidden
    // clipping bug. https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform =
        'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform =
        'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance =
          Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    } else {
      this.xStart = event ?
          event.detail.x - this.containerMetrics.boundingRect.left :
          this.containerMetrics.width / 2;
      this.yStart = event ?
          event.detail.y - this.containerMetrics.boundingRect.top :
          this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance =
          Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
        this.xStart, this.yStart);

    this.waveContainer.style.top =
        (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left =
        (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function() {
    dom(this.waveContainer.parentNode).removeChild(this.waveContainer);
  }
};

/**
Material design: [Surface
reaction](https://www.google.com/design/spec/animation/responsive-interaction.html#responsive-interaction-surface-reaction)

`paper-ripple` provides a visual effect that other paper elements can
use to simulate a rippling effect emanating from the point of contact.  The
effect can be visualized as a concentric circle with motion.

Example:

    <div style="position:relative">
      <paper-ripple></paper-ripple>
    </div>

Note, it's important that the parent container of the ripple be relative
position, otherwise the ripple will emanate outside of the desired container.

`paper-ripple` listens to "mousedown" and "mouseup" events so it would display
ripple effect when touches on it.  You can also defeat the default behavior and
manually route the down and up actions to the ripple element.  Note that it is
important if you call `downAction()` you will have to make sure to call
`upAction()` so that `paper-ripple` would end the animation loop.

Example:

    <paper-ripple id="ripple" style="pointer-events: none;"></paper-ripple>
    ...
    downAction: function(e) {
      this.$.ripple.downAction(e.detail);
    },
    upAction: function(e) {
      this.$.ripple.upAction();
    }

Styling ripple effect:

  Use CSS color property to style the ripple:

    paper-ripple {
      color: #4285f4;
    }

  Note that CSS color property is inherited so it is not required to set it on
  the `paper-ripple` element directly.

By default, the ripple is centered on the point of contact.  Apply the
`recenters` attribute to have the ripple grow toward the center of its
container.

    <paper-ripple recenters></paper-ripple>

You can also  center the ripple inside its container from the start.

    <paper-ripple center></paper-ripple>

Apply `circle` class to make the rippling effect within a circle.

    <paper-ripple class="circle"></paper-ripple>

@group Paper Elements
@element paper-ripple
@hero hero.svg
@demo demo/index.html
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
`,

  is: 'paper-ripple',
  behaviors: [IronA11yKeysBehavior],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {type: Number, value: 0.25},

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {type: Number, value: 0.8},

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {type: Boolean, value: false},

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {type: Boolean, value: false},

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating:
        {type: Boolean, readOnly: true, reflectToAttribute: true, value: false},

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {type: Boolean, value: false, observer: '_holdDownChanged'},

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {type: Boolean, value: false},

    _animating: {type: Boolean},

    _boundAnimate: {
      type: Function,
      value: function() {
        return this.animate.bind(this);
      }
    }
  },

  get target() {
    return this.keyEventTarget;
  },

  /**
   * @type {!Object}
   */
  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) {  // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = dom(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating() {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function() {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function(ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function() {
    var ripple = new Ripple(this);

    dom(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * Deprecated. Please use animateRipple() instead.
   *
   * This method name conflicts with Element#animate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate.
   *
   * @suppress {checkTypes}
   */
  animate: function() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  /**
   * An alias for animate() whose name does not conflict with the platform
   * Element.animate() method.
   */
  animateRipple: function() {
    return this.animate();
  },

  _onEnterKeydown: function() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});

/**
 * A base class for buttons.
 * @type {Class}
 * @appliesMixin ControlStateMixin
 * @appliesMixin ButtonStateMixin
 */
class AnypointButtonBase extends ControlStateMixin(ButtonStateMixin(LitElement)) {
  static get properties() {
    return {
      /**
       * The z-depth of this element, from 0-5. Setting to 0 will remove the
       * shadow, and each increasing number greater than 0 will be "deeper"
       * than the last.
       * This is for MD implementation.
       */
      elevation: { type: Number, reflect: true },
      /**
       * Button emphasis in the UI.
       *
       * Possible values:
       * - `low` - Text buttons are typically used for less important actions.
       * - `medium` - Outlined buttons are used for more emphasis than text buttons due to the stroke.
       * - `high` - Contained buttons have more emphasis, as they use use a color fill and shadow.
       *
       * Default is "low".
       */
      emphasis: { type: String, reflect: true },
      /**
       * When set ripple effect is not rendered.
       */
      noink: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get emphasis() {
    return this._emphasis;
  }

  set emphasis(value) {
    if (this._setChanged('emphasis', value)) {
      this._calculateElevation();
    }
  }

  get toggles() {
    return this._toggles;
  }

  set toggles(value) {
    if (this._setChanged('toggles', value)) {
      this._calculateElevation();
    }
  }

  get compatibility() {
    return this._compatibility;
  }

  set compatibility(value) {
    if (this._setChanged('compatibility', value)) {
      this._calculateElevation();
    }
  }

  get elevation() {
    return this._elevation;
  }

  set elevation(value) {
    if (!value) {
      value = 0;
    }
    this._setChanged('elevation', value);
  }

  constructor() {
    super();
    this.emphasis = 'low';
  }

  async _calculateElevation() {
    let e = 0;
    if (this.emphasis === 'high' && !this.compatibility) {
      if (this.toggles && this.active) {
        e = 2;
      } else if (this.pressed) {
        e = 3;
      } else {
        e = 1;
      }
    }
    await this.updateComplete;
    this.elevation = e;
  }

  _controlStateChanged() {
    super._controlStateChanged();
    this._calculateElevation();
  }

  _buttonStateChanged() {
    this._calculateElevation();
  }
}

/**
 * `anypoint-button`
 * Anypoint styled button.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof AnypointUi
 */
class AnypointButton extends AnypointButtonBase {
  static get styles() {
    return css`:host {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      position: relative;
      box-sizing: border-box;
      min-width: 5.14em;
      margin: 0 0.29em;
      outline-width: 0;
      user-select: none;
      cursor: pointer;
      z-index: 0;
      padding: 0.7em 0.57em;
      font-size: var(--anypoint-button-font-size, 15px);
      background-color: var(--anypoint-button-background-color, inherit);
      color: var(--anypoint-button-color, var(--anypoint-color-primary));
      border-width: 1px;
      border-color: var(--anypoint-button-border-color, transparent);
      border-style: solid;
      border-radius: var(--anypoint-button-border-radius, 3px);
      text-transform: var(--anypoint-button-text-transform, uppercase);
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.18s cubic-bezier(0.4, 0, 0.2, 1);
    }

    :host([hidden]) {
      display: none !important;
    }

    :host(:focus) {
      outline: none;
    }

    :host([disabled]) {
      cursor: auto;
      pointer-events: none;
    }

    :host([emphasis="low"]:not([compatibility])) {
      box-shadow: none !important;
    }

    :host([emphasis="low"][disabled]) {
      color: var(--anypoint-button-disabled-color, #a8a8a8);
    }

    :host(:not([pressed])[emphasis="low"]:hover) {
      background-color: var(--anypoint-button-emphasis-low-hover-background-color, rgba(0, 162, 223, .08));
    }

    :host(:not([pressed]):not([compatibility])[emphasis="low"][focused]) {
      background-color: var(--anypoint-button-emphasis-low-focus-background-color, rgba(0, 162, 223, .12));
      color: var(--anypoint-button-emphasis-low-focus-color, var(--anypoint-color-coreBlue4));
    }

    :host(:not([pressed])[emphasis="low"][active]) {
      background-color: var(--anypoint-button-emphasis-low-active-background-color, rgba(0, 162, 223, .16));
    }

    :host([emphasis="medium"]:not([compatibility])) {
      box-shadow: none !important;
    }

    :host([emphasis="medium"]) {
      border-color: var(--anypoint-button-emphasis-medium-focus-border-color, var(--anypoint-color-robustBlue1));
    }

    :host([emphasis="medium"][disabled]) {
      color: var(--anypoint-button-disabled-color, #a8a8a8);
      border-color: var(--anypoint-button-disabled-color, var(--anypoint-color-aluminum4));
    }

    :host(:not([pressed])[emphasis="medium"]:hover) {
      background-color: var(--anypoint-button-emphasis-medium-hover-background-color, rgba(0, 162, 223, .06));
    }

    :host(:not([pressed])[emphasis="medium"][focused]) {
      background-color: var(--anypoint-button-emphasis-medium-focus-background-color, rgba(0, 162, 223, .08));
      color: var(--anypoint-button-emphasis-low-focus-color, var(--anypoint-color-coreBlue4));
      border-color: var(--anypoint-button-emphasis-medium-focus-border-color, var(--anypoint-color-robustBlue2));
    }

    :host(:not([pressed])[emphasis="medium"][active]) {
      background-color: var(--anypoint-button-emphasis-low-active-background-color, rgba(94, 102, 249, 0.16));
    }

    :host([emphasis="high"]:not([compatibility])) {
      will-change: box-shadow;
      background-color: var(--anypoint-button-emphasis-high-background-color, var(--anypoint-color-primary));
      color: var(--anypoint-button-emphasis-high-color, var(--anypoint-color-tertiary));
    }

    :host([emphasis="high"][disabled]:not([compatibility])) {
      background: var(--anypoint-button-disabled-background-color, #eaeaea);
      color: var(--anypoint-button-disabled-color, #a8a8a8);
      box-shadow: none;
    }

    :host(:not([pressed]):not([compatibility])[emphasis="high"]:hover) {
      background-color: var(--anypoint-button-emphasis-high-hover-background-color, rgba(0, 162, 223, 0.87));
    }

    :host(:not([pressed]):not([compatibility])[emphasis="high"]:focus) {
      background-color: var(--anypoint-button-emphasis-high-focus-background-color, rgba(0, 162, 223, 0.87));
    }

    :host(:not([pressed]):not([compatibility])[emphasis="high"][active]) {
      background-color: var(--anypoint-button-emphasis-high-active-background-color, var(--anypoint-color-indigo3));
    }

    :host([elevation="1"]) {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    }

    :host([elevation="2"]) {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    }

    :host([elevation="3"]) {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    }

    :host([emphasis="high"][compatibility]) {
      background-color: var(--anypoint-button-background-color, var(--anypoint-color-primary));
      color: var(--anypoint-button-color, var(--anypoint-color-tertiary));
      border-radius: var(--anypoint-button-border-radius, 2px);
      text-transform: var(--anypoint-button-text-transform, initial);
      height: 40px;
    }

    :host([emphasis="high"][compatibility]:hover) {
      background-color: var(--anypoint-button-hover-background-color, var(--anypoint-color-coreBlue4));
    }

    :host([compatibility][focused]) {
      box-shadow: var(--anypoint-button-foxus-box-shadow-color, 0 0 0 3px #abe2f5);
    }

    :host([emphasis="high"][compatibility][pressed]) {
      background-color: var(--anypoint-button-hover-background-color, var(--anypoint-color-coreBlue5));
    }

    :host([emphasis="high"][compatibility][active]) {
      background-color: var(--anypoint-button-active-background-color, var(--anypoint-color-coreBlue5));
    }

    :host([compatibility]) paper-ripple {
      display: none;
    }

    :host([compatibility][disabled]) {
      background: var(--anypoint-button-disabled-background-color, #eaeaea);
      color: var(--anypoint-button-disabled-color, #a8a8a8);
    }

    :host ::slotted(*) {
      margin: 0 4px;
    }
    `;
  }

  render() {
    const { noink, compatibility } = this;
    const stopRipple = !!noink || !!compatibility;
    return html`<slot></slot><paper-ripple .noink="${stopRipple}"></paper-ripple>`;
  }

  get _ripple() {
    return this.shadowRoot.querySelector('paper-ripple');
  }

  connectedCallback() {
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'button');
    }
    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }
    if (super.connectedCallback) {
      super.connectedCallback();
    }
  }

  _spaceKeyDownHandler(e) {
    super._spaceKeyDownHandler(e);
    this._calculateElevation();
    if (!this._ripple.animating) {
      this._ripple.uiDownAction();
    }
  }

  _spaceKeyUpHandler(e) {
    super._spaceKeyUpHandler(e);
    this._calculateElevation();
    this._ripple.uiUpAction();
  }
}

window.customElements.define('anypoint-button', AnypointButton);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var prism = createCommonjsModule(function (module) {
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function (_self){

// Private helper vars
var lang = /\blang(?:uage)?-([\w-]+)\b/i;
var uniqueId = 0;

var _ = {
	manual: _self.Prism && _self.Prism.manual,
	disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (Array.isArray(tokens)) {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).slice(8, -1);
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function deepClone(o, visited) {
			var clone, id, type = _.util.type(o);
			visited = visited || {};

			switch (type) {
				case 'Object':
					id = _.util.objId(o);
					if (visited[id]) {
						return visited[id];
					}
					clone = {};
					visited[id] = clone;

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = deepClone(o[key], visited);
						}
					}

					return clone;

				case 'Array':
					id = _.util.objId(o);
					if (visited[id]) {
						return visited[id];
					}
					clone = [];
					visited[id] = clone;

					o.forEach(function (v, i) {
						clone[i] = deepClone(v, visited);
					});

					return clone;

				default:
					return o;
			}
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need an object and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];
			var ret = {};

			for (var token in grammar) {
				if (grammar.hasOwnProperty(token)) {

					if (token == before) {
						for (var newToken in insert) {
							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					// Do not insert token which also occur in insert. See #1525
					if (!insert.hasOwnProperty(token)) {
						ret[token] = grammar[token];
					}
				}
			}

			var old = root[inside];
			root[inside] = ret;

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === old && key != inside) {
					this[key] = ret;
				}
			});

			return ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function DFS(o, callback, type, visited) {
			visited = visited || {};

			var objId = _.util.objId;

			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					var property = o[i],
					    propertyType = _.util.type(property);

					if (propertyType === 'Object' && !visited[objId(property)]) {
						visited[objId(property)] = true;
						DFS(property, callback, null, visited);
					}
					else if (propertyType === 'Array' && !visited[objId(property)]) {
						visited[objId(property)] = true;
						DFS(property, callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		_.highlightAllUnder(document, async, callback);
	},

	highlightAllUnder: function(container, async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run('before-highlightall', env);

		var elements = container.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language = 'none', grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,'none'])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		if (element.parentNode) {
			// Set language on the parent, for styling
			parent = element.parentNode;

			if (/pre/i.test(parent.nodeName)) {
				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
			}
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		var insertHighlightedCode = function (highlightedCode) {
			env.highlightedCode = highlightedCode;

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
			callback && callback.call(env.element);
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code) {
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (!env.grammar) {
			insertHighlightedCode(_.util.encode(env.code));
			return;
		}

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				insertHighlightedCode(evt.data);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
		}
	},

	highlight: function (text, grammar, language) {
		var env = {
			code: text,
			grammar: grammar,
			language: language
		};
		_.hooks.run('before-tokenize', env);
		env.tokens = _.tokenize(env.code, env.grammar);
		_.hooks.run('after-tokenize', env);
		return Token.stringify(_.util.encode(env.tokens), env.language);
	},

	matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
		for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			if (token == target) {
				return;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Dont cache length as it changes during the loop
				for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					if (greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						var match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						// If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						if (strarr[i] instanceof Token) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						pattern.lastIndex = 0;

						var match = pattern.exec(str),
							delNum = 1;
					}

					if (!match) {
						if (oneshot) {
							break;
						}

						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1] ? match[1].length : 0;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						++i;
						pos += before.length;
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);

					if (delNum != 1)
						_.matchGrammar(text, strarr, grammar, i, pos, true, token);

					if (oneshot)
						break;
				}
			}
		}
	},

	tokenize: function(text, grammar) {
		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		_.matchGrammar(text, strarr, grammar, 0, 0, false);

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	},

	Token: Token
};

_self.Prism = _;

function Token(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
}

Token.stringify = function(o, language) {
	if (typeof o == 'string') {
		return o;
	}

	if (Array.isArray(o)) {
		return o.map(function(element) {
			return Token.stringify(element, language);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language
	};

	if (o.alias) {
		var aliases = Array.isArray(o.alias) ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _;
	}

	if (!_.disableWorkerMessageHandler) {
		// In worker
		_self.addEventListener('message', function (evt) {
			var message = JSON.parse(evt.data),
				lang = message.language,
				code = message.code,
				immediateClose = message.immediateClose;

			_self.postMessage(_.highlight(code, _.languages[lang], lang));
			if (immediateClose) {
				_self.close();
			}
		}, false);
	}

	return _;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (!_.manual && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _;

})(_self);

if ( module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof commonjsGlobal !== 'undefined') {
	commonjsGlobal.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\s\S]*?-->/,
	'prolog': /<\?[\s\S]+?\?>/,
	'doctype': /<!DOCTYPE[\s\S]+?>/i,
	'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
				inside: {
					'punctuation': [
						/^=/,
						{
							pattern: /^(\s*)["']|["']$/,
							lookbehind: true
						}
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(/__/g, tagName), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/,
			inside: {
				'rule': /@[\w-]+/
				// See rest below
			}
		},
		'url': {
			pattern: RegExp('url\\((?:' + string.source + '|[^\n\r()]*)\\)', 'i'),
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/
			}
		},
		'selector': RegExp('[^{}\\s](?:[^{};"\']|' + string.source + ')*?(?=\\s*\\{)'),
		'string': {
			pattern: string,
			greedy: true
		},
		'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
		'important': /!important\b/i,
		'function': /[-a-z0-9]+(?=\()/i,
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');

		Prism.languages.insertBefore('inside', 'attr-value', {
			'style-attr': {
				pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
				inside: {
					'attr-name': {
						pattern: /^\s*style/i,
						inside: markup.tag.inside
					},
					'punctuation': /^\s*=\s*['"]|['"]\s*$/,
					'attr-value': {
						pattern: /.+/i,
						inside: Prism.languages.css
					}
				},
				alias: 'language-css'
			}
		}, markup.tag);
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /[.\\]/
		}
	},
	'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(?:true|false)\b/,
	'function': /\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|})\s*)(?:catch|finally)\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'operator': /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
		lookbehind: true,
		greedy: true
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\${|}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	/**
	 * @param {Element} [container=document]
	 */
	self.Prism.fileHighlight = function(container) {
		container = container || document;

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		Array.prototype.slice.call(container.querySelectorAll('pre[data-src]')).forEach(function (pre) {
			// ignore if already loaded
			if (pre.hasAttribute('data-src-loaded')) {
				return;
			}

			// load current
			var src = pre.getAttribute('data-src');

			var language, parent = pre;
			var lang = /\blang(?:uage)?-([\w-]+)\b/i;
			while (parent && !lang.test(parent.className)) {
				parent = parent.parentNode;
			}

			if (parent) {
				language = (pre.className.match(lang) || [, ''])[1];
			}

			if (!language) {
				var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
				language = Extensions[extension] || extension;
			}

			var code = document.createElement('code');
			code.className = 'language-' + language;

			pre.textContent = '';

			code.textContent = 'Loading';

			pre.appendChild(code);

			var xhr = new XMLHttpRequest();

			xhr.open('GET', src, true);

			xhr.onreadystatechange = function () {
				if (xhr.readyState == 4) {

					if (xhr.status < 400 && xhr.responseText) {
						code.textContent = xhr.responseText;

						Prism.highlightElement(code);
						// mark as loaded
						pre.setAttribute('data-src-loaded', '');
					}
					else if (xhr.status >= 400) {
						code.textContent = ' Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
					}
					else {
						code.textContent = ' Error: File does not exist or is empty';
					}
				}
			};

			xhr.send(null);
		});

		if (Prism.plugins.toolbar) {
			Prism.plugins.toolbar.registerButton('download-file', function (env) {
				var pre = env.element.parentNode;
				if (!pre || !/pre/i.test(pre.nodeName) || !pre.hasAttribute('data-src') || !pre.hasAttribute('data-download-link')) {
					return;
				}
				var src = pre.getAttribute('data-src');
				var a = document.createElement('a');
				a.textContent = pre.getAttribute('data-download-link-label') || 'Download';
				a.setAttribute('download', '');
				a.href = src;
				return a;
			});
		}

	};

	document.addEventListener('DOMContentLoaded', function () {
		// execute inside handler, for dropping Event as argument
		self.Prism.fileHighlight();
	});

})();
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

var HIGHLIGHT_EVENT = 'syntax-highlight';

/**
Syntax highlighting via [Prism](http://prismjs.com/).

Place a `<prism-highlighter>` in your document, preferably as a direct child of
`<body>`. It will listen for `syntax-highlight` events on its parent element,
and annotate the code being provided via that event.

The `syntax-highlight` event's detail is expected to have a `code` property
containing the source to highlight. The event detail can optionally contain a
`lang` property, containing a string like `"html"`, `"js"`, etc.

This flow is supported by
[`<marked-element>`](https://github.com/PolymerElements/marked-element).

@element prism-highlighter
@demo demo/index.html
*/
Polymer({
  is: 'prism-highlighter',

  properties: {
    /**
     * Adds languages outside of the core Prism languages.
     *
     * Prism includes a few languages in the core library:
     *   - JavaScript
     *   - Markup
     *   - CSS
     *   - C-Like
     * Use this property to extend the core set with other Prism
     * components and custom languages.
     *
     * Example:
     *   ```
     *   <!-- with languages = {'custom': myCustomPrismLang}; -->
     *   <!-- or languages = Prism.languages; -->
     *   <prism-highlighter languages="[[languages]]"></prism-highlighter>
     *   ```
     *
     * @attribute languages
     * @type {!Object}
     */
    languages: {
      type: Object,
      value: function() {
        return {};
      }
    }
  },

  ready: function() {
    this._handler = this._highlight.bind(this);
  },

  attached: function() {
    (this.parentNode.host || this.parentElement)
        .addEventListener(HIGHLIGHT_EVENT, this._handler);
  },

  detached: function() {
    (this.parentNode.host || this.parentElement)
        .removeEventListener(HIGHLIGHT_EVENT, this._handler);
  },

  /**
   * Handle the highlighting event, if we can.
   *
   * @param {!CustomEvent} event
   */
  _highlight: function(event) {
    if (!event.detail || !event.detail.code) {
      Base._warn('Malformed', HIGHLIGHT_EVENT, 'event:', event.detail);
      return;
    }

    event.stopPropagation();

    var detail = event.detail;
    detail.code = Prism.highlight(
        detail.code, this._detectLang(detail.code, detail.lang));
  },

  /**
   * Picks a Prism formatter based on the `lang` hint and `code`.
   *
   * @param {string} code The source being highlighted.
   * @param {string=} lang A language hint (e.g. ````LANG`).
   * @return {!Prism.Lang}
   */
  _detectLang: function(code, lang) {
    if (!lang) {
      // Stupid simple detection if we have no lang, courtesy of:
      // https://github.com/robdodson/mark-down/blob/ac2eaa/mark-down.html#L93-101
      return code.match(/^\s*</) ? Prism.languages.markup :
                                   Prism.languages.javascript;
    }

    if (this.languages[lang]) {
      return this.languages[lang];
    } else if (Prism.languages[lang]) {
      return Prism.languages[lang];
    }
    switch (lang.substr(0, 2)) {
      case 'js':
      case 'es':
        return Prism.languages.javascript;
      case 'c':
        return Prism.languages.clike;
      default:
        // The assumption is that you're mostly documenting HTML when in HTML.
        return Prism.languages.markup;
    }
  },
});

/**
 * `api-example-generator`
 *
 * Examples generator from AMF model.
 *
 * ## Data model
 *
 * The result of calling `generatePayloadsExamples()`, `generatePayloadExamples()`,
 * or `computeExamples()` is an array of view models.
 *
 * ### ExampleModel
 *
 * - **hasRaw** `Boolean` - if true then `raw` property has a value
 * - **hasTitle** `Boolean` - if true then `title` property has a value
 * - **hasUnion** `Boolean` - if true then `values` property has a value
 * - **value** `String`, Optional - Example to render
 * - **title** - `String`, Optional - Example name, only when `hasTitle` is set
 * - **raw** `String`, Optional - Raw value of RAML example. This value is a
 * YAML or JSON schema value. This is only set when raw value is available in
 * the model and it is not JSON/XML.
 * - **values** `Array<ExampleModel>`, Optional - Only when `hasUnion` is set.
 *
 * ## Usage
 *
 * To generate examples for a list payloads
 *
 * ```javascript
 * const supportedOperation = {...}; // definition of AMF supported operation
 * const payloads = getPayloads(supportedOperation); // Extract array of payloads from e.g. Expects
 * const mediaTypes = generator.listMedia(payloads);
 * const examples = generator.generatePayloadsExamples(payloads, mediaTypes[0]);
 * console.log(examples);
 * ```
 *
 * To generate examples from a payload
 *
 * ```javascript
 * const examples = generator.generatePayloadExamples(payloads[0], 'application/json');
 * console.log(examples);
 * ```
 *
 * To generate examples from any object to any mime
 *
 * ```javascript
 * const shape = getTypeDeclaration(); // gets type definition
 * const examples = generator.computeExamples(shape, 'application/json');
 * console.log(examples);
 * ```
 *
 * ## Processing options
 *
 * - `rawOnly` - list "raw" examples only.
 * - `noAuto` - Don't generate an example from object properties if the example is
 * not defined in API file.
 * - `typeName` - Processed type name, used for XML types to use right XML element wrapper name.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiExampleGenerator extends AmfHelperMixin(LitElement) {
  /**
   * Lists media types names for payloads.
   * The `payloads` is an array of AMF Payload shape. It can be single Payload
   * shape as a convenient method for compact model.
   *
   * @param {Array<Object>|Object} payloads List of payloads AMF's Request shape.
   * @return {Array<String>|undefined} Returns a list of mime types or undefined
   * if not found.
   */
  listMedia(payloads) {
    if (!payloads) {
      return;
    }
    if (!(payloads instanceof Array)) {
      if (!this._hasType(payloads, this.ns.raml.vocabularies.http + 'Payload')) {
        return;
      }
      return [this._getValue(payloads, this.ns.raml.vocabularies.http + 'mediaType')];
    }
    const result = [];
    for (let i = 0; i < payloads.length; i++) {
      const payload = payloads[i];
      const mime = this._getValue(payload, this.ns.raml.vocabularies.http + 'mediaType');
      result[result.length] = mime;
    }
    return result;
  }
  /**
   * Generates a list of examples from an AMF Payloads array for a given media type.
   * The shape can be an Example in which case it will return the example value.
   * If the shape is other shape than Example shape then it looks for examples array and
   * use it to generate values. Otherwise it tries to generate an example from
   * object properties (if object).
   *
   * @param {Array<Object>|Object} payloads List of payloads to process.
   * @param {String} media A media to for which to generate the examles.
   * @param {Object} opts Generation options:
   * - noAuto `Boolean` - When set it only returns examples defined in API spec file.
   * When not set it generates examples from properties when the example is not
   * defined.
   * - type `String` - Type name of an union type. If not set it uses first type
   * - typeName `String` - When generating XML example name of the type to use as main node.
   * @return {String|undefined} Example value.
   */
  generatePayloadsExamples(payloads, media, opts) {
    if (!opts) {
      opts = {};
    }
    if (!payloads || !media && !opts.rawOnly) {
      return;
    }
    if (!(payloads instanceof Array)) {
      payloads = [payloads];
    }
    let result;
    for (let i = 0, len = payloads.length; i < len; i++) {
      const payload = payloads[i];
      const payloadMedia = this._getValue(payload, this.ns.raml.vocabularies.http + 'mediaType');
      if (media && payloadMedia !== media) {
        continue;
      }
      result = this.generatePayloadExamples(payload, media, opts);
      break;
    }
    return result;
  }
  /**
   * Generates a list of examples for a single AMF Payload shape.
   * @param {Object} payload AMF Payload shape.
   * @param {String} mime A mime type to use.
   * @param {Object} opts Generation options. See `generatePayloadsExamples()`.
   * @return {Array<Object>|undefined} List of examples.
   */
  generatePayloadExamples(payload, mime, opts) {
    if (!this._hasType(payload, this.ns.raml.vocabularies.http + 'Payload')) {
      return;
    }
    this._resolve(payload);
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = payload[sKey];
    if (!schema) {
      return;
    }
    if (schema instanceof Array) {
      schema = schema[0];
    }
    opts.typeId = payload['@id'];
    return this.computeExamples(schema, mime, opts);
  }
  /**
   * Computes examples from an AMF shape.
   * It returns examples defined in API spec file. If examples are not defined
   * and `opts.noAuto` flag is not set then it generates an example value from
   * object properties (if an object represents scalar, object, union, or an array).
   *
   * @param {Object} schema Any AMF schema.
   * @param {String} mime Examples media type. Currently `application/json` and
   * `application/xml` are supported.
   * @param {Object} opts Generation options. See `generatePayloadsExamples()`.
   * Besides that, `opts.typeId` is required to compute examples for a payload.
   * The `typeId` is a value of `@id` of the Payload shape.
   * @return {Array<Object>|undefined}
   */
  computeExamples(schema, mime, opts) {
    if (!opts) {
      opts = {};
    }
    if (!schema || !mime && !opts.rawOnly) {
      return;
    }
    this._resolve(schema);
    const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    const examples = this._ensureArray(schema[eKey]);
    if (examples) {
      return this._computeFromExamples(examples, mime, opts);
    }
    const jsonSchema = this._readJsonSchema(schema);
    if (jsonSchema) {
      return this._exampleFromJsonSchema(schema, jsonSchema);
    }

    if (opts.rawOnly) {
      return;
    }
    if (this._hasType(schema, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      const value = this._computeExampleArraySchape(schema, mime, opts);
      if (value) {
        return value;
      }
    }
    if (this._hasType(schema, this.ns.raml.vocabularies.document + 'Example')) {
      const value = this._generateFromExample(schema, mime, opts);
      if (value) {
        return [value];
      }
    }

    if (this._hasType(schema, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      return this._computeUnionExamples(schema, mime, opts);
    }

    if (opts.noAuto) {
      return;
    }

    if (this._hasType(schema, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      const result = this._computeJsonScalarValue(schema);
      return [{
        hasRaw: false,
        hasTitle: false,
        hasUnion: false,
        value: result,
        isScalar: true
      }];
    }

    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(schema[pKey]);
    if (properties && properties.length) {
      const typeName = this._getValue(schema, this.ns.w3.shacl.name + 'name');
      const value = this._exampleFromProperties(properties, mime, typeName);
      if (value) {
        return [value];
      }
    }
  }
  /**
   * Reads a raw value of JSON schema if available.
   * @param {Object} schema Schema shape of a type.
   * @return {String|undefined} JSON schema if exists.
   */
  _readJsonSchema(schema) {
    const sourceKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'sources');
    const trackedKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'parsed-json-schema');
    const valueKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'value');
    let sm = schema[sourceKey];
    if (!sm) {
      return;
    }
    if (sm instanceof Array) {
      sm = sm[0];
    }
    let tracked = sm[trackedKey];
    if (!tracked) {
      return;
    }
    if (tracked instanceof Array) {
      tracked = tracked[0];
    }
    return this._getValue(tracked, valueKey);
  }
  /**
  * Computes examples value from a list of examples.
   * @param {Array<Object>} examples List of AMF Example schapes.
   * @param {String} mime Examples media type. Currently `application/json` and
   * `application/xml` are supported.
   * @param {Object} opts Generation options. See `generatePayloadsExamples()`.
   * Besides that, `opts.typeId` is required to compute examples for a payload.
   * The `typeId` is a value of `@id` of the Payload shape.
   * @return {Array<Object>|undefined}
   */
  _computeFromExamples(examples, mime, opts) {
    examples = this._processExamples(examples);
    examples = this._listTypeExamples(examples, opts.typeId);
    if (!examples) {
      return;
    }
    const result = [];
    for (let i = 0; i < examples.length; i++) {
      const shape = examples[i];
      const value = this._generateFromExample(shape, mime, opts);
      if (value) {
        result[result.length] = value;
      }
    }
    return result;
  }
  /**
   * In AMF 4 the examples model changes from being an array of examples
   * to an object that contains an array of examples.
   * This function extracts the array of examples back to the `examples` variable,
   * respecting that the compact model can be an object instead of array.
   * If the argument is an array with more than one item it means it's pre-4.0.0
   * model.
   * @param {Array|Object} examples Examples model.
   * @return {Array|undefined} List of examples to process.
   */
  _processExamples(examples) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    if (!(examples instanceof Array)) {
      if (this._hasType(examples, this.ns.raml.vocabularies.document + 'NamedExamples')) {
        return this._ensureArray(examples[key]);
      }
      return;
    }
    if (examples.length === 1 && this._hasType(examples[0], this.ns.raml.vocabularies.document + 'NamedExamples')) {
      return this._ensureArray(examples[0][key]);
    }
    return examples;
  }
  /**
   * Uses Example shape's source maps to determine which examples should be rendered.
   * @param {Array<Object>} examples List of AMF Example schapes.
   * @param {String} typeId Payload ID
   * @return {Array<Object>|undefined}
   */
  _listTypeExamples(examples, typeId) {
    if (!typeId) {
      return examples;
    }
    const result = [];
    const sourceKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'sources');
    const trackedKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'tracked-element');
    const valueKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'value');
    const longId = typeId.indexOf('amf') === -1 ? ('amf://id' + typeId) : typeId;
    for (let i = 0, len = examples.length; i < len; i++) {
      let example = examples[i];
      if (example instanceof Array) {
        example = example[0];
      }
      let sm = example[sourceKey];
      if (!sm) {
        result[result.length] = example;
        continue;
      }
      if (sm instanceof Array) {
        sm = sm[0];
      }
      let tracked = sm[trackedKey];
      if (!tracked) {
        result[result.length] = example;
        continue;
      }
      if (tracked instanceof Array) {
        tracked = tracked[0];
      }
      const value = this._getValue(tracked, valueKey);
      if (!value) {
        continue;
      }
      const ids = value.split(',');
      if (ids.indexOf(longId) !== -1 || ids.indexOf(typeId) !== -1) {
        result[result.length] = example;
      }
    }
    return result.length ? result : undefined;
  }
  /**
   * Generate an example from an example shape.
   *
   * @param {Object} example Resolved example.
   * @param {String} mime Example content type.
   * @param {?Object} opts Processing options.
   * @return {String|undefined}
   */
  _generateFromExample(example, mime, opts) {
    let raw = this._getValue(example, this.ns.raml.vocabularies.document + 'raw');
    if (!raw) {
      raw = this._getValue(example, this.ns.w3.shacl.name + 'raw');
    }
    let title = this._getValue(example, this.ns.schema.schemaName);
    if (title && title.indexOf('example_') === 0) {
      title = undefined;
    }
    const hasRaw = !!raw;
    const result = {};
    result.hasTitle = !!title;
    result.hasUnion = false;
    if (result.hasTitle) {
      result.title = title;
    }
    if (opts.rawOnly) {
      result.hasRaw = false;
      result.value = raw;
      return result;
    }
    const isJson = mime.indexOf('json') !== -1;
    const isXml = !isJson && mime.indexOf('xml') !== -1;
    if (hasRaw) {
      if (isJson) {
        try {
          const res = JSON.parse(raw);
          const type = typeof res;
          if (type === 'string' || type === 'number' || type === 'boolean') {
            throw new Error('');
          }
          result.hasRaw = false;
          result.value = raw;
          return result;
        } catch (_) {
          // ...
        }
      }
      if (isXml) {
        if (raw.trim()[0] === '<') {
          result.hasRaw = false;
          result.value = raw;
          return result;
        }
      }
      result.hasRaw = true;
      result.raw = raw;
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'structuredValue');
    let structure = example[sKey];
    if (!structure) {
      if (result.raw) {
        result.value = result.raw;
      } else {
        result.value = '';
      }
      return result;
    }
    if (structure instanceof Array) {
      structure = structure[0];
    }
    if (this._hasType(structure, this.ns.raml.vocabularies.data + 'Scalar')) {
      const value = this._getTypedValue(structure);
      result.value = value;
      result.isScalar = true;
      return result;
    }

    if (isJson) {
      let data = this._jsonFromStructure(structure);
      if (data) {
        if (typeof data === 'object') {
          data = JSON.stringify(data, null, 2);
        }
        result.value = data;
        return result;
      }
    } else if (isXml) {
      const data = this._xmlFromStructure(structure, opts);
      result.value = data;
      return result;
    } else {
      if (result.raw) {
        result.value = result.raw;
      } else {
        result.value = '';
      }
      return result;
    }
  }

  _computeExampleArraySchape(schema, mime, opts) {
    const iKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    const items = this._ensureArray(schema[iKey]);
    if (!items) {
      return;
    }
    const isJson = mime.indexOf('json') !== -1;
    // We need only first type here as arras can have different types
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      const result = this.computeExamples(item, mime, opts);
      if (result) {
        if (isJson) {
          this._processJsonArrayExamples(result);
        }
        return result;
      }
    }
  }
  /**
   * Processes JSON examples that should be an arrays and adds brackets
   * if nescesary. When the example is empty string it adds empty string literal
   * to the example value.
   * It does the same for unions which has array of values.
   * @param {Array<Object>} examples
   */
  _processJsonArrayExamples(examples) {
    for (let i = 0; i < examples.length; i++) {
      const item = examples[i];
      if (item.values) {
        if (item.values[0].value !== undefined && item.values[0].value[0] !== '[') {
          if (item.values[0].value === '') {
            item.values[0].value = '""';
          }
          item.values[0].value = `[${item.values[0].value}]`;
        }
      } else if (item.value !== undefined && item.value[0] !== '[') {
        if (item.value === '') {
          item.value = '""';
        }
        item.value = '[' + item.value + ']';
      }
    }
  }

  _computeUnionExamples(schema, mime, opts) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const anyOf = this._ensureArray(schema[key]);
    if (!anyOf) {
      return;
    }
    const result = {
      hasTitle: false,
      hasRaw: false,
      hasUnion: true,
      values: []
    };
    for (let i = 0, len = anyOf.length; i < len; i++) {
      let unionSchape = anyOf[i];
      if (unionSchape instanceof Array) {
        unionSchape = unionSchape[0];
      }
      this._resolve(unionSchape);
      let data = this.computeExamples(unionSchape, mime, opts);
      if (!data) {
        continue;
      }
      data = data[0];
      let name = this._getValue(unionSchape, this.ns.w3.shacl.name + 'name');
      if (!name) {
        name = 'Union #' + (i + 1);
      }
      data.hasTitle = true;
      data.title = name;
      result.values[result.values.length] = data;
    }
    return result.values.length ? [result] : undefined;
  }
  /**
   * Computes value from defined `datatype` property.
   * @param {Object} shape A shape with `datatype` property.
   * @return {String|undefined} Value of the data type.
   */
  _computeScalarType(shape) {
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let dt = shape[dtKey];
    if (!dt) {
      return;
    }
    if (dt instanceof Array) {
      dt = dt[0];
    }
    let id = dt['@id'] ? dt['@id'] : dt;
    const w3index = id.indexOf(this.ns.w3.xmlSchema);
    if (w3index !== -1) {
      id = id.substr(this.ns.w3.xmlSchema.length);
    }
    const shapeindex = id.indexOf(this.ns.raml.vocabularies.shapes);
    if (shapeindex !== -1) {
      id = id.substr(this.ns.raml.vocabularies.shapes.length);
    }
    const index = id.indexOf(':');
    if (index !== -1) {
      id = id.substr(index);
    }
    return id[0].toUpperCase() + id.substr(1);
  }
  /**
   * Creates a JSON example representation from AMF example's structure
   * definition.
   * @param {Object} structure
   * @return {any}
   */
  _jsonFromStructure(structure) {
    if (!structure) {
      return;
    }
    const prefix = this.ns.raml.vocabularies.data;
    if (this._hasType(structure, prefix + 'Scalar')) {
      return this._getTypedValue(structure);
    }
    let obj;
    let isArray = false;
    if (this._hasType(structure, prefix + 'Object')) {
      obj = {};
    } else if (this._hasType(structure, prefix + 'Array')) {
      obj = [];
      isArray = true;
    } else {
      return;
    }
    if (isArray && this._hasProperty(structure, this.ns.w3.name + '1999/02/22-rdf-syntax-ns#member')) {
      const key = this._getAmfKey(this.ns.w3.name + '1999/02/22-rdf-syntax-ns#member');
      const items = structure[key];
      for (let i = 0, len = items.length; i < len; i++) {
        const item = items[i];
        this._jsonFromStructureValue(item, obj, isArray);
      }
    } else {
      const resolvedPrefix = this._getAmfKey(prefix);
      Object.keys(structure).forEach((key) => {
        if (key.indexOf(resolvedPrefix) !== 0) {
          return;
        }
        const v = structure[key];
        this._jsonFromStructureValue(v, obj, isArray, key, resolvedPrefix);
      });
    }
    return obj;
  }

  _jsonFromStructureValue(value, obj, isArray, key, resolvedPrefix) {
    if (value instanceof Array) {
      value = value[0];
    }
    const tmp = this._jsonFromStructure(value);
    if (tmp === undefined) {
      // it can be false or null
      return;
    }
    if (isArray) {
      obj[obj.length] = tmp;
    } else {
      key = key.replace(resolvedPrefix, '');
      if (key[0] === ':') {
        key = key.substr(1);
      }
      try {
        key = decodeURIComponent(key);
      } catch (_) {
        // ...
      }
      obj[key] = tmp;
    }
  }

  _xmlFromStructure(structure, opts) {
    let typeName = opts && opts.typeName || 'model';
    typeName = this._normalizeXmlTagName(typeName);
    const doc = document.implementation.createDocument('', typeName, null);
    const main = doc.documentElement;
    const keys = Object.keys(structure);
    const dataPrefix = this._getAmfKey(this.ns.raml.vocabularies.data);
    for (let i = 0, len = keys.length; i < len; i++) {
      const key = keys[i];
      if (key.indexOf(dataPrefix) !== 0) {
        continue;
      }
      let item = structure[key];
      if (item instanceof Array) {
        item = item[0];
      }
      const name = this._dataNameFromKey(key);
      this._xmlProcessDataProperty(doc, main, item, name);
    }
    const s = new XMLSerializer();
    let value = s.serializeToString(doc);
    value = '<?xml version="1.0" encoding="UTF-8"?>' + value;
    return this.formatXml(value);
  }

  formatXml(xml) {
    const PADDING = ' '.repeat(2);
    const reg = /(>)(<)(\/*)/g;
    let pad = 0;
    xml = xml.replace(reg, '$1\r\n$2$3');
    return xml.split('\r\n').map((node) => {
      let indent = 0;
      if (node.match(/.+<\/\w[^>]*>$/)) {
        indent = 0;
      } else if (node.match(/^<\/\w/) && pad > 0) {
        pad -= 1;
      } else if (node.match(/^<\w[^>]*[^/]>.*$/)) {
        indent = 1;
      } else {
        indent = 0;
      }
      pad += indent;
      return PADDING.repeat(pad - indent) + node;
    }).join('\r\n');
  }

  _getTypedValue(structure) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.data + 'value');
    let shape = structure[key];
    if (!shape) {
      return;
    }
    if (shape instanceof Array) {
      shape = shape[0];
    }
    const value = shape['@value'];
    if (!value) {
      return value;
    }
    let dt = shape['@type'];
    if (!dt) {
      const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
      dt = this._ensureArray(structure[dtKey]);
      if (dt) {
        dt = dt[0]['@id'];
      }
    }
    if (!dt) {
      return value || '';
    }
    if (dt instanceof Array) {
      dt = dt[0];
    }
    return this._typeToValue(value, dt);
  }
  /**
   * Creates a example structure for the JSON schema.
   * Old but still in use.
   * @param {Object} schema AMF schema schape
   * @param {String} jsonSchema Raw JSON schema value
   * @return {Array<Object>} Generated example model.
   */
  _exampleFromJsonSchema(schema, jsonSchema) {
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(schema[pKey]);
    let example;
    if (properties && properties.length) {
      const typeName = this._getValue(schema, this.ns.w3.shacl.name + 'name');
      example = this._exampleFromProperties(properties, 'application/json', typeName);
    }
    if (example) {
      example.hasRaw = true;
      example.raw = jsonSchema;
    } else {
      example = {
        hasRaw: false,
        hasTitle: false,
        hasUnion: false,
        value: jsonSchema
      };
    }
    return [example];
  }
  /**
   * Creates an example from RAML type properties.
   * @param {Array} properties
   * @param {String} mime Media type
   * @param {?String} typeName Name of the RAML type.
   * @param {?Boolean} isArray if true the result should be an array
   * @return {String|undefined}
   */
  _exampleFromProperties(properties, mime, typeName, isArray) {
    let result;
    if (mime.indexOf('json') !== -1) {
      const value = this._jsonExampleFromProperties(properties);
      if (value) {
        result = JSON.stringify(value, null, 2);
        if (isArray && result[0] !== '[') {
          result = '[' + result + ']';
        }
      }
    } else if (mime.indexOf('xml') !== -1) {
      result = this._xmlExampleFromProperties(properties, typeName);
      if (result) {
        result = '<?xml version="1.0" encoding="UTF-8"?>' + result;
        result = this.formatXml(result);
      }
    }
    if (result) {
      return {
        hasRaw: false,
        hasTitle: false,
        hasUnion: false,
        value: result
      };
    }
  }
  /**
   * Generates a JSON example from RAML's type properties.
   * @param {Array} properties List of type properties
   * @return {String|undefined}
   */
  _jsonExampleFromProperties(properties) {
    const result = {};
    for (let i = 0, len = properties.length; i < len; i++) {
      const property = properties[i];
      const name = this._getValue(property, this.ns.w3.shacl.name + 'name');
      if (!name) {
        continue;
      }
      const rKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
      let range = property[rKey];
      if (!range) {
        continue;
      }
      if (range instanceof Array) {
        range = range[0];
      }
      const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
      const examples = this._ensureArray(range[eKey]);
      if (examples) {
        const sKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'structuredValue');
        examples.forEach((example) => {
          let structure = example[sKey];
          if (!structure) {
            result[name] = '';
            return;
          }
          if (structure instanceof Array) {
            structure = structure[0];
          }
          const data = this._jsonFromStructure(structure);
          if (data !== undefined) {
            result[name] = data;
          }
        });
      } else {
        let value = this._computeJsonProperyValue(range);
        if (value === undefined) {
          value = '';
        }
        result[name] = value;
      }
    }
    return result;
  }
  /**
   * Computes JSON value from a range shape.
   * @param {Object} range AMF's range model.
   * @param {?String} typeName Optional, type name to use in Union type. By default first NodeShape.
   * @return {any}
   */
  _computeJsonProperyValue(range, typeName) {
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      return this._computeJsonScalarValue(range);
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      return this._computeJsonUnionValue(range, typeName);
    }
    if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      return this._computeJsonObjectValue(range);
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      return this._computeJsonArrayValue(range);
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'NilShape')) {
      return null;
    }
  }
  _computeJsonScalarValue(range) {
    const value = this._getTypeScalarValue(range);
    if (!value) {
      // This is to work with mocking services when the user just want to send an
      // example value to the server. This ensures valid input from the client
      // even of this alters the `default` value for the API (when one does not
      // exist)
      const type = this._computeScalarType(range);
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Long':
        case 'Float':
        case 'Double': return 0;
        case 'Boolean': return false;
        case 'Nil':
        case 'Null': return null;
        default: return '';
      }
    }
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let dt = range[dtKey];
    if (!dt) {
      return value || '';
    }
    if (dt instanceof Array) {
      dt = dt[0];
    }
    return this._typeToValue(value, dt['@id']);
  }
  /**
   * Casts the value to given data type represented in AMF notation.
   * @param {String} value Value encoded in AMF
   * @param {String} type AMF data type
   * @return {String|Number|Boolean} Casted value.
   */
  _typeToValue(value, type) {
    let prefix = this._getAmfKey(this.ns.w3.xmlSchema);
    if (prefix !== this.ns.w3.xmlSchema) {
      prefix += ':';
    }
    let ramlPrefix = this._getAmfKey(this.ns.raml.vocabularies.shapes);
    if (ramlPrefix !== this.ns.raml.vocabularies.shapes) {
      ramlPrefix += ':';
    }
    switch (type) {
      case prefix + 'boolean':
      case ramlPrefix + 'boolean':
      case this.ns.w3.xmlSchema + 'boolean':
      case this.ns.raml.vocabularies.shapes + 'boolean':
        if (value !== undefined) {
          return value === 'true' ? true : false;
        }
        return value;

      case prefix + 'nil':
      case ramlPrefix + 'nil':
      case this.ns.w3.xmlSchema + 'nil':
      case this.ns.raml.vocabularies.shapes + 'nil':
        return null;

      case prefix + 'integer':
      case ramlPrefix + 'integer':
      case this.ns.w3.xmlSchema + 'integer':
      case this.ns.raml.vocabularies.shapes + 'integer':
      case prefix + 'number':
      case this.ns.w3.xmlSchema + 'number':
      case ramlPrefix + 'number':
      case this.ns.raml.vocabularies.shapes + 'number':
      case prefix + 'long':
      case this.ns.w3.xmlSchema + 'long':
      case ramlPrefix + 'long':
      case this.ns.raml.vocabularies.shapes + 'long':
      case prefix + 'double':
      case this.ns.w3.xmlSchema + 'double':
      case ramlPrefix + 'double':
      case this.ns.raml.vocabularies.shapes + 'double':
      case prefix + 'float':
      case this.ns.w3.xmlSchema + 'float':
      case ramlPrefix + 'float':
      case this.ns.raml.vocabularies.shapes + 'float':
        if (value) {
          if (isNaN(value)) {
            return 0;
          }
          return Number(value);
        }
        return 0;
      default: return value || '';
    }
  }
  /**
   * Computes JSON example from UnionShape
   * @param {Object} range Type definition
   * @param {?String} typeName Optional, type name to use. By default first NodeShape.
   * @return {Object|undefined}
   */
  _computeJsonUnionValue(range, typeName) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const list = this._ensureArray(range[key]);
    if (!list) {
      return;
    }
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    for (let i = 0, len = list.length; i < len; i++) {
      let item = list[i];
      if (item instanceof Array) {
        item = item[0];
      }
      this._resolve(item);
      if (typeName) {
        const name = this._getValue(item, this.ns.w3.shacl.name + 'name');
        if (typeName !== name) {
          continue;
        }
      }
      if (this._hasType(item, this.ns.w3.shacl.name + 'NodeShape')) {
        item = this._resolve(item);
        const data = this._ensureArray(item[pKey]);
        if (data) {
          return this._jsonExampleFromProperties(data);
        }
      }
    }
  }

  _computeJsonObjectValue(range) {
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(range[pKey]);
    if (properties && properties.length) {
      return this._jsonExampleFromProperties(properties);
    }
  }

  _computeJsonArrayValue(range) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    const items = this._ensureArray(range[key]);
    if (!items) {
      return;
    }
    const result = [];
    for (let i = 0, len = items.length; i < len; i++) {
      let item = items[i];
      if (item instanceof Array) {
        item = item[0];
      }
      this._resolve(item);
      const value = this._computeJsonProperyValue(item);
      if (value !== undefined) {
        result[result.length] = value;
      }
    }
    return result;
  }

  _extractExampleRawValue(example) {
    if (example instanceof Array) {
      example = example[0];
    }
    if (this._hasType(example, this.ns.raml.vocabularies.document + 'NamedExamples')) {
      const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
      example = example[key];
      if (example instanceof Array) {
        example = example[0];
      }
    }
    return this._getValue(example, this.ns.w3.shacl.name + 'raw');
  }
  /**
   * Gets a value from a Range shape for a scalar value.
   * @param {Object} range AMF's range model.
   * @return {any}
   */
  _getTypeScalarValue(range) {
    const dvKey = this._getAmfKey(this.ns.w3.shacl.name + 'defaultValue');
    let dv = range[dvKey];
    if (dv) {
      if (dv instanceof Array) {
        dv = dv[0];
      }
      return this._getValue(dv, this.ns.raml.vocabularies.data + 'value');
    }
    const rKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    const ex = range[rKey];
    if (ex) {
      return this._extractExampleRawValue(ex);
    }
  }
  /**
   * Computes example from RAML type for XML media type.
   * @param {Array<Object>} properties
   * @param {?String} typeName RAML type name
   * @return {String}
   */
  _xmlExampleFromProperties(properties, typeName) {
    typeName = this._normalizeXmlTagName(typeName);
    const doc = document.implementation.createDocument('', typeName, null);
    const main = doc.documentElement;
    for (let i = 0, len = properties.length; i < len; i++) {
      this._xmlProcessProperty(doc, main, properties[i]);
    }
    const s = new XMLSerializer();
    return s.serializeToString(doc);
  }
  /**
   * Processes an XML property
   * @param {Document} doc Main document
   * @param {Element} node Current node
   * @param {Object} property AMF property
   */
  _xmlProcessProperty(doc, node, property) {
    if (!property) {
      return;
    }
    if (this._hasType(property, this.ns.w3.shacl.name + 'NodeShape')) {
      const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
      const properties = this._ensureArray(property[pKey]);
      if (!properties) {
        return;
      }
      for (let i = 0, len = properties.length; i < len; i++) {
        this._xmlProcessProperty(doc, node, properties[i]);
      }
      return;
    }
    const rKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
    let range = property[rKey];
    if (!range) {
      return;
    }
    if (range instanceof Array) {
      range = range[0];
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'xmlSerialization');
    let serialization = range[sKey];
    if (serialization instanceof Array) {
      serialization = serialization[0];
    }
    const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
    const examples = this._ensureArray(range[eKey]);
    if (examples) {
      let name = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlName');
      if (!name) {
        name = this._getValue(range, this.ns.w3.shacl.name + 'name');
      }
      this._xmlFromExamples(doc, node, examples[0], name);
      return;
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
      const list = this._ensureArray(range[key]);
      if (!list) {
        return;
      }
      const shape = list[0];
      if (this._hasType(shape, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
        this._xmlProcessUnionScalarProperty(doc, node, property, shape);
      } else {
        this._xmlProcessProperty(doc, node, shape);
      }
      return;
    }
    let isWrapped = false;
    if (serialization) {
      const isAtribute = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlAttribute');
      if (isAtribute) {
        this._appendXmlAttribute(node, property, range, serialization);
        return;
      }
      isWrapped = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlWrapped');
    }
    if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      this._appendXmlElements(doc, node, property, range);
      return;
    }
    if (this._hasType(range, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      this._appendXmlArray(doc, node, property, range, isWrapped);
      return;
    }
    this._appendXmlElement(doc, node, range);
  }
  /**
   * Appends XML example data to a node from an example defined on a "range"
   * property. This way it does not generate example values from type values
   * but uses object's example.
   *
   * @param {Document} doc XML document
   * @param {Node} node A node to which append values
   * @param {Object} example AMF's example definition.
   * @param {String} propertyName Name of the property being processed
   */
  _xmlFromExamples(doc, node, example, propertyName) {
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'structuredValue');
    let structure = example[sKey];
    if (structure instanceof Array) {
      structure = structure[0];
    }
    if (!structure) {
      return;
    }
    this._xmlProcessDataProperty(doc, node, structure, propertyName);
  }
  /**
   * Reads property data type.
   * @param {Object} shape
   * @return {String} Data type
   */
  _readDataType(shape) {
    const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
    let dataType = shape[dtKey];
    if (!dataType) {
      return;
    }
    if (dataType instanceof Array) {
      dataType = dataType[0];
    }
    dataType = dataType['@id'];
    return this._dataNameFromKey(dataType);
  }
  /**
   * Appends an attribute to the node from AMF property
   * @param {Element} node Current node
   * @param {Object} property AMF property
   * @param {Object} range AMF range
   * @param {Object} serialization Serialization info
   */
  _appendXmlAttribute(node, property, range, serialization) {
    let name = this._getValue(serialization, this.ns.raml.vocabularies.shapes + 'xmlName');
    if (!name) {
      name = this._getValue(range, this.ns.w3.shacl.name + 'name');
    }
    if (!name) {
      return;
    }
    if (name.indexOf('?') !== -1) {
      name = name.replace('?', '');
    }
    let value = this._readDataType(range);
    if (!value) {
      value = '';
    }
    node.setAttribute(name, value);
  }
  /**
   * Appends an element to the node tree from a type
   * @param {Document} doc Main document
   * @param {Element} node Current node
   * @param {Object} range AMF range
   * @return {Element} Newly created element
   */
  _appendXmlElement(doc, node, range) {
    let name = this._getValue(range, this.ns.w3.shacl.name + 'name');
    if (!name) {
      return;
    }
    let nodeValue = this._getValue(range, this.ns.w3.shacl.name + 'defaultValueStr');
    if (!nodeValue) {
      const eKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
      const example = range[eKey];
      if (example) {
        nodeValue = this._extractExampleRawValue(example);
      }
    }
    if (!nodeValue) {
      nodeValue = ' ';
      // Do not add default type name as users do not like this.
      // Mocking service would mark is as an error.
      // this._readDataType(range);
    }
    name = name.replace(/[^a-zA-Z0-9-]*/g, '');
    const element = doc.createElement(name);
    if (nodeValue) {
      const vn = doc.createTextNode(nodeValue);
      element.appendChild(vn);
    }
    node.appendChild(element);
    return element;
  }

  _appendXmlElements(doc, node, property, range) {
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const properties = this._ensureArray(range[pKey]);
    const element = this._appendXmlElement(doc, node, range);
    if (!properties) {
      return;
    }
    for (let i = 0, len = properties.length; i < len; i++) {
      this._xmlProcessProperty(doc, element, properties[i]);
    }
  }

  _appendXmlArray(doc, node, property, range, isWrapped) {
    if (isWrapped) {
      const element = this._appendXmlElement(doc, node, range);
      node.appendChild(element);
      node = element;
    }
    const pKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    const properties = this._ensureArray(range[pKey]);
    if (!properties) {
      return;
    }
    for (let i = 0, len = properties.length; i < len; i++) {
      const prop = properties[i];
      if (isWrapped) {
        const name = this._getValue(prop, this.ns.w3.shacl.name + 'name');
        if (!name) {
          continue;
        }
        const element = doc.createElement(name);
        node.appendChild(element);
        node = element;
      }
      this._xmlProcessProperty(doc, node, properties[i]);
    }
  }

  _xmlProcessUnionScalarProperty(doc, node, property, shape) {
    const name = this._getValue(property, this.ns.w3.shacl.name + 'name') || 'unknown';
    const type = this._readDataType(shape);
    const element = doc.createElement(name);
    element.appendChild(doc.createTextNode(type));
  }
  /**
   * Normalizes given name to a value that can be accepted by `createElement`
   * function on a document object.
   * @param {String} name A name to process
   * @return {String} Normalized name
   */
  _normalizeXmlTagName(name) {
    return name.replace(/[^a-zA-Z0-9-_]/g, '');
  }
  /**
   * Processes XML property from a data shape.
   * @param {Document} doc Main document
   * @param {Element} node Current node
   * @param {Object} property AMF property
   * @param {String} name Current property name
   */
  _xmlProcessDataProperty(doc, node, property, name) {
    if (!property || !name) {
      return;
    }
    name = this._normalizeXmlTagName(name);
    const element = doc.createElement(name);
    if (this._hasType(property, this.ns.raml.vocabularies.data + 'Scalar')) {
      const value = this._computeStructuredExampleValue(property);
      if (value !== undefined) {
        const vn = doc.createTextNode(value);
        element.appendChild(vn);
      }
    } else if (this._hasType(property, this.ns.raml.vocabularies.data + 'Array')) {
      this._processDataArrayProperties(doc, element, property, name);
    } else if (this._hasType(property, this.ns.raml.vocabularies.data + 'Object')) {
      this._processDataObjectProperties(doc, element, property, name);
    } else if (property['@value']) {
      const vn = doc.createTextNode(property['@value']);
      node.appendChild(vn);
      // Skips adding new element
      return;
    }
    node.appendChild(element);
  }
  /**
   * Computes an example from example structured value.
   *
   * @param {Object} model `structuredValue` item model.
   * @return {Object|Array} Javascript object or array with structured value.
   * @deprecated Use `amf-excample-generator` for examples generation.
   */
  _computeExampleFromStructuredValue(model) {
    if (this._hasType(model, this.ns.raml.vocabularies.data + 'Scalar')) {
      return this._computeStructuredExampleValue(this._getValue(model, this.ns.raml.vocabularies.data + 'value'));
    }
    const isObject = this._hasType(model, this.ns.raml.vocabularies.data + 'Object');
    const result = isObject ? {} : [];
    const modelKeys = ['@id', '@type'];
    Object.keys(model).forEach((key) => {
      if (modelKeys.indexOf(key) !== -1) {
        return;
      }
      const value = this._computeStructuredExampleValue(model[key][0]);
      if (isObject) {
        const name = key.substr(key.indexOf('#') + 1);
        result[name] = value;
      } else {
        result.push(value);
      }
    });
    return result;
  }
  /**
   * Computes value with propert data type for a structured example.
   * @param {Object} model Structured example item model.
   * @return {String|Boolean|Number} Value for the example.
   * @deprecated Use `amf-excample-generator` for examples generation.
   */
  _computeStructuredExampleValue(model) {
    if (!model) {
      return;
    }
    if (typeof model === 'string') {
      return model;
    }
    if (this._hasType(model, this.ns.raml.vocabularies.data + 'Scalar')) {
      const key = this._getAmfKey(this.ns.raml.vocabularies.data + 'value');
      const mValue = this._ensureArray(model[key])[0];
      const value = mValue['@value'];
      let type = mValue['@type'];
      if (!type) {
        const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
        type = this._ensureArray(model[dtKey]);
        if (type) {
          type = type[0]['@id'];
        }
      }
      switch (type) {
        case this.ns.w3.xmlSchema + 'boolean':
          return value === 'true' ? true : false;
        case this.ns.w3.xmlSchema + 'integer':
        case this.ns.w3.xmlSchema + 'long':
        case this.ns.w3.xmlSchema + 'double':
        case this.ns.w3.xmlSchema + 'float':
        case this.ns.raml.vocabularies.shapes + 'number':
          return Number(value);
        default:
          return value;
      }
    }
    return this._computeExampleFromStructuredValue(model);
  }

  _processDataArrayProperties(doc, node, property, name) {
    let childName;
    if (name.substr(-2) === 'es') {
      childName = name.substr(0, name.length - 2);
    } else if (name.substr(-1) === 's') {
      childName = name.substr(0, name.length - 1);
    } else {
      childName = name;
    }
    const key = this._getAmfKey(this.ns.w3.name + '1999/02/22-rdf-syntax-ns#member');
    const items = this._ensureArray(property[key]);
    for (let i = 0, len = items.length; i < len; i++) {
      let item = items[i];
      if (item instanceof Array) {
        item = item[0];
      }
      this._xmlProcessDataProperty(doc, node, item, childName);
    }
  }

  _processDataObjectProperties(doc, node, property) {
    const prefix = this.ns.raml.vocabularies.data;
    const resolvedPrefix = this._getAmfKey(prefix);
    Object.keys(property).forEach((key) => {
      if (key.indexOf(resolvedPrefix) !== 0) {
        return;
      }
      let item = property[key];
      if (item instanceof Array) {
        item = item[0];
      }
      const name = this._dataNameFromKey(key);
      this._xmlProcessDataProperty(doc, node, item, name);
    });
  }

  _dataNameFromKey(key) {
    let index = key.indexOf('#');
    if (index !== -1) {
      key = key.substr(index + 1);
    } else {
      index = key.indexOf(':');
      if (index !== -1) {
        key = key.substr(index + 1);
      }
    }
    return key;
  }
}
window.customElements.define('api-example-generator', ApiExampleGenerator);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element that copies a text to clipboard.
 *
 * ### Example
 *
 * ```html
 * <clipboard-copy content="test"></clipboard-copy>
 * <script>
 * const elm = document.querySelectior('clipboard-copy');
 * if(elm.copy()) {
 *  console.info('Content has been copied to the clipboard');
 * } else {
 *  console.error('Content copy error. This browser is ancient!');
 * }
 * < /script>
 * ```
 *
 *
 * @customElement
 * @memberof LogicElements
 * @demo demo/index.html
 */
class ClipboardCopy extends HTMLElement {
  static get observedAttributes() {
    return ['content'];
  }

  get content() {
    return this._content;
  }
  /**
   * A content to be copied to the clipboard.
   * It must be set before calling the `copy` function.
   *
   * @param {String} value Content to copy
   */
  set content(value) {
    this._content = value;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // Only "content" is observed
    this.content = newValue;
  }
  /**
   * Execute content copy.
   *
   * @return {Boolean} True if the content has been copied to the clipboard
   * and false if there was an error.
   */
  copy() {
    if (this._beforeCopy()) {
      return this._notifyCopied();
    }
    const el = document.createElement('textarea');
    el.value = this.content;
    el.setAttribute('readonly', '');
    el.style.position = 'absolute';
    el.style.left = '-9999px';
    document.body.appendChild(el);
    const selected = document.getSelection().rangeCount > 0 ?
      /* istanbul ignore next */
      document.getSelection().getRangeAt(0) : false;
    el.select();
    let result = false;
    try {
      result = document.execCommand('copy');
      this._notifyCopied();
    } catch (err) {
      /* istanbul ignore next */
      const ev = new CustomEvent('content-copy-error', {
        bubbles: false
      });
      /* istanbul ignore next */
      this.dispatchEvent(ev);
    }
    document.body.removeChild(el);
    document.getSelection().removeAllRanges();
    /* istanbul ignore if */
    if (selected) {
      document.getSelection().addRange(selected);
    }
    return result;
  }
  /**
   * Sends the `content-copy` event.
   * If the event is canceled then the logic from this element won't be
   * executed. Useful if current platform doesn't support `execCommand('copy')`
   * and has other way to manage clipboard.
   *
   * @return {Boolean} True if handler executed copy function.
   */
  _beforeCopy() {
    const ev = new CustomEvent('content-copy', {
      detail: {
        value: this.content
      },
      bubbles: true,
      cancelable: true,
      composed: true
    });
    this.dispatchEvent(ev);
    return ev.defaultPrevented;
  }
  /**
   * Sends the `content-copied` event that is not bubbling.
   * @return {Boolean}
   */
  _notifyCopied() {
    const ev = new CustomEvent('content-copied', {
      bubbles: false
    });
    this.dispatchEvent(ev);
    return true;
  }
  /**
   * Fired when the content has been copied to the clipboard.
   *
   * Note: You can use return value of the `copy()` function. If the return
   * value is `true` then content has been copied to clipboard.
   *
   * @event content-copied
   */
  /**
   * Fired when there was an error copying content to clipboard.
   *
   * Note: You can use return value of the `copy()` function. If the return
   * value is `flase` then content has not been copied to clipboard.
   *
   * @event content-copy-error
   */
  /**
   * Fired when executing copy function.
   * This cancelable event is dispatched before running the actual logic
   * of this element to support platforms that doesn't allow to manage
   * clipboard with `execCommand('copy')`.
   *
   * When the event is canceled then the logic is not executed.
   *
   * @event content-copy
   * @param {String} value A content t be copied to clipboard.
   */
}
window.customElements.define('clipboard-copy', ClipboardCopy);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * Common methods for `json-table` views
 * @param {Function} base
 * @return {Class}
 */
const JsonTableMixin = (base) => class extends base {
  static get properties() {
    return {
      // In pagination, page index
      page: { type: Number },
      /**
       * Number of items in pagination per page.
       * Allowed values are 10, 15, 20, 25, 50 and 100.
       */
      itemsPerPage: { type: Number },
      _oldItemsPerPage: { type: Number, attribute: 'items-per-page' },
      // If true then the pagination will be enabled for the arrays.
      paginate: { type: Boolean },
      /**
       * Enables outlined theme for inputs.
       */
      outlined: { type: Boolean, reflect: true },
      /**
       * Enables compatibility with Anypoint theme.
       */
      compatibility: { type: Boolean, reflect: true }
    };
  }

  get _oldItemsPerPage() {
    return this.itemsPerPage;
  }

  set _oldItemsPerPage(value) {
    this.itemsPerPage = value;
  }


  constructor() {
    super();
    this.page = 0;
    this.itemsPerPage = 20;
    this.paginate = false;
  }

  /**
   * Returns true if given argument is an array
   *
   * @param {any} arr Candidate to test for object
   * @return {Boolean}
   */
  isArray(arr) {
    return arr instanceof Array;
  }
  /**
   * Returns true if given argument is an object.
   *
   * @param {any} obj Candidate to test for object
   * @return {Boolean}
   */
  isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }
  /**
   * Check if given object is one of the primitives.
   *
   * @param {any} obj An object to test
   * @return True if the object is one of:
   * - string
   * - number
   * - boolean
   * - undefined
   * - null
   * @return {Boolean}
   */
  isPrimitive(obj) {
    if (obj === null) {
      return true;
    }
    const primitives = ['string', 'number', 'boolean', 'undefined'];
    const type = typeof obj;
    return primitives.indexOf(type) !== -1;
  }

  /**
   * Creates a data model for single proerty.
   *
   * @param {String} key A property name in the JSON structure
   * @param {any} value Value associated with the property.
   * @return {Object<String, any>} Internal data model for a property. Model contains following
   * keys:
   *
   * - key - a property name
   * - value - property value - without applying data model. Thois will be done in child elements
   * - isObject - set if the value is type of Object
   * - isEnum - set if the value is type of array and contains primitives only
   * - isArray - set if the value is type of Array and contains complex objects
   * - isPrimitive - set if the value is type a primitive
   */
  getPropertyModel(key, value) {
    const result = this.getItemModel(value);
    result.key = key;
    return result;
  }
  /**
   * Creates a model for a value.
   *
   * @param {any} value Array item or property value to create a model from.
   * @return {Object<String, any>} Internal data model for a property value or array item. Model
   * contains following keys:
   *
   * - value - property value - without applying data model. Thois will be done in child elements
   * - isObject - set if the value is type of Object
   * - isEnum - set if the value is type of array and contains primitives only
   * - isArray - set if the value is type of Array and contains complex objects
   * - isPrimitive - set if the value is type a primitive
   */
  getItemModel(value) {
    const result = {
      value: value
    };
    if (this.isObject(value)) {
      result.isObject = true;
    } else if (this.isArray(value)) {
      if (this.isEnum(value)) {
        result.isEnum = true;
      } else {
        result.isArray = true;
      }
    } else {
      result.isPrimitive = true;
    }
    return result;
  }
  /**
   * Checks if given array is enum (contains primitives only).
   *
   * @param {Array} arr An array to test.
   * @return {Boolean} True if the array contains primitive values only. False otherwise.
   */
  isEnum(arr) {
    if (!arr || !arr.length) {
      return false;
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      if (!this.isPrimitive(arr[i])) {
        return false;
      }
    }
    return true;
  }
  // Computes if the passed record's object is a type of array or enum.
  _isEnumOrArray(item) {
    if (!item) {
      return false;
    }
    return item.isArray || item.isEnum;
  }
  // Computes the size of item's value.
  _computeArraySize(item) {
    if (!item) {
      return 0;
    }
    if (item.isArray || item.isEnum) {
      return item.value.length || 0;
    }
    return 0;
  }
};

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * Singleton IronMeta instance.
 */
let ValidatableMixinMeta = null;
/**
 * A port of `iron-validatable-mixin` that works with any JavaScript class.
 * To be used with Polymer 3, LitElement and low level web components.
 *
 * This validatable supports multiple validators.
 *
 * Use `ValidatableMixin` to implement an element that validates user input.
 * Use the related `ArcValidatorBehavior` to add custom validation logic
 * to an iron-input or other wrappers around native inputs.
 *
 * By default, an `<iron-form>` element validates its fields when the user presses the submit
 * button.
 * To validate a form imperatively, call the form's `validate()` method, which in turn will
 * call `validate()` on all its children. By using `ValidatableMixin`, your
 * custom element will get a public `validate()`, which will return the validity
 * of the element, and a corresponding `invalid` attribute, which can be used for styling.
 *
 * To implement the custom validation logic of your element, you must override
 * the protected `_getValidity()` method of this behaviour, rather than `validate()`.
 * See [this](https://github.com/PolymerElements/iron-form/blob/master/demo/simple-element.html)
 * for an example.
 *
 * ### Accessibility
 *
 * Changing the `invalid` property, either manually or by calling `validate()` will update the
 * `aria-invalid` attribute.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 */
const ValidatableMixin = (base) => class extends base {
  static get properties() {
    return {
      /**
       * Name of the validator or validators to use.
       * If the element should be validated by more than one validator then separate names with
       * space. See docs for `PolymerValidatorBehavior` for description of how to define a
       * validator.
       */
      validator: { type: String },

      /**
       * After calling `validate()` this is be populated by latest result of the
       * test for each validator. Result item contains following properties:
       *
       * - validator {String} Name of the validator
       * - valid {Boolean} Result of the test
       * - message {String} Error message
       *
       * This property is `undefined` if `validator` is not set.
       */
      validationStates: { type: Array },
      /**
       * True if the last call to `validate` is invalid.
       */
      invalid: {
        reflect: true,
        type: Boolean
      },
      /**
       * Namespace for this validator. This property is deprecated and should
       * not be used. For all intents and purposes, please consider it a
       * read-only, config-time property.
       */
      validatorType: { type: String }
    };
  }
  /* Recompute this every time it's needed, because we don't know if the
   * underlying ValidatableMixinMeta has changed. */
  get _validator() {
    if (!ValidatableMixinMeta) {
      return null;
    }
    const validator = this.validator;
    if (!validator) {
      return null;
    }
    const validatorsNames = validator.split(' ');
    if (validatorsNames.length === 0) {
      return null;
    }
    const result = [];
    validatorsNames.forEach((name) => {
      const validator = ValidatableMixinMeta.byKey(name);
      if (validator) {
        result.push(validator);
      }
    });
    return result;
  }
  get invalid() {
    return this._invalid;
  }

  set invalid(value) {
    if (this._sop('invalid', value)) {
      this._invalidChanged(value);
      this._notifyChanged('invalid', value);
    }
  }

  get validationStates() {
    return this._validationStates;
  }

  set validationStates(value) {
    if (this._sop('validationStates', value)) {
      this._notifyChanged('validation-states', value);
    }
  }

  /**
   * @return {Function} Previously registered handler for `chips-changed` event
   */
  get oninvalid() {
    return this._oninvalid;
  }
  /**
   * Registers a callback function for `chips-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set oninvalid(value) {
    if (this._oninvalid) {
      this.removeEventListener('invalid-changed', this._oninvalid);
    }
    if (typeof value !== 'function') {
      this._oninvalid = null;
      return;
    }
    this._oninvalid = value;
    this.addEventListener('invalid-changed', value);
  }

  /**
   * @constructor
   */
  constructor() {
    super();
    ValidatableMixinMeta = new IronMeta({
      type: 'validator'
    });
    this.validatorType = 'validator';
    this.invalid = false;
  }

  _sop(prop, value) {
    const key = `_${prop}`;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    if (this.requestUpdate) {
      // Lit element
      this.requestUpdate(prop, old);
    }
    return true;
  }

  _notifyChanged(prop, value) {
    this.dispatchEvent(new CustomEvent(prop + '-changed', {
      composed: true,
      detail: {
        value
      }
    }));
  }

  _invalidChanged(invalid) {
    if (invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  }

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator() {
    const _validator = this._validator;
    return !!(_validator && _validator.length);
  }

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.
   * @param {Object} value The value to be validated. By default, it is passed
   * to the validator's `validate()` function, if a validator is set.
   * @return {boolean} True if `value` is valid.
   */
  validate(value) {
    const state = this._getValidity(value);
    this.invalid = !state;
    return state;
  }

  /**
   * Overrides `IronValidatableBehavior#hasValidator`
   *
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */
  _getValidity(value) {
    if (this.hasValidator()) {
      let result = true;
      const states = [];
      this._validator.forEach((validator) => {
        const validatorResult = {
          validator: validator.nodeName && validator.nodeName.toLowerCase(),
          message: validator.message
        };
        if (!validator.validate(value)) {
          result = false;
          validatorResult.valid = false;
        } else {
          validatorResult.valid = true;
        }
        states.push(validatorResult);
      });
      this.validationStates = states;
      return result;
    }
    return true;
  }
};

/**
 * This mixin is a port of https://github.com/PolymerElements/iron-fit-behavior
 * that works with LitElement.
 *
 * `ArcFitMixin` fits an element in another element using `max-height`
 * and `max-width`, and optionally centers it in the window or another element.
 * The element will only be sized and/or positioned if it has not already been
 * sized and/or positioned by CSS.
 *
 * CSS properties            | Action
 * --------------------------|-------------------------------------------
 * `position` set            | Element is not centered horizontally or vertically
 * `top` or `bottom` set     | Element is not vertically centered
 * `left` or `right` set     | Element is not horizontally centered
 * `max-height` set          | Element respects `max-height`
 * `max-width` set           | Element respects `max-width`
 *
 * `ArcFitMixin` can position an element into another element using
 * `verticalAlign` and `horizontalAlign`. This will override the element's css
 * position.
 *
 *     <div class="container">
 *       <iron-fit-impl verticalalign="top" horizontalalign="auto">
 *         Positioned into the container
 *       </iron-fit-impl>
 *     </div>
 *
 * Use `noOverlap` to position the element around another element without
 * overlapping it.
 *
 *     <div class="container">
 *       <iron-fit-impl nooverlap verticalalign="auto" horizontalalign="auto">
 *         Positioned around the container
 *       </iron-fit-impl>
 *     </div>
 *
 * Use `horizontalOffset, verticalOffset` to offset the element from its
 * `positionTarget`; `Polymer.IronFitBehavior` will collapse these in order to
 * keep the element within `fitInto` boundaries, while preserving the element's
 * CSS margin values.
 *
 *     <div class="container">
 *       <iron-fit-impl verticalalign="top" verticaloffset="20">
 *         With vertical offset
 *       </iron-fit-impl>
 *     </div>
 *
 * ## Usage
 *
 * ```javascript
 * import { LitElement } from 'lit-element';
 * import { ArcFitMixin } from '@advanced-rest-client/arc-fit-mixin/arc-fit-mixin.js';
 *
 * class ArcFitImpl extends ArcFitMixin(LitElement) {
 *  ...
 * }
 * ```
 *
 * ## Deprecation notice
 *
 * The following attributes are supported for compatibility with older and Polymer elements
 * but eventually will be removed and replaced wit  the corresponding new attribute.
 *
 * -   `sizing-target` > `sizingtarget`
 * -   `fit-into` > `fitinto`
 * -   `no-overlap` > `nooverlap`
 * -   `position-target` > `positiontarget`
 * -   `horizontal-align` > `horizontalalign`
 * -   `vertical-align` > `verticalalign`
 * -   `dynamic-align` > `dynamicalign`
 * -   `horizontal-offset` > `horizontaloffset`
 * -   `vertical-offset` > `verticaloffset`
 * -   `auto-fit-on-attach` > `autofitonattach`
 *
 * @param {Class} superClass
 * @return {Class}
 */
const ArcFitMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * The element that will receive a `max-height`/`width`. By default it is
       * the same as `this`, but it can be set to a child element. This is useful,
       * for example, for implementing a scrolling region inside the element.
       * @type {!Element}
       */
      sizingTarget: { type: Object },
      /**
       * The element to fit `this` into.
       * @type {!Element}
       */
      fitInto: { type: Object },
      /**
       * Will position the element around the positionTarget without overlapping
       * it.
       */
      noOverlap: { type: Boolean },
      _oldNoOverlap: { type: Boolean, attribute: 'no-overlap' },

      /**
       * The element that should be used to position the element. If not set, it
       * will default to the parent node.
       * @type {!Element}
       */
      positionTarget: { type: Object },
      /**
       * The orientation against which to align the element horizontally
       * relative to the `positionTarget`. Possible values are "left", "right",
       * "center", "auto".
       */
       horizontalAlign: { type: String },
       _oldHorizontalAlign: { type: String, attribute: 'horizontal-align' },
      /**
       * The orientation against which to align the element vertically
       * relative to the `positionTarget`. Possible values are "top", "bottom",
       * "middle", "auto".
       */
      verticalAlign: { type: String },
      _oldVerticalAlign: { type: String, attribute: 'vertical-align' },
      /**
       * If true, it will use `horizontalAlign` and `verticalAlign` values as
       * preferred alignment and if there's not enough space, it will pick the
       * values which minimize the cropping.
       */
      dynamicAlign: { type: Boolean },
      _oldDynamicAlign: { type: Boolean, attribute: 'dynamic-align' },
      /**
       * A pixel value that will be added to the position calculated for the
       * given `horizontalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `horizontalAlign`.
       *
       * If `horizontalAlign` is "left" or "center", this offset will increase or
       * decrease the distance to the left side of the screen: a negative offset
       * will move the dropdown to the left; a positive one, to the right.
       *
       * Conversely if `horizontalAlign` is "right", this offset will increase
       * or decrease the distance to the right side of the screen: a negative
       * offset will move the dropdown to the right; a positive one, to the left.
       */
      horizontalOffset: { type: Number, reflect: true },
      _oldHorizontalOffset: { type: Number, attribute: 'horizontal-offset' },
      /**
       * A pixel value that will be added to the position calculated for the
       * given `verticalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `verticalAlign`.
       *
       * If `verticalAlign` is "top" or "middle", this offset will increase or
       * decrease the distance to the top side of the screen: a negative offset
       * will move the dropdown upwards; a positive one, downwards.
       *
       * Conversely if `verticalAlign` is "bottom", this offset will increase
       * or decrease the distance to the bottom side of the screen: a negative
       * offset will move the dropdown downwards; a positive one, upwards.
       */
      verticalOffset: { type: Number, reflect: true },
      _oldVerticalOffset: { type: Number, attribute: 'vertical-offset' },

      /**
       * Set to true to auto-fit on attach.
       */
      autoFitOnAttach: { type: Boolean, reflect: true },
      _oldAutoFitOnAttach: { type: Boolean, attribute: 'auto-fit-on-attach' },

      /** @type {?Object} */
      _fitInfo: { type: Object }
    };
  }

  constructor() {
    super();

    this.sizingTarget = this;
    this.fitInto = window;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;
    this.autoFitOnAttach = false;
  }

  get _fitWidth() {
    let fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  }

  get _fitHeight() {
    let fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  }

  get _fitLeft() {
    let fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  }

  get _fitTop() {
    let fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  }

  /**
   * The element that should be used to position the element,
   * if no position target is configured.
   */
  get _defaultPositionTarget() {
    let parent = this.parentNode;
    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }

    return parent;
  }

  /**
   * The horizontal align value, accounting for the RTL/LTR text direction.
   */
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      // In RTL, "left" becomes "right".
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  }

  /**
   * True if the element should be positioned instead of centered.
   * @private
   */
  get __shouldPosition() {
    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;
  }

  get 'sizing-target'() {
    return this.sizingTarget;
  }

  set 'sizing-target'(value) {
    this.sizingTarget = value;
  }

  get 'fit-into'() {
    return this.fitInto;
  }

  set 'fit-into'(value) {
    this.fitInto = value;
  }

  get _oldNoOverlap() {
    return this.noOverlap;
  }

  set _oldNoOverlap(value) {
    this.noOverlap = value;
  }

  get 'position-target'() {
    return this.positionTarget;
  }

  set 'position-target'(value) {
    this.positionTarget = value;
  }

  get 'horizontal-align'() {
    return this.horizontalAlign;
  }

  set 'horizontal-align'(value) {
    this.horizontalAlign = value;
  }

  get _oldHorizontalAlign() {
    return this.horizontalAlign;
  }

  set _oldHorizontalAlign(value) {
    this.horizontalAlign = value;
  }

  get 'vertical-align'() {
    return this.verticalAlign;
  }

  set 'vertical-align'(value) {
    this.verticalAlign = value;
  }

  get _oldVerticalAlign() {
    return this.verticalAlign;
  }

  set _oldVerticalAlign(value) {
    this.verticalAlign = value;
  }

  get _oldDynamicAlign() {
    return this.dynamicAlign;
  }

  set _oldDynamicAlign(value) {
    this.dynamicAlign = value;
  }

  get _oldHorizontalOffset() {
    return this.horizontalOffset;
  }

  set _oldHorizontalOffset(value) {
    this.horizontalOffset = value;
  }

  get 'horizontal-offset'() {
    return this.horizontalOffset;
  }

  set 'horizontal-offset'(value) {
    this.horizontalOffset = value;
  }

  get _oldVerticalOffset() {
    return this.verticalOffset;
  }

  set _oldVerticalOffset(value) {
    this.verticalOffset = value;
  }

  get 'vertical-offset'() {
    return this.verticalOffset;
  }

  set 'vertical-offset'(value) {
    this.verticalOffset = value;
  }

  get _oldAutoFitOnAttach() {
    return this.autoFitOnAttach;
  }

  set _oldAutoFitOnAttach(value) {
    this.autoFitOnAttach = value;
  }

  connectedCallback() {
    super.connectedCallback();
    // Memoize this to avoid expensive calculations & relayouts.
    // Make sure we do it only once
    if (typeof this._isRTL === 'undefined') {
      this._isRTL = window.getComputedStyle(this).direction === 'rtl';
    }
    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      setTimeout(() => this.fit());
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.__deferredFit) {
      clearTimeout(this.__deferredFit);
      this.__deferredFit = null;
    }
  }

  /**
   * Positions and fits the element into the `fitInto` element.
   */
  fit() {
    this.position();
    this.constrain();
    this.center();
  }

  /**
   * Memoize information needed to position and size the target element.
   * @suppress {deprecated}
   */
  _discoverInfo() {
    if (this._fitInfo) {
      return;
    }
    const target = window.getComputedStyle(this);
    const sizer = window.getComputedStyle(this.sizingTarget);

    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ?
            'top' :
            (target.bottom !== 'auto' ? 'bottom' : null),
        horizontally: target.left !== 'auto' ?
            'left' :
            (target.right !== 'auto' ? 'right' : null)
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  }

  /**
   * Resets the target element's position and size constraints, and clear
   * the memoized data.
   */
  resetFit() {
    const info = this._fitInfo || {};
    if (info.sizerInlineStyle) {
      Object.keys(info.sizerInlineStyle).forEach((property) => {
        this.sizingTarget.style[property] = info.sizerInlineStyle[property];
      });
    }
    if (info.inlineStyle) {
      Object.keys(info.inlineStyle).forEach((property) => {
        this.style[property] = info.inlineStyle[property];
      });
    }
    this._fitInfo = null;
  }

  /**
   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after
   * the element or the `fitInto` element has been resized, or if any of the
   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.
   * It preserves the scroll position of the sizingTarget.
   */
  refit() {
    const scrollLeft = this.sizingTarget.scrollLeft;
    const scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  }

  /**
   * Positions the element according to `horizontalAlign, verticalAlign`.
   */
  position() {
    if (!this.__shouldPosition) {
      // needs to be centered, and it is done after constrain.
      return;
    }
    this._discoverInfo();

    this.style.position = 'fixed';
    // Need border-box for margin/padding.
    this.sizingTarget.style.boxSizing = 'border-box';
    // Set to 0, 0 in order to discover any offset caused by parent stacking
    // contexts.
    this.style.left = '0px';
    this.style.top = '0px';

    const rect = this.getBoundingClientRect();
    const positionRect = this.__getNormalizedRect(this.positionTarget);
    const fitRect = this.__getNormalizedRect(this.fitInto);

    const margin = this._fitInfo.margin;

    // Consider the margin as part of the size for position calculations.
    const size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };

    const position = this.__getPosition(
        this._localeHorizontalAlign,
        this.verticalAlign,
        size,
        rect,
        positionRect,
        fitRect);

    let left = position.left + margin.left;
    let top = position.top + margin.top;

    // We first limit right/bottom within fitInto respecting the margin,
    // then use those values to limit top/left.
    const right = Math.min(fitRect.right - margin.right, left + rect.width);
    const bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);

    // Keep left/top within fitInto respecting the margin.
    left = Math.max(
        fitRect.left + margin.left,
        Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(
        fitRect.top + margin.top,
        Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));

    // Use right/bottom to set maxWidth/maxHeight, and respect
    // minWidth/minHeight.
    this.sizingTarget.style.maxWidth =
        Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
    this.sizingTarget.style.maxHeight =
        Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';

    // Remove the offset caused by any stacking context.
    this.style.left = (left - rect.left) + 'px';
    this.style.top = (top - rect.top) + 'px';
  }

  /**
   * Constrains the size of the element to `fitInto` by setting `max-height`
   * and/or `max-width`.
   */
  constrain() {
    if (this.__shouldPosition) {
      return;
    }
    this._discoverInfo();

    const info = this._fitInfo;
    // position at (0px, 0px) if not already positioned, so we can measure the
    // natural size.
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }

    // need border-box for margin/padding
    this.sizingTarget.style.boxSizing = 'border-box';
    // constrain the width and height if not already set
    const rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(
          rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(
          rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  }

  __sizeDimension(rect, positionedBy, start, end, extent) {
    const info = this._fitInfo;
    const fitRect = this.__getNormalizedRect(this.fitInto);
    const max = extent === 'Width' ? fitRect.width : fitRect.height;
    const flip = (positionedBy === end);
    const offset = flip ? max - rect[end] : rect[start];
    const margin = info.margin[flip ? start : end];
    const offsetExtent = 'offset' + extent;
    const sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] =
        (max - margin - offset - sizingOffset) + 'px';
  }

  /**
   * Centers horizontally and vertically if not already positioned. This also
   * sets `position:fixed`.
   */
  center() {
    if (this.__shouldPosition) {
      return;
    }
    this._discoverInfo();

    const positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      // Already positioned.
      return;
    }
    // Need position:fixed to center
    this.style.position = 'fixed';
    // Take into account the offset caused by parents that create stacking
    // contexts (e.g. with transform: translate3d). Translate to 0,0 and
    // measure the bounding rect.
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    // It will take in consideration margins and transforms
    const rect = this.getBoundingClientRect();
    const fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      const top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      const left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  }

  __getNormalizedRect(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  }

  __getOffscreenArea(position, size, fitRect) {
    const verticalCrop = Math.min(0, position.top) +
        Math.min(0, fitRect.bottom - (position.top + size.height));
    const horizontalCrop = Math.min(0, position.left) +
        Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width +
        Math.abs(horizontalCrop) * size.height;
  }

  __getPosition(hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {
    // All the possible configurations.
    // Ordered as top-left, top-right, bottom-left, bottom-right.
    const positions = [
      {
        verticalAlign: 'top',
        horizontalAlign: 'left',
        top: positionRect.top + this.verticalOffset,
        left: positionRect.left + this.horizontalOffset
      },
      {
        verticalAlign: 'top',
        horizontalAlign: 'right',
        top: positionRect.top + this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset
      },
      {
        verticalAlign: 'bottom',
        horizontalAlign: 'left',
        top: positionRect.bottom - size.height - this.verticalOffset,
        left: positionRect.left + this.horizontalOffset
      },
      {
        verticalAlign: 'bottom',
        horizontalAlign: 'right',
        top: positionRect.bottom - size.height - this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset
      }
    ];

    if (this.noOverlap) {
      // Duplicate.
      for (let i = 0, l = positions.length; i < l; i++) {
        const copy = {};
        const keys = Object.keys(positions[i]);
        for (let j = 0, lk = keys.length; j < lk; j++) {
          const key = keys[j];
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      // Horizontal overlap only.
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      // Vertical overlap only.
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }

    // Consider auto as null for coding convenience.
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;

    if (!hAlign || hAlign === 'center') {
      positions.push({
        verticalAlign: 'top',
        horizontalAlign: 'center',
        top: positionRect.top + this.verticalOffset +
            (this.noOverlap ? positionRect.height : 0),
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
      positions.push({
        verticalAlign: 'bottom',
        horizontalAlign: 'center',
        top: positionRect.bottom - size.height - this.verticalOffset -
            (this.noOverlap ? positionRect.height : 0),
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
    }

    if (!vAlign || vAlign === 'middle') {
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'left',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.left + this.horizontalOffset +
            (this.noOverlap ? positionRect.width : 0)
      });
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'right',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset -
            (this.noOverlap ? positionRect.width : 0)
      });
    }

    if (vAlign === 'middle' && hAlign === 'center') {
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'center',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
    }

    let position;
    for (let i = 0; i < positions.length; i++) {
      const candidate = positions[i];
      const vAlignOk = candidate.verticalAlign === vAlign;
      const hAlignOk = candidate.horizontalAlign === hAlign;

      // If both vAlign and hAlign are defined, return exact match.
      // For dynamicAlign and noOverlap we'll have more than one candidate, so
      // we'll have to check the offscreenArea to make the best choice.
      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {
        position = candidate;
        break;
      }

      // Align is ok if alignment preferences are respected. If no preferences,
      // it is considered ok.
      const alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);

      // Filter out elements that don't match the alignment (if defined).
      // With dynamicAlign, we need to consider all the positions to find the
      // one that minimizes the cropped area.
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }

      candidate.offscreenArea =
          this.__getOffscreenArea(candidate, size, fitRect);
      // If not cropped and respects the align requirements, keep it.
      // This allows to prefer positions overlapping horizontally over the
      // ones overlapping vertically.
      if (candidate.offscreenArea === 0 && alignOk) {
        position = candidate;
        break;
      }
      position = position || candidate;
      const diff = candidate.offscreenArea - position.offscreenArea;
      // Check which crops less. If it crops equally, check if at least one
      // align setting is ok.
      if (diff < 0 || (diff === 0 && (vAlignOk || hAlignOk))) {
        position = candidate;
      }
    }

    return position;
  }
};

// Contains all connected resizables that do not have a parent.
const ORPHANS = new Set();
/**
 * This mixin is a port of [IronResizableBehavior]https://github.com/PolymerElements/iron-resizable-behavior
 * that works with LitElement.
 *
 * `ArcResizableMixin` is a behavior that can be used in web components to
 * coordinate the flow of resize events between "resizers" (elements that
 * control the size or hidden state of their children) and "resizables" (elements
 * that need to be notified when they are resized or un-hidden by their parents
 * in order to take action on their new measurements).
 *
 * Elements that perform measurement should add the `ArcResizableMixin`
 * mixin to their element definition and listen for the `iron-resize` event on
 * themselves. This event will be fired when they become showing after having
 * been hidden, when they are resized explicitly by another resizable, or when
 * the window has been resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * ## Usage
 *
 * ```javascript
 * import { LitElement } from 'lit-element';
 * import { ArcResizableMixin } from '@advanced-rest-client/arc-resizable-mixin.js';
 *
 * class ArcResizableImpl extends ArcResizableMixin(LitElement) {
 *  ...
 * }
 * ```
 *
 * @param {Class} superClass
 * @return {Class}
 */
const ArcResizableMixin = (superClass) => class extends superClass {
  /**
   * The closest ancestor element that implements `ArcResizableMixin`.
   */
  get _parentResizable() {
    return this.__parentResizable;
  }

  set _parentResizable(value) {
    const old = this.__parentResizable;
    this.__parentResizable = value;
    if (old !== value) {
      this._parentResizableChanged(value);
    }
  }

  get _notifyingDescendant() {
    return this.__notifyingDescendant;
  }

  set _notifyingDescendant(value) {
    this.__notifyingDescendant = value;
  }

  constructor() {
    super();
    this._interestedResizables = [];
    this._notifyingDescendant = false;
    this._onIronRequestResizeNotifications = this._onIronRequestResizeNotifications.bind(this);
    this.notifyResize = this.notifyResize.bind(this);
    this._onDescendantIronResize = this._onDescendantIronResize.bind(this);
    this.addEventListener('iron-request-resize-notifications', this._onIronRequestResizeNotifications, true);
  }

  connectedCallback() {
    super.connectedCallback();
    this.isAttached = true;
    setTimeout(() => {
      this._requestResizeNotifications();
    });
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.isAttached = false;
    // this.removeEventListener('iron-request-resize-notifications', this._onIronRequestResizeNotifications);
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      ORPHANS.delete(this);
      window.removeEventListener('resize', this.notifyResize);
    }

    this._parentResizable = null;
  }

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize() {
    if (!this.isAttached) {
      return;
    }
    this._interestedResizables.forEach((resizable) => {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    });
    this._fireResize();
  }

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   *
   * @param {Element} parentResizable
   */
  assignParentResizable(parentResizable) {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    }

    this._parentResizable = parentResizable;

    if (parentResizable &&
        parentResizable._interestedResizables.indexOf(this) === -1) {
      parentResizable._interestedResizables.push(this);
      parentResizable._subscribeIronResize(this);
    }
  }

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   *
   * @param {Element} target
   */
  stopResizeNotificationsFor(target) {
    const index = this._interestedResizables.indexOf(target);
    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this._unsubscribeIronResize(target);
    }
  }

  /**
   * Subscribe this element to listen to iron-resize events on the given target.
   *
   * Preferred over target.listen because the property renamer does not
   * understand to rename when the target is not specifically "this"
   *
   * @param {!HTMLElement} target Element to listen to for iron-resize events.
   */
  _subscribeIronResize(target) {
    target.addEventListener('iron-resize', this._onDescendantIronResize);
  }

  /**
   * Unsubscribe this element from listening to to iron-resize events on the
   * given target.
   *
   * Preferred over target.unlisten because the property renamer does not
   * understand to rename when the target is not specifically "this"
   *
   * @param {!HTMLElement} target Element to listen to for iron-resize events.
   */
  _unsubscribeIronResize(target) {
    target.removeEventListener('iron-resize', this._onDescendantIronResize);
  }

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify() {
    return true;
  }

  _onDescendantIronResize(e) {
    if (this._notifyingDescendant) {
      e.stopPropagation();
      return;
    }
    this._fireResize();
  }

  _fireResize() {
    this.dispatchEvent(new CustomEvent('iron-resize'));
  }

  _onIronRequestResizeNotifications(e) {
    const cp = e.composedPath && e.composedPath();
    const path = cp ? cp : e.path || [];
    const target = path[0];
    if (target === this) {
      return;
    }
    target.assignParentResizable(this);
    this._notifyDescendant(target);
    e.stopPropagation();
  }

  _parentResizableChanged(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this.notifyResize);
    }
  }

  _notifyDescendant(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  }

  _requestResizeNotifications() {
    if (!this.isAttached) {
      return;
    }

    if (document.readyState === 'loading') {
      const _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener(
          'readystatechange', function readystatechanged() {
            document.removeEventListener('readystatechange', readystatechanged);
            _requestResizeNotifications();
          });
    } else {
      this._findParent();

      if (!this._parentResizable) {
        // If this resizable is an orphan, tell other orphans to try to find
        // their parent again, in case it's this resizable.
        ORPHANS.forEach((orphan) => {
          if (orphan !== this) {
            orphan._findParent();
          }
        });

        window.addEventListener('resize', this.notifyResize);
        this.notifyResize();
      } else {
        // If this resizable has a parent, tell other child resizables of
        // that parent to try finding their parent again, in case it's this
        // resizable.
        this._parentResizable._interestedResizables
            .forEach((resizable) => {
              if (resizable !== this) {
                resizable._findParent();
              }
            });
      }
    }
  }

  _findParent() {
    this.assignParentResizable(null);
    this.dispatchEvent(new CustomEvent('iron-request-resize-notifications', {
      bubbles: true,
      cancelable: true,
      composed: true
    }));

    if (!this._parentResizable) {
      ORPHANS.add(this);
    } else {
      ORPHANS.delete(this);
    }
  }
};

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

const p$1 = Element.prototype;
const matches$1 = p$1.matches || p$1.matchesSelector || p$1.mozMatchesSelector ||
    p$1.msMatchesSelector || p$1.oMatchesSelector || p$1.webkitMatchesSelector;

class ArcFocusablesHelper {
  /**
   * Returns a sorted array of tabbable nodes, including the root node.
   * It searches the tabbable nodes in the light and shadow dom of the chidren,
   * sorting the result by tabindex.
   * @param {!Node} node
   * @return {!Array<!HTMLElement>}
   */
  getTabbableNodes(node) {
    const result = [];
    // If there is at least one element with tabindex > 0, we need to sort
    // the final array by tabindex.
    const needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  }

  /**
   * Returns if a element is focusable.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isFocusable(element) {
    // From http://stackoverflow.com/a/1600194/4228703:
    // There isn't a definite list, it's up to the browser. The only
    // standard we have is DOM Level 2 HTML
    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the
    // only elements that have a focus() method are HTMLInputElement,
    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This
    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these
    // tests with tabbables in different browsers
    // http://allyjs.io/data-tables/focusable.html

    // Elements that cannot be focused if they have [disabled] attribute.
    if (matches$1.call(element, 'input, select, textarea, button, object')) {
      return matches$1.call(element, ':not([disabled])');
    }
    // Elements that can be focused even if they have [disabled] attribute.
    return matches$1.call(
        element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');
  }

  /**
   * Returns if a element is tabbable. To be tabbable, a element must be
   * focusable, visible, and with a tabindex !== -1.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isTabbable(element) {
    return this.isFocusable(element) &&
        matches$1.call(element, ':not([tabindex="-1"])') &&
        this._isVisible(element);
  }

  /**
   * Returns the normalized element tabindex. If not focusable, returns -1.
   * It checks for the attribute "tabindex" instead of the element property
   * `tabIndex` since browsers assign different values to it.
   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
   * @param {!HTMLElement} element
   * @return {!number}
   * @private
   */
  _normalizedTabIndex(element) {
    if (this.isFocusable(element)) {
      const tabIndex = element.getAttribute('tabindex') || 0;
      return Number(tabIndex);
    }
    return -1;
  }

  /**
   * Searches for nodes that are tabbable and adds them to the `result` array.
   * Returns if the `result` array needs to be sorted by tabindex.
   * @param {!Node} node The starting point for the search; added to `result`
   * if tabbable.
   * @param {!Array<!HTMLElement>} result
   * @return {boolean}
   * @private
   */
  _collectTabbableNodes(node, result) {
    // If not an element or not visible, no need to explore children.
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    const element = /** @type {!HTMLElement} */ (node);
    if (result.indexOf(element) !== -1) {
      return false;
    }
    if (!this._isVisible(element)) {
      return false;
    }
    const tabIndex = this._normalizedTabIndex(element);
    let needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }
    // In ShadowDOM v1, tab order is affected by the order of distrubution.
    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
    // in ShadowDOM v0 tab order is not affected by the distrubution order,
    // in fact getTabbableNodes(#root) returns [#B, #A].
    //  <div id="root">
    //   <!-- shadow -->
    //     <slot name="a">
    //     <slot name="b">
    //   <!-- /shadow -->
    //   <input id="A" slot="a">
    //   <input id="B" slot="b" tabindex="1">
    //  </div>
    let children;
    if (element.localName === 'slot') {
      children = element.assignedNodes().filter((node) => node.nodeType === Node.ELEMENT_NODE);
    } else {
      // Use shadow root if possible, will check for distributed nodes.
      if (element.shadowRoot && element.shadowRoot.querySelectorAll) {
        children = element.shadowRoot.querySelectorAll('*');
      } else {
        children = element.children;
      }
    }
    for (let i = 0; i < children.length; i++) {
      // Ensure method is always invoked to collect tabbable children.
      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
    }
    return needsSort;
  }

  /**
   * Returns false if the element has `visibility: hidden` or `display: none`
   * @param {!HTMLElement} element
   * @return {boolean}
   * @private
   */
  _isVisible(element) {
    // Check inline style first to save a re-flow. If looks good, check also
    // computed style.
    let style = element.style;
    if (style.visibility !== 'hidden' && style.display !== 'none') {
      style = window.getComputedStyle(element);
      return (style.visibility !== 'hidden' && style.display !== 'none');
    }
    return false;
  }

  /**
   * Sorts an array of tabbable elements by tabindex. Returns a new array.
   * @param {!Array<!HTMLElement>} tabbables
   * @return {!Array<!HTMLElement>}
   * @private
   */
  _sortByTabIndex(tabbables) {
    // Implement a merge sort as Array.prototype.sort does a non-stable sort
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    const len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    const pivot = Math.ceil(len / 2);
    const left = this._sortByTabIndex(tabbables.slice(0, pivot));
    const right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  }

  /**
   * Merge sort iterator, merges the two arrays into one, sorted by tab index.
   * @param {!Array<!HTMLElement>} left
   * @param {!Array<!HTMLElement>} right
   * @return {!Array<!HTMLElement>}
   * @private
   */
  _mergeSortByTabIndex(left, right) {
    const result = [];
    while ((left.length > 0) && (right.length > 0)) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }

    return result.concat(left, right);
  }

  /**
   * Returns if element `a` has lower tab order compared to element `b`
   * (both elements are assumed to be focusable and tabbable).
   * Elements with tabindex = 0 have lower tab order compared to elements
   * with tabindex > 0.
   * If both have same tabindex, it returns false.
   * @param {!HTMLElement} a
   * @param {!HTMLElement} b
   * @return {boolean}
   * @private
   */
  _hasLowerTabOrder(a, b) {
    // Normalize tabIndexes
    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
    const ati = Math.max(a.tabIndex, 0);
    const bti = Math.max(b.tabIndex, 0);
    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;
  }
}

const ArcFocusablesHelper$1 = new ArcFocusablesHelper();

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/*
`arc-overlay-backdrop` is a backdrop used by `ArcOverlayMixin`. It
should be a singleton.

Originally designed by the Polymer team, ported to LitElement by ARC team.

### Styling

The following custom properties and mixins are available for styling.

Custom property | Description | Default
-------------------------------------------|------------------------|---------
`--iron-overlay-backdrop-background-color` | Backdrop background color | #000
`--iron-overlay-backdrop-opacity`          | Backdrop opacity | 0.6
`--iron-overlay-backdrop`                  | Mixin applied to `iron-overlay-backdrop`.                      | {}
`--iron-overlay-backdrop-opened`           | Mixin applied to `iron-overlay-backdrop` when it is displayed | {}
*/
class ArcOverlayBackdrop extends LitElement {
  static get styles() {
    return css`
    :host {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--arc-overlay-backdrop-background-color,
        var(--iron-overlay-backdrop-background-color, #000));
      opacity: 0;
      transition: var(--arc-overlay-backdrop-transition, opacity 0.2s);
      pointer-events: none;
    }

    :host(.opened) {
      opacity: var(--arc-overlay-backdrop-opacity, var(--iron-overlay-backdrop-opacity, 0.6));
      pointer-events: auto;
    }`;
  }

  static get properties() {
    return {
      opened: { type: Boolean, reflect: true }
    };
  }

  get opened() {
    return this.__opened;
  }

  set opened(value) {
    const old = this.__opened;
    if (old === value) {
      return;
    }
    this.__opened = value;
    this._openedChanged(value, old);
  }

  constructor() {
    super();
    this.opened = false;
    // Used to cancel previous requestAnimationFrame calls when opened changes.
    this.__openedRaf = null;

    this._onTransitionend = this._onTransitionend.bind(this);
  }

  connectedCallback() {
    this.isAttached = true;
    super.connectedCallback();
    this.addEventListener('transitionend', this._onTransitionend, true);
    if (this.opened) {
      this._openedChanged(this.opened);
    }
  }

  disconnectedCallback() {
    this.isAttached = false;
    super.disconnectedCallback();
    this.removeEventListener('transitionend', this._onTransitionend);
  }

  /**
   * Appends the backdrop to document body if needed.
   */
  prepare() {
    if (this.opened && !this.parentNode) {
      document.body.appendChild(this);
    }
  }

  /**
   * Shows the backdrop.
   */
  open() {
    this.opened = true;
  }

  /**
   * Hides the backdrop.
   */
  close() {
    this.opened = false;
  }

  /**
   * Removes the backdrop from document body if needed.
   */
  complete() {
    if (!this.opened && this.parentNode === document.body) {
      this.parentNode.removeChild(this);
    }
  }

  _onTransitionend(e) {
    if (e && e.target === this) {
      this.complete();
    }
  }

  /**
   * @param {boolean} opened
   * @private
   */
  _openedChanged(opened) {
    if (opened) {
      // Auto-attach.
      this.prepare();
    } else {
      // Animation might be disabled via the mixin or opacity custom property.
      // If it is disabled in other ways, it's up to the user to call complete.
      const cs = window.getComputedStyle(this);
      if (cs.transitionDuration === '0s' || cs.opacity === 0) {
        this.complete();
      }
    }

    if (!this.isAttached) {
      return;
    }

    // Always cancel previous requestAnimationFrame.
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    // Force relayout to ensure proper transitions.
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(() => {
      this.__openedRaf = null;
      this.toggleClass('opened', this.opened);
    });
  }
  /**
   * Toggles clas on this element.
   * @param {String} klass CSS class name to toggle
   * @param {Boolean} cond Boolean condition to test whether the class should be
   * added or removwed.
   */
  toggleClass(klass, cond) {
    if (cond) {
      if (!this.classList.contains(klass)) {
        this.classList.add(klass);
      }
    } else {
      if (this.classList.contains(klass)) {
        this.classList.remove(klass);
      }
    }
  }

  render() {
    return html`<slot></slot>`;
  }
}

window.customElements.define('arc-overlay-backdrop', ArcOverlayBackdrop);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * The class was originallt designed by Polymer team.
 * @struct
 * @constructor
 */
class ArcOverlayManager {
  constructor() {
    /**
     * Used to keep track of the opened overlays.
     * @private {!Array<!Element>}
     */
    this._overlays = [];

    /**
     * iframes have a default z-index of 100,
     * so this default should be at least that.
     * @private {number}
     */
    this._minimumZ = 101;

    /**
     * Memoized backdrop element.
     * @private {Element|null}
     */
    this._backdropElement = null;

    // Enable document-wide tap recognizer.
    // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
    // of an overlay via event.stopPropagation(). The only way to prevent
    // closing of an overlay should be through its APIs.
    // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
    // Pass no-op function because MSEdge 15 doesn't handle null as 2nd argument
    // https://github.com/Microsoft/ChakraCore/issues/3863
    document.documentElement.addEventListener('click', function() {});
    document.addEventListener('click', this._onCaptureClick.bind(this), true);
    document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
    document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
  }

  /**
   * The shared backdrop element.
   * @return {!Element} backdropElement
   */
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('arc-overlay-backdrop');
    }
    return this._backdropElement;
  }

  /**
   * The deepest active element.
   * @return {!Element} activeElement the active element
   */
  get deepActiveElement() {
    let active = document.activeElement;
    // document.activeElement can be null
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
    // In IE 11, it can also be an object when operating in iframes.
    // In these cases, default it to document.body.
    if (!active || active instanceof Element === false) {
      active = document.body;
    }
    while (active.shadowRoot && active.shadowRoot.activeElement) {
      active = active.shadowRoot.activeElement;
    }
    return active;
  }

  /**
   * Brings the overlay at the specified index to the front.
   * @param {number} i
   * @private
   */
  _bringOverlayAtIndexToFront(i) {
    const overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    let lastI = this._overlays.length - 1;
    const currentOverlay = this._overlays[lastI];
    // Ensure always-on-top overlay stays on top.
    if (currentOverlay &&
        this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    // If already the top element, return.
    if (i >= lastI) {
      return;
    }
    // Update z-index to be on top.
    const minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }

    // Shift other overlays behind the new on top.
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  }

  /**
   * Adds the overlay and updates its z-index if it's opened, or removes it if
   * it's closed. Also updates the backdrop z-index.
   * @param {!Element} overlay
   */
  addOrRemoveOverlay(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  }

  /**
   * Tracks overlays for z-index and focus management.
   * Ensures the last added overlay with always-on-top remains on top.
   * @param {!Element} overlay
   */
  addOverlay(overlay) {
    const i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    let insertionIndex = this._overlays.length;
    const currentOverlay = this._overlays[insertionIndex - 1];
    let minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    const newZ = this._getZ(overlay);

    // Ensure always-on-top overlay stays on top.
    if (currentOverlay &&
        this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      // This bumps the z-index of +2.
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      // Update minimumZ to match previous overlay's z-index.
      const previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }

    // Update z-index and insert overlay.
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);

    this.trackBackdrop();
  }

  /**
   * @param {!Element} overlay
   */
  removeOverlay(overlay) {
    const i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);

    this.trackBackdrop();
  }

  /**
   * Returns the current overlay.
   * @return {!Element|undefined}
   */
  currentOverlay() {
    const i = this._overlays.length - 1;
    return this._overlays[i];
  }

  /**
   * Returns the current overlay z-index.
   * @return {number}
   */
  currentOverlayZ() {
    return this._getZ(this.currentOverlay());
  }

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   * @param {number} minimumZ
   */
  ensureMinimumZ(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  }

  focusOverlay() {
    const current = /** @type {?} */ (this.currentOverlay());
    if (current) {
      current._applyFocus();
    }
  }

  /**
   * Updates the backdrop z-index.
   */
  trackBackdrop() {
    const overlay = this._overlayWithBackdrop();
    // Avoid creating the backdrop if there is no overlay with backdrop.
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
    // Property observers are not fired until element is attached
    // in Polymer 2.x, so we ensure element is attached if needed.
    // https://github.com/Polymer/polymer/issues/4526
    this.backdropElement.prepare();
  }

  /**
   * @return {!Array<!Element>}
   */
  getBackdrops() {
    const backdrops = [];
    for (let i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  }

  /**
   * Returns the z-index for the backdrop.
   * @return {number}
   */
  backdropZ() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  }

  /**
   * Returns the top opened overlay that has a backdrop.
   * @return {!Element|undefined}
   * @private
   */
  _overlayWithBackdrop() {
    for (let i = this._overlays.length - 1; i >= 0; i--) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  }

  /**
   * Calculates the minimum z-index for the overlay.
   *
   * @param {Element=} overlay
   * @return {Number}
   * @private
   */
  _getZ(overlay) {
    let z = this._minimumZ;
    if (overlay) {
      const z1 = Number(
          overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  }

  /**
   * @param {!Element} element
   * @param {number|string} z
   * @private
   */
  _setZ(element, z) {
    element.style.zIndex = z;
  }

  /**
   * @param {!Element} overlay
   * @param {number} aboveZ
   * @private
   */
  _applyOverlayZ(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  }

  /**
   * Returns the deepest overlay in the path.
   * @param {!Array<!Element>=} path
   * @return {!Element|undefined}
   * @suppress {missingProperties}
   * @private
   */
  _overlayInPath(path) {
    path = path || [];
    for (let i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  }

  /**
   * Ensures the click event is delegated to the right overlay.
   * @param {!Event} e
   * @private
   */
  _onCaptureClick(e) {
    let i = this._overlays.length - 1;
    if (i === -1) {
      return;
    }
    const cp = e.composedPath && e.composedPath();
    const path = /** @type {!Array<!EventTarget>} */ cp ? cp : e.path;
    let overlay;
    // Check if clicked outside of overlay.
    while ((overlay = /** @type {?} */ (this._overlays[i])) &&
           this._overlayInPath(path) !== overlay) {
      overlay._onCaptureClick(e);
      if (overlay.allowClickThrough) {
        i--;
      } else {
        break;
      }
    }
  }

  /**
   * Ensures the focus event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureFocus(event) {
    const overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  }

  /**
   * Ensures TAB and ESC keyboard events are delegated to the right overlay.
   * @param {!Event} e
   * @private
   */
  _onCaptureKeyDown(e) {
    const overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      if (this._keyboardEventMatchesKeys(e, 'Escape')) {
        overlay._onCaptureEsc(e);
      } else if (this._keyboardEventMatchesKeys(e, 'Tab')) {
        overlay._onCaptureTab(e);
      }
    }
  }

  _keyboardEventMatchesKeys(e, key) {
    if (e.key && e.key === key) {
      return true;
    }
    if (e.detail && e.detail.key === key) {
      return true;
    }
  }

  /**
   * Returns if the overlay1 should be behind overlay2.
   * @param {!Element} overlay1
   * @param {!Element} overlay2
   * @return {boolean}
   * @suppress {missingProperties}
   * @private
   */
  _shouldBeBehindOverlay(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
}

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const ArcOverlayManager$1 = new ArcOverlayManager();

/* istanbul ignore file */
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Used to calculate the scroll direction during touch events.
 * @type {!Object}
 */
const lastTouchPosition = { pageX: 0, pageY: 0 };
/**
 * Used to avoid computing event.path and filter scrollable nodes (better perf).
 * @type {?EventTarget}
 */
let lastRootTarget = null;
/**
 * @type {!Array<!Node>}
 */
let lastScrollableNodes = [];
/**
 * @type {!Array<string>}
 */
const scrollEvents = [
  // Modern `wheel` event for mouse wheel scrolling:
  'wheel',
  // Older, non-standard `mousewheel` event for some FF:
  'mousewheel',
  // IE:
  'DOMMouseScroll',
  // Touch enabled devices
  'touchstart',
  'touchmove'
];
// must be defined for modulizer
let _boundScrollHandler;
let currentLockingElement;

const _lockingElements = [];

/**
 * Returns scroll `deltaX` and `deltaY`.
 * @param {!Event} event The scroll event
 * @return {{deltaX: number, deltaY: number}} Object containing the
 * x-axis scroll delta (positive: scroll right, negative: scroll left,
 * 0: no scroll), and the y-axis scroll delta (positive: scroll down,
 * negative: scroll up, 0: no scroll).
 * @package
 */
function _getScrollInfo(event) {
  const info = { deltaX: event.deltaX, deltaY: event.deltaY };
  // Already available.
  if ('deltaX' in event) ; else if ('wheelDeltaX' in event && 'wheelDeltaY' in event) {
    // Safari has scroll info in `wheelDeltaX/Y`.
    info.deltaX = -event.wheelDeltaX;
    info.deltaY = -event.wheelDeltaY;
  } else if ('wheelDelta' in event) {
    // IE10 has only vertical scroll info in `wheelDelta`.
    info.deltaX = 0;
    info.deltaY = -event.wheelDelta;
  } else if ('axis' in event) {
    // Firefox has scroll info in `detail` and `axis`.
    info.deltaX = event.axis === 1 ? event.detail : 0;
    info.deltaY = event.axis === 2 ? event.detail : 0;
  } else if (event.targetTouches) {
    // On mobile devices, calculate scroll direction.
    const touch = event.targetTouches[0];
    // Touch moves from right to left => scrolling goes right.
    info.deltaX = lastTouchPosition.pageX - touch.pageX;
    // Touch moves from down to up => scrolling goes down.
    info.deltaY = lastTouchPosition.pageY - touch.pageY;
  }
  return info;
}

/**
 * Returns the node that is scrolling. If there is no scrolling,
 * returns undefined.
 * @param {!Array<!Node>} nodes
 * @param {number} deltaX Scroll delta on the x-axis
 * @param {number} deltaY Scroll delta on the y-axis
 * @return {!Node|undefined}
 * @package
 */
function _getScrollingNode(nodes, deltaX, deltaY) {
  // No scroll.
  if (!deltaX && !deltaY) {
    return;
  }
  // Check only one axis according to where there is more scroll.
  // Prefer vertical to horizontal.
  const verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    let canScroll = false;
    if (verticalScroll) {
      // delta < 0 is scroll up, delta > 0 is scroll down.
      canScroll = deltaY < 0 ?
          node.scrollTop > 0 :
          node.scrollTop < node.scrollHeight - node.clientHeight;
    } else {
      // delta < 0 is scroll left, delta > 0 is scroll right.
      canScroll = deltaX < 0 ?
          node.scrollLeft > 0 :
          node.scrollLeft < node.scrollWidth - node.clientWidth;
    }
    if (canScroll) {
      return node;
    }
  }
}

/**
 * Returns an array of scrollable nodes up to the current locking element,
 * which is included too if scrollable.
 * @param {!Array<!Node>} nodes
 * @return {!Array<!Node>} scrollables
 * @package
 */
function _getScrollableNodes(nodes) {
  const scrollables = [];
  const lockingIndex = nodes.indexOf(currentLockingElement);
  // Loop from root target to locking element (included).
  for (let i = 0; i <= lockingIndex; i++) {
    // Skip non-Element nodes.
    if (nodes[i].nodeType !== Node.ELEMENT_NODE) {
      continue;
    }
    const node = /** @type {!Element} */ (nodes[i]);
    // Check inline style before checking computed style.
    let style = node.style;
    if (style.overflow !== 'scroll' && style.overflow !== 'auto') {
      style = window.getComputedStyle(node);
    }
    if (style.overflow === 'scroll' || style.overflow === 'auto') {
      scrollables.push(node);
    }
  }
  return scrollables;
}

/**
 * Returns true if the event causes scroll outside the current locking
 * element, e.g. pointer/keyboard interactions, or scroll "leaking"
 * outside the locking element when it is already at its scroll boundaries.
 * @param {!Event} event
 * @return {boolean}
 * @package
 */
function _shouldPreventScrolling(event) {
  // Update if root target changed. For touch events, ensure we don't
  // update during touchmove.
  const cp = event.composedPath && event.composedPath();
  const path = cp ? cp : event.path;
  const target = path[0];
  if (event.type !== 'touchmove' && lastRootTarget !== target) {
    lastRootTarget = target;
    lastScrollableNodes = _getScrollableNodes(path);
  }

  // Prevent event if no scrollable nodes.
  if (!lastScrollableNodes.length) {
    return true;
  }
  // Don't prevent touchstart event inside the locking element when it has
  // scrollable nodes.
  if (event.type === 'touchstart') {
    return false;
  }
  // Get deltaX/Y.
  const info = _getScrollInfo(event);
  // Prevent if there is no child that can scroll.
  return !_getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);
}


function _scrollInteractionHandler(event) {
  // Avoid canceling an event with cancelable=false, e.g. scrolling is in
  // progress and cannot be interrupted.
  if (event.cancelable && _shouldPreventScrolling(event)) {
    event.preventDefault();
  }
  // If event has targetTouches (touch event), update last touch position.
  if (event.targetTouches) {
    const touch = event.targetTouches[0];
    lastTouchPosition.pageX = touch.pageX;
    lastTouchPosition.pageY = touch.pageY;
  }
}

function _lockScrollInteractions() {
  _boundScrollHandler = _boundScrollHandler || _scrollInteractionHandler.bind(undefined);
  for (let i = 0, l = scrollEvents.length; i < l; i++) {
    // NOTE: browsers that don't support objects as third arg will
    // interpret it as boolean, hence useCapture = true in this case.
    document.addEventListener(scrollEvents[i], _boundScrollHandler, { capture: true, passive: false });
  }
}

function _unlockScrollInteractions() {
  for (let i = 0, l = scrollEvents.length; i < l; i++) {
    // NOTE: browsers that don't support objects as third arg will
    // interpret it as boolean, hence useCapture = true in this case.
    document.removeEventListener(scrollEvents[i], _boundScrollHandler, { capture: true, passive: false });
  }
}

/**
 * Push an element onto the current scroll lock stack. The most recently
 * pushed element and its children will be considered scrollable. All
 * other elements will not be scrollable.
 *
 * Scroll locking is implemented as a stack so that cases such as
 * dropdowns within dropdowns are handled well.
 *
 * @param {!HTMLElement} element The element that should lock scroll.
 */
function pushScrollLock(element) {
  // Prevent pushing the same element twice
  if (_lockingElements.indexOf(element) >= 0) {
    return;
  }

  if (_lockingElements.length === 0) {
    _lockScrollInteractions();
  }

  _lockingElements.push(element);
  currentLockingElement = _lockingElements[_lockingElements.length - 1];
}

/**
 * Remove an element from the scroll lock stack. The element being
 * removed does not need to be the most recently pushed element. However,
 * the scroll lock constraints only change when the most recently pushed
 * element is removed.
 *
 * @param {!HTMLElement} element The element to remove from the scroll
 * lock stack.
 */
function removeScrollLock(element) {
  const index = _lockingElements.indexOf(element);

  if (index === -1) {
    return;
  }

  _lockingElements.splice(index, 1);
  currentLockingElement = _lockingElements[_lockingElements.length - 1];

  if (_lockingElements.length === 0) {
    _unlockScrollInteractions();
  }
}

/**
 * This mixin is a port of [IronOverlayBehavior](https://github.com/PolymerElements/iron-overlay-behavior)
 * that works with LitElement.
 *
 * Use `ArcOverlayMixin` to implement an element that can be hidden
 * or shown, and displays on top of other content. It includes an optional
 * backdrop, and can be used to implement a variety of UI controls including
 * dialogs and drop downs. Multiple overlays may be displayed at once.
 * See the [demo source
 * code](https://github.com/advanced-rest-client/arc-overlay-mixin/blob/master/demo/simple-overlay.html)
 * for an example.
 *
 * ### Closing and canceling
 *
 * An overlay may be hidden by closing or canceling. The difference between close
 * and cancel is user intent. Closing generally implies that the user
 * acknowledged the content on the overlay. By default, it will cancel whenever
 * the user taps outside it or presses the escape key. This behavior is
 * configurable with the `nocancelonesckey` and the
 * `nocancelonoutsideclick` properties. `close()` should be called explicitly
 * by the implementer when the user interacts with a control in the overlay
 * element. When the dialog is canceled, the overlay fires an
 * 'overlay-canceled' event. Call `preventDefault` on this event to prevent
 * the overlay from closing.
 *
 * ### Positioning
 *
 * By default the element is sized and positioned to fit and centered inside the
 * window. You can position and size it manually using CSS. See `ArcFitMixin`.
 *
 * ### Backdrop
 *
 * Set the `withbackdrop` attribute to display a backdrop behind the overlay.
 * The backdrop is appended to `<body>` and is of type `<arc-overlay-backdrop>`.
 * See its doc page for styling options.
 * In addition, `withbackdrop` will wrap the focus within the content in the
 * light DOM. Override the [`_focusableNodes`
 * getter](#ArcOverlayMixin:property-_focusableNodes) to achieve a
 * different behavior.
 *
 * ### Limitations
 *
 * The element is styled to appear on top of other content by setting its
 * `z-index` property. You must ensure no element has a stacking context with a
 * higher `z-index` than its parent stacking context. You should place this
 * element as a child of `<body>` whenever possible.
 *
 *
 * ## Usage
 *
 * ```javascript
 * import { LitElement } from 'lit-element';
 * import { ArcOverlayMixin } from '@advanced-rest-client/arc-overlay-mixin/arc-overlay-mixin.js';
 *
 * class ArcOverlayImpl extends ArcOverlayMixin(LitElement) {
 *  ...
 * }
 * ```
 *
 * @demo demo/index.html
 * @param {Class} superClass
 * @return {Class}
 */
const ArcOverlayMixin = (superClass) => class extends ArcFitMixin(ArcResizableMixin(superClass)) {
  static get properties() {
    return {
      /**
       * True if the overlay is currently displayed.
       */
      opened: { type: Boolean, reflect: true },
      /**
       * True if the overlay was canceled when it was last closed.
       */
      __canceled: { type: Boolean, reflect: true, attribute: 'canceled' },
      /**
       * Set to true to display a backdrop behind the overlay. It traps the focus
       * within the light DOM of the overlay.
       */
      withBackdrop: { type: Boolean, reflect: true },
      _oldWithBackdrop: { type: Boolean, attribute: 'with-backdrop' },
      /**
       * Set to true to disable auto-focusing the overlay or child nodes with
       * the `autofocus` attribute` when the overlay is opened.
       */
      noAutoFocus: { type: Boolean, reflect: true },
      _oldNoAutoFocus: { type: Boolean, attribute: 'no-auto-focus' },
      /**
       * Set to true to disable canceling the overlay with the ESC key.
       */
      noCancelOnEscKey: { type: Boolean, reflect: true },
      _oldNoCancelOnEscKey: { type: Boolean, attribute: 'no-cancel-on-esc-key' },
      /**
       * Set to true to disable canceling the overlay by clicking outside it.
       */
      noCancelOnOutsideClick: { type: Boolean, reflect: true },
      _oldNoCancelOnOutsideClick: { type: Boolean, attribute: 'no-cancel-on-outside-click' },
      /**
       * Contains the reason(s) this overlay was last closed (see
       * `overlay-closed`). `ArcOverlayMixin` provides the `canceled`
       * reason; implementers of the behavior can provide other reasons in
       * addition to `canceled`.
       */
      closingReason: { type: Object },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       */
      restoreFocusOnClose: { type: Boolean, reflect: true },
      _oldRestoreFocusOnClose: { type: Boolean, attribute: 'restore-focus-on-close' },
      /**
       * Set to true to allow clicks to go through overlays.
       * When the user clicks outside this overlay, the click may
       * close the overlay below.
       */
      allowClickThrough: { type: Boolean, reflect: true },
      _oldAllowClickThrough: { type: Boolean, attribute: 'allow-click-through' },
      /**
       * Set to true to keep overlay always on top.
       */
      alwaysOnTop: { type: Boolean, reflect: true },
      _oldAlwaysOnTop: { type: Boolean, attribute: 'always-on-top' },
      /**
       * Determines which action to perform when scroll outside an opened overlay
       * happens. Possible values: lock - blocks scrolling from happening, refit -
       * computes the new position on the overlay cancel - causes the overlay to
       * close
       */
      scrollAction: { type: String, reflect: true },
      _oldScrollAction: { type: String, attribute: 'scroll-action' },
      /**
       * Shortcut to access to the overlay manager.
       * @private
       * @type {!IronOverlayManagerClass}
       */
      _manager: { type: Object },
      /**
       * The node being focused.
       * @type {?Node}
       */
      _focusedChild: { type: Object }
    };
  }
  /**
   * True if the overlay is currently displayed.
   */
  get opened() {
    return this._opened;
  }

  set opened(value) {
    const old = this._opened;
    if (value === old) {
      return;
    }
    this._opened = value;
    if (this.requestUpdate) {
      this.requestUpdate('opened', old);
    }
    this._openedChanged(value);
    this.__updateScrollObservers(this._isAttached, value, this.scrollAction);
    this.dispatchEvent(new CustomEvent('opened-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * True if the overlay was canceled when it was last closed.
   */
  get canceled() {
    return this.__canceled;
  }

  get _canceled() {
    return this.__canceled;
  }

  set _canceled(value) {
    if (value === this.__canceled) {
      return;
    }
    this.__canceled = value;
    this._canceledChanged(value);
  }

  /**
   * Set to true to display a backdrop behind the overlay. It traps the focus
   * within the light DOM of the overlay.
   */
  get withBackdrop() {
    return this._withBackdrop;
  }

  set withBackdrop(value) {
    const old = this._withBackdrop;
    if (value === old) {
      return;
    }
    this._withBackdrop = value;
    if (this.requestUpdate) {
      this.requestUpdate('withBackdrop', old);
    }
    this._withBackdropChanged(value);
  }

  get _oldWithBackdrop() {
    return this.withBackdrop;
  }

  set _oldWithBackdrop(value) {
    this.withBackdrop = value;
  }

  get _oldNoAutoFocus() {
    return this.noAutoFocus;
  }

  set _oldNoAutoFocus(value) {
    this.noAutoFocus = value;
  }

  get _oldNoCancelOnEscKey() {
    return this.noCancelOnEscKey;
  }

  set _oldNoCancelOnEscKey(value) {
    this.noCancelOnEscKey = value;
  }

  get _oldNoCancelOnOutsideClick() {
    return this.noCancelOnOutsideClick;
  }

  set _oldNoCancelOnOutsideClick(value) {
    this.noCancelOnOutsideClick = value;
  }

  get _oldRestoreFocusOnClose() {
    return this.restoreFocusOnClose;
  }

  set _oldRestoreFocusOnClose(value) {
    this.restoreFocusOnClose = value;
  }

  get _oldAllowClickThrough() {
    return this.allowClickThrough;
  }

  set _oldAllowClickThrough(value) {
    this.allowClickThrough = value;
  }

  get _oldAlwaysOnTop() {
    return this.alwaysOnTop;
  }

  set _oldAlwaysOnTop(value) {
    this.alwaysOnTop = value;
  }

  get _oldScrollAction() {
    return this.scrollAction;
  }

  set _oldScrollAction(value) {
    this.scrollAction = value;
  }

  get 'scroll-action'() {
    return this.scrollAction;
  }

  set 'scroll-action'(value) {
    this.scrollAction = value;
  }

  get isAttached() {
    return this._isAttached;
  }

  set isAttached(value) {
    this._isAttached = value;
    this.__updateScrollObservers(value, this._opened, this.scrollAction);
  }

  get scrollAction() {
    return this._scrollAction;
  }

  set scrollAction(value) {
    this._scrollAction = value;
    this.__updateScrollObservers(this._isAttached, this._opened, value);
  }

  /**
   * The backdrop element.
   * @return {!Element}
   */
  get backdropElement() {
    return this._manager.backdropElement;
  }

  /**
   * Returns the node to give focus to.
   * @return {!Node}
   */
  get _focusNode() {
    return this._focusedChild || this.querySelector('[autofocus]') || this;
  }

  /**
   * Array of nodes that can receive focus (overlay included), ordered by
   * `tabindex`. This is used to retrieve which is the first and last focusable
   * nodes in order to wrap the focus for overlays `with-backdrop`.
   *
   * If you know what is your content (specifically the first and last focusable
   * children), you can override this method to return only `[firstFocusable,
   * lastFocusable];`
   * @return {!Array<!Node>}
   * @protected
   */
  get _focusableNodes() {
    return ArcFocusablesHelper$1.getTabbableNodes(this);
  }
  /**
   * @return {Function} Previously registered handler for `opened-changed` event
   */
  get onopenedchanged() {
    return this['_onopened-changed'];
  }
  /**
   * Registers a callback function for `opened-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onopenedchanged(value) {
    this._registerCallback('opened-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `overlay-canceled` event
   */
  get onoverlaycanceled() {
    return this['_onoverlay-canceled'];
  }
  /**
   * Registers a callback function for `overlay-canceled` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onoverlaycanceled(value) {
    this._registerCallback('overlay-canceled', value);
  }
  /**
   * @return {Function} Previously registered handler for `overlay-opened` event
   */
  get onoverlayopened() {
    return this['_onoverlay-opened'];
  }
  /**
   * Registers a callback function for `overlay-opened` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onoverlayopened(value) {
    this._registerCallback('overlay-opened', value);
  }
  /**
   * @return {Function} Previously registered handler for `overlay-closed` event
   */
  get onoverlayclosed() {
    return this['_onoverlay-closed'];
  }
  /**
   * Registers a callback function for `overlay-closed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onoverlayclosed(value) {
    this._registerCallback('overlay-closed', value);
  }

  constructor() {
    super();
    this._opened = false;
    this._canceled = false;
    this.noAutoFocus = false;
    this.noCancelOnEscKey = false;
    this.noCancelOnOutsideClick = false;
    this.restoreFocusOnClose = false;
    this._manager = ArcOverlayManager$1;

    // Used to skip calls to notifyResize and refit while the overlay is
    // animating.
    this.__isAnimating = false;
    // with-backdrop needs tabindex to be set in order to trap the focus.
    // If it is not set, IronOverlayBehavior will set it, and remove it if
    // with-backdrop = false.
    this.__shouldRemoveTabIndex = false;
    // Used for wrapping the focus on TAB / Shift+TAB.
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    // Used by to keep track of the RAF callbacks.
    this.__rafs = {};
    // Focused node before overlay gets opened. Can be restored on close.
    this.__restoreFocusNode = null;
    // Scroll info to be restored.
    this.__scrollTop = this.__scrollLeft = null;
    // Root nodes hosting the overlay, used to listen for scroll events on them.
    this.__rootNodes = null;

    this._onIronResize = this._onIronResize.bind(this);
    this.__onCaptureScroll = this.__onCaptureScroll.bind(this);
    this._boundSchedule = this._boundSchedule.bind(this);
  }

  connectedCallback() {
    super.connectedCallback();
    this.addEventListener('iron-resize', this._onIronResize);

    if (!this._elementReady) {
      this._elementReady = true;
      this.updateComplete.then(() => {
        this._ensureSetup();
      });
    }

    // Call _openedChanged here so that position can be computed correctly.
    if (this.opened) {
      this._openedChanged(this.opened);
    }
    this._setupSlotListeners();
    this._ensureAria();
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener('iron-resize', this._onIronResize);
    this._removeSlotListeners();

    Object.keys(this.__rafs).forEach((cb) => {
      if (this.__rafs[cb] !== null) {
        cancelAnimationFrame(this.__rafs[cb]);
      }
    });
    this.__rafs = {};
    this._manager.removeOverlay(this);
    // We got detached while animating, ensure we show/hide the overlay
    // and fire overlay-opened/closed event!
    if (this.__isAnimating) {
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        // Restore the focus if necessary.
        this._applyFocus();
        this._finishRenderClosed();
      }
    }
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }

  _setupSlotListeners() {
    const observer = new MutationObserver((mutations) => {
      this._processMutations(mutations);
    });
    this._childrenObserver = observer;
    this._childrenObserver.observe(this, { childList: true });
  }

  _removeSlotListeners() {
    this._unlistenSlots(this.children);
    this._childrenObserver.disconnect();
    this._childrenObserver = null;
  }

  _processMutations(mutations) {
    if (mutations) {
      for (let i=0; i < mutations.length; i++) {
        const mutation = mutations[i];
        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }
        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
      this._onNodesChange();
    }
  }

  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */
  _listenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      const n = nodeList[i];
      if (n.localName === 'slot') {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }

  /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */
  _unlistenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      const n = nodeList[i];
      if (n.localName === 'slot') {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }

  _boundSchedule() {
    setTimeout(() => {
      this._onNodesChange();
    });
  }

  /**
   * Toggle the opened state of the overlay.
   */
  toggle() {
    this._canceled = false;
    this.opened = !this.opened;
  }

  /**
   * Open the overlay.
   */
  open() {
    this._canceled = false;
    this.opened = true;
  }

  /**
   * Close the overlay.
   */
  close() {
    this._canceled = false;
    this.opened = false;
  }

  /**
   * Cancels the overlay.
   * @param {Event=} event The original event
   */
  cancel(event) {
    const detail = {
      cancelable: true,
      bubbles: true,
      composed: true,
      detail: event
    };
    let cancelEvent = new CustomEvent('overlay-canceled', detail);
    this.dispatchEvent(cancelEvent);
    if (cancelEvent.defaultPrevented) {
      return;
    }
    cancelEvent = new CustomEvent('iron-overlay-canceled', detail);
    this.dispatchEvent(cancelEvent);
    if (cancelEvent.defaultPrevented) {
      return;
    }

    this._canceled = true;
    this.opened = false;
  }

  /**
   * Invalidates the cached tabbable nodes. To be called when any of the
   * focusable content changes (e.g. a button is disabled).
   */
  invalidateTabbables() {
    this.__firstFocusableNode = this.__lastFocusableNode = null;
  }

  _ensureSetup() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = 'none';
    this.style.display = 'none';
  }

  /**
   * Called when `opened` changes.
   * @param {boolean=} opened
   * @protected
   */
  _openedChanged(opened) {
    this._ensureAria(opened);
    // Defer any animation-related code on attached
    // (_openedChanged gets called again on attached).
    if (!this.isAttached) {
      return;
    }

    this.__isAnimating = true;

    // Deraf for non-blocking rendering.
    this.__deraf('__openedChanged', this.__openedChanged);
  }

  _ensureAria(opened) {
    if (opened === undefined) {
      opened = this.opened;
    }
    if (opened) {
      this.removeAttribute('aria-hidden');
    } else {
      this.setAttribute('aria-hidden', 'true');
    }
  }

  _canceledChanged() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  }

  _withBackdropChanged() {
    // If tabindex is already set, no need to override it.
    if (this.withBackdrop && !this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '-1');
      this.__shouldRemoveTabIndex = true;
    } else if (this.__shouldRemoveTabIndex) {
      this.removeAttribute('tabindex');
      this.__shouldRemoveTabIndex = false;
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  }

  /**
   * tasks which must occur before opening; e.g. making the element visible.
   * @protected
   */
  _prepareRenderOpened() {
    // Store focused node.
    this.__restoreFocusNode = this._manager.deepActiveElement;

    // Needed to calculate the size of the overlay so that transitions on its
    // size will have the correct starting points.
    this._preparePositioning();
    this.refit();
    this._finishPositioning();

    // Safari will apply the focus to the autofocus element when displayed
    // for the first time, so we make sure to return the focus where it was.
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
      this.__restoreFocusNode.focus();
    }
  }

  /**
   * Tasks which cause the overlay to actually open; typically play an
   * animation.
   * @protected
   */
  _renderOpened() {
    this._finishRenderOpened();
  }

  /**
   * Tasks which cause the overlay to actually close; typically play an
   * animation.
   * @protected
   */
  _renderClosed() {
    this._finishRenderClosed();
  }

  /**
   * Tasks to be performed at the end of open action. Will fire
   * `overlay-opened`.
   * @protected
   */
  _finishRenderOpened() {
    this.notifyResize();
    this.__isAnimating = false;
    const detail = {
      bubbles: true,
      composed: true
    };
    this.dispatchEvent(new CustomEvent('overlay-opened', detail));
    this.dispatchEvent(new CustomEvent('iron-overlay-opened', detail));
  }

  /**
   * Tasks to be performed at the end of close action. Will fire
   * `overlay-closed`.
   * @protected
   */
  _finishRenderClosed() {
    // Hide the overlay.
    this.style.display = 'none';
    // Reset z-index only at the end of the animation.
    this.style.zIndex = '';
    this.notifyResize();
    this.__isAnimating = false;
    const detail = {
      bubbles: true,
      composed: true,
      detail: this.closingReason
    };
    this.dispatchEvent(new CustomEvent('overlay-closed', detail));
    this.dispatchEvent(new CustomEvent('iron-overlay-closed', detail));
  }

  _preparePositioning() {
    this.style.transition = this.style.webkitTransition = 'none';
    this.style.transform = this.style.webkitTransform = 'none';
    this.style.display = '';
  }

  _finishPositioning() {
    // First, make it invisible & reactivate animations.
    this.style.display = 'none';
    // Force reflow before re-enabling animations so that they don't start.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = '';
    this.style.transform = this.style.webkitTransform = '';
    // Now that animations are enabled, make it visible again
    this.style.display = '';
    // Force reflow, so that following animations are properly started.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
  }

  /**
   * Applies focus according to the opened state.
   * @protected
   */
  _applyFocus() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    } else {
      // Restore focus.
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        // If the activeElement is `<body>` or inside the overlay,
        // we are allowed to restore the focus. In all the other
        // cases focus might have been moved elsewhere by another
        // component or by an user interaction (e.g. click on a
        // button outside the overlay).
        const activeElement = this._manager.deepActiveElement;
        if (activeElement === document.body ||
            this.shadowRoot.contains(activeElement) ||
            this.contains(activeElement)) {
          this.__restoreFocusNode.focus();
        }
      }
      this.__restoreFocusNode = null;
      this._focusNode.blur();
      this._focusedChild = null;
    }
  }

  /**
   * Cancels (closes) the overlay. Call when click happens outside the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureClick(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  }

  /**
   * Keeps track of the focused child. If withBackdrop, traps focus within
   * overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureFocus(event) {
    if (!this.withBackdrop) {
      return;
    }
    const cp = event.composedPath && event.composedPath();
    const path = cp ? cp : event.path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild = path[0];
    }
  }

  /**
   * Handles the ESC key event and cancels (closes) the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureEsc(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  }

  /**
   * Handles TAB key events to track focus changes.
   * Will wrap focus for overlays withBackdrop.
   * @param {!Event} event
   * @protected
   */
  _onCaptureTab(event) {
    if (!this.withBackdrop) {
      return;
    }
    this.__ensureFirstLastFocusables();
    // TAB wraps from last to first focusable.
    // Shift + TAB wraps from first to last focusable.
    const shift = event.shiftKey;
    const nodeToCheck =
        shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    const nodeToSet =
        shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    let shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      // If nodeToCheck is the same as nodeToSet, it means we have an overlay
      // with 0 or 1 focusables; in either case we still need to trap the
      // focus within the overlay.
      shouldWrap = true;
    } else {
      // In dom=shadow, the manager will receive focus changes on the main
      // root but not the ones within other shadow roots, so we can't rely on
      // _focusedChild, but we should check the deepest active element.
      const focusedNode = this._manager.deepActiveElement;
      // If the active element is not the nodeToCheck but the overlay itself,
      // it means the focus is about to go outside the overlay, hence we
      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).
      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);
    }

    if (shouldWrap) {
      // When the overlay contains the last focusable element of the document
      // and it's already focused, pressing TAB would move the focus outside
      // the document (e.g. to the browser search bar). Similarly, when the
      // overlay contains the first focusable element of the document and it's
      // already focused, pressing Shift+TAB would move the focus outside the
      // document (e.g. to the browser search bar).
      // In both cases, we would not receive a focus event, but only a blur.
      // In order to achieve focus wrapping, we prevent this TAB event and
      // force the focus. This will also prevent the focus to temporarily move
      // outside the overlay, which might cause scrolling.
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  }

  /**
   * Refits if the overlay is opened and not animating.
   * @protected
   */
  _onIronResize() {
    if (this.opened && !this.__isAnimating) {
      this.__deraf('refit', this.refit);
    }
  }

  /**
   * Will call notifyResize if overlay is opened.
   * Can be overridden in order to avoid multiple observers on the same node.
   * @protected
   */
  _onNodesChange() {
    if (this.opened && !this.__isAnimating) {
      // It might have added focusable nodes, so invalidate cached values.
      this.invalidateTabbables();
      this.notifyResize();
    }
  }

  /**
   * Updates the references to the first and last focusable nodes.
   * @private
   */
  __ensureFirstLastFocusables() {
    const focusableNodes = this._focusableNodes;
    this.__firstFocusableNode = focusableNodes[0];
    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
  }

  /**
   * Tasks executed when opened changes: prepare for the opening, move the
   * focus, update the manager, render opened/closed.
   * @private
   */
  __openedChanged() {
    if (this.opened) {
      // Make overlay visible, then add it to the manager.
      this._prepareRenderOpened();
      this._manager.addOverlay(this);
      // Move the focus to the child node with [autofocus].
      this._applyFocus();

      this._renderOpened();
    } else {
      // Remove overlay, then restore the focus before actually closing.
      this._manager.removeOverlay(this);
      this._applyFocus();

      this._renderClosed();
    }
  }

  /**
   * Debounces the execution of a callback to the next animation frame.
   * @param {!string} jobname
   * @param {!Function} callback Always bound to `this`
   * @private
   */
  __deraf(jobname, callback) {
    const rafs = this.__rafs;
    if (rafs[jobname] !== null) {
      cancelAnimationFrame(rafs[jobname]);
    }
    rafs[jobname] = requestAnimationFrame(function nextAnimationFrame() {
      rafs[jobname] = null;
      callback.call(this);
    }.bind(this));
  }

  /**
   * @param {boolean} isAttached
   * @param {boolean} opened
   * @param {string=} scrollAction
   * @private
   */
  __updateScrollObservers(isAttached, opened, scrollAction) {
    if (!isAttached || !opened || !this.__isValidScrollAction(scrollAction)) {
      removeScrollLock(this);
      this.__removeScrollListeners();
    } else {
      if (scrollAction === 'lock') {
        this.__saveScrollPosition();
        pushScrollLock(this);
      }
      this.__addScrollListeners();
    }
  }

  /**
   * @private
   */
  __addScrollListeners() {
    if (!this.__rootNodes) {
      this.__rootNodes = [];
      // Listen for scroll events in all shadowRoots hosting this overlay only
      // when in native ShadowDOM.
      let node = this;
      while (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {
          this.__rootNodes.push(node);
        }
        node = node.host || node.assignedSlot || node.parentNode;
      }
      this.__rootNodes.push(document);
    }
    this.__rootNodes.forEach((el) => {
      el.addEventListener('scroll', this.__onCaptureScroll, {
        capture: true,
        passive: true,
      });
    });
  }

  /**
   * @private
   */
  __removeScrollListeners() {
    if (this.__rootNodes) {
      this.__rootNodes.forEach((el) => {
        el.removeEventListener('scroll', this.__onCaptureScroll, {
          capture: true,
          passive: true,
        });
      });
    }
    if (!this.isAttached) {
      this.__rootNodes = null;
    }
  }

  /**
   * @param {string=} scrollAction
   * @return {boolean}
   * @private
   */
  __isValidScrollAction(scrollAction) {
    return scrollAction === 'lock' || scrollAction === 'refit' ||
        scrollAction === 'cancel';
  }

  __onCaptureScroll(event) {
    if (this.__isAnimating) {
      return;
    }
    // Check if scroll outside the overlay.
    const cp = event.composedPath && event.composedPath();
    const path = cp ? cp : event.path;
    if (path.indexOf(this) >= 0) {
      return;
    }
    switch (this.scrollAction) {
      case 'lock':
        // NOTE: scrolling might happen if a scroll event is not cancellable, or
        // if user pressed keys that cause scrolling (they're not prevented in
        // order not to break a11y features like navigate with arrow keys).
        this.__restoreScrollPosition();
        break;
      case 'refit':
        this.__deraf('refit', this.refit);
        break;
      case 'cancel':
        this.cancel(event);
        break;
    }
  }

  /**
   * Memoizes the scroll position of the outside scrolling element.
   * @private
   */
  __saveScrollPosition() {
    if (document.scrollingElement) {
      this.__scrollTop = document.scrollingElement.scrollTop;
      this.__scrollLeft = document.scrollingElement.scrollLeft;
    } else {
      // Since we don't know if is the body or html, get max.
      this.__scrollTop =
          Math.max(document.documentElement.scrollTop, document.body.scrollTop);
      this.__scrollLeft = Math.max(
          document.documentElement.scrollLeft, document.body.scrollLeft);
    }
  }

  /**
   * Resets the scroll position of the outside scrolling element.
   * @private
   */
  __restoreScrollPosition() {
    if (document.scrollingElement) {
      document.scrollingElement.scrollTop = this.__scrollTop;
      document.scrollingElement.scrollLeft = this.__scrollLeft;
    } else {
      // Since we don't know if is the body or html, set both.
      document.documentElement.scrollTop = document.body.scrollTop =
          this.__scrollTop;
      document.documentElement.scrollLeft = document.body.scrollLeft =
          this.__scrollLeft;
    }
  }

  /**
   * Fired after the overlay opens.
   * @event overlay-opened
   */
  /**
   * Fired after the overlay opens.
   * @event iron-overlay-opened
   * @deprecated Use `overlay-opened` event instead
   */
  /**
   * Fired when the overlay is canceled, but before it is closed.
   * @event iron-overlay-canceled
   * @param {Event} event The closing of the overlay can be prevented
   * by calling `event.preventDefault()`. The `event.detail` is the original event
   * that originated the canceling (e.g. ESC keyboard event or click event outside
   * the overlay).
   * @deprecated Use `overlay-canceled` event instead
   */
  /**
   * Fired when the overlay is canceled, but before it is closed.
   * @event overlay-canceled
   * @param {Event} event The closing of the overlay can be prevented
   * by calling `event.preventDefault()`. The `event.detail` is the original event
   * that originated the canceling (e.g. ESC keyboard event or click event outside
   * the overlay).
   */
  /**
   * Fired after the overlay closes.
   * @event overlay-closed
   * @param {Event} event The `event.detail` is the `closingReason` property
   * (contains `canceled`, whether the overlay was canceled).
   */
  /**
   * Fired after the overlay closes.
   * @event iron-overlay-closed
   * @param {Event} event The `event.detail` is the `closingReason` property
   * (contains `canceled`, whether the overlay was canceled).
   * @deprecated Use `overlay-closed` instead.
   */
};

class AnypointDropdown extends ArcOverlayMixin(ControlStateMixin(LitElement)) {
  static get styles() {
    return css`
    :host {
      position: fixed;
    }

    .contentWrapper ::slotted(*) {
      overflow: auto;
    }

    .contentWrapper.animating ::slotted(*) {
      overflow: hidden;
      pointer-events: none;
    }
    `;
  }

  static get properties() {
    return {
      /**
       * An animation config. If provided, this will be used to animate the
       * opening of the dropdown. Pass an Array for multiple animations.
       * See `neon-animation` documentation for more animation configuration
       * details.
       */
      openAnimationConfig: { type: Object },

      /**
       * An animation config. If provided, this will be used to animate the
       * closing of the dropdown. Pass an Array for multiple animations.
       * See `neon-animation` documentation for more animation configuration
       * details.
       */
      closeAnimationConfig: { type: Object },
      /**
       * If provided, this will be the element that will be focused when
       * the dropdown opens.
       */
      focusTarget: { type: Object },
      /**
       * Set to true to disable animations when opening and closing the
       * dropdown.
       */
      noAnimations: { type: Boolean },
      /**
       * By default, the dropdown will constrain scrolling on the page
       * to itself when opened.
       * Set to true in order to prevent scroll from being constrained
       * to the dropdown when it opens.
       * This property is a shortcut to set `scrollAction` to lock or refit.
       * Prefer directly setting the `scrollAction` property.
       */
      allowOutsideScroll: { type: Boolean }
    };
  }

  get allowOutsideScroll() {
    return this._allowOutsideScroll;
  }

  set allowOutsideScroll(value) {
    const old = this._allowOutsideScroll;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._allowOutsideScroll = value;
    this._allowOutsideScrollChanged(value);
  }

  get positionTarget() {
    return this._positionTarget;
  }

  set positionTarget(value) {
    const old = this._positionTarget;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._positionTarget = value;
    this._updateOverlayPosition();
  }

  get verticalAlign() {
    return this._verticalAlign;
  }

  set verticalAlign(value) {
    const old = this._verticalAlign;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._verticalAlign = value;
    this._updateOverlayPosition();
  }

  get horizontalAlign() {
    return this._horizontalAlign;
  }

  set horizontalAlign(value) {
    const old = this._horizontalAlign;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._horizontalAlign = value;
    this._updateOverlayPosition();
  }

  get verticalOffset() {
    return this._verticalOffset;
  }

  set verticalOffset(value) {
    const old = this._verticalOffset;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._verticalOffset = value;
    this._updateOverlayPosition();
  }

  get horizontalOffset() {
    return this._horizontalOffset;
  }

  set horizontalOffset(value) {
    const old = this._horizontalOffset;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._horizontalOffset = value;
    this._updateOverlayPosition();
  }

  /**
   * The element that is contained by the dropdown, if any.
   */
  get containedElement() {
    const slot = this.shadowRoot.querySelector('slot');
    if (!slot) {
      return null;
    }
    const nodes = slot.assignedNodes({ flatten: true });
    for (let i = 0, l = nodes.length; i < l; i++) {
      if (nodes[i].nodeType === Node.ELEMENT_NODE) {
        return nodes[i];
      }
    }
    return null;
  }

  get contentWrapper() {
    return this.shadowRoot.querySelector('.contentWrapper');
  }

  constructor() {
    super();
    this.horizontalAlign = 'left';
    this.verticalAlign = 'top';
    this.noAnimations = false;
    this.allowOutsideScroll = false;
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    // Ensure scrollAction is set.
    if (!this.scrollAction) {
      this.scrollAction = this.allowOutsideScroll ? 'refit' : 'lock';
    }
    this._readied = true;
  }

  firstUpdated() {
    if (!this.sizingTarget || this.sizingTarget === this) {
      this.sizingTarget = this.containedElement || this;
    }
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.cancelAnimation();
  }

  _updateOverlayPosition() {
    // from ArcOverlayMixin
    if (this.isAttached) {
      // from  ArcResizableMixin
      this.notifyResize();
    }
  }

  _openedChanged(opened) {
    if (opened && this.disabled) {
      // from ArcOverlayMixin
      this.cancel();
    } else {
      this.cancelAnimation();
      super._openedChanged(opened);
    }
  }

  _renderOpened() {
    if (!this.noAnimations) {
      this.contentWrapper.classList.add('animating');
      this.playAnimation('open');
    } else {
      super._renderOpened();
    }
  }

  _renderClosed() {
    if (!this.noAnimations) {
      this.contentWrapper.classList.add('animating');
      this.playAnimation('close');
    } else {
      super._renderClosed();
    }
  }

  /**
   * Called when animation finishes on the dropdown (when opening or
   * closing). Responsible for "completing" the process of opening or
   * closing the dropdown by positioning it or setting its display to
   * none.
   */
  _onAnimationFinish() {
    this._activeAnimations = undefined;
    this.contentWrapper.classList.remove('animating');
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }
  /**
   * Sets scrollAction according to the value of allowOutsideScroll.
   * Prefer setting directly scrollAction.
   * @param {Boolean} allowOutsideScroll
   */
  _allowOutsideScrollChanged(allowOutsideScroll) {
    // Wait until initial values are all set.
    if (!this._readied) {
      return;
    }
    if (!allowOutsideScroll) {
      this.scrollAction = 'lock';
    } else if (!this.scrollAction || this.scrollAction === 'lock') {
      this.scrollAction = 'refit';
    }
  }

  _applyFocus() {
    const focusTarget = this.focusTarget || this.containedElement;
    if (focusTarget && this.opened && !this.noAutoFocus) {
      focusTarget.focus();
    } else {
      super._applyFocus();
    }
  }

  playAnimation(name) {
    if (window.KeyframeEffect === undefined) {
      this._onAnimationFinish();
      return;
    }

    const node = this.containedElement;
    let origin;
    switch (this.verticalAlign) {
      case 'bottom': origin = '100%'; break;
      case 'middle': origin = '50%'; break;
      default: origin = '0%';
    }
    this._setPrefixedProperty(node, 'transformOrigin', `0% ${origin}`);
    let results;
    if (name === 'open') {
      results = this._configureStartAnimation(node, this.openAnimationConfig);
    } else {
      results = this._configureEndAnimation(node, this.closeAnimationConfig);
    }
    if (!results || !results.length) {
      this._onAnimationFinish();
      return;
    }
    this._activeAnimations = results;
  }

  cancelAnimation() {
    if (!this._activeAnimations) {
      return;
    }
    this._activeAnimations.forEach((anim) => {
      if (anim && anim.cancel) {
        anim.cancel();
      }
    });
    this._activeAnimations = [];
  }

  _runEffects(node, config) {
    const results = [];
    for (let i = 0; i < config.length; i++) {
      const options = config[i];
      try {
        this.__runAnimation(node, options, results);
      } catch (_) {
        continue;
      }
    }
    return results;
  }

  __runAnimation(node, options, results) {
    const result = node.animate(options.keyframes, options.timing);
    results[results.length] = result;
    result.onfinish = () => {
      result.onfinish = null;
      const index = results.findIndex((item) => item === result);
      results.splice(index, 1);
      if (!results.length) {
        this._onAnimationFinish();
      }
    };
  }

  _configureStartAnimation(node, config) {
    if (window.KeyframeEffect === undefined) {
      return null;
    }
    if (!config) {
      config = [{
        keyframes: [
          { transform: 'scale(1, 0)' },
          { transform: 'scale(1, 1)' }
        ],
        timing: {
          delay: 0,
          duration: 200,
          easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
          fill: 'both'
        }
      }];
    }
    return this._runEffects(node, config);
  }

  _configureEndAnimation(node, config) {
    if (window.KeyframeEffect === undefined) {
      return null;
    }
    if (!config) {
      config = [{
        keyframes: [
          { transform: 'scale(1, 1)' },
          { transform: 'scale(1, 0)' }
        ],
        timing: {
          delay: 0,
          duration: 200,
          easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
          fill: 'both'
        }
      }];
    }
    return this._runEffects(node, config);
  }

  _setPrefixedProperty(node, property, value) {
    const map = {
      transform: ['webkitTransform'],
      transformOrigin: ['mozTransformOrigin', 'webkitTransformOrigin']
    };
    const prefixes = map[property];
    for (let index = 0, len = prefixes.length; index < len; index++) {
      const prefix = prefixes[index];
      node.style[prefix] = value;
    }
    node.style[property] = value;
  }

  render() {
    return html`
    <div class="contentWrapper">
      <slot name="dropdown-content"></slot>
    </div>
    `;
  }
}

window.customElements.define('anypoint-dropdown', AnypointDropdown);

/**
 * `anypoint-button`
 * Anypoint styled button.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof AnypointUi
 */
class AnypointIconButton extends AnypointButtonBase {
  static get styles() {
    return css`
    :host {
      display: inline-block;
      position: relative;
      width: 40px;
      height: 40px;
      outline: none;
    }

    paper-ripple {
      opacity: 0.6;
      color: currentColor;
    }

    :host ::slotted(*) {
      margin: 0;
      padding: 0;
      color: var(--anypoint-icon-button-color, var(--anypoint-color-primary));
    }

    .icon {
      cursor: pointer;
      border-radius: 50%;
      border-width: 1px;
      border-style: solid;
      border-color: transparent;

      position: relative;
      width: 100%;
      height: 100%;

      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([disabled]) {
      pointer-events: none;
      cursor: auto;
    }

    :host([disabled]) ::slotted(*) {
      color: var(--anypoint-icon-button-disabled-color, #a8a8a8) !important;
    }

    /* Low emhasis styles */
    :host([emphasis="low"]:not(:disabled)) .icon {
      background-color: none;
      border-color: none;
      box-shadow: none !important;
    }

    :host([emphasis="low"]:not(:disabled)) ::slotted(*) {
      color: var(--anypoint-icon-button-emphasis-low-color, var(--anypoint-color-primary));
    }

    :host([emphasis="low"]:hover) .icon {
      background-color: var(--anypoint-icon-button-emphasis-low-hover-background-color, rgba(0, 162, 223, .08));
    }

    :host([emphasis="low"][focused]) .icon {
      background-color: var(--anypoint-icon-button-emphasis-low-focus-background-color, rgba(0, 162, 223, .12));
    }

    :host([emphasis="low"][active]) .icon {
      background-color: var(--anypoint-icon-button-emphasis-low-active-background-color, rgba(0, 162, 223, .16));
    }

    :host([emphasis="low"][active]) ::slotted(*) {
      color: var(--anypoint-icon-button-emphasis-low-focus-color, var(--anypoint-color-coreBlue4));
    }

    /* Medium emphasis styles */
    :host([emphasis="medium"]) .icon {
      border-color: var(--anypoint-icon-button-emphasis-medium-focus-border-color, var(--anypoint-color-robustBlue1));
      box-shadow: none !important;
    }

    :host([emphasis="medium"][disabled]) .icon {
      border-color: var(--anypoint-icon-button-disabled-color, var(--anypoint-color-aluminum4));
    }

    :host([emphasis="medium"][disabled]) ::slotted(*) {
      color: var(--anypoint-icon-button-disabled-color, #a8a8a8);
    }

    :host([emphasis="medium"]:hover) .icon {
      background-color: var(--anypoint-icon-button-emphasis-medium-hover-background-color, rgba(0, 162, 223, .06));
    }

    :host([emphasis="medium"][focused]) .icon {
      background-color: var(--anypoint-icon-button-emphasis-medium-focus-background-color, rgba(0, 162, 223, .08));
      border-color: var(--anypoint-icon-button-emphasis-medium-focus-border-color, var(--anypoint-color-robustBlue2));
    }

    :host([emphasis="medium"][focused]) ::slotted(*) {
      color: var(--anypoint-icon-button-emphasis-low-focus-color, var(--anypoint-color-coreBlue4));
    }

    :host([emphasis="medium"][active]) .icon {
      background-color: var(--anypoint-icon-button-emphasis-low-active-background-color, rgba(94, 102, 249, 0.16));
    }
    /* High emphasis styles */

    :host([emphasis="high"]) .icon {
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: box-shadow;
      background-color: var(--anypoint-icon-button-emphasis-high-background-color, var(--anypoint-color-primary));
    }

    :host([emphasis="high"]) ::slotted(*) {
      color: var(--anypoint-icon-button-emphasis-high-color, var(--anypoint-color-tertiary));
    }

    :host([emphasis="high"][disabled]) .icon {
      background: var(--anypoint-icon-button-disabled-background-color, #eaeaea);
      box-shadow: none;
    }

    :host([emphasis="high"][disabled]) ::slotted(*) {
      color: var(--anypoint-icon-button-disabled-color, #a8a8a8);
    }

    :host([emphasis="high"]:hover) .icon {
      background-color: var(--anypoint-icon-button-emphasis-high-hover-background-color, rgba(0, 162, 223, 0.87));
    }

    :host(:not([pressed])[emphasis="high"][active]) .icon {
      background-color:
        var(--anypoint-icon-button-emphasis-high-active-background-color, var(--anypoint-color-indigo3));
    }

    :host([elevation="1"]) .icon {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    }

    :host([elevation="2"]) .icon,
    :host([elevation][emphasis="high"][focused]) > .icon {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    }

    :host([elevation="3"]) .icon {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    }
    `;
  }

  render() {
    return html`
      <div class="icon">
        <slot></slot>
        <paper-ripple class="circle" center .noink="${this.noink}"></paper-ripple>
      </div>
    `;
  }

  get _ripple() {
    return this.shadowRoot.querySelector('paper-ripple');
  }

  connectedCallback() {
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'button');
    }
    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }
    if (super.connectedCallback) {
      super.connectedCallback();
    }
  }

  _spaceKeyDownHandler(e) {
    super._spaceKeyDownHandler(e);
    this._enterDownHandler();
  }

  _spaceKeyUpHandler(e) {
    super._spaceKeyUpHandler(e);
    this._enterUpHandler();
  }

  _buttonStateChanged() {
    this._calculateElevation();
  }

  _keyDownHandler(e) {
    super._keyDownHandler(e);
    if (e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
      this._enterDownHandler();
    }
  }

  _keyUpHandler(e) {
    super._keyUpHandler(e);
    if (e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
      this._enterUpHandler();
    }
  }

  _enterDownHandler() {
    this._calculateElevation();
    if (!this._ripple.animating) {
      this._ripple.uiDownAction();
    }
  }

  _enterUpHandler() {
    this._calculateElevation();
    this._ripple.uiUpAction();
  }
}

window.customElements.define('anypoint-icon-button', AnypointIconButton);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Polymer({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {type: String, observer: '_nameChanged'},

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {type: Number, value: 24},

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {type: Boolean, value: false},

    /**
     * Set to true to measure RTL based on the dir attribute on the body or
     * html elements (measured on document.body or document.documentElement as
     * available).
     */
    useGlobalRtlAttribute: {type: Boolean, value: false}
  },

  created: function() {
    this._meta = new IronMeta({type: 'iconset', key: null, value: null});
  },

  attached: function() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function(n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(
        iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = dom(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function(element) {
    // Remove old svg element
    if (element._svgIcon) {
      dom(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement =
            (document.body && document.body.hasAttribute('dir')) ?
            document.body :
            document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL =
            target && window.getComputedStyle(target)['direction'] === 'rtl';
      }
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function() {
      this.fire('iron-iconset-added', this, {node: window});
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    dom(this).querySelectorAll('[id]').forEach(function(icon) {
      icons[icon.id] = icon;
    });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox =
              content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText =
              'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText +=
            '-webkit-transform:scale(-1,1);transform:scale(-1,1);transform-origin:center;';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around
      // https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a
      // shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});

const $documentContainer = document.createElement('template');
let hasDropdown = false;
try {
  const node = document.head.querySelector('iron-iconset-svg[name="anypoint-dropdown-menu"]');
  /* istanbul ignore if */
  if (node) {
    hasDropdown = true;
  }
  /* istanbul ignore next */
} catch (_) {
  hasDropdown = false;
}
/* istanbul ignore else */
if (!hasDropdown) {
  $documentContainer.innerHTML = `<iron-iconset-svg name="anypoint-dropdown-menu" size="16">
  <svg><defs>
    <g
      id="adm-arrow-down">
      <path
        xmlns="http://www.w3.org/2000/svg"
        d="M8.002 11.352L3.501 4.924l1.027-.276 3.473 4.96 3.471-4.959 1.027.275-4.497 6.428z"></path>
    </g>
  </defs></svg>
  </iron-iconset-svg>`;
  document.head.appendChild($documentContainer.content);
}

/**
 * Accessible dropdown menu for Anypoint platform.
 *
 * The element works perfectly with `anypoint-listbox` which together creates an
 * accessible list of options. The listbox can be replaced by any other element
 * that support similar functionality but make sure it has an appropriate aria
 * support.
 *
 * See README.md file for detailed documentation.
 */
class AnypointDropdownMenu extends ValidatableMixin(ControlStateMixin(LitElement)) {
  static get styles() {
    return css`
    :host {
      /* Default size of an <input> */
      width: 200px;
      display: inline-block;
      position: relative;
      text-align: left;
      outline: none;
      height: 56px;
      box-sizing: border-box;
      font-size: 1rem;
      /* Anypoint UI controls margin in forms */
      margin: 16px 8px;
    }

    .hidden {
      display: none !important;
    }

    .trigger-button.form-disabled {
      pointer-events: none;
      opacity: var(--anypoint-dropdown-menu-disabled-opacity, 0.43);
    }

    .label.resting.form-disabled, {
      opacity: var(--anypoint-dropdown-menu-disabled-opacity, 0.43);
    }

    :host([nolabelfloat]) {
      height: 40px;
    }

    .input-container {
      position: relative;
      height: 100%;
      /* width: inherit; */
      background-color: var(--anypoint-dropdown-menu-background-color, #F5F5F5);

      border: 1px var(--anypoint-dropdown-menu-border-color, transparent) solid;
      border-radius: 4px 4px 0 0;
      border-bottom-width: 1px;
      border-bottom-style: solid;
      border-bottom-color: var(--anypoint-dropdown-menu-border-bottom-color, #8e8e8e);
      transition: border-bottom-color 0.22s linear;
      transform-origin: center center;

      cursor: default;
    }

    :host([invalid]) .input-container,
    :host(:invalid) .input-container {
      border-bottom: 1px solid var(--anypoint-dropdown-error-color, var(--error-color)) !important;
    }

    .input-container.form-disabled {
      opacity: var(--anypoint-dropdown-menu-disabled-opacity, 0.43);
      border-bottom: 1px dashed var(--anypoint-dropdown-menu-color, var(--secondary-text-color));
    }

    :host([opened]) .input-container,
    :host([focused]) .input-container,
    :host(:focus) .input-container {
      border-bottom-color: var(--anypoint-dropdown-menu-hover-border-color, var(--anypoint-color-coreBlue3));
    }

    .input-wrapper {
      display: flex;
      flex-direction: row;
      align-items: center;
      height: 100%;
      position: relative;
    }

    .input {
      flex: 1;
      margin: 12px 0px 0px 8px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: calc(100% - 40px);
    }

    :host(:dir(rtl)) .input {
      text-align: right;
      margin: 0px 8px 0px 0px;
    }

    :host([dir="rtl"]) .input {
      text-align: right;
      margin: 12px 8px 0px 0px;
    }

    :host([nolabelfloat]) .input {
      margin-top: 0 !important;
    }

    .input-spacer {
      visibility: hidden;
      margin-left: -12px;
    }

    .label {
      position: absolute;
      transition: transform 0.12s ease-in-out, max-width 0.12s ease-in-out;
      will-change: transform;
      border-radius: 3px;
      margin: 0;
      padding: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      z-index: 1;
      max-width: calc(100% - 16px);
      text-overflow: clip;
      color: var(--anypoint-dropdown-menu-label-color, #616161);
      transform-origin: left top;
      left: 8px;
      top: calc(100% / 2 - 8px);
      font-size: 1rem;
    }

    :host(:dir(rtl)) .label {
      text-align: right;
      right: 8px;
      left: auto;
    }
    /* Not every browser support syntax above and for those who doesn't
      this style has to be repeated or it won't be applied. */
    :host([dir="rtl"]) .label {
      text-align: right;
      right: 8px;
      left: auto;
      transform-origin: right top;
    }

    .label.resting {
      transform: translateY(0) scale(1);
    }

    .label.floating {
      transform: translateY(-80%) scale(0.75);
      max-width: calc(100% + 20%);
    }

    :host([nolabelfloat]:not([compatibility])) .label.floating {
      display: none !important;
    }

    :host([invalid]) .label,
    :host(:invalid) .label {
      color: var(--anypoint-dropdown-error-color, var(--error-color)) !important;
    }

    .trigger-icon {
      transform: rotate(0);
      transition: transform 0.12s ease-in-out;
      will-change: transform;
      color: var(--anypoint-dropdown-menu-label-color, #616161);
    }

    .trigger-icon.opened {
      transform: rotate(-180deg);
    }

    :host([opened]) .trigger-icon,
    :host([focused]) .trigger-icon,
    :host(:focus) .trigger-icon {
      color: var(--anypoint-dropdown-menu-trigger-icon-active-color, var(--primary-color));
    }

    anypoint-dropdown {
      margin-top: 58px;
      width: auto;
    }

    .dropdown-content {
      box-shadow: var(--anypoiont-dropdown-shaddow);
    }

    :host([verticalalign="bottom"]) anypoint-dropdown {
      margin-bottom: 56px;
      margin-top: auto;
    }

    :host([nolabelfloat]) anypoint-dropdown {
      margin-top: 40px;
    }

    .assistive-info {
      overflow: hidden;
      margin-top: -2px;
      height: 20px;
      position: absolute;
    }

    .invalid,
    .info {
      padding: 0;
      margin: 0 0 0 8px;
      font-size: .875rem;
      transition: transform 0.12s ease-in-out;
    }

    .info {
      color: var(--anypoint-dropdown-menu-info-message-color, #616161);
    }

    .info.label-hidden {
      transform: translateY(-200%);
    }

    .invalid {
      color: var(--anypoint-dropdown-menu-error-color, var(--error-color));
    }

    .invalid.label-hidden,
    .invalid.info-offset.label-hidden {
      transform: translateY(-200%);
    }

    .invalid.info-offset {
      transform: translateY(-100%);
    }

    /* Outlined theme */
    :host([outlined]) .input-container {
      border: 1px var(--anypoint-dropdown-menu-border-color, #8e8e8e) solid;
      background-color: var(--anypoint-dropdown-menu-background-color, #fff);
      border-radius: 4px;
      transition: border-bottom-color 0.22s linear;
    }

    :host([outlined]) .input {
      margin-top: 0;
    }

    :host([outlined]) .label.resting {
      margin-top: 0;
      top: calc(100% / 2 - 8px);
    }

    :host([outlined]) .label.floating {
      background-color: var(--anypoint-dropdown-menu-label-background-color, white);
      transform: translateY(-130%) scale(0.75);
      max-width: 120%;
      padding: 0 2px;
      left: 6px;
    }

    :host([outlined][invalid]) .input-container,
    :host([outlined]:invalid) .input-container {
      border: 1px solid var(--anypoint-dropdown-error-color, var(--error-color)) !important;
    }

    /* Anypoint compatibility theme */

    :host([compatibility]) {
      height: 40px;
      margin-top: 20px;
    }

    :host([compatibility]) .input-container {
      border: none;
      border-left: 2px var(--anypoint-dropdown-menu-border-color, #8e8e8e) solid;
      border-right: 2px var(--anypoint-dropdown-menu-border-color, #8e8e8e) solid;
      border-radius: 0;
      box-sizing: border-box;
    }

    :host([compatibility][focused]) .input-container,
    :host([compatibility]:hover) .input-container {
      border-left-color: var(--anypoint-dropdown-menu-compatibility-focus-border-color, #58595a);
      border-right-color: var(--anypoint-dropdown-menu-compatibility-focus-border-color, #58595a);
      background-color: var(--anypoint-dropdown-menu-compatibility-focus-background-color, #f9fafb);
    }

    :host([compatibility][invalid]) .input-container {
      border-left-color: var(--anypoint-dropdown-menu-error-color, var(--error-color));
      border-right-color: var(--anypoint-dropdown-menu-error-color, var(--error-color));
      border-bottom: none !important;
    }

    :host([compatibility]) .label {
      font-size: .875rem;
      left: -2px;
      top: -18px;
      transform: none;
      font-weight: 500;
      color: var(--anypoint-dropdown-menu-compatibility-label-color, #616161);
    }

    :host([compatibility]) anypoint-dropdown {
      margin-top: 40px;
    }

    :host([compatibility]) .input {
      margin-top: 0;
    }

    :host([compatibility]) .invalid,
    :host([compatibility]) .info {
      margin-left: 0px;
    }

    :host([nolabelfloat][compatibility]) {
      margin-top: 0px;
    }

    :host([compatibility]) anypoint-dropdown {
      border-bottom: 2px var(--anypoint-dropdown-menu-border-color, #E0E0E0) solid;
      border-top: 2px var(--anypoint-dropdown-menu-border-color, #E0E0E0) solid;
    }

    :host([compatibility]) .dropdown-content {
      box-shadow: none;
    }

    :host([nolabelfloat][compatibility]) .label.resting {
      top: calc(100% / 2 - 8px);
      left: 10px;
      font-size: 1rem;
    }
    `;
  }

  render() {
    const {
      opened,
      horizontalAlign,
      verticalAlign,
      dynamicAlign,
      horizontalOffset,
      verticalOffset,
      noOverlap,
      openAnimationConfig,
      closeAnimationConfig,
      noAnimations,
      allowOutsideScroll,
      restoreFocusOnClose,
      value,
      invalidMessage,
      infoMessage,
      compatibility,
      _labelClass,
      _errorAddonClass,
      _infoAddonClass,
      _triggerClass,
      _inputContainerClass
    } = this;

    const renderValue = value || '';
    return html`
    <div class="${_inputContainerClass}">
      <div class="${_labelClass}">
        <slot name="label"></slot>
      </div>

      <div class="input-wrapper">
        <div class="input">
          ${renderValue}
          <span class="input-spacer">&nbsp;</span>
        </div>
        <anypoint-icon-button
          @click="${this.toggle}"
          aria-label="Toggles dropdown menu"
          tabindex="-1"
          aria-label="Toggles dropdown menu"
          class="${_triggerClass}"
          ?compatibility="${compatibility}">
          <iron-icon
            class="trigger-icon ${opened ? 'opened' : ''}"
            icon="anypoint-dropdown-menu:adm-arrow-down"></iron-icon>
        </anypoint-icon-button>
      </div>

      <anypoint-dropdown
        .opened="${opened}"
        .horizontalAlign="${horizontalAlign}"
        .verticalAlign="${verticalAlign}"
        .dynamicAlign="${dynamicAlign}"
        .horizontalOffset="${horizontalOffset}"
        .verticalOffset="${verticalOffset}"
        .noOverlap="${noOverlap}"
        .openAnimationConfig="${openAnimationConfig}"
        .closeAnimationConfig="${closeAnimationConfig}"
        .noAnimations="${noAnimations}"
        .allowOutsideScroll="${allowOutsideScroll}"
        .restoreFocusOnClose="${restoreFocusOnClose}"
        ?compatibility="${compatibility}"
        @overlay-closed="${this._dropdownClosed}"
        @overlay-opened="${this._dropdownOpened}"
        @select="${this._selectHandler}"
        @deselect="${this._deselectHandler}">
        <div slot="dropdown-content" class="dropdown-content">
          <slot id="content" name="dropdown-content"></slot>
        </div>
      </anypoint-dropdown>
    </div>
    <div class="assistive-info">
    ${infoMessage ? html`<p class="${_infoAddonClass}">${infoMessage}</p>` : undefined}
    ${invalidMessage ?
      html`<p class="${_errorAddonClass}">${invalidMessage}</p>` :
      undefined}
    </div>
    `;
  }
  /**
   * For form-associated custom elements. Marks this custom element
   * as form enabled element.
   */
  static get formAssociated() {
    return true;
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * returns `<form>` element associated with this constol.
   */
  get form() {
    return this._internals && this._internals.form || null;
  }

  get validationStates() {
    return this._validationStates;
  }

  set validationStates(value) {
    const old = this._validationStates;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._validationStates = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('validationStates', old);
    }
    this._hasValidationMessage = !!(value && value.length);
    this._validationStatesChanged(value);
    this.dispatchEvent(new CustomEvent('validationstates-changed', {
      detail: {
        value
      }
    }));
  }

  get hasValidationMessage() {
    return this._hasValidationMessage;
  }

  get _hasValidationMessage() {
    return this.__hasValidationMessage;
  }

  set _hasValidationMessage(value) {
    const old = this.__hasValidationMessage;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__hasValidationMessage = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('hasValidationMessage', old);
    }
    this.__hasValidationMessage = value;
    this.dispatchEvent(new CustomEvent('hasvalidationmessage-changed', {
      detail: {
        value
      }
    }));
  }

  get autoValidate() {
    return this._autoValidate;
  }

  set autoValidate(value) {
    const old = this._autoValidate;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._autoValidate = value;
    this._autoValidateChanged(value);
  }

  get invalidMessage() {
    return this._invalidMessage;
  }

  set invalidMessage(value) {
    const old = this._invalidMessage;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._invalidMessage = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('invalidMessage', old);
    }
    this._hasValidationMessage = this.invalid && !!value;
  }

  get _labelClass() {
    const labelFloating = !!this.value;
    let klas = 'label';
    if (labelFloating && this.noLabelFloat) {
      klas += ' hidden';
    } else {
      klas += labelFloating ? ' floating' : ' resting';
    }
    if (this._formDisabled || this.disabled) {
      klas += ' form-disabled';
    }
    return klas;
  }

  get _infoAddonClass() {
    let klas = 'info';
    const isInavlidWithMessage = !!this.invalidMessage && this.invalid;
    if (isInavlidWithMessage) {
      klas += ' label-hidden';
    }
    return klas;
  }

  get _errorAddonClass() {
    let klas = 'invalid';
    if (!this.invalid) {
      klas += ' label-hidden';
    }
    if (this.infoMessage) {
      klas += ' info-offset';
    }
    return klas;
  }

  get _triggerClass() {
    let klas = 'trigger-button';
    if (this._formDisabled || this.disabled) {
      klas += ' form-disabled';
    }
    return klas;
  }

  get _inputContainerClass() {
    let klas = 'input-container';
    if (this._formDisabled || this.disabled) {
      klas += ' form-disabled';
    }
    return klas;
  }

  get selectedItem() {
    return this._selectedItem;
  }

  get _selectedItem() {
    return this.__selectedItem;
  }

  set _selectedItem(value) {
    const old = this.__selectedItem;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__selectedItem = value;
    this._selectedItemChanged(value);
  }

  get opened() {
    return this._opened || false;
  }

  set opened(value) {
    const old = this._opened;
    if (old === value) {
      return;
    }
    if (value && (this._disabled || this._formDisabled)) {
      return;
    }
    this._opened = value;
    this.requestUpdate('opened', old);
    this._openedChanged(value);
    this.dispatchEvent(new CustomEvent('opened-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {?Element} The content element that is contained by the dropdown menu, if any.
   */
  get contentElement() {
    const slot = this.shadowRoot.querySelector('slot[name="dropdown-content"]');
    if (!slot) {
      return null;
    }
    const nodes = slot.assignedNodes();
    for (let i = 0, l = nodes.length; i < l; i++) {
      if (nodes[i].nodeType === Node.ELEMENT_NODE) {
        return nodes[i];
      }
    }
    return null;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    if (old === value) {
      return;
    }
    this._value = value;
    this.requestUpdate('value', old);
    /* istanbul ignore else */
    if (this._internals) {
      this._internals.setFormValue(value);
    }
  }

  get disabled() {
    return this._disabled || false;
  }

  set disabled(value) {
    const old = this._disabled;
    if (old === value) {
      return;
    }
    this._disabled = value;
    this.requestUpdate('disabled', old);
    if (this.opened) {
      this.opened = false;
    }
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  static get properties() {
    return {
      /**
       * An animation config. If provided, this will be used to animate the
       * opening of the dropdown. Pass an Array for multiple animations.
       * See `neon-animation` documentation for more animation configuration
       * details.
       */
      openAnimationConfig: { type: Object },

      /**
       * An animation config. If provided, this will be used to animate the
       * closing of the dropdown. Pass an Array for multiple animations.
       * See `neon-animation` documentation for more animation configuration
       * details.
       */
      closeAnimationConfig: { type: Object },
      /**
       * Set to true to disable animations when opening and closing the
       * dropdown.
       */
      noAnimations: { type: Boolean, reflect: true },
      /**
       * By default, the dropdown will constrain scrolling on the page
       * to itself when opened.
       * Set to true in order to prevent scroll from being constrained
       * to the dropdown when it opens.
       * This property is a shortcut to set `scrollAction` to lock or refit.
       * Prefer directly setting the `scrollAction` property.
       */
      allowOutsideScroll: { type: Boolean, reflect: true },
      /**
       * The orientation against which to align the element vertically
       * relative to the `positionTarget`. Possible values are "top", "bottom",
       * "middle", "auto".
       */
      verticalAlign: { type: String },
      /**
       * The orientation against which to align the element horizontally
       * relative to the `positionTarget`. Possible values are "left", "right",
       * "center", "auto".
       */
      horizontalAlign: { type: String },
      /**
       * A pixel value that will be added to the position calculated for the
       * given `verticalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `verticalAlign`.
       *
       * If `verticalAlign` is "top" or "middle", this offset will increase or
       * decrease the distance to the top side of the screen: a negative offset
       * will move the dropdown upwards; a positive one, downwards.
       *
       * Conversely if `verticalAlign` is "bottom", this offset will increase
       * or decrease the distance to the bottom side of the screen: a negative
       * offset will move the dropdown downwards; a positive one, upwards.
       */
      verticalOffset: { type: Number },
      /**
       * A pixel value that will be added to the position calculated for the
       * given `horizontalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `horizontalAlign`.
       *
       * If `horizontalAlign` is "left" or "center", this offset will increase or
       * decrease the distance to the left side of the screen: a negative offset
       * will move the dropdown to the left; a positive one, to the right.
       *
       * Conversely if `horizontalAlign` is "right", this offset will increase
       * or decrease the distance to the right side of the screen: a negative
       * offset will move the dropdown to the right; a positive one, to the left.
       */
      horizontalOffset: { type: Number },
      /**
       * If true, it will use `horizontalAlign` and `verticalAlign` values as
       * preferred alignment and if there's not enough space, it will pick the
       * values which minimize the cropping.
       */
      dynamicAlign: { type: Boolean, reflect: true },
      /**
       * True if the list is currently displayed.
       */
      opened: { type: Boolean, reflect: true },
      /**
       * Selected item value calculated as it's (in order) label property, label
       * attribute, and `innerText` value.
       */
      value: { type: String },
      /**
       * Name of the form control.
       * Note, form-associated custom elements may not be supported as first
       * implementation was released in Chrome M77 in July 2019. It may require
       * using custom form element to gather form data.
       */
      name: { type: String },
      /**
       * When set it marks the element as required. Calling the `validate`
       * function will mark this control as invalid when no value is selected.
       */
      required: { type: Boolean, reflect: true },
      /**
       * Automatically calls `validate()` function when dropdown closes.
       */
      autoValidate: { type: Boolean, reflect: true },
      /**
       * The error message to display when the input is invalid.
       */
      invalidMessage: { type: String },
      /**
       * Assistive text value.
       * Rendered beflow the input.
       */
      infoMessage: { type: String },
      /**
       * After calling `validate()` this will be populated by latest result of the test for each
       * validator. Result item will contain following properties:
       *
       * - validator {String} Name of the validator
       * - valid {Boolean} Result of the test
       * - message {String} Error message, populated only if `valid` equal `false`
       *
       * This property is `undefined` if `validator` is not set.
       */
      validationStates: { type: Array },
      /**
       * Value computed from `invalidMessage`, `invalid` and `validationStates`.
       * True if the validation message should be displayed.
       */
      _hasValidationMessage: { type: Boolean },
      /**
       * Will position the list around the button without overlapping
       * it.
       */
      noOverlap: { type: Boolean },
      /**
       * Enables outlined theme.
       */
      outlined: { type: Boolean, reflect: true },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * When set the label is rendered only when not selected state.
       * It is useful when using the dropdown in an application menu bar.
       */
      noLabelFloat: { type: Boolean, reflect: true },
      /**
       * When set the control is rendered as disabled form control.
       */
      disabled: { type: Boolean, reflect: true }
    };
  }

  constructor() {
    super();
    this.horizontalAlign = 'left';
    this.verticalAlign = 'top';
    this.noAnimations = false;
    this.allowOutsideScroll = false;
    this.dynamicAlign = false;
    this.noOverlap = false;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;
    this.restoreFocusOnClose = false;
    this.value = '';

    this._clickHandler = this._clickHandler.bind(this);
    this._onKeydown = this._onKeydown.bind(this);
    this._focusHandler = this._focusHandler.bind(this);
    /* istanbul ignore else */
    if (this.attachInternals) {
      this._internals = this.attachInternals();
    }
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }
    if (!this.hasAttribute('aria-haspopup')) {
      this.setAttribute('aria-haspopup', 'listbox');
    }
    // aria-expanded is set with `opened` flag which is initialzed in the cosntructor.
    this.addEventListener('click', this._clickHandler);
    this.addEventListener('keydown', this._onKeydown);
    this.addEventListener('focus', this._focusHandler);
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('click', this._clickHandler);
    this.removeEventListener('keydown', this._onKeydown);
    this.removeEventListener('focus', this._focusHandler);
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * is called when for disabled state changed.
   * @param {Boolean} disabled Form disabled state
   */
  formDisabledCallback(disabled) {
    const old = this._formDisabled;
    this._formDisabled = disabled;
    if (disabled && this.opened) {
      this.opened = false;
    }
    this.requestUpdate('_formDisabled', old);
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * is called when the form has been reset
   */
  formResetCallback() {
    this.value = '';
    const node = this.contentElement;
    /* istanbul ignore else */
    if (node) {
      node.selected = undefined;
    }
    this._internals.setFormValue('');
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * is called when the form state has been restored
   *
   * @param {String} state Restored value
   */
  formStateRestoreCallback(state) {
    this._internals.setFormValue(state);
  }

  firstUpdated() {
    this._openedChanged(this.opened);
    const contentElement = this.contentElement;
    const item = contentElement && contentElement.selectedItem;
    if (item) {
      this._selectedItem = item;
    }
  }
  /**
   * Handler for `click` event.
   * Opens the list of the click originated from the shadow DOM.
   * @param {MouseEvent} e
   */
  _clickHandler(e) {
    const path = e.path || e.composedPath && e.composedPath();
    /* istanbul ignore if */
    if (!path) {
      return;
    }
    /* istanbul ignore else */
    if (path.indexOf(this) !== -1 && !this.opened) {
      this.opened = true;
      e.preventDefault();
      e.stopPropagation();
    }
  }
  /**
   * Focuses on the listbox, if available.
   */
  _focusContent() {
    const node = this.contentElement;
    if (node) {
      node.focus();
    }
  }
  /**
   * Handler for the `focus` event.
   * Focuses on the listbox when opened.
   */
  _focusHandler() {
    if (this.opened) {
      this._focusContent();
    }
  }
  /**
   * Handler for the keydown event.
   * @param {KeyboardEvent} e
   */
  _onKeydown(e) {
    if (e.key === 'ArrowDown') {
      this._onDownKey(e);
    } else if (e.key === 'ArrowUp') {
      this._onUpKey(e);
    } else if (e.key === 'Escape') {
      this._onEscKey(e);
    }
  }
  /**
   * Handler for ArrowDown button press.
   * Opens the list if it's not open and focuses on the list otherwise.
   *
   * The event should be cancelled or it may cause unwanted behavior.
   *
   * @param {KeyboardEvent} e
   */
  _onDownKey(e) {
    if (!this.opened) {
      this.opened = true;
    } else {
      this._focusContent();
    }
    e.preventDefault();
    e.stopPropagation();
  }
  /**
   * Handler for ArrowUp button press.
   * Opens the list if it's not open and focuses on the list otherwise.
   *
   * The event should be cancelled or it may cause unwanted behavior.
   *
   * @param {KeyboardEvent} e
   */
  _onUpKey(e) {
    if (!this.opened) {
      this.opened = true;
    } else {
      this._focusContent();
    }
    e.preventDefault();
    e.stopPropagation();
  }
  /**
   * Handler for Escape button press.
   * Closes the list if it's open.
   */
  _onEscKey() {
    if (this.opened) {
      this.opened = false;
    }
  }
  /**
   * Compute the label for the dropdown given a selected item.
   *
   * @param {Element} selectedItem A selected Element item, with an
   * optional `label` property.
   */
  _selectedItemChanged(selectedItem) {
    let value = '';
    if (selectedItem) {
      value = selectedItem.label || selectedItem.getAttribute('label') ||
        selectedItem.textContent.trim();
    }
    this.value = value;
  }
  /**
   * Toggles `opened` state.
   *
   * @param {?MouseEvent} e When set it cancels the event
   */
  toggle(e) {
    if (this.disabled || this._formDisabled) {
      return;
    }
    this.opened = !this.opened;
    if (e && e.preventDefault) {
      e.preventDefault();
      e.stopPropagation();
    }
  }

  /**
   * Show the dropdown content.
   */
  open() {
    if (this.disabled || this._formDisabled) {
      return;
    }
    this.opened = true;
  }
  /**
   * Hide the dropdown content.
   */
  close() {
    if (this.disabled || this._formDisabled) {
      return;
    }
    this.opened = false;
  }

  _dropdownClosed() {
    this.opened = false;
    if (this.autoValidate) {
      this.validate();
      this._updateNativeValidationState();
    }
    this.focus();
  }

  _updateNativeValidationState() {
    if (!this._internals) {
      return;
    }
    if (this.invalid) {
      this._internals.setValidity({
        customError: true
      }, 'Please select a value.');
    } else {
      this._internals.setValidity({});
    }
  }

  _dropdownOpened() {
    this._focusContent();
  }

  _selectHandler(e) {
    this.opened = false;
    this._selectedItem = e.detail.item;
  }

  _deselectHandler() {
    this._selectedItem = null;
  }
  /**
   * Returns false if the element is required and does not have a selection,
   * and true otherwise.
   *
   * @return {boolean} true if `required` is false, or if `required` is true
   * and the element has a valid selection.
   */
  _getValidity() {
    return (this.disabled || this._formDisabled) || !this.required || (this.required && !!this.value);
  }

  _openedChanged(opened) {
    const openState = opened ? 'true' : 'false';
    this.setAttribute('aria-expanded', openState);
    const e = this.contentElement;
    if (e) {
      e.setAttribute('aria-expanded', openState);
    }
  }

  checkValidity() {
    return this._getValidity() && ((this._internals && this._internals.checkValidity()) || true);
  }
  /**
   * Called when validation states changed.
   * Validation states are set by validatable mixin and is a result of calling
   * a custom validator. Each validator returns an object with `valid` and `message`
   * properties.
   *
   * See `ValidatableMixin` for more information.
   *
   * @param {?Array<Object>} states
   */
  _validationStatesChanged(states) {
    if (!states || !states.length) {
      return;
    }
    const parts = [];
    for (let i = 0, len = states.length; i < len; i++) {
      if (!states[i].valid) {
        parts[parts.length] = states[i].message;
      }
    }
    this.invalidMessage = parts.join('. ');
  }
  /**
   * Calles when `autoValidate` changed
   * @param {Boolean} value
   */
  _autoValidateChanged(value) {
    if (value) {
      this.validate();
    }
  }
  /**
   * From `ValidatableMixin`
   * @param {Boolean} value Current invalid sate
   */
  _invalidChanged(value) {
    super._invalidChanged(value);
    this._hasValidationMessage = value && !!this.invalidMessage;
    this._ensureInvalidAlertSate(value);
  }

  _ensureInvalidAlertSate(invalid) {
    if (!this.invalidMessage) {
      return;
    }
    const node = this.shadowRoot.querySelector('p.invalid');
    if (!node) {
      return;
    }
    if (invalid) {
      node.setAttribute('role', 'alert');
    } else {
      node.removeAttribute('role');
    }
    setTimeout(() => {
      node.removeAttribute('role');
    }, 1000);
  }
}

window.customElements.define('anypoint-dropdown-menu', AnypointDropdownMenu);

/**
 * Port of `@polymer/iron-selector/iron-selection.js`.
 */
class AnypointSelection {
  /**
   * @param {!Function} selectCallback
   * @suppress {missingProvide}
   */
  constructor(selectCallback) {
    this.multi = false;
    this.selection = [];
    this.selectCallback = selectCallback;
  }

  /**
   * Retrieves the selected item(s).
   *
   * @return {*} Returns the selected item(s). If the multi property is true,
   * `get` will return an array, otherwise it will return
   * the selected item or undefined if there is no selection.
   */
  get() {
    return this.multi ? this.selection.slice() : this.selection[0];
  }

  /**
   * Clears all the selection except the ones indicated.
   *
   * @param {Array} excludes items to be excluded.
   */
  clear(excludes) {
    this.selection.slice().forEach(function(item) {
      if (!excludes || excludes.indexOf(item) < 0) {
        this.setItemSelected(item, false);
      }
    }, this);
  }

  /**
   * Indicates if a given item is selected.
   *
   * @param {*} item The item whose selection state should be checked.
   * @return {boolean} Returns true if `item` is selected.
   */
  isSelected(item) {
    return this.selection.indexOf(item) >= 0;
  }

  /**
   * Sets the selection state for a given item to either selected or deselected.
   *
   * @param {*} item The item to select.
   * @param {boolean} isSelected True for selected, false for deselected.
   */
  setItemSelected(item, isSelected) {
    if (item !== null) {
      if (isSelected !== this.isSelected(item)) {
        // proceed to update selection only if requested state differs from
        // current
        if (isSelected) {
          this.selection.push(item);
        } else {
          const i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    }
  }

  /**
   * Sets the selection state for a given item. If the `multi` property
   * is true, then the selected state of `item` will be toggled; otherwise
   * the `item` will be selected.
   *
   * @param {*} item The item to select.
   */
  select(item) {
    if (this.multi) {
      this.toggle(item);
    } else if (this.get() !== item) {
      this.setItemSelected(this.get(), false);
      this.setItemSelected(item, true);
    }
  }

  /**
   * Toggles the selection state for `item`.
   *
   * @param {*} item The item to toggle.
   */
  toggle(item) {
    this.setItemSelected(item, !this.isSelected(item));
  }
}

/**
 * The set of excluded elements where the key is the `localName`
 * of the element that will be ignored from the item list.
 */
const excludedLocalNames = {
  'template': 1,
  'dom-bind': 1,
  'dom-if': 1,
  'dom-repeat': 1
};

const p$2 = Element.prototype;
const normalizedMatchesSelector$1 =
  p$2.matches ||
  p$2.matchesSelector ||
  p$2.mozMatchesSelector ||
  p$2.msMatchesSelector ||
  p$2.oMatchesSelector ||
  p$2.webkitMatchesSelector;
/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @param {!Node} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
const matchesSelector$1 = function(node, selector) {
  return normalizedMatchesSelector$1.call(node, selector);
};
/**
 * Port of `@polymer/iron-selector/iron-selectable.js`.
 *
 * A mixin to be applied to a class where child elements can be selected.
 *
 * Note, by default the mixin works with LitElement. If used with different class
 * make sure that attributes are reflected to properties correctly.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 */
const AnypointSelectableMixin = (base) =>
  class extends base {
    /**
     * Fired when anypoint-selector is activated (selected or deselected).
     * It is fired before the selected items are changed.
     * Cancel the event to abort selection.
     *
     * @event activate
     */

    /**
     * Fired when an item is selected
     *
     * @event select
     */

    /**
     * Fired when an item is deselected
     *
     * @event deselect
     */

    /**
     * Fired when the list of selectable items changes (e.g., items are
     * added or removed). The detail of the event is a mutation record that
     * describes what changed.
     *
     * @event children-changed
     */

    /**
     * Fired when anypoint-selector is activated (selected or deselected).
     * It is fired before the selected items are changed.
     * Cancel the event to abort selection.
     *
     * @event iron-activate
     * @deprecated Use `activate`instead. It is for compatibility with Polymer elements.
     */

    /**
     * Fired when an item is selected
     *
     * @event iron-select
     * @deprecated Use `select. It is for compatibility with Polymer elements.
     */

    /**
     * Fired when an item is deselected
     *
     * @event iron-deselect
     * @deprecated Use `deselect`instead. It is for compatibility with Polymer elements.
     */

    /**
     * Fired when the list of selectable items changes (e.g., items are
     * added or removed). The detail of the event is a mutation record that
     * describes what changed.
     *
     * @event iron-items-changed
     * @deprecated Use `children-changed`instead. It is for compatibility with Polymer elements.
     */

    static get properties() {
      return {
        /**
         * If you want to use an attribute value or property of an element for
         * `selected` instead of the index, set this to the name of the attribute
         * or property. Hyphenated values are converted to camel case when used to
         * look up the property of a selectable element. Camel cased values are
         * *not* converted to hyphenated values for attribute lookup. It's
         * recommended that you provide the hyphenated form of the name so that
         * selection works in both cases. (Use `attr-or-property-name` instead of
         * `attrOrPropertyName`.)
         */
        attrForSelected: { type: String },

        /**
         * Gets or sets the selected element. The default is to use the index of the
         * item.
         * @type {string|number}
         */
        selected: { },

        /**
         * Returns the currently selected item.
         *
         * @type {?Object}
         */
        _selectedItem: { type: Object },

        /**
         * The event that fires from items when they are selected. Selectable
         * will listen for this event from items and update the selection state.
         * Set to empty string to listen to no events.
         *
         * @default click
         */
        activateEvent: { type: String },

        /**
         * This is a CSS selector string.  If this is set, only items that match the
         * CSS selector are selectable.
         */
        selectable: { type: String },

        /**
         * The class to set on elements when selected.
         *
         * @default selected
         */
        selectedClass: { type: String },

        /**
         * The attribute to set on elements when selected.
         */
        selectedAttribute: { type: String },

        /**
         * Default fallback if the selection based on selected with
         * `attrForSelected` is not found.
         *
         * @type {String|Number}
         */
        fallbackSelection: { },

        /**
         * The list of items from which a selection can be made.
         */
        items: { type: Array }
      };
    }

    get attrForSelected() {
      return this._attrForSelected;
    }

    set attrForSelected(value) {
      const old = this._attrForSelected;
      /* istanbul ignore if */
      if (old === value) {
        return;
      }
      this._attrForSelected = value;
      this._updateAttrForSelected();
    }

    get selected() {
      return this._selected;
    }

    set selected(value) {
      const old = this._selected;
      /* istanbul ignore if */
      if (old === value) {
        return;
      }
      this._selected = value;
      /* istanbul ignore else */
      if (this.requestUpdate) {
        this.requestUpdate('selected', value);
      }
      this._updateSelected(value);
      this.dispatchEvent(
        new CustomEvent('selected-changed', {
          detail: {
            value
          }
        })
      );
    }

    get items() {
      return this._items;
    }

    get _items() {
      return this.__items;
    }

    set _items(value) {
      const old = this.__items;
      /* istanbul ignore if */
      if (old === value) {
        return;
      }
      this.__items = value;
      /* istanbul ignore else */
      if (this.requestUpdate) {
        this.requestUpdate('_items', value);
      }
      this.dispatchEvent(
        new CustomEvent('items-changed', {
          detail: {
            value
          }
        })
      );
    }

    get selectedItem() {
      return this._selectedItem;
    }

    get _selectedItem() {
      return this.__selectedItem;
    }

    set _selectedItem(value) {
      const old = this.__selectedItem;
      /* istanbul ignore if */
      if (old === value) {
        return;
      }
      this.__selectedItem = value;
      /* istanbul ignore else */
      if (this.requestUpdate) {
        this.requestUpdate('_selectedItem', value);
      }
      this.dispatchEvent(
        new CustomEvent('selecteditem-changed', {
          detail: {
            value
          }
        })
      );
    }

    get activateEvent() {
      return this._activateEvent;
    }

    set activateEvent(value) {
      const old = this._activateEvent;
      /* istanbul ignore if */
      if (old === value) {
        return;
      }
      this._activateEvent = value;
      this._activateEventChanged(value, old);
    }

    get fallbackSelection() {
      return this._fallbackSelection;
    }

    set fallbackSelection(value) {
      const old = this._fallbackSelection;
      /* istanbul ignore if */
      if (old === value) {
        return;
      }
      this._fallbackSelection = value;
      this._checkFallback(value);
    }

    /**
     * @return {Function} Previously registered handler for `selected-changed` event
     */
    get onselectedchanged() {
      return this['_onselected-changed'];
    }
    /**
     * Registers a callback function for `selected-changed` event
     * @param {Function} value A callback to register. Pass `null` or `undefined`
     * to clear the listener.
     */
    set onselectedchanged(value) {
      this._registerCallback('selected-changed', value);
    }

    /**
     * @return {Function} Previously registered handler for `selecteditem-changed` event
     */
    get onselecteditemchanged() {
      return this['_onselecteditem-changed'];
    }
    /**
     * Registers a callback function for `selecteditem-changed` event
     * @param {Function} value A callback to register. Pass `null` or `undefined`
     * to clear the listener.
     */
    set onselecteditemchanged(value) {
      this._registerCallback('selecteditem-changed', value);
    }

    /**
     * @return {Function} Previously registered handler for `items-changed` event
     */
    get onitemschanged() {
      return this['_onitems-changed'];
    }
    /**
     * Registers a callback function for `items-changed` event
     * @param {Function} value A callback to register. Pass `null` or `undefined`
     * to clear the listener.
     */
    set onitemschanged(value) {
      this._registerCallback('items-changed', value);
    }

    /**
     * @return {Function} Previously registered handler for `select` event
     */
    get onselect() {
      return this._onselect;
    }
    /**
     * Registers a callback function for `select` event
     * @param {Function} value A callback to register. Pass `null` or `undefined`
     * to clear the listener.
     */
    set onselect(value) {
      this._registerCallback('select', value);
    }

    /**
     * @return {Function} Previously registered handler for `deselect` event
     */
    get ondeselect() {
      return this._ondeselect;
    }
    /**
     * Registers a callback function for `deselect` event
     * @param {Function} value A callback to register. Pass `null` or `undefined`
     * to clear the listener.
     */
    set ondeselect(value) {
      this._registerCallback('deselect', value);
    }

    /**
     * @return {Function} Previously registered handler for `activate` event
     */
    get onactivate() {
      return this._onactivate;
    }
    /**
     * Registers a callback function for `activate` event
     * @param {Function} value A callback to register. Pass `null` or `undefined`
     * to clear the listener.
     */
    set onactivate(value) {
      this._registerCallback('activate', value);
    }

    constructor() {
      super();
      this.attrForSelected = null;
      this.fallbackSelection = null;
      this.selectedAttribute = null;
      this.selectedClass = 'selected';
      this.activateEvent = 'click';
      this._items = [];

      this._filterItem = this._filterItem.bind(this);
      this._activateHandler = this._activateHandler.bind(this);
      this._selection = new AnypointSelection(this._applySelection.bind(this));
      this._mutationHandler = this._mutationHandler.bind(this);
      this._slotchangeHandler = this._slotchangeHandler.bind(this);
    }

    connectedCallback() {
      /* istanbul ignore else */
      if (super.connectedCallback) {
        super.connectedCallback();
      }
      this._observer = this._observeItems(this);
      this._observeSlotItems();
      this._updateItems();
      this._updateSelected();
    }

    disconnectedCallback() {
      /* istanbul ignore else */
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
      if (this._observer) {
        this._observer.disconnect();
        this._observer = null;
      }
      this._removeListener(this.activateEvent);
      this._unobserveSlotItems();
    }

    _registerCallback(eventType, value) {
      const key = `_on${eventType}`;
      if (this[key]) {
        this.removeEventListener(eventType, this[key]);
      }
      if (typeof value !== 'function') {
        this[key] = null;
        return;
      }
      this[key] = value;
      this.addEventListener(eventType, value);
    }

    _addListener(eventName) {
      this.addEventListener(eventName, this._activateHandler);
    }

    _removeListener(eventName) {
      this.removeEventListener(eventName, this._activateHandler);
    }
    /**
     * Observe items change in the element's light DOM
     * @return {Object} The observer handler
     */
    _observeItems() {
      const config = { attributes: true, childList: true, subtree: false };
      const observer = new MutationObserver(this._mutationHandler);
      observer.observe(this, config);
      return observer;
    }
    /**
     * Observers changes in slot children where slot is in the light DOM.
     */
    _observeSlotItems() {
      const nodes = this.querySelectorAll('slot');
      for (let i = 0, len = nodes.length; i < len; i++) {
        nodes[i].addEventListener('slotchange', this._slotchangeHandler);
      }
    }
    /**
     * Removes change observers from slot children where slot is in the light DOM.
     */
    _unobserveSlotItems() {
      const nodes = this.querySelectorAll('slot');
      for (let i = 0, len = nodes.length; i < len; i++) {
        nodes[i].removeEventListener('slotchange', this._slotchangeHandler);
      }
    }
    /**
     * When light DOM mutate this method is called to remove listener from
     * removed `<slot>` children.
     * @param {NodeList} nodeList List of removed children.
     */
    _checkRemovedSlot(nodeList) {
      for (let i = 0, len = nodeList.length; i < len; i++) {
        if (nodeList[i].localName === 'slot') {
          nodeList[i].removeEventListener('slotchange', this._slotchangeHandler);
        }
      }
    }
    /**
     * Handler for the `slotchange` event dispatched on slot.
     * Updates items and selection.
     */
    _slotchangeHandler() {
      this._updateItems();
      this._updateSelected();
    }
    /**
     * Callback for a mutation event dispatched by the MutationObserver.
     * @param {Array<Object>} mutationsList List of mutations.
     */
    _mutationHandler(mutationsList) {
      this._updateItems();
      this._updateSelected();
      for(const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          this._checkRemovedSlot(mutation.removedNodes);
        }
      }
      // Let other interested parties know about the change so that
      // we don't have to recreate mutation observers everywhere.
      const config = {
        bubbles: true,
        composed: true,
        detail: mutationsList
      };
      this.dispatchEvent(new CustomEvent('children-changed', config));
      this.dispatchEvent(new CustomEvent('iron-items-changed', config));
    }

    /**
     * Returns the index of the given item.
     *
     * @method indexOf
     * @param {Object} item
     * @return {number} Returns the index of the item
     */
    indexOf(item) {
      return this.items ? this.items.indexOf(item) : -1;
    }

    /**
     * Selects the given value.
     *
     * @method select
     * @param {string|number} value the value to select.
     */
    select(value) {
      this.selected = value;
    }

    /**
     * Selects the previous item.
     *
     * @method selectPrevious
     */
    selectPrevious() {
      const length = this.items.length;
      let index = length - 1;
      if (this.selected !== undefined) {
        index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
      }
      this.selected = this._indexToValue(index);
    }

    /**
     * Selects the next item.
     *
     * @method selectNext
     */
    selectNext() {
      let index = 0;
      if (this.selected !== undefined) {
        index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
      }
      this.selected = this._indexToValue(index);
    }

    /**
     * Selects the item at the given index.
     *
     * @method selectIndex
     * @param {Number} index
     */
    selectIndex(index) {
      this.select(this._indexToValue(index));
    }

    _checkFallback() {
      this._updateSelected();
    }

    _activateEventChanged(eventName, old) {
      this._removeListener(old);
      this._addListener(eventName);
    }

    _updateItems() {
      let nodes = this._queryDistributedElements(this.selectable || '*');
      nodes = nodes.filter(this._filterItem);
      this._items = nodes;
    }

    _queryDistributedElements(selector) {
      const nodes = Array.from(this.children);
      // checks for slots and replaces a slot with it's nodes.
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.localName === 'slot') {
          const tmp = node.assignedNodes({ flatten: true });
          nodes.splice(i, 1, ...tmp);
        }
      }
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        if (node.nodeType !== Node.ELEMENT_NODE || !matchesSelector$1(node, selector)) {
          nodes.splice(i, 1);
        }
      }
      return nodes;
    }

    _updateAttrForSelected() {
      if (this.selectedItem) {
        this.selected = this._valueForItem(this.selectedItem);
      }
    }

    _updateSelected() {
      this._selectSelected(this.selected);
    }

    _selectSelected(selected) {
      if (!this.items) {
        return;
      }

      const item = this._valueToItem(selected);
      if (item) {
        this._selection.select(item);
      } else {
        this._selection.clear();
      }
      // Check for items, since this array is populated only when attached
      // Since Number(0) is falsy, explicitly check for undefined
      if (this.fallbackSelection && this.items.length && this._selection.get() === undefined) {
        this.selected = this.fallbackSelection;
      }
    }

    _filterItem(node) {
      return !excludedLocalNames[node.localName];
    }

    _valueToItem(value) {
      return value === null ? null : this.items[this._valueToIndex(value)];
    }

    _valueToIndex(value) {
      if (this.attrForSelected) {
        for (let i = 0, len = this.items.length; i < len; i++) {
          const item = this.items[i];
          if (this._valueForItem(item) === value) {
            return i;
          }
        }
      } else {
        return Number(value);
      }
    }

    _indexToValue(index) {
      if (this.attrForSelected) {
        const item = this.items[index];
        if (item) {
          return this._valueForItem(item);
        }
      } else {
        return index;
      }
    }

    _valueForItem(item) {
      if (!item) {
        return null;
      }
      if (!this.attrForSelected) {
        const i = this.indexOf(item);
        return i === -1 ? null : i;
      }
      const dash = this.attrForSelected;
      const prop = dash.indexOf('-') < 0 ? dash : dash.replace(/-[a-z]/g, (m) => m[1].toUpperCase());
      const propValue = item[prop];
      return propValue !== undefined ? propValue : item.getAttribute(this.attrForSelected);
    }

    _applySelection(item, isSelected) {
      if (this.selectedClass) {
        this.toggleClass(this.selectedClass, isSelected, item);
      }
      if (this.selectedAttribute) {
        if (isSelected) {
          item.setAttribute(this.selectedAttribute, '');
        } else {
          item.removeAttribute(this.selectedAttribute);
        }
      }
      this._selectionChange();
      const opts = {
        bubbles: true,
        composed: true,
        detail: {
          item
        }
      };
      const name = isSelected ? 'select' : 'deselect';
      this.dispatchEvent(new CustomEvent(name, opts));
      this.dispatchEvent(new CustomEvent(`iron-${name}`, opts));
    }

    toggleClass(klass, selected, node) {
      if (selected) {
        node.classList.add(klass);
      } else {
        node.classList.remove(klass);
      }
    }

    _selectionChange() {
      this._selectedItem = this._selection.get();
    }

    _activateHandler(e) {
      let t = e.target;
      const items = this.items;
      while (t && t !== this) {
        const i = items.indexOf(t);
        if (i >= 0) {
          const value = this._indexToValue(i);
          this._itemActivate(value, t);
          return;
        }
        t = t.parentNode;
      }
    }

    _itemActivate(value, item) {
      const opts = {
        cancelable: true,
        bubbles: true,
        composed: true,
        detail: {
          selected: value,
          item
        }
      };
      let e = new CustomEvent('activate', opts);
      this.dispatchEvent(e);
      if (e.defaultPrevented) {
        return;
      }
      e = new CustomEvent('iron-activate', opts);
      this.dispatchEvent(e);
      if (e.defaultPrevented) {
        return;
      }
      this.select(value);
    }
  };

/**
 * Port of `@polymer/iron-selector/iron-multi-selectable.js`.
 *
 * A mixin to be applied to a class where child elements can be selected and selection
 * can be applied to more than one item.
 *
 * Note, by default the mixin works with LitElement. If used with different class
 * make sure that attributes are reflected to properties correctly.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 * @appliesMixin AnypointSelectableMixin
 */
const AnypointMultiSelectableMixin = (base) => class extends AnypointSelectableMixin(base) {
  static get properties() {
    return {
      /**
       * If true, multiple selections are allowed.
       */
      multi: { type: Boolean },
      /**
       * Gets or sets the selected elements. This is used instead of `selected`
       * when `multi` is true.
       */
      selectedValues: { type: Array },
      _selectedItems: { type: Array }
    };
  }

  get multi() {
    return this._multi;
  }

  set multi(value) {
    const old = this._multi;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._multi = value;
    this.multiChanged(value);
  }

  get selectedValues() {
    return this._selectedValues;
  }

  set selectedValues(value) {
    const old = this._selectedValues;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._selectedValues = value;
    this._updateSelected();
    this.dispatchEvent(new CustomEvent('selectedvalues-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Array<Element>} An array of currently selected items.
   */
  get selectedItems() {
    return this._selectedItems;
  }

  get _selectedItems() {
    return this.__selectedItems;
  }

  set _selectedItems(value) {
    const old = this.__selectedItems;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__selectedItems = value;
    this.dispatchEvent(new CustomEvent('selecteditems-changed', {
      detail: {
        value
      }
    }));
  }

  /**
   * @return {Function} Previously registered handler for `selectedvalues-changed` event
   */
  get onselectedvalueschanged() {
    return this['_onselectedvalues-changed'];
  }
  /**
   * Registers a callback function for `selectedvalues-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onselectedvalueschanged(value) {
    this._registerCallback('selectedvalues-changed', value);
  }

  /**
   * @return {Function} Previously registered handler for `selecteditems-changed` event
   */
  get onselecteditemschanged() {
    return this['_onselecteditems-changed'];
  }
  /**
   * Registers a callback function for `selecteditems-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onselecteditemschanged(value) {
    this._registerCallback('selecteditems-changed', value);
  }

  constructor() {
    super();
    this.multi = false;
    this._selectedValues = [];
    this._selectedItems = [];
  }

  /**
   * Selects the given value. If the `multi` property is true, then the selected
   * state of the `value` will be toggled; otherwise the `value` will be
   * selected.
   *
   * @method select
   * @param {string|number} value the value to select.
   */
  select(value) {
    if (this.multi) {
      this._toggleSelected(value);
    } else {
      this.selected = value;
    }
  }

  multiChanged(multi) {
    this._selection.multi = multi;
    this._updateSelected();
  }

  _updateAttrForSelected() {
    if (!this.multi) {
      super._updateAttrForSelected();
    } else if (this.selectedItems && this.selectedItems.length > 0) {
      this.selectedValues =
        this.selectedItems.map((selectedItem) => this._indexToValue(this.indexOf(selectedItem)))
          .filter((unfilteredValue) => unfilteredValue !== null);
    }
  }

  _updateSelected() {
    if (this.multi) {
      this._selectMulti(this.selectedValues);
    } else {
      this._selectSelected(this.selected);
    }
  }

  _selectMulti(values) {
    values = values || [];

    const selectedItems = (this._valuesToItems(values) || [])
      .filter((item) => item !== null && item !== undefined);

    // clear all but the current selected items
    this._selection.clear(selectedItems);

    // select only those not selected yet
    for (let i = 0; i < selectedItems.length; i++) {
      this._selection.setItemSelected(selectedItems[i], true);
    }

    // Check for items, since this array is populated only when attached
    if (this.fallbackSelection && !this._selection.get().length) {
      const fallback = this._valueToItem(this.fallbackSelection);
      if (fallback) {
        this.select(this.fallbackSelection);
      }
    }
  }

  _selectionChange() {
    const s = this._selection.get();
    if (this.multi) {
      this._selectedItems = s;
      this._selectedItem = (s.length ? s[0] : null);
    } else {
      if (s !== null && s !== undefined) {
        this._selectedItems = [s];
        this._selectedItem = s;
      } else {
        this._selectedItems = [];
        this._selectedItem = null;
      }
    }
  }

  _toggleSelected(value) {
    const i = this.selectedValues.indexOf(value);
    const unselected = i < 0;
    const items = this.selectedValues;
    if (unselected) {
      items.push(value);
    } else {
      items.splice(i, 1);
    }
    this.selectedValues = [...items];
  }

  _valuesToItems(values) {
    return (values === null) ?
      null :
      values.map((value) => this._valueToItem(value));
  }
};

/**
 * The list of keys has been taken from
 * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState
 * @private
 */
const MODIFIER_KEYS$1 = [
  'Alt',
  'AltGraph',
  'CapsLock',
  'Control',
  'Fn',
  'FnLock',
  'Hyper',
  'Meta',
  'NumLock',
  'OS',
  'ScrollLock',
  'Shift',
  'Super',
  'Symbol',
  'SymbolLock'
];

const SEARCH_RESET_TIMEOUT_MS = 1000;

/**
 * Port of `@polymer/iron-menu-behavior`.
 *
 * A mixin that implement accessible menu and menubar behaviors.
 *
 * Note, by default the mixin works with LitElement. If used with different class
 * make sure that attributes are reflected to properties correctly.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 * @appliesMixin AnypointMultiSelectableMixin
 */
const AnypointMenuMixin = (base) => class extends AnypointMultiSelectableMixin(base) {
  static get properties() {
    return {
      /**
       * If true, multiple selections are allowed.
       */
      _focusedItem: { type: Object },
      /**
       * The attribute to use on menu items to look up the item title. Typing the
       * first letter of an item when the menu is open focuses that item. If
       * unset, `textContent` will be used.
       */
      attrForItemTitle: { type: String },

      /**
       * @type {boolean}
       */
      disabled: { type: Boolean },

      _previousTabIndex: { type: Number },
      /**
       * When set it adds `aria-selected` attribute to currently selected item.
       *
       * The `aria-selected` attribute is invalid with default role of this
       * element ("menu"). If you manually change the role to some other that
       * accepts `aria-selected` attribute on children then set this property.
       */
      useAriaSelected: { type: Boolean }
    };
  }

  /**
   * @return {?Element} The currently focused item.
   */
  get focusedItem() {
    return this._focusedItem;
  }

  get _focusedItem() {
    return this.__focusedItem;
  }

  set _focusedItem(value) {
    const old = this.__focusedItem;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__focusedItem = value;
    this._focusedItemChanged(value, old);
  }

  get disabled() {
    return this._disabled;
  }

  set disabled(value) {
    const old = this._disabled;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._disabled = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('disabled', value);
    }
    this._disabledChanged(value);
  }

  constructor() {
    super();
    this._previousTabIndex = 0;

    this._onFocus = this._onFocus.bind(this);
    this._onKeydown = this._onKeydown.bind(this);
    this._onItemsChanged = this._onItemsChanged.bind(this);
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'menu');
    }
    this.addEventListener('focus', this._onFocus);
    this.addEventListener('keydown', this._onKeydown);
    this.addEventListener('children-changed', this._onItemsChanged);

    if (this._disabled === undefined) {
      this.disabled = false;
    }

    this._resetTabindices();
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('focus', this._onFocus);
    this.removeEventListener('keydown', this._onKeydown);
    this.removeEventListener('children-changed', this._onItemsChanged);
  }

  multiChanged(value) {
    super.multiChanged(value);
    if (value) {
      this.setAttribute('aria-multiselectable', 'true');
    } else {
      this.removeAttribute('aria-multiselectable');
    }
  }

  _onItemsChanged(e) {
    const mutationsList = e.detail;
    for(const mutation of mutationsList) {
      if (mutation.type === 'childList' && mutation.addedNodes.length) {
        this._resetTabindices();
      }
    }
  }
  /**
   * Handler for the keydown event.
   * @param {KeyboardEvent} e
   */
  _onKeydown(e) {
    if (e.key === 'ArrowDown') {
      this._onDownKey(e);
    } else if (e.key === 'ArrowUp') {
      this._onUpKey(e);
    } else if (e.key === 'Tab' && e.shiftKey) {
      this._onShiftTabDown(e);
    } else if (e.key === 'Escape') {
      this._onEscKey(e);
    } else {
      this._focusWithKeyboardEvent(e);
    }
    e.stopPropagation();
  }
  /**
   * Handler that is called when the up key is pressed.
   *
   * @param {CustomEvent} e A key combination event.
   */
  _onUpKey(e) {
    this._focusPrevious();
    e.preventDefault();
  }
  /**
   * Handler that is called when the down key is pressed.
   *
   * @param {CustomEvent} e A key combination event.
   */
  _onDownKey(e) {
    e.preventDefault();
    e.stopPropagation();
    this._focusNext();
  }
  /**
   * Handler that is called when the esc key is pressed.
   *
   * @param {CustomEvent} e A key combination event.
   */
  _onEscKey() {
    const focusedItem = this.focusedItem;
    if (focusedItem) {
      focusedItem.blur();
    }
  }

  _focusWithKeyboardEvent(e) {
    // Make sure that the key pressed is not a modifier key.
    // getModifierState is not being used, as it is not available in Safari
    // earlier than 10.0.2 (https://trac.webkit.org/changeset/206725/webkit)
    if (MODIFIER_KEYS$1.indexOf(e.key) !== -1) {
      return;
    }
    if (this._clearSearchTextDebouncer) {
      clearTimeout(this._clearSearchTextDebouncer);
      this._clearSearchTextDebouncer = undefined;
    }
    let searchText = this._searchText || '';
    const key = e.key && e.key.length === 1 ?
        e.key :
        String.fromCharCode(e.keyCode);
    searchText += key.toLocaleLowerCase();

    const searchLength = searchText.length;
    for (let i = 0, len = this.items.length; i < len; i++) {
      const item = this.items[i];
      if (item.hasAttribute('disabled')) {
        continue;
      }

      const attr = this.attrForItemTitle || 'textContent';
      const title = (item[attr] || item.getAttribute(attr) || '').trim();

      if (title.length < searchLength) {
        continue;
      }

      if (title.slice(0, searchLength).toLocaleLowerCase() === searchText) {
        this._focusedItem = (item);
        break;
      }
    }

    this._searchText = searchText;
    this._clearSearchTextDebouncer = setTimeout(() => this._clearSearchText(), SEARCH_RESET_TIMEOUT_MS);
  }

  _clearSearchText() {
    this._searchText = '';
  }

  /**
   * Resets all tabindex attributes to the appropriate value based on the
   * current selection state. The appropriate value is `0` (focusable) for
   * the default selected item, and `-1` (not keyboard focusable) for all
   * other items. Also sets the correct initial values for aria-selected
   * attribute, true for default selected item and false for others.
   */
  _resetTabindices() {
    const firstSelectedItem = this.multi ?
        (this.selectedItems && this.selectedItems[0]) :
        this.selectedItem;
    const aria = this.useAriaSelected;
    this.items.forEach((item) => {
      item.setAttribute('tabindex', item === firstSelectedItem ? '0' : '-1');
      if (aria) {
        item.setAttribute('aria-selected', this._selection.isSelected(item));
      }
    });
  }

  /**
   * Selects the given value. If the `multi` property is true, then the selected
   * state of the `value` will be toggled; otherwise the `value` will be
   * selected.
   *
   * @param {string|number} value the value to select.
   */
  select(value) {
    const item = this._valueToItem(value);
    if (item && item.hasAttribute('disabled')) {
      return;
    }
    this._focusedItem = (item);
    super.select(value);
  }
  /**
   * Focuses the previous item (relative to the currently focused item) in the
   * menu, disabled items will be skipped.
   * Loop until length + 1 to handle case of single item in menu.
   */
  _focusPrevious() {
    const length = this.items.length;
    const curFocusIndex = Number(this.indexOf(this.focusedItem));

    for (let i = 1; i < length + 1; i++) {
      const item = this.items[(curFocusIndex - i + length) % length];
      if (!item.hasAttribute('disabled')) {
        const owner = (item.getRootNode && item.getRootNode()) || document;
        this._focusedItem = item;
        // Focus might not have worked, if the element was hidden or not
        // focusable. In that case, try again.
        if (owner.activeElement === item) {
          return;
        }
      }
    }
  }

  _focusNext() {
    const length = this.items.length;
    const curFocusIndex = Number(this.indexOf(this.focusedItem));
    for (let i = 1; i < length + 1; i++) {
      const item = this.items[(curFocusIndex + i) % length];
      if (!item.hasAttribute('disabled')) {
        const owner = (item.getRootNode && item.getRootNode()) || document;
        this._focusedItem = item;
        // Focus might not have worked, if the element was hidden or not
        // focusable. In that case, try again.
        if (owner.activeElement === item) {
          return;
        }
      }
    }
  }
  /**
   * Mutates items in the menu based on provided selection details, so that
   * all items correctly reflect selection state.
   *
   * @param {Element} item An item in the menu.
   * @param {boolean} isSelected True if the item should be shown in a
   * selected state, otherwise false.
   */
  _applySelection(item, isSelected) {
    if (this.useAriaSelected) {
      if (isSelected) {
        item.setAttribute('aria-selected', 'true');
      } else {
        item.setAttribute('aria-selected', 'false');
      }
    }
    super._applySelection(item, isSelected);
  }
  /**
   * Discretely updates tabindex values among menu items as the focused item
   * changes.
   *
   * @param {Element} focusedItem The element that is currently focused.
   * @param {?Element} old The last element that was considered focused, if
   * applicable.
   */
  _focusedItemChanged(focusedItem, old) {
    if (old) {
      old.setAttribute('tabindex', '-1');
    }
    if (focusedItem && !focusedItem.hasAttribute('disabled') && !this.disabled) {
      focusedItem.setAttribute('tabindex', '0');
      focusedItem.focus();
    }
  }

  /**
   * Handler that is called when a shift+tab keypress is detected by the menu.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onShiftTabDown() {
    const oldTabIndex = this.getAttribute('tabindex');

    this._shiftTabPressed = true;

    this._focusedItem = null;

    this.setAttribute('tabindex', '-1');

    setTimeout(() => {
      this.setAttribute('tabindex', oldTabIndex);
      this._shiftTabPressed = false;
      // NOTE(cdata): polymer/polymer#1305
    }, 1);
  }

  _onFocus(e) {
    if (this._shiftTabPressed) {
      // do not focus the menu itself
      return;
    }
    let path = e.composedPath && e.composedPath();
    if (!path) {
      path = e.path;
    }
    const rootTarget = path[0];
    if (rootTarget !== this && typeof rootTarget.tabIndex !== 'undefined' && !this.contains(rootTarget)) {
      return;
    }
    // focus the selected item when the menu receives focus, or the first item
    // if no item is selected
    const firstSelectedItem = this.multi ?
    (this.selectedItems && this.selectedItems[0]) :
    this.selectedItem;

    this._focusedItem = null;

    if (firstSelectedItem) {
      this._focusedItem = firstSelectedItem;
    } else if (this.items.length) {
      // We find the first none-disabled item (if one exists)
      this._focusNext();
    }
  }

  _activateHandler(e) {
    super._activateHandler(e);
    e.stopPropagation();
  }

  _disabledChanged(disabled) {
    if (disabled) {
      this._previousTabIndex = this.hasAttribute('tabindex') ? this.tabIndex : 0;
      this.removeAttribute('tabindex');  // No tabindex means not tab-able or select-able.
    } else if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', this._previousTabIndex);
    }
  }
};

let globalId = 1;

class AnypointListbox extends AnypointMenuMixin(LitElement) {
  static get styles() {
    return css`
    :host {
      display: block;
      padding: var(--anypoint-listbox-padding, 0);
      background-color: var(--anypoint-listbox-background-color, var(--primary-background-color));
      color: var(--anypoint-listbox-color, var(--primary-text-color));
    }

    :host ::slotted(.selected) {
      font-weight: 700;
    }
    `;
  }

  render() {
    return html`<slot></slot>`;
  }

  static get properties() {
    return {
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get compatibility() {
    return this._compatibility;
  }

  set compatibility(value) {
    const old = this._compatibility;
    if (old === value) {
      return;
    }
    this._compatibility = value;
    this._updateChildrenCompatibility(value);
  }

  constructor() {
    super();
    this._selectHandler = this._selectHandler.bind(this);
    this._deselectHandler = this._deselectHandler.bind(this);
  }

  connectedCallback() {
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'listbox');
    }
    this.setAttribute('aria-activedescendant', '');
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('select', this._selectHandler);
    this.addEventListener('deselect', this._deselectHandler);

    this._initSeelction();
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('select', this._selectHandler);
    this.removeEventListener('deselect', this._deselectHandler);
  }

  firstUpdated() {
    const { compatibility } = this;
    if (compatibility) {
      this._updateChildrenCompatibility(compatibility);
    }
  }

  /**
   * Initializes `aria-activedescendant` when element is attached to the DOM.
   */
  _initSeelction() {
    if (this.selectedItem) {
      this._setActiveDescendant(this.selectedItem);
    }
  }
  /**
   * Sets `aria-activedescendant` value to selected element's id.
   * @param {CustomEvent} e
   */
  _selectHandler(e) {
    const { item } = e.detail;
    this._setActiveDescendant(item);
  }
  /**
   * Sets `aria-activedescendant` value to node's id.
   * @param {Element} node
   */
  _setActiveDescendant(node) {
    this._ensureNodeId(node);
    this.setAttribute('aria-activedescendant', node.id);
  }
  /**
   * Removes `aria-activedescendant` from the element when item is
   * deselected.
   */
  _deselectHandler() {
    this.setAttribute('aria-activedescendant', '');
  }
  /**
   * Ensures the node to have an ID.
   * It is later used with aria attributes.
   * @param {Element} node
   */
  _ensureNodeId(node) {
    if (!node.id) {
      node.id = 'anypointlistbox-' + globalId;
      globalId++;
    }
  }
  /**
   * Updates `compatibility` state on children.
   * This is a convinience method to set `compatibility` property on this element
   * and propagate it on children instead of setting this property on each
   * item separately.
   * @param {Boolean} compatibility Current state of `compatibility` property
   */
  _updateChildrenCompatibility(compatibility) {
    const slot = this.shadowRoot.querySelector('slot');
    if (!slot) {
      return;
    }
    const nodes = slot.assignedNodes();
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      if (node.nodeType !== Node.ELEMENT_NODE) {
        continue;
      }
      if (compatibility) {
        node.setAttribute('compatibility', '');
      } else {
        node.removeAttribute('compatibility', '');
      }
    }
  }
}

window.customElements.define('anypoint-listbox', AnypointListbox);

const style = css`
  html {
    --anypoint-color-primary: #00a2df;
    --anypoint-color-secondary: #506773;
    --anypoint-color-danger: #d1344e;
    --anypoint-color-success: #17bc65;
    --anypoint-color-tertiary: #ffffff;

    --anypoint-color-coreBlue1: #abe2f5;
    --anypoint-color-coreBlue2: #48c1ed;
    --anypoint-color-coreBlue3: #00a2df;
    --anypoint-color-coreBlue4: #087299;
    --anypoint-color-coreBlue5: #114459;

    --anypoint-color-robustBlue1: #a1b1b8;
    --anypoint-color-robustBlue2: #6b8a99;
    --anypoint-color-robustBlue3: #506773;
    --anypoint-color-robustBlue4: #32444d;
    --anypoint-color-robustBlue5: #272f33;

    --anypoint-color-futureGreen1: #aaf2cb;
    --anypoint-color-futureGreen2: #33cc7a;
    --anypoint-color-futureGreen3: #17bc65;
    --anypoint-color-futureGreen4: #0e8c48;
    --anypoint-color-futureGreen5: #174d30;

    --anypoint-color-aluminum1: #f9fafb;
    --anypoint-color-aluminum2: #f4f5f6;
    --anypoint-color-aluminum3: #e8e9ea;
    --anypoint-color-aluminum4: #cacbcc;
    --anypoint-color-aluminum5: #989a9b;

    --anypoint-color-steel1: #6b6c6d;
    --anypoint-color-steel2: #58595a;
    --anypoint-color-steel3: #3a3b3c;
    --anypoint-color-steel4: #262728;
    --anypoint-color-steel5: #121314;

    --anypoint-color-yellow3: #f2be24;
    --anypoint-color-viridian3: #00b49d;
    --anypoint-color-teal3: #00b5d1;
    --anypoint-color-navy3: #178bea;
    --anypoint-color-indigo3: #5e66f9;
    --anypoint-color-violet3: #9a63f9;
    --anypoint-color-red3: #d1344e;
  }
`;

try {
  document.adoptedStyleSheets = document.adoptedStyleSheets.concat(style.styleSheet);
} catch (_) {
  /* istanbul ignore next */
  {
    const s = document.createElement('style');
    s.type = 'text/css';
    s.innerHTML = style.cssText;
    document.getElementsByTagName('head')[0].appendChild(s);
  }
}

var styles = css`
  :host,
  .anypoint-item {
    display: block;
    position: relative;
    min-height: var(--anypoint-item-min-height, 48px);
    padding: var(--anypoint-item-padding, 0px 12px);
    cursor: pointer;

    -webkit-transition: background-color 0.16s ease-in-out 0s;
    transition: background-color 0.16s ease-in-out 0s;
  }

  :host([compatibility]),
  .anypoint-item[compatibility] {
    padding: var(--anypoint-item-padding, 0px 10px);
    min-height: var(--anypoint-item-min-height, 40px);

    border-left-width: 2px;
    border-right-width: 2px;
    border-left-color: var(--anypoint-item-border-left-color, var(--anypoint-color-aluminum4));
    border-right-color: var(--anypoint-item-border-right-color, var(--anypoint-color-aluminum4));
    border-left-style: solid;
    border-right-style: solid;
  }

  :host([compatibility]:hover),
  .anypoint-item[compatibility]:hover {
    color: var(--anypoint-item-focus-color, var(--anypoint-color-coreBlue3));
    border-left-color: var(
      --anypoint-item-border-left-hover-color,
      var(--anypoint-color-coreBlue3)
    );
    border-right-color: var(
      --anypoint-item-border-right-hover-color,
      var(--anypoint-color-coreBlue3)
    );
    background-color: var(--anypoint-item-hover-background-color, initial);
  }

  :host(:hover),
  .anypoint-item:hover {
    background-color: var(--anypoint-item-hover-background-color, #F5F5F5);
  }

  :host(:focus),
  .anypoint-item:focus {
    position: relative;
    outline: 0;
    background-color: var(--anypoint-item-focused-background-color, initial);
    font-weight: var(--anypoint-item-focused-font-weight, initial);
  }

  :host([compatibility]:focus),
  .anypoint-item[compatibility]:focus {
    color: var(--anypoint-item-focused-color, var(--anypoint-color-coreBlue3));
  }

  :host(:focus):before,
  .anypoint-item:focus:before {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: var(--anypoint-item-before-background, currentColor);
    content: '';
    opacity: var(--anypoint-item-before-opacity, var(--dark-divider-opacity));
    pointer-events: none;
  }

  :host([compatibility]:focus):before,
  .anypoint-item[compatibility]:focus:before {
    background: var(--anypoint-item-before-background);
    opacity: var(--anypoint-item-before-opacity);
  }

  .anypoint-item {
    outline: none;
    width: 100%;
    text-align: left;
  }

  :host([hidden]),
  .anypoint-item[hidden] {
    display: none !important;
  }

  :host(.iron-selected),
  :host(.selected),
  .anypoint-item.iron-selected,
  .anypoint-item.selected {
    font-weight: var(--anypoint-item-selected-weight, bold);
  }

  :host([disabled]),
  .anypoint-item[disabled] {
    color: var(--anypoint-item-disabled-color, var(--disabled-text-color));
  }

  :host([pressed]),
  .anypoint-item[pressed],
  .anypoint-item.pressed {
    position: relative;
    outline: 0;
    background-color: var(--anypoint-item-pressed-background-color, #BDBDBD);
  }

  :host([compatibility][pressed]),
  .anypoint-item[compatibility][pressed],
  .anypoint-item[compatibility].pressed {
    background-color: var(--anypoint-item-pressed-background-color, initial);
  }
`;

/**
 * `anypoint-item`
 * An Anypoint list item.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof AnypointUi
 */
class AnypointItem extends HoverableMixin(ControlStateMixin(ButtonStateMixin(LitElement))) {
  static get styles() {
    return [
      styles,
      css`
        :host {
          display: flex;
          flex-direction: row;
          align-items: center;
        }
      `,
    ];
  }

  static get properties() {
    return {
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  render() {
    return html`
      <slot></slot>
    `;
  }

  connectedCallback() {
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'option');
    }
    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }
    if (super.connectedCallback) {
      super.connectedCallback();
    }
  }
}

window.customElements.define('anypoint-item', AnypointItem);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
The `<iron-flex-layout>` component provides simple ways to use
[CSS flexible box
layout](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes),
also known as flexbox. Note that this is an old element, that was written
before all modern browsers had non-prefixed flex styles. As such, nowadays you
don't really need to use this element anymore, and can use CSS flex styles
directly in your code.

This component provides two different ways to use flexbox:

1. [Layout
classes](https://github.com/PolymerElements/iron-flex-layout/tree/master/iron-flex-layout-classes.html).
The layout class stylesheet provides a simple set of class-based flexbox rules,
that let you specify layout properties directly in markup. You must include this
file in every element that needs to use them.

    Sample use:

    ```
    <custom-element-demo>
      <template>
        <script src="../webcomponentsjs/webcomponents-lite.js"></script>
        <next-code-block></next-code-block>
      </template>
    </custom-element-demo>
    ```

    ```js
    import {html} from '@polymer/polymer/lib/utils/html-tag.js';
    import '@polymer/iron-flex-layout/iron-flex-layout-classes.js';

    const template = html`
      <style is="custom-style" include="iron-flex iron-flex-alignment"></style>
      <style>
        .test { width: 100px; }
      </style>
      <div class="layout horizontal center-center">
        <div class="test">horizontal layout center alignment</div>
      </div>
    `;
    document.body.appendChild(template.content);
    ```

2. [Custom CSS
mixins](https://github.com/PolymerElements/iron-flex-layout/blob/master/iron-flex-layout.html).
The mixin stylesheet includes custom CSS mixins that can be applied inside a CSS
rule using the `@apply` function.

Please note that the old [/deep/ layout
classes](https://github.com/PolymerElements/iron-flex-layout/tree/master/classes)
are deprecated, and should not be used. To continue using layout properties
directly in markup, please switch to using the new `dom-module`-based
[layout
classes](https://github.com/PolymerElements/iron-flex-layout/tree/master/iron-flex-layout-classes.html).
Please note that the new version does not use `/deep/`, and therefore requires
you to import the `dom-modules` in every element that needs to use them.

@group Iron Elements
@pseudoElement iron-flex-layout
@demo demo/index.html
*/
const template = html$1`
<custom-style>
  <style is="custom-style">
    [hidden] {
      display: none !important;
    }
  </style>
</custom-style>
<custom-style>
  <style is="custom-style">
    html {

      --layout: {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
      };

      --layout-inline: {
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
      };

      --layout-horizontal: {
        @apply --layout;

        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
      };

      --layout-horizontal-reverse: {
        @apply --layout;

        -ms-flex-direction: row-reverse;
        -webkit-flex-direction: row-reverse;
        flex-direction: row-reverse;
      };

      --layout-vertical: {
        @apply --layout;

        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
      };

      --layout-vertical-reverse: {
        @apply --layout;

        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      };

      --layout-wrap: {
        -ms-flex-wrap: wrap;
        -webkit-flex-wrap: wrap;
        flex-wrap: wrap;
      };

      --layout-wrap-reverse: {
        -ms-flex-wrap: wrap-reverse;
        -webkit-flex-wrap: wrap-reverse;
        flex-wrap: wrap-reverse;
      };

      --layout-flex-auto: {
        -ms-flex: 1 1 auto;
        -webkit-flex: 1 1 auto;
        flex: 1 1 auto;
      };

      --layout-flex-none: {
        -ms-flex: none;
        -webkit-flex: none;
        flex: none;
      };

      --layout-flex: {
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      };

      --layout-flex-2: {
        -ms-flex: 2;
        -webkit-flex: 2;
        flex: 2;
      };

      --layout-flex-3: {
        -ms-flex: 3;
        -webkit-flex: 3;
        flex: 3;
      };

      --layout-flex-4: {
        -ms-flex: 4;
        -webkit-flex: 4;
        flex: 4;
      };

      --layout-flex-5: {
        -ms-flex: 5;
        -webkit-flex: 5;
        flex: 5;
      };

      --layout-flex-6: {
        -ms-flex: 6;
        -webkit-flex: 6;
        flex: 6;
      };

      --layout-flex-7: {
        -ms-flex: 7;
        -webkit-flex: 7;
        flex: 7;
      };

      --layout-flex-8: {
        -ms-flex: 8;
        -webkit-flex: 8;
        flex: 8;
      };

      --layout-flex-9: {
        -ms-flex: 9;
        -webkit-flex: 9;
        flex: 9;
      };

      --layout-flex-10: {
        -ms-flex: 10;
        -webkit-flex: 10;
        flex: 10;
      };

      --layout-flex-11: {
        -ms-flex: 11;
        -webkit-flex: 11;
        flex: 11;
      };

      --layout-flex-12: {
        -ms-flex: 12;
        -webkit-flex: 12;
        flex: 12;
      };

      /* alignment in cross axis */

      --layout-start: {
        -ms-flex-align: start;
        -webkit-align-items: flex-start;
        align-items: flex-start;
      };

      --layout-center: {
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
      };

      --layout-end: {
        -ms-flex-align: end;
        -webkit-align-items: flex-end;
        align-items: flex-end;
      };

      --layout-baseline: {
        -ms-flex-align: baseline;
        -webkit-align-items: baseline;
        align-items: baseline;
      };

      /* alignment in main axis */

      --layout-start-justified: {
        -ms-flex-pack: start;
        -webkit-justify-content: flex-start;
        justify-content: flex-start;
      };

      --layout-center-justified: {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      };

      --layout-end-justified: {
        -ms-flex-pack: end;
        -webkit-justify-content: flex-end;
        justify-content: flex-end;
      };

      --layout-around-justified: {
        -ms-flex-pack: distribute;
        -webkit-justify-content: space-around;
        justify-content: space-around;
      };

      --layout-justified: {
        -ms-flex-pack: justify;
        -webkit-justify-content: space-between;
        justify-content: space-between;
      };

      --layout-center-center: {
        @apply --layout-center;
        @apply --layout-center-justified;
      };

      /* self alignment */

      --layout-self-start: {
        -ms-align-self: flex-start;
        -webkit-align-self: flex-start;
        align-self: flex-start;
      };

      --layout-self-center: {
        -ms-align-self: center;
        -webkit-align-self: center;
        align-self: center;
      };

      --layout-self-end: {
        -ms-align-self: flex-end;
        -webkit-align-self: flex-end;
        align-self: flex-end;
      };

      --layout-self-stretch: {
        -ms-align-self: stretch;
        -webkit-align-self: stretch;
        align-self: stretch;
      };

      --layout-self-baseline: {
        -ms-align-self: baseline;
        -webkit-align-self: baseline;
        align-self: baseline;
      };

      /* multi-line alignment in main axis */

      --layout-start-aligned: {
        -ms-flex-line-pack: start;  /* IE10 */
        -ms-align-content: flex-start;
        -webkit-align-content: flex-start;
        align-content: flex-start;
      };

      --layout-end-aligned: {
        -ms-flex-line-pack: end;  /* IE10 */
        -ms-align-content: flex-end;
        -webkit-align-content: flex-end;
        align-content: flex-end;
      };

      --layout-center-aligned: {
        -ms-flex-line-pack: center;  /* IE10 */
        -ms-align-content: center;
        -webkit-align-content: center;
        align-content: center;
      };

      --layout-between-aligned: {
        -ms-flex-line-pack: justify;  /* IE10 */
        -ms-align-content: space-between;
        -webkit-align-content: space-between;
        align-content: space-between;
      };

      --layout-around-aligned: {
        -ms-flex-line-pack: distribute;  /* IE10 */
        -ms-align-content: space-around;
        -webkit-align-content: space-around;
        align-content: space-around;
      };

      /*******************************
                Other Layout
      *******************************/

      --layout-block: {
        display: block;
      };

      --layout-invisible: {
        visibility: hidden !important;
      };

      --layout-relative: {
        position: relative;
      };

      --layout-fit: {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-scroll: {
        -webkit-overflow-scrolling: touch;
        overflow: auto;
      };

      --layout-fullbleed: {
        margin: 0;
        height: 100vh;
      };

      /* fixed position */

      --layout-fixed-top: {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
      };

      --layout-fixed-right: {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
      };

      --layout-fixed-bottom: {
        position: fixed;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-fixed-left: {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
      };

    }
  </style>
</custom-style>`;

template.setAttribute('style', 'display: none;');
document.head.appendChild(template.content);

var style$1 = document.createElement('style');
style$1.textContent = '[hidden] { display: none !important; }';
document.head.appendChild(style$1);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**

The `iron-icon` element displays an icon. By default an icon renders as a 24px
square.

Example using src:

    <iron-icon src="star.png"></iron-icon>

Example setting size to 32px x 32px:

    <iron-icon class="big" src="big_star.png"></iron-icon>

    <style is="custom-style">
      .big {
        --iron-icon-height: 32px;
        --iron-icon-width: 32px;
      }
    </style>

The iron elements include several sets of icons. To use the default set of
icons, import `iron-icons.js` and use the `icon` attribute to specify an icon:

    <script type="module">
      import "@polymer/iron-icons/iron-icons.js";
    </script>

    <iron-icon icon="menu"></iron-icon>

To use a different built-in set of icons, import the specific
`iron-icons/<iconset>-icons.js`, and specify the icon as `<iconset>:<icon>`.
For example, to use a communication icon, you would use:

    <script type="module">
      import "@polymer/iron-icons/communication-icons.js";
    </script>

    <iron-icon icon="communication:email"></iron-icon>

You can also create custom icon sets of bitmap or SVG icons.

Example of using an icon named `cherry` from a custom iconset with the ID
`fruit`:

    <iron-icon icon="fruit:cherry"></iron-icon>

See `<iron-iconset>` and `<iron-iconset-svg>` for more information about how to
create a custom iconset.

See the `iron-icons` demo to see the icons available in the various iconsets.

### Styling

The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--iron-icon` | Mixin applied to the icon | {}
`--iron-icon-width` | Width of the icon | `24px`
`--iron-icon-height` | Height of the icon | `24px`
`--iron-icon-fill-color` | Fill color of the svg icon | `currentcolor`
`--iron-icon-stroke-color` | Stroke color of the svg icon | none

@group Iron Elements
@element iron-icon
@demo demo/index.html
@hero hero.svg
@homepage polymer.github.io
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        @apply --layout-inline;
        @apply --layout-center-center;
        position: relative;

        vertical-align: middle;

        fill: var(--iron-icon-fill-color, currentcolor);
        stroke: var(--iron-icon-stroke-color, none);

        width: var(--iron-icon-width, 24px);
        height: var(--iron-icon-height, 24px);
        @apply --iron-icon;
      }

      :host([hidden]) {
        display: none;
      }
    </style>
`,

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {type: String},

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {type: String},

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {type: String},

    /**
     * @type {!IronMeta}
     */
    _meta: {value: Base.create('iron-meta', {type: 'iconset'})}

  },

  observers: [
    '_updateIcon(_meta, isAttached)',
    '_updateIcon(theme, isAttached)',
    '_srcChanged(src, isAttached)',
    '_iconChanged(icon, isAttached)'
  ],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function(src) {
    this._updateIcon();
  },

  _usesIconset: function() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        dom(this.root).removeChild(this._img);
      }
      if (this._iconName === '') {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */ (
            this._meta.byKey(this._iconsetName));
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      dom(this.root).appendChild(this._img);
    }
  }
});

/**
@license
Copyright 2016 Pawel Psztyc, The ARC team
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* eslint-disable max-len */
const $documentContainer$1 = document.createElement('template');
$documentContainer$1.innerHTML = `<iron-iconset-svg size="24" name="arc">
<svg>
  <defs>
    <g id="account-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path></g>
    <g id="add-circle-outline"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
    <g id="add"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g>
    <g id="arc-icon"><path style="fill:#2196F3" d="M2.3,1h19.3C22.4,1,23,1.6,23,2.3v19.4c0,0.7-0.6,1.3-1.3,1.3H2.3C1.6,23,1,22.4,1,21.7 V2.3C1,1.6,1.6,1,2.3,1z"></path><path style="opacity:0.42;fill:#FFFFFF" d="M15.8,7.1v5.1h-1.9l3.7,4.7l3.7-4.7h-1.9V7.1H15.8L15.8,7.1z"></path><path style="fill:#FFFFFF" d="M10.7,19.3v-7.6h2.8L8.1,4.8l-5.5,6.9h2.8v7.6H10.7z"></path></g>
    <g id="arc-icon-arrows"><polygon style="fill:#2196F3;" points="13.3,11.7 8.3,5.2 3.2,11.7 5.7,11.7 5.7,11.7 5.8,11.7 5.8,18.8 10.7,18.8 10.7,11.7 "></polygon><polygon style="opacity:0.42;fill:#2196F3;" points="19,12.5 19,7.7 15.7,7.7 15.7,12.5 13.9,12.5 17.4,16.8 20.8,12.5 "></polygon></g>
    <g id="archive"><path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"></path></g>
    <g id="arrow-back"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></g>
    <g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
    <g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
    <g id="assignment"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g>
    <g id="bug-report"><path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z"></path></g>
    <g id="build"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"></path></g>
    <g id="cached"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"></path></g>
    <g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
    <g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
    <g id="cancel"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path></g>
    <g id="clear"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
    <g id="clear-all"><path d="M5 13h14v-2H5v2zm-2 4h14v-2H3v2zM7 7v2h14V7H7z"></path></g>
    <g id="close"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
    <g id="cloud-download"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z"></path></g>
    <g id="code"><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></g>
    <g id="collections-bookmark"><path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 10l-2.5-1.5L15 12V4h5v8z"></path></g>
    <g id="insert-comment"><path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path></g>
    <g id="content-copy"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g>
    <g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
    <g id="desktop-windows"><path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H3V4h18v12z"></path></g>
    <g id="done"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></g>
    <g id="drive-color" transform="matrix(1.597046e-4,0,0,1.6517796e-4,1.3671875,2.9482084)"><polygon points="133156,76894 110963,115341 22194,115341 44385,76894 " style="fill:#3777e3"></polygon><polygon points="88772,0 44385,0 88772,76894 133156,76894 " style="fill:#ffcf63"></polygon><polygon points="66578,38447 44385,0 0,76894 22194,115341 " style="fill:#11a861"></polygon></g>
    <g id="drive" transform="matrix(1.597046e-4,0,0,1.6517796e-4,1.3671875,2.9482084)"><polygon points="22194,115341 44385,76894 133156,76894 110963,115341"></polygon><polygon points="88772,76894 133156,76894 88772,0 44385,0"></polygon><polygon points="0,76894 22194,115341 66578,38447 44385,0"></polygon></g>
    <g id="edit"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
    <g id="error"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
    <g id="expand-less"><path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path></g>
    <g id="expand-more"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></g>
    <g id="export-variant"><path d="M12,1L8,5H11V14H13V5H16M18,23H6C4.89,23 4,22.1 4,21V9A2,2 0 0,1 6,7H9V9H6V21H18V9H15V7H18A2,2 0 0,1 20,9V21A2,2 0 0,1 18,23Z"></path></g>
    <g id="file-download"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
    <g id="filter-list"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path></g>
    <g id="folder-shared"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"></path></g>
    <g id="help"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path></g>
    <g id="help-outline"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path></g>
    <g id="history"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
    <g id="home"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></g>
    <g id="import-export"><path d="M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z"></path></g>
    <g id="info"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></g>
    <g id="info-outline"><path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"></path></g>
    <g id="insert-chart"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path></g>
    <g id="insert-drive-file"><path d="M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z"></path></g>
    <g id="keyboard-arrow-down"><path d="M7.41 7.84L12 12.42l4.59-4.58L18 9.25l-6 6-6-6z"></path></g>
    <g id="keyboard-arrow-up"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></g>
    <g id="keyboard-arrow-right"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"></path></g>
    <g id="list"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path></g>
    <g id="markdown" transform="matrix(0.04690339,0,0,0.04690339,0,5.225434)"><path d="m 123.38173,73.504 -50.39773,0 0,167.496 52.516,0 0,-93 50,60 47.62725,-60 0,93 49.87275,0 0,-167.496 -49.87276,0 L 175.5,135.5 Z M 39.998409,0 474.00159,0 C 496.08284,0 514,17.906303 514,39.994846 l 0,235.010304 C 514,297.09032 496.0921,315 474.00159,315 L 39.998409,315 C 17.917157,315 0,297.0937 0,275.00515 L 0,39.994846 C 0,17.909682 17.907898,0 39.998409,0 Z M 360,74.5 l -0.49739,0 -1e-5,86 -48.0026,0 74,80.5 74.00256,-80.99442 -49.97984,0 0,-85.50558 z m 0,0"></path></g>
    <g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
    <g id="mode-edit"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
    <g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
    <g id="new-releases"><path d="M23 12l-2.44-2.78.34-3.68-3.61-.82-1.89-3.18L12 3 8.6 1.54 6.71 4.72l-3.61.81.34 3.68L1 12l2.44 2.78-.34 3.69 3.61.82 1.89 3.18L12 21l3.4 1.46 1.89-3.18 3.61-.82-.34-3.68L23 12zm-10 5h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
    <g id="notifications-active"><path d="M7.58 4.08L6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2c.15-2.65 1.51-4.97 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43c2.02 1.45 3.39 3.77 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z"></path></g>
    <g id="open-in-new"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
    <g id="raml-r"><path d="M14.44,1.48H3L4.16,3.3H14.37a4.59,4.59,0,0,1,3.31,1.41A4.8,4.8,0,0,1,19,8.07,4.45,4.45,0,0,1,17.7,11.3a5.72,5.72,0,0,1-3.28,1.54H13.17l-3.45,0,1,1.72h1.51l.08.13h0l4.45,7.51,0,0,0,0a1,1,0,0,0,1.7-.71.54.54,0,0,0-.15-.41,1.21,1.21,0,0,1-.14-.2l-3.68-6.26a6.47,6.47,0,0,0,4.51-1.92A6.61,6.61,0,0,0,14.44,1.48Z"></path></g>
    <g id="rate-review"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 14v-2.47l6.88-6.88c.2-.2.51-.2.71 0l1.77 1.77c.2.2.2.51 0 .71L8.47 14H6zm12 0h-7.5l2-2H18v2z"></path></g>
    <g id="refresh"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
    <g id="remove-circle-outline"><path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
    <g id="pin-drawer"><path d="M 15.462891 4.0332031 L 15.462891 20.007812 L 18.392578 20.007812 L 18.392578 4.0332031 L 15.462891 4.0332031 z M 6.9921875 6.0195312 L 5.5820312 7.4296875 L 10.162109 12.019531 L 5.5820312 16.609375 L 6.9921875 18.019531 L 12.992188 12.019531 L 6.9921875 6.0195312 z M 16.017578 11.873047 L 17.865234 11.873047 L 17.865234 19.509766 L 16.017578 19.509766 L 16.017578 11.873047 z"></path></g>
    <g id="spellcheck"><path d="M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59l-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z"></path></g>
    <g id="sentiment-very-dissatisfied"><path d="M11.99 2C6.47 2 2 6.47 2 12s4.47 10 9.99 10S22 17.53 22 12 17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm4.18-12.24l-1.06 1.06-1.06-1.06L13 8.82l1.06 1.06L13 10.94 14.06 12l1.06-1.06L16.18 12l1.06-1.06-1.06-1.06 1.06-1.06zM7.82 12l1.06-1.06L9.94 12 11 10.94 9.94 9.88 11 8.82 9.94 7.76 8.88 8.82 7.82 7.76 6.76 8.82l1.06 1.06-1.06 1.06zM12 14c-2.33 0-4.31 1.46-5.11 3.5h10.22c-.8-2.04-2.78-3.5-5.11-3.5z"></path></g>
    <g id="sentiment-neutral"><path d="M9 14h6v1.5H9z"></path><circle cx="15.5" cy="9.5" r="1.5"></circle><circle cx="8.5" cy="9.5" r="1.5"></circle><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
    <g id="save"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></g>
    <g id="save-alt"><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"></path><path fill="none" d="M0 0h24v24H0z"></path></g>
    <g id="search"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></g>
    <g id="send"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g>
    <g id="settings"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></g>
    <g id="shield" transform="translate(0,-1028.3622)"><circle r="11.962877" cy="1040.3993" cx="11.962877" style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#1c8adb;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.40000001;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"></circle><path d="m 5.7226134,1035.2177 -5.71610049,5.7162 c 0.25024909,5.9429 3.35576479,9.2981 8.15641339,11.1171 2.1658257,-2.1563 4.3267587,-4.3171 6.4790417,-6.5004 z" style="fill:url(#linearGradient5637);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" inkscape:connector-curvature="0"></path><path d="m 11.962898,1033.391 c -2.0501345,1.0013 -4.3555189,1.8135 -6.240256,1.8267 1.1575901,7.1589 1.8218083,9.9255 6.240256,12.1899 4.418427,-2.2644 5.082673,-5.031 6.240258,-12.1899 -1.884728,-0.013 -4.190132,-0.8254 -6.240258,-1.8267 z" style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" inkscape:connector-curvature="0"></path><path d="m 11.962878,1033.391 0,7.0084 5.261505,0 c 0.352779,-1.4257 0.64548,-3.121 0.978701,-5.1818 -1.884728,-0.013 -4.19008,-0.8254 -6.240206,-1.8266 z m 0,7.0084 -5.2615633,0 c 0.8727443,3.5268 2.1150231,5.3956 5.2615633,7.0082 l 0,-7.0082 z" style="fill:#000000;fill-opacity:0.13473056;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" inkscape:connector-curvature="0"></path></g>
    <g id="short-text"><path d="M4 9h16v2H4zm0 4h10v2H4z"></path></g>
    <g id="star"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
    <g id="star-border"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
    <g id="view-column"><path d="M10 18h5V5h-5v13zm-6 0h5V5H4v13zM16 5v13h5V5h-5z"></path></g>
    <g id="view-list"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"></path></g>
    <g id="visibility"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
    <g id="visibility-off"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"></path></g>
    <g id="warning"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
    <g id="wrap-text"><path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></g>
    <g id="zoom-in"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm2.5-4h-2v2H9v-2H7V9h2V7h1v2h2v1z"></path></g>
  </defs></svg>
</iron-iconset-svg>`;

document.head.appendChild($documentContainer$1.content);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

class JsonTablePrimitiveTeaser extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
      margin: 4px 0;
    }

    :host([opened]) .primitive-wrapper {
      max-height: none;
    }

    .primitive-wrapper {
      max-height: var(--json-table-primitive-teaser-max-heigth, 160px);
      overflow: hidden;
      padding: 4px 0;
    }

    *[hidden] {
      display: none !important;
    }

    .toggle {
      font-size: inherit;
      color: inherit;
      margin-top: 12px;
      display: inline-block;
    }`;
  }

  render() {
    const { _isOverflow, opened } = this;
    return html`
    <div class="primitive-wrapper">
      <slot></slot>
    </div>
    <a href="#" class="toggle" ?hidden="${!_isOverflow}" @click="${this.toggle}">${this._computeToggleLabel(opened)}</a>`;
  }

  static get properties() {
    return {
      // If true then the whole value will be visible.
      opened: {
        type: Boolean,
        reflect: true
      },
      // DOM change observer
      _observer: { type: Object },
      // if true then the content overflows the max height area.
      _isOverflow: { type: Boolean },
      // Container's max height when closed.
      maxHeight: { type: String }
    };
  }

  get _wrapper() {
    return this.shadowRoot.querySelector('.primitive-wrapper');
  }

  get maxHeight() {
    return this._maxHeight;
  }

  set maxHeight(value) {
    this._maxHeight = value;
    this._maxHeightChanged(value);
  }

  constructor() {
    super();
    this._contentChanged = this._contentChanged.bind(this);
    this.opened = false;
    this._isOverflow = false;
    this.maxHeight = '160px';
  }

  connectedCallback() {
    super.connectedCallback();
    const config = { attributes: false, childList: true, subtree: true };
    this._observer = new MutationObserver(this._contentChanged);
    this._observer.observe(this, config);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._observer) {
      this._observer.disconnect();
      this._observer = undefined;
    }
  }

  firstUpdated() {
    this._contentChanged();
  }

  _contentChanged() {
    const wrap = this._wrapper;
    if (!wrap) {
      return;
    }
    const oh = wrap.offsetHeight; // current height
    const sh = wrap.scrollHeight; // content height
    this._isOverflow = sh > oh;
  }

  toggle(e) {
    e.preventDefault();
    this.opened = !this.opened;
  }

  _computeToggleLabel(opened) {
    return opened ? 'show less' : 'show more';
  }

  _maxHeightChanged(maxHeight) {
    maxHeight = maxHeight || '160px';
    this.style.setProperty('--json-table-primitive-teaser-max-heigth', maxHeight);
  }
}
window.customElements.define('json-table-primitive-teaser', JsonTablePrimitiveTeaser);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element that displays array structure.
 *
 * ### Example
 *
 * ```html
 * <json-table-array json="[...]"></json-table-array>
 * ```
 *
 *
 * @customElement
 * @appliesMixin JsonTableMixin
 * @memberof UiElements
 */
class JsonTableArray extends JsonTableMixin(LitElement) {
  static get styles() {
    return css`:host {
     display: block;
     font-size: var(--arc-font-body1-font-size);
     font-weight: var(--arc-font-body1-font-weight);
     line-height: var(--arc-font-body1-line-height);
   }

   anypoint-dropdown-menu {
     width: 70px;
   }

   table {
     border-collapse: collapse;
   }

   th {
     white-space: nowrap;
     text-align: left;
     padding: 8px 16px;
     font-size: 14px;
     color: var(--json-table-array-header-color, #58595A);
     border-bottom: 3px #e8e9ea solid;
   }

   td {
     min-width: 60px;
     padding: 8px 16px;
     word-break: normal;
     vertical-align: top;
     border-bottom: 1px #E8E9EA solid;
     font-size: 14px;
     color: var(--json-table-array-body-color, #121314);
   }

   *[hidden] {
     display: none !important;
   }

   .enum-value {
     display: block;
     padding: 4px 0;
     margin: 4px 0;
   }

   .enum-value::after {
     content: ',';
     color: rgba(0, 0, 0, 0.54);
   }

   .enum-value:last-of-type::after {
     content: ''
   }

   .toggle-view {
     font-size: inherit;
     color: inherit;
     margin-top: 12px;
     display: block;
     white-space: nowrap;
   }

   .toggle-view.active {
     display: inline-block;
     margin-top: 0;
   }

   .table-actions {
     height: 56px;
     display: flex;
     flex-direction: row;
     align-items: center;
     font-size: var(--table-actions-label-font-size);
     color: var(--table-actions-label-color);
   }

   .page-items-count-selector,
   .page-count {
     margin-right: 32px;
     height: 56px;
     display: flex;
     flex-direction: row;
     align-items: center;
   }`;
  }

  _paginationTemplate() {
    const { paginate, itemsPerPage, _startItemLabel, _endItemLabel, _maxItemsLabel, page, outlined, compatibility } = this;
    if (!paginate) {
      return;
    }
    return html`<div class="table-actions">
      <div class="page-items-count-selector">
        <span class="page-items-count-label">Items per page</span>
        <anypoint-dropdown-menu
          nolabelfloat
          ?outlined="${outlined}"
          ?legacy="${compatibility}">
          <label slot="label">Select</label>
          <anypoint-listbox
            ?legacy="${compatibility}"
            slot="dropdown-content"
            attrforselected="data-value"
            .selected="${itemsPerPage}"
            @selected-changed="${this._ippHandler}">
            <anypoint-item data-value="10">10</anypoint-item>
            <anypoint-item data-value="15">15</anypoint-item>
            <anypoint-item data-value="20">20</anypoint-item>
            <anypoint-item data-value="25">25</anypoint-item>
            <anypoint-item data-value="50">50</anypoint-item>
            <anypoint-item data-value="100">100</anypoint-item>
          </anypoint-listbox>
        </anypoint-dropdown-menu>
      </div>
      <div class="page-count">
        ${_startItemLabel}-${_endItemLabel} of ${_maxItemsLabel}
      </div>
      <div class="page-paginators">
        <anypoint-icon-button
          aria-label="Activate to render previous page"
          @click="${this.previousPage}"
          ?disabled="${this._isDisabedPrevious(page)}"
          ?legacy="${compatibility}">
          <iron-icon icon="arc:chevron-left"></iron-icon>
        </anypoint-icon-button>
        <anypoint-icon-button
          aria-label="Activate to render next page"
          @click="${this.nextPage}"
          ?disabled="${this._isDisabedNext(_maxItemsLabel, _endItemLabel)}"
          ?legacy="${compatibility}">
          <iron-icon icon="arc:chevron-right"></iron-icon>
        </anypoint-icon-button>
      </div>
    </div>`;
  }

  _dispayTemplate(display, hasColumns, columns) {
    const { paginate, page, itemsPerPage, outlined, compatibility } = this;
    return display.map((displayItem) => html`<tr>
      ${hasColumns ? columns.map((column) => html`<td>
        ${this._isPrimitive(displayItem, column) ?
          html`<json-table-primitive-teaser
            class="primitive-value">${this._getValue(displayItem, column)}</json-table-primitive-teaser>` :
          undefined}
        ${this._isObject(displayItem, column) ?
          html`<json-table-object
            .json="${this._getValue(displayItem, column)}"
            ?paginate="${paginate}"
            .page="${page}"
            .itemsPerPage="${itemsPerPage}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"></json-table-object>` :
          undefined}
        ${this._isEnum(displayItem, column) ?
          this._getValue(displayItem, column).map((item) => html`<span class="enum-value">${item}</span>`) :
          undefined}

        ${this._isArray(displayItem, column) ? html`<span class="object-info">
          <span class="object-label" array="">Array (${this._computeValueSize(displayItem, column)})</span>
          <a href="#" class="toggle-view" data-target="array" @click="${this._toggleItem}">show array</a></span>
          <json-table-array
            hidden
            .json="${this._getValue(displayItem, column)}"
            ?paginate="${paginate}"
            .page="${page}"
            .itemsPerPage="${itemsPerPage}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"></json-table-array>` : undefined}
      </td>`) : undefined}
    </tr>`);
  }

  render() {
    const { _columns, _display } = this;
    const hasColumns = !!(_columns && _columns.length);
    const hasDisplay = !!(_display && _display.length);

    return html`
    ${this._paginationTemplate()}
    <table>
      ${hasColumns ? html`<thead>
        <tr>
        ${_columns.map((item) => html`<th>${item}</th>`)}
        </tr>
      </thead>` : undefined}
      <tbody>
        ${hasDisplay ? this._dispayTemplate(_display, hasColumns, _columns) : undefined}
      </tbody>
    </table>
    ${this._paginationTemplate()}`;
  }

  static get properties() {
    return {
      // An object to render.
      json: { type: Array },
      // List of computed column names
      _columns: { type: Array },
      // data model created from the `json` attribute.
      _display: { type: Array },
      // A label for start index in pagination (1-based)
      _startItemLabel: { type: Number },
      // A label for end index in pagination (1-based)
      _endItemLabel: { type: Number },
      // A label for end index in pagination (1-based)
      _maxItemsLabel: { type: Number }
    };
  }

  get json() {
    return this._json;
  }

  set json(value) {
    const old = this._json;
    if (old === value) {
      return;
    }
    this._json = value;
    this._jsonChanged(value);
    this._computeDisplay();
  }

  get columns() {
    return this._columns;
  }

  get paginate() {
    return this._paginate;
  }

  set paginate(value) {
    const old = this._paginate;
    if (old === value) {
      return;
    }
    this._paginate = value;
    this.requestUpdate('paginate', old);
    this._computeDisplay();
  }

  get page() {
    return this._page;
  }

  set page(value) {
    const old = this._page;
    if (old === value) {
      return;
    }
    this._page = value;
    this.requestUpdate('page', old);
    this._computeDisplay();
  }

  get itemsPerPage() {
    return this._itemsPerPage;
  }

  set itemsPerPage(value) {
    const old = this._itemsPerPage;
    if (old === value) {
      return;
    }
    this._itemsPerPage = value;
    this.requestUpdate('itemsPerPage', old);
    this._computeDisplay();
  }

  /**
   * Creates a data model from the `json` property.
   *
   * TODO: This should be a deep data observer to update only the portion of the model that
   * actually has changed.
   *
   * @param {Array} json
   */
  _jsonChanged(json) {
    if (!json) {
      this._display = undefined;
      this._columns = undefined;
      return;
    }
    const names = this._computeColumns(json);
    this._columns = names;
  }

  _computeDisplay() {
    const { json, paginate, page, itemsPerPage } = this;
    if (!json) {
      return;
    }
    const maxInxdex = json.length - 1;
    if (maxInxdex === -1) {
      return;
    }
    if (paginate && maxInxdex <= itemsPerPage) {
      this.paginate = false;
      return;
    }
    const startIndex = paginate ? (page * itemsPerPage) : 0;
    if (maxInxdex < startIndex) {
      return;
    }
    const endIndex = paginate ? Math.min(startIndex + itemsPerPage - 1, maxInxdex) : maxInxdex;
    const result = [];
    for (let i = startIndex; i <= endIndex; i++) {
      result.push(this.getItemModel(json[i]));
    }
    this._display = result;
    this._startItemLabel = startIndex + 1;
    this._endItemLabel = Math.min(endIndex + 1, maxInxdex);
    this._maxItemsLabel = maxInxdex;
  }
  /**
   * Computes the list of column names for the table.
   * It will contain all properties keys fond in the array.
   * @param {Array} json
   * @return {Array<String>}
   */
  _computeColumns(json) {
    if (this.isEnum(json)) {
      // no column names
      return;
    }
    const columnNames = [];
    json.forEach(function(value) {
      if (this.isObject(value)) {
        const names = Object.keys(value);
        for (let i = 0, len = names.length; i < len; i++) {
          if (columnNames.indexOf(names[i]) === -1) {
            columnNames.push(names[i]);
          }
        }
      }
    }, this);
    return columnNames.length ? columnNames : undefined;
  }
  // Checks if passed `item` is a primitive
  _isPrimitive(item, column) {
    if (!item || !item.value || typeof column === undefined) {
      return false;
    }
    if (!(column in item.value)) {
      return false;
    }
    const obj = item.value[column];
    return this.isPrimitive(obj);
  }

  _isObject(item, column) {
    if (!item || !item.value || typeof column === undefined) {
      return false;
    }
    if (!(column in item.value)) {
      return false;
    }
    const obj = item.value[column];
    return this.isObject(obj);
  }

  _isEnum(item, column) {
    if (!item || !item.value || typeof column === undefined) {
      return false;
    }
    if (!(column in item.value)) {
      return false;
    }
    const obj = item.value[column];
    return this.isArray(obj) && this.isEnum(obj);
  }

  _isArray(item, column) {
    if (!item || !item.value || typeof column === undefined) {
      return false;
    }
    if (!(column in item.value)) {
      return false;
    }
    const obj = item.value[column];
    return this.isArray(obj) && !this.isEnum(obj);
  }

  _getValue(item, column) {
    if (!item || !item.value || typeof column === undefined) {
      return;
    }
    if (!(column in item.value)) {
      return;
    }
    return item.value[column];
  }

  _toggleItem(e) {
    e.preventDefault();
    let cell;
    let currentElement = e.target;
    const targetAnchor = e.target;
    const templateTarget = currentElement.dataset.target;
    const test = true;
    while (test) {
      if (currentElement.nodeName === 'TD') {
        cell = currentElement;
        break;
      }
      currentElement = currentElement.parentElement;
      if (!currentElement) {
        throw new Error('Couldn\'t find table cell in the event path.');
      }
    }
    const node = cell.querySelector(`json-table-array`);
    const label = cell.querySelector(`.object-label[${templateTarget}]`);
    if (node.hasAttribute('hidden')) {
      node.removeAttribute('hidden');
      e.target.textContent = 'hide ' + templateTarget;
      label.setAttribute('hidden', true);
      targetAnchor.classList.add('active');
    } else {
      node.setAttribute('hidden', '');
      e.target.textContent = 'show ' + templateTarget;
      label.removeAttribute('hidden');
      targetAnchor.classList.remove('active');
    }
  }
  /**
   * When pagination is enabled this will increase page number.
   * This will do nothing if pagination isn't enabled or there's no next page of results to
   * display.
   * @return {Boolean}
   */
  nextPage() {
    const maxIndex = this._maxItemsLabel;
    const endIndex = this._endItemLabel;
    if (maxIndex <= endIndex) {
      return false;
    }
    this.page++;
  }
  /**
   * When pagination is enabled this will decrease page number.
   * This will do nothing if pagination isn't enabled or there's no previous page of results to
   * display.
   */
  previousPage() {
    if (!this.paginate || this.page === 0) {
      return;
    }
    this.page--;
  }
  /**
   * Computes if the previous page button for the pagination should be disabled.
   *
   * @param {Number} page Current page index
   * @return {Boolean} true if there's previous page of the results
   */
  _isDisabedPrevious(page) {
    return page === 0;
  }

  _isDisabedNext(maxItemsLabel, endItemLabel) {
    if (maxItemsLabel <= endItemLabel) {
      return true;
    }
    return false;
  }

  _computeValueSize(item, column) {
    const value = this._getValue(item, column);
    return value && value.length || 0;
  }

  _ippHandler(e) {
    this.itemsPerPage = e.detail.value;
  }
}
window.customElements.define('json-table-array', JsonTableArray);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element that displays object structure.
 *
 * ### Example
 *
 * ```html
 * <json-table-object json="{...}"></json-table-object>
 * ```
 *
 * ### Styling
 *
 * `<json-table>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--json-table-object` | Mixin applied to the element | `{}`
 *
 * @customElement
 * @appliesMixin JsonTableMixin
 * @memberof UiElements
 */
class JsonTableObject extends JsonTableMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
      --json-table-property-name-width: auto;
    }

    .item {
      display: flex;
      flex-direction: row;
      min-height: 24px;
      padding: 8px 0;
      border-bottom: 1px var(--json-table-item-border-bottom-color, rgba(0, 0, 0, 0.12)) solid;
    }

    .item.array,
    .item.object {
      display: flex;
      flex-direction: column;
    }

    .item:last-of-type {
      border-bottom: none;
    }

    .property-name {
      color: var(--json-table-list-property-name-color, #000);
      word-break: break-all;
      margin-right: 12px;
      padding-right: 12px;
      white-space: normal;
      word-break: normal;
      margin: 8px 12px 8px 0;
    }

    .property-value {
      flex: 1;
      word-wrap: normal;
      overflow: auto;
    }

    .object .property-value,
    .array .property-value {
      overflow: visible;
    }

    .object .property-value {
      margin-left: var(--json-table-indent-size, 12px);
    }

    .object .property-name,
    .array .property-name  {
      font-weight: 600;
      width: auto;
      min-width: auto;
    }

    json-table-object,
    json-table-array {
      overflow: auto;
    }

    :host > .object > .property-name,
    :host > .array > .property-name {
      color: var(--json-table-list-property-name-color, #000);
    }

    .enum-value {
      display: block;
    }

    .enum-value::after {
      content: ',';
      color: rgba(0, 0, 0, 0.54);
    }

    .enum-value:last-of-type::after {
      content: ''
    }

    .object-label,
    .array-label {
      color: var(--json-table-complex-name-label-color, #58595A);
    }`;
  }

  render() {
    const { _display, paginate, page, itemsPerPage, outlined, compatibility } = this;

    if (!(_display && _display.length)) {
      return;
    }
    return html`
    ${_display.map((item) => html`<div class="item ${this._computeItemClass(item)}">
      <div class="property-name">
        ${item.key}
        ${item.isObject ? html`<span class="object-label">(Object)</span>` : undefined}
        ${this._isEnumOrArray(item) ? html`<span class="array-label">(Array ${this._computeArraySize(item)})</span>` : undefined}
      </div>
      <div class="property-value">
        ${item.isObject ? html`<json-table-object
          .json="${item.value}"
          ?paginate="${paginate}"
          .page="${page}"
          .itemsPerPage="${itemsPerPage}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"></json-table-object>` : undefined}
        ${item.isEnum ?
          item.value.map((item) => html`<span class="enum-value">${item}</span>`) :
          undefined}
        ${item.isArray ? html`<div class="array-wrapper">
          <json-table-array
            .json="${item.value}"
            ?paginate="${paginate}"
            .page="${page}"
            .itemsPerPage="${itemsPerPage}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"></json-table-array>
        </div>` : undefined}

        ${item.isPrimitive ? html`<json-table-primitive-teaser class="primitive-value">${item.value}</json-table-primitive-teaser>` : undefined}
      </div>
    </div>`)}`;
  }

  get json() {
    return this._json;
  }

  set json(value) {
    const old = this._json;
    if (old === value) {
      return;
    }
    this._json = value;
    this._jsonChanged(value);
  }

  static get properties() {
    return {
      // An object to render.
      json: { type: Object },
      // data model created from the `json` attribute.
      _display: { type: Array }
    };
  }
  /**
   * Creates a data model from the JSON object.
   * The element is only interested in first level properties. Other properties will be rendered
   * by child elements.
   *
   * TODO: This should be a deep data observer to update only the portion of the model that
   * actually had changed.
   *
   * @param {Object} json
   */
  _jsonChanged(json) {
    if (!json) {
      this._display = undefined;
      return;
    }
    const names = Object.keys(json);
    const model = names.map((key) => this.getPropertyModel(key, json[key]));
    this._display = model;
  }

  _computeItemClass(item) {
    if (item.isArray/* || item.isEnum*/) {
      return 'array';
    }
    if (item.isEnum) {
      return 'enum';
    }
    if (item.isObject) {
      return 'object';
    }
  }
}
window.customElements.define('json-table-object', JsonTableObject);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * A table view from the JSON structure.
 *
 * The element renders a table and / or list view from a JSON object.
 * If JSON is an array it renders a table view. For objects it renders a list view.
 *
 * Complex object are represented as an embedded view of a list or table inside the parent object
 * representation. That may create very complex structure and lead to performance issues when computing
 * data model and building the DOM. Therefore the element will only build the first level of the view.
 * If the object / array contains other objects / arrays it will show only a button to display embeded
 * objects. That should prohibit from freezing the UI while rendering the view.
 *
 * Another optimization is pagination (disabled by default). After setting the `paginate` property
 * array tables will contain a pagination with `itemsPerPage` items rendered at a time. The user can
 * change number of items at any time.
 *
 * ### Example
 * ```html
 * <json-table json="[...]" paginate items-per-page="15"></json-table>
 * ```
 *
 * ## Content actions
 *
 * The element can render an actions pane above the table / list view. Action pane is to
 * display content actions that is relevant in context of the content displayed
 * below the buttons. It should be icon buttons list or just buttons added to this view.
 *
 * Buttons must have `slot="content-action"` attributte set to be included to this view.
 *
 * ```html
 * <json-table json='{"json": "test"}'>
 *  <paper-icon-button
 *    slot="content-action"
 *    title="Copy content to clipboard"
 *    icon="arc:content-copy"></paper-icon-button>
 * </json-table>
 * ```
 *
 * ### Styling
 *
 * `<json-table>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--json-table` | Mixin applied to the element | `{}`
 * `--json-table-main-array-wrapper` | Mixin applied to the top level array's table view. This element has `overflow` property set.  | `{}`
 * `--json-table-item-border-bottom-color` | Color of the bottom border in the array able items or in the object list row | `rgba(0, 0, 0, 0.12)`
 * `--json-table-list-property-name-width` | Width of the property name for the list view for the object display | `120px`
 * `--json-table-array-header-color` | Color of the array table header labels | ``
 * `--json-table-array-body-color` | Color of the array table body values | ``
 *
 * @customElement
 * @appliesMixin JsonTableMixin
 * @memberof UiElements
 */
class JsonTable extends JsonTableMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
    }

    .array-wrapper {
      display: flex;
      flex-direction: row;
      overflow-y: hidden;
      overflow-x: auto;
    }

    json-table-array {
      flex: 1;
      flex-basis: 0.000000001px;
    }

    .actions-panel {
      display: flex;
      flex-direction: row;
      align-items: center;
    }`;
  }

  render() {
    const { _renderJson, paginate, page, itemsPerPage, outlined, compatibility } = this;
    return html`
    <div class="actions-panel">
      <slot name="content-action"></slot>
    </div>
    ${Array.isArray(_renderJson) ? html`<div class="array-wrapper">
      <json-table-array
        .json="${_renderJson}"
        ?paginate="${paginate}"
        .page="${page}"
        .itemsPerPage="${itemsPerPage}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"></json-table-array>
    </div>` : undefined}
    ${this.isObject(_renderJson) ? html`<json-table-object
      .json="${_renderJson}"
      ?paginate="${paginate}"
      .page="${page}"
      .itemsPerPage="${itemsPerPage}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}"></json-table-object>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * JSON data to display.
       * If provided data is type of string then it will use the `JSON.stringify` function to
       * create a JavaScript object from string.
       */
      json: { },
      // A copy of the `json` object so it can be altered by the element.
      _renderJson: Object,

      _parserError: { type: Boolean }
    };
  }

  get json() {
    return this._json;
  }

  set json(value) {
    const old = this._json;
    if (old === value) {
      return;
    }
    this._json = value;
    this._jsonChanged(value);
  }
  /**
   * Will be set to true if the passed `json` is a string and it's not valid JSON.
   * @return {Boolean}
   */
  get parserError() {
    return this._parserError;
  }

  constructor() {
    super();
    this._parserError = false;
  }
  /**
   * Handler for `json` attribute value change.
   *
   * @param {Object|Array} json JSON object to render.
   */
  _jsonChanged(json) {
    this._parserError = false;
    this._renderJson = undefined;

    if (!json) {
      return;
    }

    if (typeof json === 'string') {
      try {
        json = JSON.parse(json);
        // No need for copy.
        this._setRenderJson(json);
        return;
      } catch (e) {
        this._parserError = true;
        return;
      }
    }
    if (this.isArray(json)) {
      this._setRenderJson(Array.from(json));
    } else {
      this._setRenderJson(Object.assign({}, json));
    }
  }
  /**
   * Sets `_renderJson` property after 1 ms.
   *
   * @param {Object|Array} json JSON object to render.
   */
  _setRenderJson(json) {
    if (this.__timer) {
      clearTimeout(this.__timer);
    }
    this.__timer = setTimeout(() => {
      this.__timer = undefined;
      this._renderJson = json;
    }, 1);
  }
}
window.customElements.define('json-table', JsonTable);

var styles$1 = css`
  /**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */
  code[class*='language-'],
  pre[class*='language-'] {
    white-space: pre-wrap;
    word-spacing: normal;
    word-break: break-all;
    word-wrap: break-word;
    line-height: 1.5;
    tab-size: 4;
    hyphens: auto;
    background-color: var(--prism-container-background-color);
    display: block;
    font-family: var(--arc-font-code-family, monospace);
    font-size: var(--arc-font-code-font-size, 10pt);
  }

  pre[class*='language-']::-moz-selection,
  pre[class*='language-']::-moz-selection,
  code[class*='language-']::-moz-selection,
  code[class*='language-']::-moz-selection {
    text-shadow: none;
    background: var(--prism-container-selection-background-color, #b3d4fc);
  }

  pre[class*='language-']::selection,
  pre[class*='language-']::selection,
  code[class*='language-']::selection,
  code[class*='language-']::selection {
    text-shadow: none;
    background: var(--prism-container-selection-background-color, #b3d4fc);
  }

  @media print {
    code[class*='language-'],
    pre[class*='language-'] {
      text-shadow: none;
    }
  }
  /* Code blocks */

  pre[class*='language-'] {
    padding: 1em;
    margin: 0.5em 0;
    overflow: auto;
  }

  :not(pre) > code[class*='language-'],
  pre[class*='language-'] {
    background: var(--prism-container-pre-background-color, #f5f2f0);
  }
  /* Inline code */

  :not(pre) > code[class*='language-'] {
    padding: 0.1em;
    border-radius: 0.3em;
    white-space: normal;
  }

  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: var(--code-token-comment-value-color, slategray);
  }

  .token.punctuation {
    color: var(--code-punctuation-value-color, #999);
  }

  .namespace {
    opacity: 0.7;
  }

  .token.property,
  .token.tag,
  .token.constant,
  .token.symbol,
  .token.deleted {
    color: var(--code-property-value-color, #905);
  }

  .token.number {
    color: var(--code-type-number-value-color, #905);
  }

  .token.boolean {
    color: var(--code-type-boolean-value-color, #905);
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: var(--code-type-text-value-color, #690);
  }

  .token.operator,
  .token.entity,
  .token.url,
  .language-css .token.string,
  .style .token.string {
    color: var(--code-operator-value-color, #a67f59);
    background: var(--code-operator-value-background-color, hsla(0, 0%, 100%, 0.5));
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: var(--code-keyword-value-color, #07a);
  }

  .token.function {
    color: var(--code-function-value-color, #dd4a68);
  }

  .token.regex,
  .token.important,
  .token.variable {
    color: var(--code-variable-value-color, #e90);
  }

  .token.important,
  .token.bold {
    font-weight: bold;
  }

  .token.italic {
    font-style: italic;
  }

  .token.entity {
    cursor: help;
  }
`;

/**
 * `api-example-render`
 *
 * Renders a JSON values using Prism highlighter or JSON table.
 *
 * ## Data model
 *
 * The model is generated by `api-example-generator`. Use it to generate
 * view model for examples for AMF shape.
 *
 * ### ExampleModel
 *
 * - **hasRaw** `Boolean` - if true then `raw` property has a value
 * - **hasTitle** `Boolean` - if true then `title` property has a value
 * - **hasUnion** `Boolean` - if true then `values` property has a value
 * - **value** `String`, Optional - Example to render
 * - **title** - `String`, Optional - Example name, only when `hasTitle` is set
 * - **raw** `String`, Optional - Raw value of RAML example. This value is a
 * YAML or JSON schema value. This is only set when raw value is available in
 * the model and it is not JSON/XML.
 * - **values** `Array<ExampleModel>`, Optional - Only when `hasUnion` is set.
 *
 * ## Example
 *
 * ```javascript
 * <api-example-render example="{...}" is-json mime-type="application/json"></api-example-render>
 * ```
 *
 * ## Styling
 *
 * `<api-resource-example-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-example-render` | Mixin applied to this elment | `{}`
 * `--code-block` | Mixin applied to the output block | `{}`
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 */
class ApiExampleRender extends LitElement {
  static get styles() {
    return [
      styles$1,
      css`
      :host {
        display: block;
        padding: 4px;
        background-color: var(--code-background-color, #f5f2f0);
      }

      .code-wrapper {
        padding: 8px;
      }

      #output {
        white-space: pre-wrap;
        word-wrap: var(--code-block-word-wrap, break-word);
        word-break: var(--code-block-word-break, break-all);
        font-family: var(--arc-font-code-family);
      }

      [hidden] {
        display: none !important;
      }

      .example-title {
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
        font-size: 15px;
        margin: 0 8px 4px 8px;
      }

      .union-toggle {
        outline: none;
        background-color: var(--api-type-document-union-button-background-color, transparent);
        color: var(--api-type-document-union-button-color, #000);
        border-width: 1px;
        border-color: var(--api-body-document-media-button-border-color, #a3b11d);
        border-style: solid;
      }

      .union-toggle[activated] {
        background-color: var(--api-type-document-union-button-active-background-color, #CDDC39);
        color: var(--api-type-document-union-button-active-color, #000);
      }

      .action-button {
        outline: none;
        border-width: 1px;
        border-color: var(--api-body-document-action-button-border-color, #BDBDBD);
        border-style: solid;
      }

      .action-button[active] {
        background-color: var(--api-resource-example-document-button-active-background-color, #e0e0e0);
        color: var(--api-resource-example-document-button-active-color, currentColor);
      }

      .union-type-selector {
        margin: 12px 8px;
      }

      json-table {
        margin: 0 8px;
      }

      .examples-header {
        display: flex;
        align-items: center;
        flex-direction: row;
      }

      .example-actions {
        display: flex;
        justify-content: flex-end;
        flex-wrap: wrap;
        flex: 1;
      }`
    ];
  }

  static get properties() {
    return {
      /**
       * Data to render.
       */
      example: { type: Object },
      /**
       * Examples media type
       */
      mediaType: { type: String },
      /**
       * When true the example is a JSON type example.
       */
      isJson: { type: Boolean },
      /**
       * Index of selected union.
       */
      selectedUnion: { type: Number },
      /**
       * Current state of "table" button. When tru the button is highlighted.
       * Note, this won't trigger rendering table/code view as this property is used
       * by `api-resource-example-document` to handle table state change.
       */
      table: { type: Boolean },
      /**
       * When set it renders JSON table instead of code view.
       */
      renderTable: { type: Boolean },
      /**
       * Opens example source view (source from API spec file).
       */
      sourceOpened: { type: Boolean },
      /**
       * When set the title won't be rendered event if the example has one.
       */
      noTitle: { type: Boolean },
      /**
       * When set the actions row (copy, switch view type) is not rendered.
       */
      noActions: { type: Boolean },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean }
    };
  }

  get table() {
    return this._table;
  }

  set table(value) {
    if (this._setObservableProperty('table', value)) {
      this.dispatchEvent(new CustomEvent('table-changed', {
        composed: true,
        detail: {
          value
        }
      }));
    }
  }

  get mediaType() {
    return this._mediaType;
  }

  set mediaType(value) {
    if (this._setObservableProperty('mediaType', value)) {
      this._dataChanged(value, this._example, this._sourceOpened);
    }
  }

  get example() {
    return this._example;
  }

  set example(value) {
    if (this._setObservableProperty('example', value)) {
      this._dataChanged(this._mediaType, value, this._sourceOpened);
      this.selectedUnion = 0;
    }
  }

  get sourceOpened() {
    return this._sourceOpened;
  }

  set sourceOpened(value) {
    if (this._setObservableProperty('sourceOpened', value)) {
      this._dataChanged(this._mediaType, this._example, value);
    }
  }

  constructor() {
    super();
    this.sourceOpened = false;
  }

  _setObservableProperty(prop, value) {
    const key = '_' + prop;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }
  /**
   * Computes whether passed value is a valig JSON object, when component is
   * marked to parse JSON data.
   * @param {Boolean} isJson [description]
   * @param {String} value Current example value
   * @return {Boolean}
   */
  _computeIsJson(isJson, value) {
    if (!isJson) {
      return false;
    }
    if (!value) {
      return false;
    }
    try {
      const result = JSON.parse(value);
      return typeof result === 'object';
    } catch (_) {
      return false;
    }
  }

  _computeHasRaw(value, raw) {
    if (!raw) {
      return false;
    }
    return String(raw) !== String(value);
  }

  _dataChanged(mediaType, example) {
    if (this.__changeDebouncer || !example) {
      return;
    }
    this.__changeDebouncer = true;
    setTimeout(() => {
      this.__changeDebouncer = false;
      this._renderCode();
    });
  }

  _renderCode() {
    const example = this.example;
    if (!example || (!example.value && example.values)) {
      return;
    }
    const output = this.shadowRoot.querySelector('#output');
    if (!output) {
      setTimeout(() => this._renderCode());
      return;
    }
    if (this.sourceOpened) {
      output.innerHTML = this.highlight(String(example.raw), 'yaml');
    } else {
      const value = String(example.value);
      if (value || value === false || value === 0) {
        output.innerHTML = this.highlight(value, this.mediaType);
      } else {
        output.innerText = '(no value in example)';
      }
    }
  }
  /**
   * Dispatches `syntax-highlight` custom event
   * @param {String} code Code to highlight
   * @param {String} type Mime type of the code
   * @return {String} Highlighted code.
   */
  highlight(code, type) {
    let lang;
    if (type) {
      if (type.indexOf('json') !== -1) {
        lang = 'json';
      } else if (type.indexOf('xml') !== -1) {
        lang = 'xml';
      }
    }
    const ev = new CustomEvent('syntax-highlight', {
      bubbles: true,
      composed: true,
      detail: {
        code,
        lang
      }
    });
    this.dispatchEvent(ev);
    return ev.detail.code;
  }
  /**
   * Coppies current response text value to clipboard."tabble"
   *
   * @param {Event} e
   */
  _copyToClipboard(e) {
    const button = e.target;
    const copy = this.shadowRoot.querySelector('clipboard-copy');
    if (copy.copy()) {
      button.innerText = 'Done';
    } else {
      button.innerText = 'Error';
    }
    button.disabled = true;
    if ('part' in button) {
      button.part.add('content-action-button-disabled');
      button.part.add('code-content-action-button-disabled');
    }
    setTimeout(() => this._resetCopyButtonState(button), 1000);
  }
  /**
   * Resets button icon.
   * @param {Element} button Button to reset.
   */
  _resetCopyButtonState(button) {
    button.innerText = 'Copy';
    button.disabled = false;
    if ('part' in button) {
      button.part.remove('content-action-button-disabled');
      button.part.remove('code-content-action-button-disabled');
    }
  }

  _computeUnionExamples(selectedUnion, example) {
    if (selectedUnion === undefined || selectedUnion < 0) {
      return;
    }
    if (!example || !example.values) {
      return;
    }
    return example.values[selectedUnion];
  }

  _toggleTable(e) {
    const { target } = e;
    const { value } = e.detail;
    this.table = value;
    if (value && this.sourceOpened) {
      this.sourceOpened = !value;
    }
    this._toggleActionButtonCssPart(target, value);
  }

  _toggleSourceOpened(e) {
    const { target } = e;
    const { value } = e.detail;
    this.sourceOpened = value;
    if (value && this.table) {
      this.table = !value;
    }
    this._toggleActionButtonCssPart(target, value);
  }

  _toggleActionButtonCssPart(target, active) {
    if (!('part' in target)) {
      return;
    }
    const parts = ['content-action-button-active', 'code-content-action-button-active'];
    for (let i = 0, len = parts.length; i < len; i++) {
      if (active) {
        target.part.add(parts[i]);
      } else {
        target.part.remove(parts[i]);
      }
    }
  }
  /**
   * Handler for union type button click.
   * Sets `selectedUnion` property.
   *
   * @param {ClickEvent} e
   */
  _selectUnion(e) {
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    if (this.selectedUnion === index) {
      e.target.setAttribute('activated', '');
    } else {
      this.selectedUnion = index;
    }
  }

  _renderUnion(example) {
    const values = example.values;
    if (!values) {
      return;
    }
    const unions = example.values.map((item) => item.title);
    const selectedUnion = this.selectedUnion;
    const unionExample = this._computeUnionExamples(selectedUnion, example);
    return html`
      <div class="union-type-selector">
        <span>Any of:</span>
        ${unions.map((item, index) => html`
          <anypoint-button
            class="union-toggle"
            ?activated="${selectedUnion === index}"
            @click="${this._selectUnion}"
            data-index="${index}"
            ?legacy="${this.legacy}"
            title="Select ${item} type">${item}</anypoint-button>`)}
      </div>
      ${unionExample ? html`
        <api-example-render
          .example="${unionExample}"
          .isJson="${this.isJson}"
          .mediaType="${this.mediaType}"
          .table="${this.table}"
          .renderTable="${this.renderTable}"
          notitle
          .noActions="${this.noActions}"></api-example-render>` : undefined}
    `;
  }

  _headerTemplate(example) {
    const renderTitle = !example.isScalar || example.hasTitle;
    const noActions = !!(this.noActions || example.isScalar);
    if (noActions && !renderTitle) {
      return '';
    }
    return html`<div class="examples-header">
      ${renderTitle ? this._titleTemplate(example) : ''}
      ${!noActions ? this._actionsTemplate(example) : ''}
    </div>`;
  }

  _titleTemplate(example) {
    const label = (this.noTitle || !example.title) ? 'Example' : example.title;
    return html`<span class="example-title">${label}</span>`;
  }

  _actionsTemplate(example) {
    const { legacy } = this;
    const hasRaw = this._computeHasRaw(example.value, example.raw);
    const isJson = this._computeIsJson(this.isJson, example.value);
    return html`
    <div class="example-actions">
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="copy"
        @click="${this._copyToClipboard}"
        ?legacy="${legacy}"
        title="Copy example to clipboard"
      >Copy</anypoint-button>
      ${isJson ? html`
        <anypoint-button
          part="content-action-button, code-content-action-button"
          class="action-button"
          data-action="table"
          toggles
          .active="${this.table}"
          @active-changed="${this._toggleTable}"
          ?legacy="${legacy}"
          title="Toggle between table and JSON view"
        >Table view</anypoint-button>` : undefined}
      ${hasRaw ? html`
        <anypoint-button
          part="content-action-button, code-content-action-button"
          class="action-button"
          data-action="code"
          toggles
          .active="${this.sourceOpened}"
          @active-changed="${this._toggleSourceOpened}"
          ?legacy="${legacy}"
          title="Toggle between JSON and example source view"
        >Source vierw</anypoint-button>` : undefined}
    </div>`;
  }

  _renderExample(example) {
    return html`<div class="example">
      ${this._headerTemplate(example)}
      ${this.renderTable ? html`<json-table .json="${example.value}"></json-table>`: undefined}
      <div class="code-wrapper" part="code-wrapper, example-code-wrapper" ?hidden="${this.renderTable}">
        <code id="output" class="markdown-html" part="markdown-html" language-xml=""></code>
      </div>
    </div>`;
  }

  render() {
    const example = this.example;
    if (!example) {
      return html``;
    }
    const isUnion = !!(example && example.hasUnion);
    return html`
    ${isUnion ? this._renderUnion(example) : this._renderExample(example)}
    <clipboard-copy .content="${example.value}"></clipboard-copy>
    `;
  }
}
window.customElements.define('api-example-render', ApiExampleRender);

/**
 * `api-resource-example-document`
 *
 * Renders list of examples defined in AMF model. It renders values that
 * are structured examples (JSON, RAML type).
 *
 * This element uses `api-example-generator` to generate view model for examples.
 * It can accept AMF's Payload shape, array of Payload shapes, or any other
 * AMF shape. If the shape is compatible (has examples, properties, items, unions etc)
 * then examples list is rendered.
 *
 * The mime type (`media-type`) must be set in order to compute examples.
 *
 * ## Example
 *
 * ```html
 * <api-resource-example-document
 *  payload="[...]"
 *  media-type="application/json"></api-resource-example-document>
 * ```
 *
 * ## Styling
 *
 * `<api-resource-example-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-resource-example-document` | Mixin applied to this elment | `{}`
 * `--api-resource-example-document-title` | Mixin applied to example title | `{}`
 * `--api-resource-example-document-button-active-background-color` | Background color of active button | `#e0e0e0`
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin ApiElements.AmfHelperMixin
 */
class ApiResourceExampleDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`
    :host {
      display: block;
    }

    .example:not(:last-of-type) {
      margin-bottom: 24px;
    }

    .example-title {
      font-weight: var(--arc-font-body1-font-weight);
      line-height: var(--arc-font-body1-line-height);
      font-size: 15px;
      margin: 8px 8px 20px 12px;
      display: block;
    }`;
  }

  static get properties() {
    return {
      /**
       * AMF model for examples.
       * It can be Payload shape, list of Payload shapes, or any shape.
       */
      examples: { type: Array },
      /**
       * Examples media type
       */
      mediaType: { type: String },
      /**
       * Type (model) name for which examples are generated for.
       * This is used by RAML to XML examples processor to wrap the example
       * in type name. If missing this wrapping is omnited.
       */
      typeName: { type: String },
      /**
       * Rendered payload ID (if any) to associate examples with the paylaod.
       */
      payloadId: String,
      /**
       * Computed in a debouncer examples to render.
       */
      _renderedExamples: {
        type: Array
      },
      /**
       * Computed value, true if there are examples to render.
       * This value is reflected to attribute so the element can be hidden
       * via CSS until examples are set.
       *
       * ```css
       * api-resource-example-document { display: none; }
       * api-resource-example-document[has-examples] { display: block; }
       * ```
       */
      hasExamples: {
        type: Boolean,
        reflect: true
      },
      /**
       * If true it will display a table view instead of JSON code.
       * `isJson` must be set to use this option.
       */
      table: {
        type: Boolean,
        reflect: true
      },
      /**
       * Computed value, true if selected media type is application/json
       * or equivalent.
       */
      isJson: {
        type: Boolean,
        reflect: true
      },
      /**
       * Configuration passed to example generator.
       * When set the generator only returns examples that are defined in API
       * file, without auto generating examples from object properties.
       */
      noAuto: { type: Boolean, reflect: true },
      /**
       * When set the actions row (copy, switch view type) is not rendered.
       */
      noActions: { type: Boolean, reflect: true },
      /**
       * When set it only renders "raw" examples. To be used when media type context is unknown.
       * This can happen if RAML type document is rendered outside method documentation
       * (not in a request/response body when media type is known).
       *
       * Note, this can return JSON, XML, YAML or any other value
       * depending on original source.
       */
      rawOnly: { type: Boolean, reflect: true },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean },
      _effectiveTable: {
        type: Boolean
      },
      /**
       * True if current environment has localStorage suppport.
       * Chrome apps do not have localStorage property.
       */
      _hasLocalStorage: {
        type: Boolean
      }
    };
  }

  get hasLocalStorage() {
    return this._hasLocalStorage;
  }

  get renderedExamples() {
    return this.__renderedExamples;
  }

  get _renderedExamples() {
    return this.__renderedExamples;
  }

  set _renderedExamples(value) {
    if (this._setObservableProperty('_renderedExamples', value)) {
      this.dispatchEvent(new CustomEvent('rendered-examples-changed', {
        composed: true,
        detail: {
          value
        }
      }));
    }
  }

  get table() {
    return this._table;
  }

  set table(value) {
    if (this._setObservableProperty('table', value)) {
      this._tableChanged(value);
      this._effectiveTable = this._computeEffectiveTable(value, this._isJson);
    }
  }

  get mediaType() {
    return this._mediaType;
  }

  set mediaType(value) {
    if (this._setObservableProperty('mediaType', value)) {
      this.isJson = this._computeIsJson(value);
      this._computeExamples(this.examples, value, this.rawOnly, this.typeName, this.noAuto, this.payloadId);
    }
  }

  get isJson() {
    return this._isJson;
  }

  set isJson(value) {
    if (this._setObservableProperty('isJson', value)) {
      this._effectiveTable = this._computeEffectiveTable(this._table, value);
    }
  }

  get examples() {
    return this._examples;
  }

  set examples(value) {
    if (this._setObservableProperty('examples', value)) {
      this._computeExamples(value, this._mediaType, this._rawOnly, this._typeName, this._noAuto, this._payloadId);
    }
  }

  get rawOnly() {
    return this._rawOnly;
  }

  set rawOnly(value) {
    if (this._setObservableProperty('rawOnly', value)) {
      this._computeExamples(this._examples, this._mediaType, value, this._typeName, this._noAuto, this._payloadId);
    }
  }

  get typeName() {
    return this._typeName;
  }

  set typeName(value) {
    if (this._setObservableProperty('typeName', value)) {
      this._computeExamples(this._examples, this._mediaType, this._rawOnly, value, this._noAuto, this._payloadId);
    }
  }

  get noAuto() {
    return this._noAuto;
  }

  set noAuto(value) {
    if (this._setObservableProperty('noAuto', value)) {
      this._computeExamples(this._examples, this._mediaType, this._rawOnly, this._typeName, value, this._payloadId);
    }
  }

  get payloadId() {
    return this._payloadId;
  }

  set payloadId(value) {
    if (this._setObservableProperty('payloadId', value)) {
      this._computeExamples(this._examples, this._mediaType, this._rawOnly, this._typeName, this._noAuto, value);
    }
  }

  get hasExamples() {
    return this._hasExamples;
  }

  set hasExamples(value) {
    if (this._setObservableProperty('hasExamples', value)) {
      this.dispatchEvent(new CustomEvent('has-examples-changed', {
        composed: true,
        detail: {
          value
        }
      }));
    }
  }

  _setObservableProperty(prop, value) {
    const key = '_' + prop;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }

  constructor() {
    super();
    this._onStorageChanged = this._onStorageChanged.bind(this);
    this._onJsonTableStateChanged = this._onJsonTableStateChanged.bind(this);

    this._hasLocalStorage = this._hasStorageSupport();
    this.noActions = false;
    this.isJson = false;
    this.hasExamples = false;
    this._ensureJsonTable();
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    window.addEventListener('storage', this._onStorageChanged);
    window.addEventListener('json-table-state-changed', this._onJsonTableStateChanged);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    window.removeEventListener('storage', this._onStorageChanged);
    window.removeEventListener('json-table-state-changed', this._onJsonTableStateChanged);
  }

  _hasStorageSupport() {
    /* global chrome */
    if (typeof chrome !== 'undefined' && chrome.i18n) {
      // Chrome apps have `chrome.i18n` property, regular website doesn't.
      // This is to avoid annoying warning message in Chrome apps.
      return false;
    }
    try {
      localStorage.getItem('test');
      return true;
    } catch (_) {
      return false;
    }
  }
  /**
   * When response's content type is JSON the view renders the
   * JSON table element. This function reads current state for the table
   * (if it is turned on) and handles view change if needed.
   */
  _ensureJsonTable() {
    if (!this.hasLocalStorage) {
      return;
    }
    const isTable = this._localStorageValueToBoolean(localStorage.jsonTableEnabled);
    if (this.table !== isTable) {
      this.table = isTable;
    }
  }
  /**
   * Updates "table" state in localstorage and disaptches
   * `json-table-state-changed` event.
   *
   * @param {Boolean} state Current "table" state.
   */
  _tableChanged(state) {
    if (state === undefined) {
      return;
    }
    if (!this.hasLocalStorage) {
      this._dispatchTableState(state);
      return;
    }
    if (localStorage.jsonTableEnabled !== String(state)) {
      window.localStorage.setItem('jsonTableEnabled', state);
      this._dispatchTableState(state);
    }
  }
  /**
   * Dispatches `json-table-state-changed` custom event.
   * @param {Boolean} enabled
   * @return {CustomEvent}
   */
  _dispatchTableState(enabled) {
    const e = new CustomEvent('json-table-state-changed', {
      bubbles: true,
      composed: true,
      detail: {
        enabled
      }
    });
    this.dispatchEvent(e);
    return e;
  }
  /**
   * Updates the value of the `isJsonTable` property when the corresponding localStorage
   * property change.
   *
   * @param {Event} e Storage event
   */
  _onStorageChanged(e) {
    if (e.key !== 'jsonTableEnabled' || !this.hasLocalStorage) {
      return;
    }
    if (e.newValue === undefined) {
      return;
    }
    const v = this._localStorageValueToBoolean(e.newValue);
    if (this.table !== v) {
      this.table = v;
    }
  }
  /**
   * Reads the local value (always a string) as a boolean value.
   *
   * @param {String} value The value read from the local storage.
   * @return {Boolean} Boolean value read from the value.
   */
  _localStorageValueToBoolean(value) {
    if (!value) {
      return false;
    }
    if (value === 'true') {
      value = true;
    } else {
      value = false;
    }
    return value;
  }
  /**
   * Handler to the incomming `json-table-state-changed` event.
   * Sets the `table` property if it is different.
   *
   * @param {CustomEvent} e
   */
  _onJsonTableStateChanged(e) {
    if (e.composedPath()[0] === this) {
      return;
    }
    const { enabled } = e.detail;
    if (enabled !== this.table) {
      this.table = enabled;
    }
  }
  /**
   * Runs the debouncer to update examples list.
   */
  _computeExamples() {
    if (this._examplesDebouncer) {
      return;
    }
    this._examplesDebouncer = true;
    setTimeout(() => {
      this._examplesDebouncer = false;
      this.__computeExamples(this.examples, this.mediaType, this.rawOnly, this.typeName, this.payloadId, this.noAuto);
    });
  }

  __computeExamples(examples, mediaType, rawOnly, typeName, payloadId, noAuto) {
    this._renderedExamples = undefined;
    this.hasExamples = false;
    if (!examples || (!mediaType && !rawOnly)) {
      return;
    }
    const opts = {
      typeName,
      typeId: payloadId,
      noAuto,
      rawOnly
    };
    const generator = this.shadowRoot.querySelector('#exampleGenerator');
    let result;
    if (examples instanceof Array) {
      if (this._hasType(examples[0], this.ns.raml.vocabularies.http + 'Payload')) {
        result = generator.generatePayloadsExamples(examples, mediaType, opts);
      } else {
        for (let i = 0, len = examples.length; i < len; i++) {
          const item = generator.computeExamples(examples[i], mediaType, opts);
          if (item) {
            if (result) {
              result = result.concat(item);
            } else {
              result = item;
            }
          }
        }
      }
    } else if (this._hasType(examples, this.ns.raml.vocabularies.http + 'Payload')) {
      result = generator.generatePayloadExamples(examples, mediaType, opts);
    } else {
      // try anything...
      result = generator.computeExamples(examples, mediaType, opts);
    }
    if (result && result.length) {
      this._renderedExamples = result;
      this.hasExamples = true;
    }
  }
  /**
   * Computes value for `isJson` property
   * @param {String} type Current media type.
   * @return {Boolean}
   */
  _computeIsJson(type) {
    return !!(type && type.indexOf('json') !== -1);
  }
  /**
   * Computes value for `_effectiveTable`.
   * @param {Boolean} table Current state of table view for JSON.
   * @param {Boolean} isJson [description]
   * @return {Boolean} True when current media type is JSON and table is enabled.
   */
  _computeEffectiveTable(table, isJson) {
    return !!(isJson && table);
  }

  _tableCHangedHandler(e) {
    this.table = e.detail.value;
  }

  _examplesTemplate(examples) {
    let parts = 'content-action-button, code-content-action-button, content-action-button-disabled, ';
    parts += 'code-content-action-button-disabled content-action-button-active, ';
    parts += 'code-content-action-button-active, code-wrapper, example-code-wrapper, markdown-html';
    return examples.map((item) => html`
      <api-example-render
      exportparts="${parts}"
      class="example"
      .example="${item}"
      ?isjson="${this.isJson}"
      ?mediatype="${this.mediaType}"
      ?table="${this.table}"
      ?rendertable="${this._effectiveTable}"
      ?noactions="${this.noActions}"
      @table-changed="${this._tableCHangedHandler}"
      ?legacy="${this.legacy}"></api-example-render>`);
  }

  render() {
    const examples = this.renderedExamples || [];
    return html`
    <prism-highlighter></prism-highlighter>
    <api-example-generator .amf="${this.amf}" id="exampleGenerator"></api-example-generator>
    ${examples.length > 1 ? html`<span class="example-title">Examples</span>` : undefined}
    ${examples.length ? this._examplesTemplate(examples) : undefined}`;
  }
}
window.customElements.define('api-resource-example-document', ApiResourceExampleDocument);

var freeze$1 = Object.freeze || function (x) {
  return x;
};

var html$2 = freeze$1(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
var svg$1 = freeze$1(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);

var svgFilters = freeze$1(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

var mathMl = freeze$1(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

var text = freeze$1(['#text']);

var freeze$2 = Object.freeze || function (x) {
  return x;
};

var html$1$1 = freeze$2(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);

var svg$1$1 = freeze$2(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

var mathMl$1 = freeze$2(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

var xml = freeze$2(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;

var _ref$1 = typeof Reflect !== 'undefined' && Reflect;
var apply$1 = _ref$1.apply;

if (!apply$1) {
  apply$1 = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array) {
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      var lcElement = element.toLowerCase();
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!Object.isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = {};

  var property = void 0;
  for (property in object) {
    if (apply$1(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

var seal = Object.seal || function (x) {
  return x;
};

var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g // eslint-disable-line no-control-regex
);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _ref = typeof Reflect !== 'undefined' && Reflect;
var apply = _ref.apply;

var arraySlice = Array.prototype.slice;
var freeze = Object.freeze;

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (error) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '1.0.11';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;
  var useDOMParser = false;
  var removeTitle = false;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      Text = window.Text,
      Comment = window.Comment,
      DOMParser = window.DOMParser,
      TrustedTypes = window.TrustedTypes;

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.

  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(TrustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      getElementsByTagName = _document.getElementsByTagName,
      createDocumentFragment = _document.createDocumentFragment;
  var importNode = originalDocument.importNode;


  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$2), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1$1), _toConsumableArray(svg$1$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Output should be safe for jQuery's $() factory? */
  var SAFE_FOR_JQUERY = false;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
   * `Node` is imported into the current `Document`. If this flag is not enabled the
   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
   * DOMPurify. */
  var RETURN_DOM_IMPORT = false;

  /* Output should be free from DOM clobbering attacks? */
  var SANITIZE_DOM = true;

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = addToSet({}, ['audio', 'head', 'math', 'script', 'style', 'template', 'svg', 'video']);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);

  /* Attributes safe for values like "javascript:" */
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form');

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      cfg = {};
    }

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet({}, cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false

    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$2);
        addToSet(ALLOWED_ATTR, html$1$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg$1$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    DOMPurify.removed.push({ element: node });
    try {
      node.parentNode.removeChild(node);
    } catch (error) {
      node.outerHTML = emptyHTML;
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      DOMPurify.removed.push({
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (error) {
      DOMPurify.removed.push({
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = dirty.match(/^[\s]+/);
      leadingWhitespace = matches && matches[0];
      if (leadingWhitespace) {
        dirty = dirty.slice(leadingWhitespace.length);
      }
    }

    /* Use DOMParser to workaround Firefox bug (see comment below) */
    if (useDOMParser) {
      try {
        doc = new DOMParser().parseFromString(dirty, 'text/html');
      } catch (error) {}
    }

    /* Remove title to fix a mXSS bug in older MS Edge */
    if (removeTitle) {
      addToSet(FORBID_TAGS, ['title']);
    }

    /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
    Safari (see comment below) */
    if (!doc || !doc.documentElement) {
      doc = implementation.createHTMLDocument('');
      var _doc = doc,
          body = _doc.body;

      body.parentNode.removeChild(body.parentNode.firstElementChild);
      body.outerHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    }

    if (leadingWhitespace) {
      doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
  };

  // Firefox uses a different parser for innerHTML rather than
  // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)
  // which means that you *must* use DOMParser, otherwise the output may
  // not be safe if used in a document.write context later.
  //
  // So we feature detect the Firefox bug and use the DOMParser if necessary.
  //
  // MS Edge, in older versions, is affected by an mXSS behavior. The second
  // check tests for the behavior and fixes it if necessary.
  if (DOMPurify.isSupported) {
    (function () {
      try {
        var doc = _initDocument('<svg><p><style><img src="</style><img src=x onerror=1//">');
        if (doc.querySelector('svg img')) {
          useDOMParser = true;
        }
      } catch (error) {}
    })();

    (function () {
      try {
        var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');
        if (doc.querySelector('title').innerHTML.match(/<\/title/)) {
          removeTitle = true;
        }
      } catch (error) {}
    })();
  }

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
      return NodeFilter.FILTER_ACCEPT;
    }, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    if (elm instanceof Text || elm instanceof Comment) {
      return false;
    }

    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function') {
      return true;
    }

    return false;
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(obj) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    hooks[entryPoint].forEach(function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  // eslint-disable-next-line complexity
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    var tagName = currentNode.nodeName.toLowerCase();

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Keep content except for black-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
        try {
          var htmlToInsert = currentNode.innerHTML;
          currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
        } catch (error) {}
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Remove in case a noscript/noembed XSS is suspected */
    if (tagName === 'noscript' && currentNode.innerHTML.match(/<\/noscript/i)) {
      _forceRemove(currentNode);
      return true;
    }

    if (tagName === 'noembed' && currentNode.innerHTML.match(/<\/noembed/i)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Convert markup to cover jQuery behavior */
    if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {
      DOMPurify.removed.push({ element: currentNode.cloneNode() });
      if (currentNode.innerHTML) {
        currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');
      } else {
        currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
      }
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = content.replace(MUSTACHE_EXPR$$1, ' ');
      content = content.replace(ERB_EXPR$$1, ' ');
      if (currentNode.textContent !== content) {
        DOMPurify.removed.push({ element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && DATA_ATTR$$1.test(lcName)) ; else if (ALLOW_ARIA_ATTR && ARIA_ATTR$$1.test(lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;

      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href') && lcTag !== 'script' && value.indexOf('data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var idAttr = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = attr.value.trim();
      lcName = name.toLowerCase();

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;

      /* Remove attribute */
      // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
      // remove a "name" attribute from an <img> tag that has an "id"
      // attribute at the time.
      if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
        idAttr = attributes.id;
        attributes = apply(arraySlice, attributes, []);
        _removeAttribute('id', currentNode);
        _removeAttribute(name, currentNode);
        if (attributes.indexOf(idAttr) > l) {
          currentNode.setAttribute('id', idAttr.value);
        }
      } else if (
      // This works around a bug in Safari, where input[type=file]
      // cannot be dynamically set after type has been removed
      currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
        continue;
      } else {
        // This avoids a crash in Safari v9.0 with double-ids.
        // The trick is to first set the id to be empty and then to
        // remove the attribute
        if (name === 'id') {
          currentNode.setAttribute(name, '');
        }

        _removeAttribute(name, currentNode);
      }

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = value.replace(MUSTACHE_EXPR$$1, ' ');
        value = value.replace(ERB_EXPR$$1, ' ');
      }

      /* Is `value` valid for this attribute? */
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        DOMPurify.removed.pop();
      } catch (error) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    if (!dirty) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw new TypeError('toString is not a function');
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw new TypeError('dirty is not a string, aborting');
        }
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    if (IN_PLACE) ; else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!-->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
        return trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (RETURN_DOM_IMPORT) {
        /* AdoptNode() is not used because internal state is not reset
               (e.g. the past names map of a HTMLFormElement), this is safe
               in theory but we would rather not risk another attack vector.
               The state that is cloned by importNode() is explicitly defined
               by the specs. */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = serializedHTML.replace(MUSTACHE_EXPR$$1, ' ');
      serializedHTML = serializedHTML.replace(ERB_EXPR$$1, ' ');
    }

    return trustedTypesPolicy ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = tag.toLowerCase();
    var lcName = attr.toLowerCase();
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    hooks[entryPoint].push(hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint].pop();
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

var marked$1 = createCommonjsModule(function (module, exports) {
(function(root) {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  nptable: noop,
  table: noop,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d{1,9}\.)/;
block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?-->/;
block.html = edit(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit(block._paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} +')
  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>')
  .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
  table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
});

/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge({}, block.normal, {
  html: edit(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
  fences: noop, // fences not supported
  paragraph: edit(block.normal._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' *#{1,6} *[^\n]')
    .replace('lheading', block.lheading)
    .replace('blockquote', ' {0,3}>')
    .replace('|fences', '')
    .replace('|list', '')
    .replace('|html', '')
    .getRegex()
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = Object.create(null);
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.pedantic) {
    this.rules = block.pedantic;
  } else if (this.options.gfm) {
    this.rules = block.gfm;
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      listStart,
      listItems,
      t,
      space,
      i,
      tag,
      l,
      isordered,
      istask,
      ischecked;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      var lastToken = this.tokens[this.tokens.length - 1];
      src = src.substring(cap[0].length);
      // An indented code block cannot interrupt a paragraph.
      if (lastToken && lastToken.type === 'paragraph') {
        lastToken.text += '\n' + cap[0].trimRight();
      } else {
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          codeBlockStyle: 'indented',
          text: !this.options.pedantic
            ? rtrim(cap, '\n')
            : cap
        });
      }
      continue;
    }

    // fences
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2] ? cap[2].trim() : cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (cap = this.rules.nptable.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(item.cells[i], item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      listStart = {
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : '',
        loose: false
      };

      this.tokens.push(listStart);

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      listItems = [];
      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) */, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull.length > 1 ? b.length === 1
            : (b.length > 1 || (this.options.smartLists && b !== bull))) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        if (loose) {
          listStart.loose = true;
        }

        // Check for task list items
        istask = /^\[[ xX]\] /.test(item);
        ischecked = undefined;
        if (istask) {
          ischecked = item[1] !== ' ';
          item = item.replace(/^\[[ xX]\] +/, '');
        }

        t = {
          type: 'list_item_start',
          task: istask,
          checked: ischecked,
          loose: loose
        };

        listItems.push(t);
        this.tokens.push(t);

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      if (listStart.loose) {
        l = listItems.length;
        i = 0;
        for (; i < l; i++) {
          listItems[i].loose = true;
        }
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (cap = this.rules.table.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(
            item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
            item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
  strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
  em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noop,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
};

// list of punctuation marks from common mark spec
// without ` and ] to workaround Rule 17 (inline code blocks/links)
inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit(inline.tag)
  .replace('comment', block._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~+(?=\S)([\s\S]*?\S)~+/,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
});

inline.gfm.url = edit(inline.gfm.url, 'i')
  .replace('email', inline.gfm._extended_email)
  .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text)
    .replace('\\b_', '\\b_| {2,}\\n')
    .replace(/\{2,\}/g, '*')
    .getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.pedantic) {
    this.rules = inline.pedantic;
  } else if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      title,
      cap,
      prevCapZero;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[1]);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = true;
      } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = false;
      }

      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      var lastParenIndex = findClosingBracket(cap[2], '()');
      if (lastParenIndex > -1) {
        var linkLen = 4 + cap[1].length + lastParenIndex;
        cap[2] = cap[2].substring(0, lastParenIndex);
        cap[0] = cap[0].substring(0, linkLen).trim();
        cap[3] = '';
      }
      src = src.substring(cap[0].length);
      this.inLink = true;
      href = cap[2];
      if (this.options.pedantic) {
        link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) {
          href = link[1];
          title = link[3];
        } else {
          title = '';
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
      out += this.outputLink(cap, {
        href: InlineLexer.escapes(href),
        title: InlineLexer.escapes(title)
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      src = src.substring(cap[0].length);
      out += this.renderer.link(href, null, text);
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      if (this.inRawBlock) {
        out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
      } else {
        out += this.renderer.text(escape(this.smartypants(cap[0])));
      }
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

InlineLexer.escapes = function(text) {
  return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = link.href,
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || marked.defaults;
}

Renderer.prototype.code = function(code, infostring, escaped) {
  var lang = (infostring || '').match(/\S*/)[0];
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw, slugger) {
  if (this.options.headerIds) {
    return '<h'
      + level
      + ' id="'
      + this.options.headerPrefix
      + slugger.slug(raw)
      + '">'
      + text
      + '</h'
      + level
      + '>\n';
  }
  // ignore IDs
  return '<h' + level + '>' + text + '</h' + level + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.checkbox = function(checked) {
  return '<input '
    + (checked ? 'checked="" ' : '')
    + 'disabled="" type="checkbox"'
    + (this.options.xhtml ? ' /' : '')
    + '> ';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  if (body) body = '<tbody>' + body + '</tbody>';

  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + body
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' align="' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }
  var out = '<a href="' + escape(href) + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }

  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function(text) {
  return text;
};

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
};

TextRenderer.prototype.br = function() {
  return '';
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
  this.slugger = new Slugger();
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, { renderer: new TextRenderer() })
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  this.token = this.tokens.pop();
  return this.token;
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)),
        this.slugger);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';
      var loose = this.token.loose;
      var checked = this.token.checked;
      var task = this.token.task;

      if (this.token.task) {
        body += this.renderer.checkbox(checked);
      }

      while (this.next().type !== 'list_item_end') {
        body += !loose && this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }
      return this.renderer.listitem(body, task, checked);
    }
    case 'html': {
      // TODO parse inline content if parameter markdown=1
      return this.renderer.html(this.token.text);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
    default: {
      var errMsg = 'Token with "' + this.token.type + '" type was not found.';
      if (this.options.silent) {
        console.log(errMsg);
      } else {
        throw new Error(errMsg);
      }
    }
  }
};

/**
 * Slugger generates header id
 */

function Slugger() {
  this.seen = {};
}

/**
 * Convert string to unique id
 */

Slugger.prototype.slug = function(value) {
  var slug = value
    .toLowerCase()
    .trim()
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
    .replace(/\s/g, '-');

  if (this.seen.hasOwnProperty(slug)) {
    var originalSlug = slug;
    do {
      this.seen[originalSlug]++;
      slug = originalSlug + '-' + this.seen[originalSlug];
    } while (this.seen.hasOwnProperty(slug));
  }
  this.seen[slug] = 0;

  return slug;
};

/**
 * Helpers
 */

function escape(html, encode) {
  if (encode) {
    if (escape.escapeTest.test(html)) {
      return html.replace(escape.escapeReplace, function(ch) { return escape.replacements[ch]; });
    }
  } else {
    if (escape.escapeTestNoEncode.test(html)) {
      return html.replace(escape.escapeReplaceNoEncode, function(ch) { return escape.replacements[ch]; });
    }
  }

  return html;
}

escape.escapeTest = /[&<>"']/;
escape.escapeReplace = /[&<>"']/g;
escape.replacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  var row = tableRow.replace(/\|/g, function(match, offset, str) {
        var escaped = false,
            curr = offset;
        while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
        if (escaped) {
          // odd number of slashes means | is escaped
          // so we leave it alone
          return '|';
        } else {
          // add space before unescaped |
          return ' |';
        }
      }),
      cells = row.split(/ \|/),
      i = 0;

  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push('');
  }

  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
// /c*$/ is vulnerable to REDOS.
// invert: Remove suffix of non-c chars instead. Default falsey.
function rtrim(str, c, invert) {
  if (str.length === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  var suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < str.length) {
    var currChar = str.charAt(str.length - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }

  return str.substr(0, str.length - suffLen);
}

function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  var level = 0;
  for (var i = 0; i < str.length; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}

function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    checkSanitizeDeprecation(opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.getDefaults = function() {
  return {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    xhtml: false
  };
};

marked.defaults = marked.getDefaults();

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.Slugger = Slugger;

marked.parse = marked;

{
  module.exports = marked;
}
})();
});

var marked$2 = /*#__PURE__*/Object.freeze({
    'default': marked$1,
    __moduleExports: marked$1
});

if (!window.marked) {
  // For webpack support for the Polymer 3 version created by the Polymer
  // Modulizer More info:
  // https://github.com/PolymerElements/marked-element/issues/81
  window.marked = marked$2;
}

const SafeHtmlUtils = {
  AMP_RE: new RegExp(/&/g),
  GT_RE: new RegExp(/>/g),
  LT_RE: new RegExp(/</g),
  SQUOT_RE: new RegExp(/'/g),
  QUOT_RE: new RegExp(/"/g),
  htmlEscape: function(s) {
    if (typeof s !== 'string') {
      return s;
    }
    if (s.indexOf('&') !== -1) {
      s = s.replace(SafeHtmlUtils.AMP_RE, '&amp;');
    }
    if (s.indexOf('<') !== -1) {
      s = s.replace(SafeHtmlUtils.LT_RE, '&lt;');
    }
    if (s.indexOf('>') !== -1) {
      s = s.replace(SafeHtmlUtils.GT_RE, '&gt;');
    }
    if (s.indexOf('"') !== -1) {
      s = s.replace(SafeHtmlUtils.QUOT_RE, '&quot;');
    }
    if (s.indexOf("'") !== -1) {
      s = s.replace(SafeHtmlUtils.SQUOT_RE, '&#39;');
    }
    return s;
  }
};
/**
Element wrapper for the [marked](https://github.com/chjj/marked) library.

Based on Polymer's `marked-element`.

`<marked-element>` accepts Markdown source and renders it to a child
element with the class `markdown-html`. This child element can be styled
as you would a normal DOM element. If you do not provide a child element
with the `markdown-html` class, the Markdown source will still be rendered,
but to a shadow DOM child that cannot be styled.

### Markdown Content

The Markdown source can be specified several ways:

#### Use the `markdown` attribute to bind markdown

```html
<marked-element markdown="`Markdown` is _awesome_!">
  <div slot="markdown-html"></div>
</marked-element>
```
#### Use `<script type="text/markdown">` element child to inline markdown

```html
<marked-element>
  <div slot="markdown-html"></div>
  <script type="text/markdown">
    Check out my markdown!
    We can even embed elements without fear of the HTML parser mucking up their
    textual representation:
  </script>
</marked-element>
```
#### Use `<script type="text/markdown" src="URL">` element child to specify remote markdown

```html
<marked-element>
  <div slot="markdown-html"></div>
  <script type="text/markdown" src="../guidelines.md"></script>
</marked-element>
```

Note that the `<script type="text/markdown">` approach is *static*. Changes to
the script content will *not* update the rendered markdown!

Though, you can data bind to the `src` attribute to change the markdown.

```html
<marked-element>
  <div slot="markdown-html"></div>
  <script type="text/markdown" src$="[[source]]"></script>
</marked-element>
<script>
  ...
  this.source = '../guidelines.md';
</script>
```

### Styling

If you are using a child with the `markdown-html` class, you can style it
as you would a regular DOM element:

```css
[slot="markdown-html"] p {
  color: red;
}
[slot="markdown-html"] td:first-child {
  padding-left: 24px;
}
```

@demo demo/index.html
 */
class ArcMarked extends LitElement {
  static get styles() {
    return css`
      :host {
        display: block;
        padding: 24px;
      }
    `;
  }

  static get properties() {
    return {
      /**
       * The markdown source that should be rendered by this element.
       */
      markdown: { type: String },
      /**
       * Enable GFM line breaks (regular newlines instead of two spaces for
       * breaks)
       */
      breaks: { type: Boolean },
      /**
       * Conform to obscure parts of markdown.pl as much as possible. Don't fix
       * any of the original markdown bugs or poor behavior.
       */
      pedantic: { type: Boolean },
      /**
       * Function used to customize a renderer based on the [API specified in the
       * Marked
       * library](https://github.com/chjj/marked#overriding-renderer-methods).
       * It takes one argument: a marked renderer object, which is mutated by the
       * function.
       */
      renderer: { type: Function },
      /**
       * Sanitize the output. Ignore any HTML that has been input.
       */
      sanitize: { type: Boolean },
      /**
       * Function used to customize a sanitize behavior.
       * It takes one argument: element String without text Contents.
       *
       * e.g. `<div>` `<a href="/">` `</p>'.
       * Note: To enable this function, must set `sanitize` to true.
       * WARNING: If you are using this option to untrusted text, you must to
       * prevent XSS Attacks.
       */
      sanitizer: { type: Function },
      /**
       * If true, disables the default sanitization of any markdown received by
       * a request and allows fetched unsanitized markdown
       *
       * e.g. fetching markdown via `src` that has HTML.
       * Note: this value overrides `sanitize` if a request is made.
       */
      disableRemoteSanitization: { type: Boolean },
      /**
       * Use "smart" typographic punctuation for things like quotes and dashes.
       */
      smartypants: { type: Boolean }
    };
  }

  get markdown() {
    return this._markdown;
  }

  set markdown(value) {
    if (this._setObservableProperty('markdown', value)) {
      this.renderMarkdown();
    }
  }

  get breaks() {
    return this._breaks;
  }

  set breaks(value) {
    if (this._setObservableProperty('breaks', value)) {
      this.renderMarkdown();
    }
  }

  get pedantic() {
    return this._pedantic;
  }

  set pedantic(value) {
    if (this._setObservableProperty('pedantic', value)) {
      this.renderMarkdown();
    }
  }

  get renderer() {
    return this._renderer;
  }

  set renderer(value) {
    if (this._setObservableProperty('renderer', value)) {
      this.renderMarkdown();
    }
  }

  get sanitize() {
    return this._sanitize;
  }

  set sanitize(value) {
    if (this._setObservableProperty('sanitize', value)) {
      this.renderMarkdown();
    }
  }

  get sanitizer() {
    return this._sanitizer;
  }

  set sanitizer(value) {
    if (this._setObservableProperty('sanitizer', value)) {
      this.renderMarkdown();
    }
  }

  get smartypants() {
    return this._smartypants;
  }

  set smartypants(value) {
    if (this._setObservableProperty('smartypants', value)) {
      this.renderMarkdown();
    }
  }

  _setObservableProperty(prop, value) {
    const key = `_${prop}`;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }

  constructor() {
    super();
    this.breaks = false;
    this.pedantic = false;
    this.sanitize = false;
    this.disableRemoteSanitization = false;
    this.smartypants = false;
  }

  firstUpdated() {
    this._outputElement = this.outputElement;
    if (this.markdown) {
      this.renderMarkdown();
      return;
    }

    // Use the Markdown from the first `<script>` descendant whose MIME type
    // starts with "text/markdown". Script elements beyond the first are
    // ignored.
    this._markdownElement = this.querySelector('[type="text/markdown"]');
    if (!this._markdownElement) {
      return;
    }

    if (this._markdownElement.src) {
      this._request(this._markdownElement.src);
    }

    if (this._markdownElement.textContent.trim() !== '') {
      this.markdown = this._unindent(this._markdownElement.textContent);
    }

    const observer = new MutationObserver(this._onScriptAttributeChanged.bind(this));
    observer.observe(this._markdownElement, { attributes: true });
  }

  connectedCallback() {
    super.connectedCallback();
    this._attached = true;
    this._outputElement = this.outputElement;
    this.renderMarkdown();
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this._attached = false;
  }

  /**
   * Unindents the markdown source that will be rendered.
   *
   * @param {string} text
   * @return {string}
   */
  unindent(text) {
    return this._unindent(text);
  }

  get outputElement() {
    const slot = this.shadowRoot.querySelector('slot');
    if (!slot) {
      return null;
    }
    const child = slot
      .assignedNodes()
      .find((node) => node.nodeType === 1 && node.getAttribute('slot') === 'markdown-html');
    return child || this.shadowRoot.querySelector('#content');
  }

  /**
   * Renders `markdown` into this element's DOM.
   *
   * This is automatically called whenever the `markdown` property is changed.
   *
   * The only case where you should be calling this is if you are providing
   * markdown via `<script type="text/markdown">` after this element has been
   * constructed (or updating that markdown).
   */
  renderMarkdown() {
    if (!this._attached) {
      return;
    }
    if (!this._outputElement) {
      return;
    }

    if (!this.markdown) {
      this._outputElement.innerHTML = '';
      return;
    }
    /* global marked */
    const renderer = new marked.Renderer();

    if (this.renderer) {
      this.renderer(renderer);
    }
    let data;
    if (this.sanitize) {
      if (this.sanitizer) {
        data = this.sanitizer(this.markdown);
      } else {
        data = purify.sanitize(this.markdown);
        if (typeof data !== 'string') {
          data = this.markdown;
        }
      }
      data = SafeHtmlUtils.htmlEscape(data);
    } else {
      data = this.markdown;
    }
    const opts = {
      renderer: renderer,
      highlight: this._highlight.bind(this),
      breaks: this.breaks,
      pedantic: this.pedantic,
      smartypants: this.smartypants
    };
    this._outputElement.innerHTML = marked(data, opts);
    this.dispatchEvent(
      new CustomEvent('marked-render-complete', {
        composed: true
      })
    );
  }

  /**
   * Fired when the content is being processed and before it is rendered.
   * Provides an opportunity to highlight code blocks based on the programming
   * language used. This is also known as syntax highlighting. One example would
   * be to use a prebuilt syntax highlighting library, e.g with
   * [highlightjs](https://highlightjs.org/).
   *
   * @param {string} code
   * @param {string} lang
   * @return {string}
   * @event syntax-highlight
   */
  _highlight(code, lang) {
    const e = new CustomEvent('syntax-highlight', {
      composed: true,
      bubbles: true,
      detail: {
        code,
        lang
      }
    });
    this.dispatchEvent(e);
    return e.detail.code || code;
  }

  /**
   * @param {string} text
   * @return {string}
   */
  _unindent(text) {
    if (!text) {
      return text;
    }
    const lines = text.replace(/\t/g, '  ').split('\n');
    const indent = lines.reduce(function(prev, line) {
      if (/^\s*$/.test(line)) {
        return prev; // Completely ignore blank lines.
      }
      const lineIndent = line.match(/^(\s*)/)[0].length;
      if (prev === null) {
        return lineIndent;
      }
      return lineIndent < prev ? lineIndent : prev;
    }, null);

    return lines.map((l) => l.substr(indent)).join('\n');
  }

  /**
   * Fired when the XHR finishes loading
   *
   * @param {string} url
   * @event marked-loadend
   */
  _request(url) {
    this._xhr = new XMLHttpRequest();
    const xhr = this._xhr;

    if (xhr.readyState > 0) {
      return;
    }

    xhr.addEventListener('error', this._handleError.bind(this));
    xhr.addEventListener(
      'loadend',
      function(e) {
        const status = this._xhr.status || 0;
        // Note: if we are using the file:// protocol, the status code will be 0
        // for all outcomes (successful or otherwise).
        if (status === 0 || (status >= 200 && status < 300)) {
          this.sanitize = !this.disableRemoteSanitization;
          this.markdown = e.target.response;
        } else {
          this._handleError(e);
        }

        this.dispatchEvent(
          new CustomEvent('marked-loadend', {
            composed: true,
            bubbles: true,
            detail: e
          })
        );
      }.bind(this)
    );

    xhr.open('GET', url);
    xhr.setRequestHeader('Accept', 'text/markdown');
    xhr.send();
  }

  /**
   * Fired when an error is received while fetching remote markdown content.
   *
   * @param {!Event} e
   * @event marked-request-error
   */
  _handleError(e) {
    const evt = new CustomEvent('marked-request-error', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: e
    });
    this.dispatchEvent(evt);
    if (!evt.defaultPrevented) {
      this.markdown = 'Failed loading markdown source';
    }
  }

  /**
   * @param {!Array<!MutationRecord>} mutation
   */
  _onScriptAttributeChanged(mutation) {
    if (mutation[0].attributeName !== 'src') {
      return;
    }

    this._request(this._markdownElement.src);
  }

  render() {
    return html`
      <slot name="markdown-html">
        <div id="content"></div>
      </slot>
    `;
  }
}

window.customElements.define('arc-marked', ArcMarked);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * A mixin that contains common function for `property-*-document` elements.
 *
 * @mixinFunction
 * @memberof ArcBehaviors
 * @appliesMixin AmfHelperMixin
 * @param {Class} base
 * @return {Class}
 */
const PropertyDocumentMixin = (base) => class extends AmfHelperMixin(base) {
  static get properties() {
    return {
      /**
       * A property shape definition of AMF.
       *
       * @type {Object}
       */
      shape: { type: Object },
      /**
       * Computes value of shape's http://raml.org/vocabularies/shapes#range
       * @type {Object}
       */
      range: { type: Object },
      /**
       * Type's current media type.
       * This is used to select/generate examples according to current body
       * media type. When not set it only renders examples that were defined
       * in API specfile in a form as they were written.
       */
      mediaType: { type: String },
      /**
       * When set it removes actions bar from the examples render.
       */
      noExamplesActions: { type: Boolean },

      _hasMediaType: { type: Boolean },

      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * When enabled it renders external types as links and dispatches
       * `api-navigation-selection-changed` when clicked.
       */
      graph: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get mediaType() {
    return this._mediaType;
  }

  set mediaType(value) {
    if (this._setObservableProperty('mediaType', value)) {
      this._hasMediaType = this._computeHasMediaType(value);
    }
  }

  get graph() {
    return this._graph;
  }

  set graph(value) {
    if (this._setObservableProperty('graph', value)) {
      this._evaluateGraph();
    }
  }

  constructor() {
    super();
    this._hasMediaType = false;
  }

  _setObservableProperty(prop, value) {
    const key = '_' + prop;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    if (this.requestUpdate) {
      this.requestUpdate(prop, old);
    }
    return true;
  }
  /**
   * Computes type from a `http://raml.org/vocabularies/shapes#range` object
   *
   * @param {Object} range AMF property range object
   * @return {String} Data type of the property.
   */
  _computeRangeDataType(range) {
    if (!range) {
      return;
    }
    const rs = this.ns.raml.vocabularies.shapes;
    if (this._hasType(range, rs + 'ScalarShape')) {
      const sc = this.ns.w3.xmlSchema;
      const key = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
      const data = this._ensureArray(range[key]);
      const id = (data && data[0]) ? data[0]['@id'] : '';
      switch (id) {
        case this._getAmfKey(sc + 'string'):
        case sc + 'string':
          return 'String';
        case this._getAmfKey(sc + 'integer'):
        case sc + 'integer':
          return 'Integer';
        case this._getAmfKey(sc + 'long'):
        case sc + 'long':
          return 'Long';
        case this._getAmfKey(sc + 'float'):
        case sc + 'float':
          return 'Float';
        case this._getAmfKey(sc + 'double'):
        case sc + 'double':
          return 'Double';
        case this._getAmfKey(rs + 'number'):
        case rs + 'number':
          return 'Number';
        case this._getAmfKey(sc + 'boolean'):
        case sc + 'boolean':
          return 'Boolean';
        case this._getAmfKey(sc + 'dateTime'):
        case sc + 'dateTime':
          return 'DateTime';
        case this._getAmfKey(rs + 'dateTimeOnly'):
        case rs + 'dateTimeOnly':
          return 'Time';
        case this._getAmfKey(sc + 'time'):
        case sc + 'time':
          return 'Time';
        case this._getAmfKey(sc + 'date'):
        case sc + 'date':
          return 'Date';
        case this._getAmfKey(sc + 'base64Binary'):
        case sc + 'base64Binary':
          return 'Base64 binary';
        case this._getAmfKey(rs + 'password'):
        case rs + 'password':
          return 'Password';
      }
    }
    if (this._hasType(range, rs + 'UnionShape')) {
      return 'Union';
    }
    if (this._hasType(range, rs + 'ArrayShape')) {
      return 'Array';
    }
    if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      return 'Object';
    }
    if (this._hasType(range, rs + 'FileShape')) {
      return 'File';
    }
    if (this._hasType(range, rs + 'NilShape')) {
      return 'Null';
    }
    if (this._hasType(range, rs + 'AnyShape')) {
      return 'Any';
    }
    if (this._hasType(range, rs + 'MatrixShape')) {
      return 'Matrix';
    }
    if (this._hasType(range, rs + 'TupleShape')) {
      return 'Tuple';
    }
    if (this._hasType(range, rs + 'UnionShape')) {
      return 'Union';
    }
    if (this._hasType(range, rs + 'RecursiveShape')) {
      return 'Recursive';
    }
    return 'Unknown type';
  }
  /**
   * Computes value for `range` property.
   * @param {Object} shape Current shape object.
   * @return {Object} Range object
   */
  _computeRange(shape) {
    if (!shape) {
      return;
    }
    let data;
    if (this._hasType(shape, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      data = shape;
    } else if (this._hasType(shape, this.ns.raml.vocabularies.http + 'Parameter')) {
      const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
      data = this._ensureArray(shape[key]);
      data = (data && data.length) ? data[0] : undefined;
    } else {
      const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
      data = this._ensureArray(shape[key]);
      data = (data && data.length) ? data[0] : undefined;
    }
    return data;
  }
  /**
   * Computes properties to render Array items documentation.
   *
   * @param {Object} range Range object of current shape.
   * @return {Array<Object>|undefined} List of Array items.
   */
  _computeArrayProperties(range) {
    if (!range) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    let item = range[key];
    if (!item) {
      return;
    }
    if (item instanceof Array) {
      item = item[0];
    }
    item = this._resolve(item);
    if (!item) {
      return;
    }
    switch (true) {
      case this._hasType(item, this.ns.raml.vocabularies.shapes + 'ScalarShape'):
        item.isShape = true;
        return this._ensureArray(item);
      case this._hasType(item, this.ns.raml.vocabularies.shapes + 'UnionShape'):
      case this._hasType(item, this.ns.raml.vocabularies.shapes + 'ArrayShape'):
        item.isType = true;
        return [item];
      default:
        {
          const pkey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
          const items = this._ensureArray(item[pkey]);
          if (items) {
            items.forEach((item) => item.isShape = true);
          }
          return items;
        }
    }
  }
  /**
   * Computes value for `isUnion` property.
   * Union type is identified as a `http://raml.org/vocabularies/shapes#UnionShape`
   * type.
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsUnion(range) {
    return this._hasType(range, this.ns.raml.vocabularies.shapes + 'UnionShape');
  }
  /**
   * Computes value for `isObject` property.
   * Object type is identified as a `http://raml.org/vocabularies/shapes#NodeShape`
   * type.
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsObject(range) {
    return this._hasType(range, this.ns.w3.shacl.name + 'NodeShape');
  }
  /**
   * Computes value for `isArray` property.
   * Array type is identified as a `http://raml.org/vocabularies/shapes#ArrayShape`
   * type.
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsArray(range) {
    return this._hasType(range, this.ns.raml.vocabularies.shapes + 'ArrayShape');
  }
  /**
   * Computes list of union type labels to render.
   *
   * @param {Boolean} isUnion
   * @param {Object} range
   * @return {Array<Object>}
   */
  _computeUnionTypes(isUnion, range) {
    if (!isUnion || !range) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const list = this._ensureArray(range[key]);
    if (!list) {
      return;
    }
    return list.map((item) => {
      if (item instanceof Array) {
        item = item[0];
      }
      item = this._resolve(item);
      let isScalar = this._hasType(item, this.ns.raml.vocabularies.shapes + 'ScalarShape');
      const isNil = this._hasType(item, this.ns.raml.vocabularies.shapes + 'NilShape');
      if (!isScalar && isNil) {
        isScalar = true;
      }
      const isArray = this._hasType(item, this.ns.raml.vocabularies.shapes + 'ArrayShape');
      const isType = !isScalar && !isArray;
      let label;
      if (isArray) {
        label = this._getValue(item, this.ns.w3.shacl.name + 'name');
        if (!label) {
          const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
          label = this._computeArrayUnionLabel(item[key]);
        }
      } else if (isNil) {
        label = 'Null';
      } else {
        label = this._getValue(item, this.ns.schema.schemaName);
        if (!label) {
          label = this._getValue(item, this.ns.w3.shacl.name + 'name');
        }
        if (!label && this._hasType(item, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
          label = this._computeRangeDataType(item);
        }
      }
      if (!label) {
        label = 'Unnamed type';
      }
      return {
        isScalar,
        isArray,
        isType,
        label
      };
    });
  }
  /**
   * Computes union type label when the union is in Array.
   *
   * @param {Array|Object} items Array's items property or a single property
   * @return {String|undefined} Label for the union type.
   */
  _computeArrayUnionLabel(items) {
    if (!items) {
      return;
    }
    if (items instanceof Array) {
      items = items[0];
    }
    items = this._resolve(items);
    if (this._hasType(items, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      return this._computeRangeDataType(items);
    }
    return this._computeDisplayName(items, items);
  }

  /**
   * Computes name label for the shape.
   *
   * @param {Object} range Range object of current shape.
   * @param {Object} shape The shape of the property.
   * @return {String} Display name of the property
   */
  _computeDisplayName(range, shape) {
    if (!shape || !range) {
      return;
    }
    // let name;
    if (this._hasType(shape, this.ns.raml.vocabularies.http + 'Parameter')) {
      return this._getValue(range, this.ns.schema.schemaName);
      // if(!name) {
      //   name =  this._getValue(shape, this.ns.raml.vocabularies.http + 'paramName');
      // }
    } else if (this._hasType(range, this.ns.w3.shacl.name + 'NodeShape')) {
      return this._getValue(shape, this.ns.w3.shacl.name + 'name');
    } else {
      return this._getValue(range, this.ns.schema.schemaName);
      // if (!name) {
      //   name = this._getValue(range, this.ns.w3.shacl.name + 'name');
      // }
    }
    // if (!name) {
    //   // File and Union types does not have "name" on range object.
    //   name = this._getValue(shape, this.ns.w3.shacl.name + 'name');
    // }
    // if (name && name[name.length - 1] === '?') {
    //   name = name.substr(0, name.length - 1);
    // }
    // return name;
  }

  _computeHasMediaType(mediaType) {
    return !!mediaType;
  }

  _evaluateGraph() {}
};

/**
 * `property-range-document`
 *
 * Renders a documentation for a shape property of AMF model.
 *
 * ## Styling
 *
 * `<property-range-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--property-range-document` | Mixin applied to this elment | `{}`
 * `--api-type-document-type-attribute-color` | Color of each attribute that describes a property | `#616161`
 * `--api-type-document-examples-title-color` | Color of examples section title | ``
 * `--api-type-document-examples-border-color` | Example section border color | `transparent`
 * `--code-background-color` | Background color of the examples section | ``
 * `--arc-font-body1` | Mixin applied to an example name label | `{}`
 * `--arc-font-body2` | Mixin applied to the examples section title | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin PropertyDocumentMixin
 */
class PropertyRangeDocument extends PropertyDocumentMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
    }

    [hidden] {
      display: none !important;
    }

    .property-attribute {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      margin: 4px 0;
      padding: 0;
      color: var(--api-type-document-type-attribute-color, #616161);
    }

    .property-attribute:last-of-type {
      margin-bottom: 12px;
    }

    .attribute-label {
      font-weight: 500;
      margin-right: 12px;
    }

    .attribute-value {
      flex: 1;
      flex-basis: 0.000000001px;
    }

    .attribute-value ul {
      margin: 0;
      padding-left: 18px;
    }

    .examples {
      border: 1px var(--api-type-document-examples-border-color, transparent) solid;
      background-color: var(--code-background-color);
    }

    api-annotation-document {
      margin-bottom: 12px;
    }

    .examples-section-title {
      font-size: var(--arc-font-body2-font-size);
      font-weight: var(--arc-font-body2-font-weight);
      line-height: var(--arc-font-body2-line-height);
      padding: 8px;
      margin: 0;
      color: var(--api-type-document-examples-title-color);
    }

    .example-title {
      font-weight: var(--arc-font-body1-font-weight);
      line-height: var(--arc-font-body1-line-height);
      font-size: 15px;
      margin: 0;
      padding: 0 8px;
    }`;
  }

  static get properties() {
    return {
      /**
       * Name of the property that is being described by this definition.
       */
      propertyName: { type: String },
      /**
       * Computed value form the shape. True if the property is ENUM.
       */
      isEnum: { type: Boolean, reflect: true },
      /**
       * Computed value, true if current property is an union.
       */
      isUnion: { type: Boolean, reflect: true },
      /**
       * Computed value, true if current property is an object.
       */
      isObject: { type: Boolean, reflect: true },
      /**
       * Computed value, true if current property is an array.
       */
      isArray: { type: Boolean, reflect: true },
      /**
       * Computed value, true if current property is a File.
       */
      isFile: { type: Boolean },
      /**
       * Computed values for list of enums.
       * Enums are list of types names.
       *
       * @type {Array<String>}
       */
      enumValues: { type: Array },
      /**
       * When set it removes actions bar from the examples render.
       */
      noExamplesActions: { type: Boolean },
      _hasExamples: { type: Boolean },
      exampleSectionTitle: { type: String }
    };
  }

  get range() {
    return this._range;
  }

  set range(value) {
    if (this._setObservableProperty('range', value)) {
      this._rangeChanged(value);
    }
  }

  _rangeChanged(range) {
    this._hasExamples = false;
    const isEnum = this.isEnum = this._computeIsEnum(range);
    this.isUnion = this._computeIsUnion(range);
    this.isObject = this._computeIsObject(range);
    this.isArray = this._computeIsArray(range);
    this.isFile = this._computeIsFile(range);
    this.enumValues = isEnum ? this._computeEnumValues(range) : false;
  }
  /**
   * Computes value `isEnum` property.
   * @param {Object} range Current `range` object.
   * @return {Boolean} Curently it always returns `false`
   */
  _computeIsEnum(range) {
    const key = this._getAmfKey(this.ns.w3.shacl.name + 'in');
    return !!(range && (key in range));
  }
  /**
   * Computes value for `isUnion` property.
   * Union type is identified as a `http://raml.org/vocabularies/shapes#UnionShape`
   * type.
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsUnion(range) {
    return this._hasType(range, this.ns.raml.vocabularies.shapes + 'UnionShape');
  }
  /**
   * Computes value for `isObject` property.
   * Object type is identified as a `http://raml.org/vocabularies/shapes#NodeShape`
   * type.
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsObject(range) {
    return this._hasType(range, this.ns.w3.shacl.name + 'NodeShape');
  }

  /**
   * Computes value for `isArray` property.
   * Array type is identified as a `http://raml.org/vocabularies/shapes#ArrayShape`
   * type.
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsArray(range) {
    return this._hasType(range, this.ns.raml.vocabularies.shapes + 'ArrayShape');
  }
  /**
   * Computes value for `isFile` property
   *
   * @param {Object} range Range object of current shape.
   * @return {Boolean}
   */
  _computeIsFile(range) {
    return this._hasType(range, this.ns.raml.vocabularies.shapes + 'FileShape');
  }

  _computeObjectProperties(range) {
    if (!range) {
      return;
    }
    const pkey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    return range[pkey];
  }
  /**
   * Computes value for `enumValues` property.
   *
   * @param {Object} range Range object of current shape.
   * @return {Array<String>|undefined} List of enum types.
   */
  _computeEnumValues(range) {
    if (!range) {
      return;
    }
    const ikey = this._getAmfKey(this.ns.w3.shacl.name + 'in');
    let model = range[ikey];
    if (!model) {
      return;
    }
    model = this._ensureArray(model);
    if (model instanceof Array) {
      model = model[0];
    }
    const results = [];
    Object.keys(model).forEach((key) => {
      const amfKey = this._getAmfKey('http://www.w3.org/2000/01/rdf-schema#');
      if (key.indexOf(amfKey) !== 0) {
        return;
      }
      let value = model[key];
      if (value instanceof Array) {
        value = value[0];
      }
      let result = this._getValue(value, this.ns.raml.vocabularies.data + 'value');
      if (result) {
        if (result['@value']) {
          result = result['@value'];
        }
        results.push(result);
      }
    });
    return results;
  }

  _examplesChanged(e) {
    const { value } = e.detail;
    this.exampleSectionTitle = value && value.length === 1 ? 'Example' : 'Examples';
  }

  _hasExamplesHandler(e) {
    this._hasExamples = e.detail.value;
  }

  _listItemTemplate(label, title, key, isArray) {
    let value = isArray ? this._getValueArray(this.range, key) : this._getValue(this.range, key);
    if (isArray && value instanceof Array) {
      value = value.join(', ');
    }
    return html`<div class="property-attribute" part="property-attribute">
      <span class="attribute-label" part="attribute-label">${label}:</span>
      <span class="attribute-value" part="attribute-value" title="${title}">${value}</span>
    </div>`;
  }

  _nonFilePropertisTemplate() {
    const range = this.range;
    return html`
    ${this._hasProperty(range, this.ns.w3.shacl.minLength) ?
      this._listItemTemplate('Minimum characters', 'Minimum number of characters in the value', this.ns.w3.shacl.minLength) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.maxLength) ?
      this._listItemTemplate('Maximum characters', 'Maximum number of characters in the value', this.ns.w3.shacl.maxLength) :
      undefined}`;
  }

  _filePropertisTemplate() {
    const range = this.range;
    return html`
    <section class="file-properties">
    ${this._hasProperty(range, this.ns.w3.shacl.fileType) ?
      this._listItemTemplate('File types', 'File mime types accepted by the endpoint', this.ns.w3.shacl.fileType, true) :
      undefined}
    ${this._hasProperty(range, this.ns.aml.vocabularies.shapes + 'fileType') ?
      this._listItemTemplate('File types', 'File mime types accepted by the endpoint',
        this.ns.aml.vocabularies.shapes + 'fileType', true) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.minLength) ?
      this._listItemTemplate('File minimum size', 'Minimum size of the file accepted by this endpoint',
        this.ns.w3.shacl.minLength) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.maxLength) ?
      this._listItemTemplate('File maximum size', 'Maximum size of the file accepted by this endpoint',
        this.ns.w3.shacl.maxLength) :
      undefined}
    </section>`;
  }

  _enumTemplate() {
    const items = this.enumValues;
    if (!items || !items.length) {
      return;
    }
    return html`<div class="property-attribute enum-values" part="property-attribute">
      <span class="attribute-label" part="attribute-label">Enum values:</span>
      <span class="attribute-value" part="attribute-value" title="List of possible values to use with this property">
        <ul>
        ${items.map((item) => html`<li>${item}</li>`)}
        </ul>
      </span>
    </div>`;
  }

  render() {
    const range = this.range;
    return html`
    ${this._hasProperty(range, this.ns.w3.shacl.defaultValueStr) ?
      this._listItemTemplate('Default value', 'This value is used as a default value', this.ns.w3.shacl.defaultValueStr) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.pattern) ?
      this._listItemTemplate('Pattern', 'Regular expression value for this property', this.ns.w3.shacl.pattern) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.minInclusive) ?
      this._listItemTemplate('Min value', 'Minimum numeric value possible to set on this property',
        this.ns.w3.shacl.minInclusive) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.maxInclusive) ?
      this._listItemTemplate('Max value', 'Maximum numeric value possible to set on this property',
        this.ns.w3.shacl.maxInclusive) :
      undefined}
    ${this._hasProperty(range, this.ns.w3.shacl.multipleOf) ?
      this._listItemTemplate('Multiple of', 'The numeric value has to be multiplicable by this value',
        this.ns.w3.shacl.multipleOf) :
      undefined}
    ${this.isFile ? this._filePropertisTemplate() : this._nonFilePropertisTemplate()}
    ${this.isEnum ? this._enumTemplate() : undefined}

    <api-annotation-document ?compatibility="${this.compatibility}" .amf="${this.amf}" .shape="${this.range}"></api-annotation-document>
    <section class="examples" ?hidden="${!this._hasExamples}">
      <api-resource-example-document
        .amf="${this.amf}"
        .examples="${range}"
        .mediaType="${this.mediaType}"
        .typeName="${this.propertyName}"
        noauto
        ?compatibility="${this.compatibility}"
        ?noactions="${this.noExamplesActions}"
        ?rawonly="${!this._hasMediaType}"
        ?graph="${this.graph}"
        @rendered-examples-changed="${this._examplesChanged}"
        @has-examples-changed="${this._hasExamplesHandler}"></api-resource-example-document>
    </section>`;
  }
}
window.customElements.define('property-range-document', PropertyRangeDocument);

/**
 * `property-shape-document`
 *
 * Renders a documentation for a shape property of AMF model.
 *
 * ## Styling
 *
 * `<property-shape-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--property-shape-document` | Mixin applied to this elment | `{}`
 * `--property-shape-document-array-color` | Property border color when type is an array | `#8BC34A`
 * `--property-shape-document-object-color` | Property border color when type is an object | `#FF9800`
 * `--property-shape-document-union-color` | Property border color when type is an union | `#FFEB3B`
 * `--arc-font-subhead` | Theme mixin, applied to the property title | `{}`
 * `--property-shape-document-title` | Mixin applied to the property title | `{}`
 * `--api-type-document-property-parent-color` | Color of the parent property label | `#757575`
 * `--api-type-document-property-color` | Color of the property name label when display name is used | `#757575`
 * `--api-type-document-child-docs-margin-left` | Margin left of item's description | `0px`
 * `--api-type-document-type-color` | Color of the "type" trait | `white`
 * `--api-type-document-type-background-color` | Background color of the "type" trait | `#1473bf`
 * `--api-type-document-trait-background-color` | Background color to main range trait (type name) | `#EEEEEE`,
 * `--api-type-document-trait-border-radius` | Border radious of a main property traits | `3px`
 * `--api-type-document-property-name-width` | Width of the left hand side column with property name | `240px`
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin PropertyDocumentMixin
 */
class PropertyShapeDocument extends PropertyDocumentMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      css`:host {
        display: block;
        border-bottom-width: 1px;
        border-bottom-color: var(--property-shape-document-border-bottom-color, #CFD8DC);
        border-bottom-style: var(--property-shape-document-border-bottom-style, dashed);
        padding: var(--property-shape-document-padding);
      }

      :host(:last-of-type) {
        border-bottom: none;
      }

      [hidden] {
        display: none !important;
      }

      .property-title {
        font-size: var(--property-shape-document-title-font-size, var(--arc-font-subhead-font-size));
        font-weight: var(--property-shape-document-title-font-weight, var(--arc-font-subhead-font-weight));
        line-height: var(--property-shape-document-title-line-height, var(--arc-font-subhead-line-height));

        margin: 4px 0 4px 0;
        font-size: 1rem;
        font-weight: var(--api-type-document-property-title-font-weight, 500);
        word-break: break-word;
        color: var(--api-type-document-property-title-color);
      }

      .property-title[secondary] {
        font-weight: var(--api-type-document-property-title-secondary-font-weight, 400);
        color: var(--api-type-document-property-title-secondary-color, #616161);
      }

      .parent-label {
        color: var(--api-type-document-property-parent-color, #757575);
      }

      .property-display-name {
        font-weight: var(--api-type-document-property-name-font-weight, 500);
        color: var(--api-type-document-property-name-color, var(--api-type-document-property-color, #212121));
        margin: 4px 0 4px 0;
        font-size: var(--api-type-document-property-name-font-size, 16px);
      }

      .doc-wrapper {
        transition: background-color 0.4s linear;
      }
      .doc-wrapper.with-description {
        margin-top: 20px;
      }

      :host([isobject]) .doc-wrapper.complex,
      :host([isunion]) .doc-wrapper.complex,
      :host([isarray]) .doc-wrapper.complex {
        padding-left: var(--api-type-document-child-docs-padding-left, 20px);
        margin-left: var(--api-type-document-child-docs-margin-left, 0px);
        margin-top: 12px;
        padding-right: var(--api-type-document-child-docs-padding-right, initial);
      }

      :host([isobject]) .doc-wrapper {
        border-left-color: var(--property-shape-document-object-color, #FF9800);
        border-left-width: 2px;
        border-left-style: solid;
        padding-left: 12px;
      }

      :host([isarray]) .doc-wrapper {
        border-left: 2px var(--property-shape-document-array-color, #8BC34A) solid;
        padding-left: 12px;
      }

      :host([isunion]) .doc-wrapper {
        border-left: 2px var(--property-shape-document-union-color, #FFEB3B) solid;
        padding-left: 12px;
      }

      .property-traits {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }

      .property-traits > span {
        display: inline-block;
        margin-right: 8px;
        padding: var(--api-type-document-trait-padding, 2px 4px);
        background-color: var(--api-type-document-trait-background-color, #EEEEEE);
        color: var(--api-type-document-trait-color, #616161);
        border-radius: var(--api-type-document-trait-border-radius, 3px);
        font-size: var(--api-type-document-trait-font-size, 13px);
      }

      .property-traits > span.data-type {
        background-color: var(--api-type-document-type-background-color, #1473bf);
        color: var(--api-type-document-type-color, white);
        padding: var(--api-type-document-trait-data-type-padding, 2px 4px);
        font-weight: var(--api-type-document-trait-data-type-font-weight, normal);
      }

      :host([narrow]) .property-description {
        margin: 20px 0;
      }

      .content-wrapper,
      .shape-docs {
        margin-top: 12px;
      }

      /* .content-wrapper {
        display: flex;
        flex-direction: row;
      } */

      .shape-properties {
        min-width: var(--api-type-document-property-name-width, 120px);
      }

      .shape-docs {
        flex: 1;
        flex-basis: 0.000000001px;
        word-break: break-word;
        overflow: hidden;
      }

      .shape-docs .doc-wrapper {
        border-left: none !important;
        padding-left: 0 !important;
      }

      /* :host([narrow]) .content-wrapper {
        display: block;
        -ms-flex-direction: initial;
        -webkit-flex-direction: initial;
        flex-direction: initial;
      } */

      :host([narrow]) .shape-docs {
        -ms-flex: initial;
        -webkit-flex: initial;
        flex: initial;
        -webkit-flex-basis: initial;
        flex-basis: initial;
      }

      :host([narrow]) .shape-properties {
        min-width: 100%;
      }

      :host([narrow]) .shape-properties > * {
        display: inline-block;
        vertical-align: middle;
        margin-right: 8px;
      }

      arc-marked {
        background-color: transparent;
        padding: 0;
      }

      .link-label {
        text-decoration: underline;
        cursor: pointer;
      }`
    ];
  }

  static get properties() {
    return {
      /**
       * Computed value of shape's http://raml.org/vocabularies/shapes#range
       * @type {Object}
       */
      range: { type: Object },
      /**
       * Computed value of "display name" of the property
       */
      displayName: { type: String },
      /**
       * A type property name.
       * This may be different from `displayName` property if
       * `displayName` was specified in the API spec for this property.
       */
      propertyName: { type: String },
      /**
       * Computed value, true if `displayName` has been defined for this
       * property.
       */
      hasDisplayName: { type: Boolean },
      /**
       * Computed value, true if current property is an union.
       */
      isUnion: {
        type: Boolean,
        reflect: true
      },
      /**
       * Computed value, true if current property is an object.
       */
      isObject: {
        type: Boolean,
        reflect: true
      },
      /**
       * Computed value, true if current property is an array.
       */
      isArray: {
        type: Boolean,
        reflect: true
      },
      /**
       * Computed value, true if this propery contains a complex
       * structure. It is computed when the property is and array,
       * object, or union.
       */
      isComplex: { type: Boolean },
      /**
       * Should be set if described properties has a parent type.
       * This is used when recursively iterating over properties.
       */
      parentTypeName: { type: String },
      /**
       * Computed value, true if `parentTypeName` has a value.
       */
      hasParentTypeName: { type: Boolean },
      /**
       * Computed value of shape data type
       * @type {Object}
       */
      propertyDataType: { type: String },
      /**
       * Computed value form the shape. True if the property is required.
       */
      isRequired: { type: Boolean },
      /**
       * Computed value form the shape. True if the property is ENUM.
       */
      isEnum: { type: Boolean },
      /**
       * A description of the property to render.
       */
      propertyDescription: { type: String },
      /**
       * Computed value, true if desceription is set.
       */
      hasPropertyDescription: { type: Boolean },
      /**
       * A property to set when the component is rendered in the narrow
       * view. To be used with mobile rendering or when the
       * components occupies only small part of the screen.
       */
      narrow: {
        type: Boolean,
        reflect: true
      },
      /**
       * When set it removes actions bar from the examples render.
       */
      noExamplesActions: { type: Boolean },

      _targetTypeId: { type: String },
      _targetTypeName: { type: String }
    };
  }

  get shape() {
    return this._shape;
  }

  set shape(value) {
    if (this._setObservableProperty('shape', value)) {
      this._shapeChanged(value);
      this._shapeRangeChanged(value, this._range);
    }
  }

  get range() {
    return this._range;
  }

  set range(value) {
    if (this._setObservableProperty('range', value)) {
      this._rangeChanged(value);
      this._shapeRangeChanged(this._shape, value);
    }
  }

  get parentTypeName() {
    return this._parentTypeName;
  }

  set parentTypeName(value) {
    if (this._setObservableProperty('parentTypeName', value)) {
      this.hasParentTypeName = !!value;
    }
  }

  constructor() {
    super();
    this.hasDisplayName = false;
    this.hasParentTypeName = false;
    this.hasPropertyDescription = false;
  }

  __amfChanged() {
    this._shapeChanged(this._shape);

    this._evaluateGraph();
  }

  _shapeChanged(shape) {
    if (!this._amf) {
      return;
    }
    this.range = this._computeRange(shape);
    this.isRequired = this._computeIsRequired(shape);
  }

  _rangeChanged(range) {
    this.propertyDescription = this._computeDescription(range);
    this.hasPropertyDescription = this._computeHasStringValue(this.propertyDescription);
    this.isEnum = this._computeIsEnum(range);
    this.isUnion = this._computeIsUnion(range);
    this.isObject = this._computeIsObject(range);
    this.isArray = this._computeIsArray(range);
    this.isComplex = this._computeIsComplex(this.isUnion, this.isObject, this.isArray);

    this._evaluateGraph();
  }

  _shapeRangeChanged(shape, range) {
    this.displayName = this._computeDisplayName(range, shape);
    this.propertyName = this._computePropertyName(range, shape);
    this.hasDisplayName = this._computeHasDisplayName(this.displayName, this.propertyName);
    this.propertyDataType = this._computeObjectDataType(range, shape);
  }

  _computeObjectDataType(range, shape) {
    let type = range && this._computeRangeDataType(this._resolve(range));
    if (!type) {
      type = shape && this._computeRangeDataType(this._resolve(shape));
    }
    return type;
  }
  /**
   * Computes name of the property. This may be different from the
   * `displayName` if `displayName` is set in API spec.
   *
   * @param {Object} range Range object of current shape.
   * @param {Object} shape The shape object
   * @return {String} Display name of the property
   */
  _computePropertyName(range, shape) {
    if (!shape && !range) {
      return;
    }
    if (shape) {
      shape = this._resolve(shape);
      if (this._hasType(shape, this.ns.raml.vocabularies.http + 'Parameter')) {
        return this._getValue(shape, this.ns.schema.schemaName);
      }
      if (this._hasType(shape, this.ns.w3.shacl.name + 'PropertyShape') ||
        this._hasType(shape, this.ns.raml.vocabularies.shapes + 'NilShape') ||
        this._hasType(shape, this.ns.raml.vocabularies.shapes + 'AnyShape')) {
        return this._getValue(shape, this.ns.w3.shacl.name + 'name');
      }
    }
    if (range) {
      range = this._resolve(range);
      const name = this._getValue(range, this.ns.w3.shacl.name + 'name');
      if (name === 'items' &&
      this._hasType(shape, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
        return;
      }
      return name;
    }
  }
  /**
   * Computes value for `hasDisplayName` property.
   * Indicates that `displayName` has been defined in the API specification.
   *
   * @param {String} displayName
   * @param {String} propertyName
   * @return {Boolean}
   */
  _computeHasDisplayName(displayName, propertyName) {
    return !!(displayName) && displayName !== propertyName;
  }
  /**
   * Computes value for `hasParentTypeName`.
   * @param {String?} parentTypeName
   * @return {Boolean}
   */
  _computeHasParentTypeName(parentTypeName) {
    return !!parentTypeName;
  }
  /**
   * Computes value for `isRequired` property.
   * In AMF model a property is required when `http://www.w3.org/ns/shacl#minCount`
   * does not equal `0`.
   *
   * @param {Object} shape Current shape object
   * @return {Boolean}
   */
  _computeIsRequired(shape) {
    if (!shape) {
      return false;
    }
    shape = this._resolve(shape);
    if (this._hasType(shape, this.ns.raml.vocabularies.http + 'Parameter')) {
      return this._getValue(shape, this.ns.w3.hydra.core + 'required');
    }
    const data = this._getValue(shape, this.ns.w3.shacl.name + 'minCount');
    return data !== undefined && data !== 0;
  }
  /**
   * Computes value `isEnum` property.
   * @param {Object} range Current `range` object.
   * @return {Boolean} Curently it always returns `false`
   */
  _computeIsEnum(range) {
    const ikey = this._getAmfKey(this.ns.w3.shacl.name + 'in');
    return !!(range && (ikey in range));
  }
  /**
   * Computes value for `propertyDescription`.
   * @param {Object} range Range model
   * @return {String} Description to render.
   */
  _computeDescription(range) {
    if (!range) {
      return;
    }
    return this._getValue(range, this.ns.schema.desc);
  }
  /**
   * Computes value for `isComplex` property.
   * @param {Boolean} isUnion
   * @param {Boolean} isObject
   * @param {Boolean} isArray
   * @return {Boolean}
   */
  _computeIsComplex(isUnion, isObject, isArray) {
    return isUnion || isObject || isArray;
  }

  _evaluateGraph() {
    this._targetTypeId = undefined;
    this._targetTypeName = undefined;
    if (!this.graph) {
      return;
    }
    const { amf, range } = this;
    if (!amf || !range) {
      return;
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'sources');
    const maps = this._ensureArray(range[sKey]);
    if (!maps) {
      return;
    }
    const dKey = this._getAmfKey(this.ns.raml.vocabularies.docSourceMaps + 'declared-element');
    const dElm = this._ensureArray(maps[0][dKey]);
    if (!dElm) {
      return;
    }
    const id = this._getValue(dElm[0], this.ns.raml.vocabularies.docSourceMaps + 'element');
    this._targetTypeId = id;
    const type = this._getType(amf, id);
    if (!type) {
      return;
    }

    this._targetTypeName = this._getValue(type, this.ns.w3.shacl.name + 'name');
  }

  _getType(amf, id) {
    const dcs = this._computeDeclares(amf);
    let refs; // this._computeReferences(amf);
    return this._computeType(dcs, refs, id);
  }

  _navigateType() {
    const e = new CustomEvent('api-navigation-selection-changed', {
      bubbles: true,
      composed: true,
      detail: {
        selected: this._targetTypeId,
        type: 'type'
      }
    });
    this.dispatchEvent(e);
  }

  _linkKeydown(e) {
    if (e.key === 'Enter') {
      this._navigateType();
    }
  }

  _complexTemplate() {
    if (!this.isComplex) {
      return;
    }
    const range = this._resolve(this.range);
    const parentTypeName = this.isArray ? 'item' : this.displayName;
    return html`<div class="doc-wrapper complex">
      <div class="doc-content">
      <api-type-document
        class="children"
        .amf="${this.amf}"
        .type="${range}"
        .parentTypeName="${parentTypeName}"
        ?narrow="${this.narrow}"
        ?compatibility="${this.compatibility}"
        ?noexamplesactions="${this.noExamplesActions}"
        nomainexample
        .mediaType="${this.mediaType}"
        ?graph="${this.graph}"></api-type-document>
      </div>
    </div>`;
  }

  _getTypeNameTemplate() {
    const dataType = this.propertyDataType;
    const id = this._targetTypeId;
    if (id) {
      const label = this._targetTypeName;
      return html`
        <span
          class="data-type link-label"
          role="link"
          tabindex="0"
          @click="${this._navigateType}"
          @keydown="${this._linkKeydown}">${label}</span>
        <span class="type-data-type">${dataType}</span>
      `;
    }
    return html`<span class="data-type">${dataType}</span>`;
  }

  render() {
    return html`
    ${this.hasDisplayName ? html`<div class="property-display-name">${this.displayName}</div>` : undefined}
    ${this.propertyName ? html`<div class="property-title" ?secondary="${this.hasDisplayName}">
      <span class="parent-label" ?hidden="${!this.hasParentTypeName}">${this.parentTypeName}.</span>
      <span class="property-name">${this.propertyName}</span>
    </div>` : undefined}

    <div class="content-wrapper">
      <div class="shape-properties">
        <div class="property-traits">
          ${this._getTypeNameTemplate()}
          ${this.isRequired ?
            html`<span class="required-type" title="This property is required by the API">Required</span>` : undefined}
          ${this.isEnum ?
            html`<span class="enum-type" title="This property represent enumerable value">Enum</span>` : undefined}
        </div>
      </div>
      <div class="shape-docs">
      ${this.hasPropertyDescription ? html`<div class="property-description">
          <arc-marked .markdown="${this.propertyDescription}">
            <div slot="markdown-html" class="markdown-body"></div>
          </arc-marked>
        </div>` : undefined}

        <div class="doc-wrapper ${this.hasPropertyDescription ? 'with-description' : ''}">
          <div class="doc-content">
            <property-range-document
              .amf="${this.amf}"
              .shape="${this.shape}"
              .range="${this.range}"
              ?compatibility="${this.compatibility}"
              ?noexamplesactions="${this.noExamplesActions}"
              .mediaType="${this.mediaType}"
              .propertyName="${this.propertyName}"
              ?graph="${this.graph}"></property-range-document>
          </div>
        </div>
      </div>
    </div>

    ${this._complexTemplate()}`;
  }
}
window.customElements.define('property-shape-document', PropertyShapeDocument);

/**
 * `api-type-document`
 *
 * An element that recuresively renders a documentation for a data type
 * using from model.
 *
 * Pass AMF's shape type `property` array to render the documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin PropertyDocumentMixin
 * @appliesMixin AmfHelperMixin
 */
class ApiTypeDocument extends PropertyDocumentMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
      font-size: var(--arc-font-body1-font-size);
      font-weight: var(--arc-font-body1-font-weight);
      line-height: var(--arc-font-body1-line-height);
    }

    property-shape-document {
      padding: 12px 0;
    }

    property-shape-document:last-of-type,
    :last-of-type {
      border-bottom: none;
    }

    .array-children {
      box-sizing: border-box;
      padding-left: 12px;
      border-left: 2px var(--property-shape-document-array-color, #8BC34A) solid;
    }

    :host([hasparenttype]) .array-children {
      padding-left: 0px;
      border-left: none;
    }

    .inheritance-label {
      font-size: var(--api-type-document-inheritance-label-font-size, 16px);
    }

    .media-type-selector {
      margin: 20px 0;
    }

    .media-toggle {
      outline: none;
      color: var(--api-type-document-media-button-color, #000);
      background-color: var(--api-type-document-media-button-background-color, #fff);
      border-width: 1px;
      border-color: var(--api-type-document-media-button-border-color, #a3b11d);
      border-style: solid;
    }

    .media-toggle[activated] {
      background-color: var(--api-type-document-media-button-active-background-color, #CDDC39);
    }

    .union-toggle {
      outline: none;
      background-color: var(--api-type-document-union-button-background-color, #fff);
      color: var(--api-type-document-union-button-color, #000);
      border-width: 1px;
      border-color: var(--api-type-document-media-button-border-color, #a3b11d);
      border-style: solid;
    }

    .union-toggle[activated] {
      background-color: var(--api-type-document-union-button-active-background-color, #CDDC39);
      color: var(--api-type-document-union-button-active-color, #000);
    }

    .union-type-selector {
      margin: 12px 0;
    }`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * A type definition to render.
       * This should be a one of the following AMF types:
       *
       * - `http://www.w3.org/ns/shacl#NodeShape` (Object)
       * - `http://raml.org/vocabularies/shapes#UnionShape` (Union)
       * - `http://raml.org/vocabularies/shapes#ArrayShape` (Array)
       * - `http://raml.org/vocabularies/shapes#ScalarShape` (single property)
       *
       * It also accepts array of properties like list of headers or
       * parameters.
       * @type {Object|Array}
       */
      type: { type: Object },
      /**
       * Media type to use to render examples.
       * If not set a "raw" version of the example from API spec file is used.
       */
      mediaType: { type: String },
      /**
       * A list of supported media types for the type.
       * This is used by `api-resource-example-document` to compute examples.
       * In practive it should be value of raml's `mediaType`.
       *
       * Each item in the array is just a name of thr media type.
       *
       * Example:
       *
       * ```json
       * ["application/json", "application/xml"]
       * ```
       *
       * @type {Array<String>}
       */
      mediaTypes: { type: Array },
      /**
       * Currently selected media type.
       * It is an index of a media type in `mediaTypes` array.
       * It is set to `0` each time the body changes.
       */
      selectedMediaType: { type: Number },
      // The type after it has been resolved.
      _resolvedType: { type: Object },
      /**
       * Should be set if described properties has a parent type.
       * This is used when recursively iterating over properties.
       */
      parentTypeName: { type: String },
      /**
       * Computed value, true if the shape has parent type.
       */
      hasParentType: { type: Boolean },
      /**
       * True if given `type` is a scalar property
       */
      isScalar: { type: Boolean },
      /**
       * True if given `type` is an array property
       */
      isArray: { type: Boolean },
      /**
       * True if given `type` is an object property
       */
      isObject: { type: Boolean },
      /**
       * True if given `type` is an union property
       */
      isUnion: { type: Boolean },
      /**
       * True if given `type` is OAS "and" type.
       */
      isAnd: { type: Boolean },
      /**
       * Computed list of union type types to render in union type
       * selector.
       * Each item has `label` and `isScalar` property.
       *
       * @type {Array<Object>}
       */
      unionTypes: { type: Array },
      /**
       * List of types definition and name for OAS' "and" type
       */
      andTypes: { type: Array },
      /**
       * Selected index of union type in `unionTypes` array.
       */
      selectedUnion: { type: Number },
      /**
       * A property to set when the component is rendered in the narrow
       * view. To be used with mobile rendering or when the
       * components occupies only small part of the screen.
       */
      narrow: { type: Boolean },
      /**
       * When set an example in this `type` object won't be rendered even if set.
       */
      noMainExample: { type: Boolean },
      /**
       * When rendering schema for a payload set this to the payload ID
       * so the examples can be correctly rendered.
       */
      selectedBodyId: { type: String },

      _hasExamples: { type: Boolean },

      _renderMainExample: { type: Boolean }
    };
  }

  get type() {
    return this._type;
  }

  set type(value) {
    if (this._setObservableProperty('type', value)) {
      this._resolvedType = this._resolve(value);
      this.__typeChanged();
    }
  }

  get mediaTypes() {
    return this._mediaTypes;
  }

  set mediaTypes(value) {
    if (this._setObservableProperty('mediaTypes', value)) {
      this._mediaTypesChanged(value);
    }
  }

  get parentTypeName() {
    return this._parentTypeName;
  }

  set parentTypeName(value) {
    if (this._setObservableProperty('parentTypeName', value)) {
      this.hasParentType = !!value;
    }
  }

  get unionTypes() {
    return this._unionTypes;
  }

  set unionTypes(value) {
    if (this._setObservableProperty('unionTypes', value)) {
      this._unionTypesChanged(value);
    }
  }

  get noMainExample() {
    return this._noMainExample;
  }

  set noMainExample(value) {
    if (this._setObservableProperty('noMainExample', value)) {
      this._renderMainExample = this._computeRenderMainExample(value, this._hasExamples);
    }
  }

  get _hasExamples() {
    return this.__hasExamples;
  }

  set _hasExamples(value) {
    if (this._setObservableProperty('_hasExamples', value)) {
      this._renderMainExample = this._computeRenderMainExample(this.noMainExample, value);
    }
  }

  constructor() {
    super();
    this.hasParentType = false;
  }

  _computeRenderMainExample(noMainExample, hasExamples) {
    return !!(!noMainExample && hasExamples);
  }
  /**
   * Called when resolved type or amf changed.
   * Creates a debouncer to compute UI values so it's independent of
   * order of assigning properties.
   */
  __typeChanged() {
    if (this.__typeChangeDebouncer) {
      return;
    }
    this.__typeChangeDebouncer = true;
    setTimeout(() => {
      this.__typeChangeDebouncer = false;
      this._typeChanged(this._resolvedType);
    });
  }

  /**
   * Handles type change. Sets basic view control properties.
   *
   * @param {Array|Object} type Passed type/
   */
  _typeChanged(type) {
    if (!type) {
      return;
    }
    let isScalar = false;
    let isArray = false;
    let isObject = false;
    let isUnion = false;
    let isAnd = false;
    if (type instanceof Array) {
      isObject = true;
    } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'ScalarShape') ||
      this._hasType(type, this.ns.raml.vocabularies.shapes + 'NilShape')) {
      isScalar = true;
    } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      isUnion = true;
      this.unionTypes = this._computeUnionTypes(true, type);
    } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      isArray = true;
    } else if (this._hasType(type, this.ns.w3.shacl.name + 'NodeShape')) {
      isObject = true;
    } else if (this._hasType(type, this.ns.raml.vocabularies.shapes + 'AnyShape')) {
      const key = this._getAmfKey(this.ns.w3.shacl.name + 'and');
      if (key in type) {
        isAnd = true;
        this.andTypes = this._computeAndTypes(type[key]);
      } else {
        isScalar = true;
      }
    }
    this.isScalar = isScalar;
    this.isArray = isArray;
    this.isObject = isObject;
    this.isUnion = isUnion;
    this.isAnd = isAnd;
  }
  /**
   * Computes parent name for the array type table.
   *
   * @param {?String} parent `parentTypeName` if available
   * @return {String} Parent type name of refault value for array type.
   */
  _computeArrayParentName(parent) {
    return parent || '';
  }
  /**
   * Resets union selection when union types list changes.
   *
   * @param {?Array} types List of current union types.
   */
  _unionTypesChanged(types) {
    if (!types) {
      return;
    }
    this.selectedUnion = 0;
  }
  /**
   * Handler for union type button click.
   * Sets `selectedUnion` property.
   *
   * @param {ClickEvent} e
   */
  _selectUnion(e) {
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    if (this.selectedUnion === index) {
      e.target.active = true;
    } else {
      this.selectedUnion = index;
    }
  }
  /**
   * Computes properties for union type.
   *
   * @param {Object} type Current `type` value.
   * @param {Number} selected Selected union index from `unionTypes` array
   * @return {Array<Object>|undefined} Properties for union type.
   */
  _computeUnionProperty(type, selected) {
    if (!type) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const data = type[key];
    if (!data) {
      return;
    }
    let item = data[selected];
    if (!item) {
      return;
    }
    if (item instanceof Array) {
      item = item[0];
    }
    if (this._hasType(item, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      item = this._resolve(item);
      const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
      const items = this._ensureArray(item[key]);
      if (items && items.length === 1) {
        let result = items[0];
        if (result instanceof Array) {
          result = result[0];
        }
        result = this._resolve(result);
        return result;
      }
    }
    if (item instanceof Array) {
      item = item[0];
    }
    return this._resolve(item);
  }
  /**
   * Helper function for the view. Extracts `http://www.w3.org/ns/shacl#property`
   * from the shape model
   *
   * @param {Object} item Range object
   * @return {Array<Object>} Shape object
   */
  _computeProperties(item) {
    if (!item) {
      return;
    }
    if (item instanceof Array) {
      return item;
    }
    const key = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    return this._ensureArray(item[key]);
  }
  /**
   * Computes list values for `andTypes` property.
   * @param {Array<Object>} items List of OAS' "and" properties
   * @return {Array<Object>} An array of type definitions and label to render
   */
  _computeAndTypes(items) {
    if (!items || !items.length) {
      return;
    }
    return items.map((item) => {
      if (item instanceof Array) {
        item = item[0];
      }
      item = this._resolve(item);
      let label = this._getValue(item, this.ns.schema.schemaName);
      if (!label) {
        label = this._getValue(item, this.ns.w3.shacl.name + 'name');
      }
      if (label && label.indexOf('item') === 0) {
        label = undefined;
      }
      return {
        label,
        type: item
      };
    });
  }
  /**
   * Observer for `mediaTypes` property.
   * Controls media type selected depending on the value.
   *
   * @param {?Array<String>} types List of media types that are supported by the API.
   */
  _mediaTypesChanged(types) {
    if (!types || !(types instanceof Array) || !types.length) {
      this.renderMediaSelector = false;
    } else if (types.length === 1) {
      this.renderMediaSelector = false;
      this.mediaType = types[0];
    } else {
      this.renderMediaSelector = true;
      this.mediaType = types[0];
      this.selectedMediaType = 0;
    }
  }

  /**
   * Computes if `selected` equals current item index.
   *
   * @param {Number} selected
   * @param {Number} index
   * @return {Boolean}
   */
  _mediaTypeActive(selected, index) {
    return selected === index;
  }

  /**
   * Handler for media type type button click.
   * Sets `selected` property.
   *
   * @param {ClickEvent} e
   */
  _selectMediaType(e) {
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    if (index !== this.selectedMediaType) {
      this.selectedMediaType = index;
      this.mediaType = this.mediaTypes[index];
    } else {
      e.target.active = true;
    }
  }

  _apiChangedHandler(e) {
    const { value } = e.detail;
    this.amf = value;
  }

  _hasExamplesHandler(e) {
    const { value } = e.detail;
    this._hasExamples = value;
  }

  _objectTemplate() {
    const items = this._computeProperties(this._resolvedType);
    if (!items || !items.length) {
      return;
    }
    return items.map((item) => html`<property-shape-document
      class="object-document"
      .shape="${this._resolve(item)}"
      .amf="${this.amf}"
      .parentTypeName="${this.parentTypeName}"
      ?narrow="${this.narrow}"
      ?noexamplesactions="${this.noExamplesActions}"
      ?compatibility="${this.compatibility}"
      ?graph="${this.graph}"
      .mediaType="${this.mediaType}"></property-shape-document>`);
  }

  _arrayTemplate() {
    const items = this._computeArrayProperties(this._resolvedType) || [];
    return html`
    ${this.hasParentType ? html`<property-shape-document
      class="array-document"
      .amf="${this.amf}"
      .shape="${this._resolvedType}"
      parentTypeName="Array test"
      ?narrow="${this.narrow}"
      ?noexamplesactions="${this.noExamplesActions}"
      ?compatibility="${this.compatibility}"
      .mediaType="${this.mediaType}"
      ?graph="${this.graph}"></property-shape-document>` : undefined}

      <div class="array-children">
      ${items.map((item) => html`
        ${item.isShape ? html`<property-shape-document
          class="array-document"
          .amf="${this.amf}"
          .shape="${item}"
          parentTypeName="${this._computeArrayParentName(this.parentTypeName, item)}"
          ?narrow="${this.narrow}"
          ?noexamplesactions="${this.noExamplesActions}"
          ?compatibility="${this.compatibility}"
          .mediaType="${this.mediaType}"
          ?graph="${this.graph}"></property-shape-document>` : undefined}
        ${item.isType ? html`<api-type-document
          class="union-document"
          .amf="${this.amf}"
          .parentTypeName="${this.parentTypeName}"
          .type="${item}"
          ?narrow="${this.narrow}"
          ?noexamplesactions="${this.noExamplesActions}"
          ?nomainexample="${this._renderMainExample}"
          ?compatibility="${this.compatibility}"
          .mediaType="${this.mediaType}"
          ?graph="${this.graph}"></api-type-document>` : undefined}
      `)}
      </div>
    `;
  }

  _unionTemplate() {
    const items = this.unionTypes || [];
    return html`
    <div class="union-type-selector">
      <span>Any of:</span>
      ${items.map((item, index) => html`<anypoint-button
        class="union-toggle"
        data-index="${index}"
        ?activated="${this.selectedUnion === index}"
        aria-pressed="${this.selectedUnion === index ? 'true' : 'false'}"
        @click="${this._selectUnion}"
        ?compatibility="${this.compatibility}"
        title="Select ${item.label} type">${item.label}</anypoint-button>`)}
    </div>
    <api-type-document
      class="union-document"
      .amf="${this.amf}"
      .parentTypeName="${this.parentTypeName}"
      .type="${this._computeUnionProperty(this._resolvedType, this.selectedUnion)}"
      ?narrow="${this.narrow}"
      ?noexamplesactions="${this.noExamplesActions}"
      ?nomainexample="${this._renderMainExample}"
      ?compatibility="${this.compatibility}"
      .mediaType="${this.mediaType}"
      ?graph="${this.graph}"></api-type-document>
    `;
  }

  _anyTemplate() {
    const items = this.andTypes;
    if (!items || !items.length) {
      return;
    }
    return html`
    ${items.map((item) => html`
      ${item.label ?
        html`<p class="inheritance-label">Properties inherited from <b>${item.label}</b>.</p>` :
        html`<p class="inheritance-label">Properties defined inline.</p>`}
    <api-type-document
      class="and-document"
      .amf="${this.amf}"
      .type="${item.type}"
      ?narrow="${this.narrow}"
      ?noexamplesactions="${this.noExamplesActions}"
      ?nomainexample="${this._renderMainExample}"
      ?compatibility="${this.compatibility}"
      .mediaType="${this.mediaType}"
      ?graph="${this.graph}"></api-type-document>`)}`;
  }

  render() {
    let parts = 'content-action-button, code-content-action-button, content-action-button-disabled, ';
    parts += 'code-content-action-button-disabled content-action-button-active, ';
    parts += 'code-content-action-button-active, code-wrapper, example-code-wrapper, markdown-html';
    const mediaTypes = this.mediaTypes || [];
    return html`
    ${this.aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" scope="${this.aware}"></raml-aware>` : undefined}
    <section class="examples" ?hidden="${!this._renderMainExample}">
      ${this.renderMediaSelector ? html`<div class="media-type-selector">
        <span>Media type:</span>
        ${mediaTypes.map((item, index) => {
          const selected = this.selectedMediaType === index;
          const pressed = selected ? 'true' : 'false';
          return html`<anypoint-button
            part="content-action-button"
            class="media-toggle"
            data-index="${index}"
            ?activated="${selected}"
            aria-pressed="${pressed}"
            @click="${this._selectMediaType}"
            ?compatibility="${this.compatibility}"
            title="Select ${item} media type">${item}</anypoint-button>`;
        })}
      </div>` : undefined}

      <api-resource-example-document
        .amf="${this.amf}"
        .payloadId="${this.selectedBodyId}"
        .examples="${this._resolvedType}"
        .mediaType="${this.mediaType}"
        .typeName="${this.parentTypeName}"
        @has-examples-changed="${this._hasExamplesHandler}"
        ?noauto="${!!this.isScalar}"
        ?noactions="${this.noExamplesActions}"
        ?rawOnly="${!this.mediaType}"
        ?compatibility="${this.compatibility}"
        exportparts="${parts}"></api-resource-example-document>
    </section>

    ${this.isObject ? this._objectTemplate() : undefined}
    ${this.isArray ? this._arrayTemplate() : undefined}
    ${this.isScalar ? html`<property-shape-document
      class="shape-document"
      .amf="${this.amf}"
      .shape="${this._resolvedType}"
      .parentTypeName="${this.parentTypeName}"
      ?narrow="${this.narrow}"
      ?noexamplesactions="${this.noExamplesActions}"
      ?compatibility="${this.compatibility}"
      .mediaType="${this.mediaType}"
      ?graph="${this.graph}"></property-shape-document>` : undefined}
    ${this.isUnion ? this._unionTemplate() : undefined}
    ${this.isAnd ? this._anyTemplate() : undefined}`;
  }
}
window.customElements.define('api-type-document', ApiTypeDocument);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

// Contains all connected resizables that do not have a parent.
var ORPHANS$1 = new Set();

/**
 * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
 * coordinate the flow of resize events between "resizers" (elements that
 *control the size or hidden state of their children) and "resizables" (elements
 *that need to be notified when they are resized or un-hidden by their parents
 *in order to take action on their new measurements).
 *
 * Elements that perform measurement should add the `IronResizableBehavior`
 *behavior to their element definition and listen for the `iron-resize` event on
 *themselves. This event will be fired when they become showing after having
 *been hidden, when they are resized explicitly by another resizable, or when
 *the window has been resized.
 *
 * Note, the `iron-resize` event is non-bubbling.
 *
 * @polymerBehavior
 * @demo demo/index.html
 **/
const IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged',
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false,
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
    this._boundOnDescendantIronResize = this._onDescendantIronResize.bind(this);
  },

  attached: function() {
    this._requestResizeNotifications();
  },

  detached: function() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      ORPHANS$1.delete(this);
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function(resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function(parentResizable) {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    }

    this._parentResizable = parentResizable;

    if (parentResizable &&
        parentResizable._interestedResizables.indexOf(this) === -1) {
      parentResizable._interestedResizables.push(this);
      parentResizable._subscribeIronResize(this);
    }
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this._unsubscribeIronResize(target);
    }
  },

  /**
   * Subscribe this element to listen to iron-resize events on the given target.
   *
   * Preferred over target.listen because the property renamer does not
   * understand to rename when the target is not specifically "this"
   *
   * @param {!HTMLElement} target Element to listen to for iron-resize events.
   */
  _subscribeIronResize: function(target) {
    target.addEventListener('iron-resize', this._boundOnDescendantIronResize);
  },

  /**
   * Unsubscribe this element from listening to to iron-resize events on the
   * given target.
   *
   * Preferred over target.unlisten because the property renamer does not
   * understand to rename when the target is not specifically "this"
   *
   * @param {!HTMLElement} target Element to listen to for iron-resize events.
   */
  _unsubscribeIronResize: function(target) {
    target.removeEventListener(
        'iron-resize', this._boundOnDescendantIronResize);
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function(element) {
    return true;
  },

  _onDescendantIronResize: function(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // no need to use this during shadow dom because of event retargeting
    if (!useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function() {
    this.fire('iron-resize', null, {node: this, bubbles: false});
  },

  _onIronRequestResizeNotifications: function(event) {
    var target = /** @type {!EventTarget} */ (dom(event).rootTarget);
    if (target === this) {
      return;
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },

  _requestResizeNotifications: function() {
    if (!this.isAttached) {
      return;
    }

    if (document.readyState === 'loading') {
      var _requestResizeNotifications =
          this._requestResizeNotifications.bind(this);
      document.addEventListener(
          'readystatechange', function readystatechanged() {
            document.removeEventListener('readystatechange', readystatechanged);
            _requestResizeNotifications();
          });
    } else {
      this._findParent();

      if (!this._parentResizable) {
        // If this resizable is an orphan, tell other orphans to try to find
        // their parent again, in case it's this resizable.
        ORPHANS$1.forEach(function(orphan) {
          if (orphan !== this) {
            orphan._findParent();
          }
        }, this);

        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      } else {
        // If this resizable has a parent, tell other child resizables of
        // that parent to try finding their parent again, in case it's this
        // resizable.
        this._parentResizable._interestedResizables
            .forEach(function(resizable) {
              if (resizable !== this) {
                resizable._findParent();
              }
            }, this);
      }
    }
  },

  _findParent: function() {
    this.assignParentResizable(null);
    this.fire(
        'iron-request-resize-notifications',
        null,
        {node: this, bubbles: true, cancelable: true});

    if (!this._parentResizable) {
      ORPHANS$1.add(this);
    } else {
      ORPHANS$1.delete(this);
    }
  }
};

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
`iron-collapse` creates a collapsible block of content.  By default, the content
will be collapsed.  Use `opened` or `toggle()` to show/hide the content.

    <button on-click="toggle">toggle collapse</button>

    <iron-collapse id="collapse">
      <div>Content goes here...</div>
    </iron-collapse>

    ...

    toggle: function() {
      this.$.collapse.toggle();
    }

`iron-collapse` adjusts the max-height/max-width of the collapsible element to
show/hide the content.  So avoid putting padding/margin/border on the
collapsible directly, and instead put a div inside and style that.

    <style>
      .collapse-content {
        padding: 15px;
        border: 1px solid #dedede;
      }
    </style>

    <iron-collapse>
      <div class="collapse-content">
        <div>Content goes here...</div>
      </div>
    </iron-collapse>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--iron-collapse-transition-duration` | Animation transition duration | `300ms`

@group Iron Elements
@hero hero.svg
@demo demo/index.html
@element iron-collapse
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        display: block;
        transition-duration: var(--iron-collapse-transition-duration, 300ms);
        /* Safari 10 needs this property prefixed to correctly apply the custom property */
        -webkit-transition-duration: var(--iron-collapse-transition-duration, 300ms);
        overflow: visible;
      }

      :host(.iron-collapse-closed) {
        display: none;
      }

      :host(:not(.iron-collapse-opened)) {
        overflow: hidden;
      }
    </style>

    <slot></slot>
`,

  is: 'iron-collapse',
  behaviors: [IronResizableBehavior],

  properties: {

    /**
     * If true, the orientation is horizontal; otherwise is vertical.
     *
     * @attribute horizontal
     */
    horizontal: {type: Boolean, value: false, observer: '_horizontalChanged'},

    /**
     * Set opened to true to show the collapse element and to false to hide it.
     *
     * @attribute opened
     */
    opened:
        {type: Boolean, value: false, notify: true, observer: '_openedChanged'},

    /**
     * When true, the element is transitioning its opened state. When false,
     * the element has finished opening/closing.
     *
     * @attribute transitioning
     */
    transitioning: {type: Boolean, notify: true, readOnly: true},

    /**
     * Set noAnimation to true to disable animations.
     *
     * @attribute noAnimation
     */
    noAnimation: {type: Boolean},

    /**
     * Stores the desired size of the collapse body.
     * @private
     */
    _desiredSize: {type: String, value: ''}
  },

  get dimension() {
    return this.horizontal ? 'width' : 'height';
  },

  /**
   * `maxWidth` or `maxHeight`.
   * @private
   */
  get _dimensionMax() {
    return this.horizontal ? 'maxWidth' : 'maxHeight';
  },

  /**
   * `max-width` or `max-height`.
   * @private
   */
  get _dimensionMaxCss() {
    return this.horizontal ? 'max-width' : 'max-height';
  },

  hostAttributes: {
    role: 'group',
    'aria-hidden': 'true',
  },

  listeners: {transitionend: '_onTransitionEnd'},

  /**
   * Toggle the opened state.
   *
   * @method toggle
   */
  toggle: function() {
    this.opened = !this.opened;
  },

  show: function() {
    this.opened = true;
  },

  hide: function() {
    this.opened = false;
  },

  /**
   * Updates the size of the element.
   * @param {string} size The new value for `maxWidth`/`maxHeight` as css property value, usually `auto` or `0px`.
   * @param {boolean=} animated if `true` updates the size with an animation, otherwise without.
   */
  updateSize: function(size, animated) {
    // Consider 'auto' as '', to take full size.
    size = size === 'auto' ? '' : size;

    var willAnimate = animated && !this.noAnimation && this.isAttached &&
        this._desiredSize !== size;

    this._desiredSize = size;

    this._updateTransition(false);
    // If we can animate, must do some prep work.
    if (willAnimate) {
      // Animation will start at the current size.
      var startSize = this._calcSize();
      // For `auto` we must calculate what is the final size for the animation.
      // After the transition is done, _transitionEnd will set the size back to
      // `auto`.
      if (size === '') {
        this.style[this._dimensionMax] = '';
        size = this._calcSize();
      }
      // Go to startSize without animation.
      this.style[this._dimensionMax] = startSize;
      // Force layout to ensure transition will go. Set scrollTop to itself
      // so that compilers won't remove it.
      this.scrollTop = this.scrollTop;
      // Enable animation.
      this._updateTransition(true);
      // If final size is the same as startSize it will not animate.
      willAnimate = (size !== startSize);
    }
    // Set the final size.
    this.style[this._dimensionMax] = size;
    // If it won't animate, call transitionEnd to set correct classes.
    if (!willAnimate) {
      this._transitionEnd();
    }
  },

  /**
   * enableTransition() is deprecated, but left over so it doesn't break
   * existing code. Please use `noAnimation` property instead.
   *
   * @method enableTransition
   * @deprecated since version 1.0.4
   */
  enableTransition: function(enabled) {
    Base._warn(
        '`enableTransition()` is deprecated, use `noAnimation` instead.');
    this.noAnimation = !enabled;
  },

  _updateTransition: function(enabled) {
    this.style.transitionDuration = (enabled && !this.noAnimation) ? '' : '0s';
  },

  _horizontalChanged: function() {
    this.style.transitionProperty = this._dimensionMaxCss;
    var otherDimension =
        this._dimensionMax === 'maxWidth' ? 'maxHeight' : 'maxWidth';
    this.style[otherDimension] = '';
    this.updateSize(this.opened ? 'auto' : '0px', false);
  },

  _openedChanged: function() {
    this.setAttribute('aria-hidden', !this.opened);

    this._setTransitioning(true);
    this.toggleClass('iron-collapse-closed', false);
    this.toggleClass('iron-collapse-opened', false);
    this.updateSize(this.opened ? 'auto' : '0px', true);

    // Focus the current collapse.
    if (this.opened) {
      this.focus();
    }
  },

  _transitionEnd: function() {
    this.style[this._dimensionMax] = this._desiredSize;
    this.toggleClass('iron-collapse-closed', !this.opened);
    this.toggleClass('iron-collapse-opened', this.opened);
    this._updateTransition(false);
    this.notifyResize();
    this._setTransitioning(false);
  },

  _onTransitionEnd: function(event) {
    if (dom(event).rootTarget === this) {
      this._transitionEnd();
    }
  },

  _calcSize: function() {
    return this.getBoundingClientRect()[this.dimension] + 'px';
  }
});

/**
 * `api-parameters-document`
 *
 * URI and query parameters documentation table based on
 * [AMF](https://github.com/mulesoft/amf) json/ld model.
 *
 * It rquires you to set at least one of the following properties:
 * - baseUriParameters
 * - endpointParameters
 * - queryParameters
 *
 * Otherwise it render empty block element.
 *
 * See demo for example implementation.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 */
class ApiParametersDocument extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
      font-size: var(--arc-font-body1-font-size);
      font-weight: var(--arc-font-body1-font-weight);
      line-height: var(--arc-font-body1-line-height);
    }

    [hidden] {
      display: none !important;
    }

    .section-title-area {
      display: flex;
      flex-direction: row;
      align-items: center;
      cursor: pointer;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      border-bottom: 1px var(--api-parameters-document-title-border-color, #e5e5e5) solid;
    }

    .section-title-area .table-title {
      flex: 1;
      flex-basis: 0.000000001px;
    }

    .toggle-icon {
      outline: none;
      margin-left: 8px;
      transform: rotateZ(0deg);
      transition: transform 0.3s ease-in-out;
    }

    .toggle-icon.opened {
      transform: rotateZ(-180deg);
    }

    .table-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: var(--arc-font-subhead-font-size);
      font-weight: var(--arc-font-subhead-font-weight);
      line-height: var(--arc-font-subhead-line-height);
    }

    :host([narrow]) .table-title {
      font-size: var(--api-parameters-document-title-narrow-font-size, initial);
    }

    .icon {
      display: block;
      width: 24px;
      height: 24px;
      fill: currentColor;
    }`;
  }

  render() {
    const {
      aware,
      pathOpened,
      queryOpened,
      _effectivePathParameters,
      queryParameters,
      amf,
      narrow,
      compatibility,
      headerLevel,
      graph
    } = this;
    const hasPathParameters = !!(_effectivePathParameters && _effectivePathParameters.length);
    const hasQueryParameters = !!(queryParameters && queryParameters.length);
    return html`
    ${aware ?
      html`<raml-aware
        @api-changed="${this._apiChangedHandler}"
        .scope="${aware}"
        data-source="api-parameters-document"></raml-aware>` : undefined}
    ${hasPathParameters ? html`<section class="uri-parameters">
      <div class="section-title-area" @click="${this.toggleUri}" title="Toogle URI parameters details">
        <div class="table-title" role="heading" aria-level="${headerLevel}">URI parameters</div>
        <div class="title-area-actions">
          <anypoint-button class="toggle-button" ?compatibility="${compatibility}">
            ${this._computeToggleActionLabel(pathOpened)}
            <span class="icon ${this._computeToggleIconClass(pathOpened)}">${expandMore}</span>
          </anypoint-button>
        </div>
      </div>
      <iron-collapse .opened="${pathOpened}">
        <api-type-document
          .amf="${amf}"
          .type="${_effectivePathParameters}"
          ?compatibility="${compatibility}"
          ?narrow="${narrow}"
          ?graph="${graph}"></api-type-document>
      </iron-collapse>
    </section>` : undefined}

    ${hasQueryParameters ? html`<section class="query-parameters">
      <div class="section-title-area" @click="${this.toggleQuery}" title="Toogle query parameters details">
        <div class="table-title" role="heading" aria-level="${headerLevel}">Query parameters</div>
        <div class="title-area-actions">
          <anypoint-button class="toggle-button" ?compatibility="${compatibility}">
            ${this._computeToggleActionLabel(queryOpened)}
            <span class="icon ${this._computeToggleIconClass(queryOpened)}">${expandMore}</span>
          </anypoint-button>
        </div>
      </div>
      <iron-collapse .opened="${queryOpened}">
        <api-type-document
          .amf="${amf}"
          .type="${queryParameters}"
          ?compatibility="${compatibility}"
          ?narrow="${narrow}"
          ?graph="${graph}"></api-type-document>
      </iron-collapse>
    </section>`: undefined}`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * Generated AMF json/ld model form the API spec.
       * The element assumes the object of the first array item to be a
       * type of `"http://raml.org/vocabularies/document#Document`
       * on AMF vocabulary.
       *
       * It is only usefult for the element to resolve references.
       *
       * @type {Object|Array}
       */
      amf: { type: Object },
      /**
       * Set to true to open the query parameters view.
       * Autormatically updated when the view is toggled from the UI.
       */
      queryOpened: { type: Boolean },
      /**
       * Set to true to open the path parameters view.
       * Autormatically updated when the view is toggled from the UI.
       */
      pathOpened: { type: Boolean },
      /**
       * The `http://raml.org/vocabularies/http#variable` entry
       * from API's `http://raml.org/vocabularies/http#server` model.
       *
       * @type {Array<Object>}
       */
      baseUriParameters: { type: Array },
      /**
       * Endpoint path parameters as
       * `http://raml.org/vocabularies/http#parameter` property value of the
       * type of `http://raml.org/vocabularies/http#EndPoint`
       * @type {Array<Object>}
       */
      endpointParameters: { type: Array },
      /**
       * Method query parameters as
       * `http://raml.org/vocabularies/http#parameter` property value of the
       * type of `http://raml.org/vocabularies/http#Request`
       * @type {Array<Object>}
       */
      queryParameters: { type: Array },
      /**
       * Set to render a mobile friendly view.
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * Type of the header in the documentation section.
       * Should be in range of 1 to 6.
       *
       * @default 2
       */
      headerLevel: { type: Number },
      /**
       * Passed to `api-type-document`. Enables internal links rendering for types.
       */
      graph: { type: Boolean },

      _effectivePathParameters: { type: Array }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get baseUriParameters() {
    return this._baseUriParameters;
  }

  set baseUriParameters(value) {
    if (this._sop('baseUriParameters', value)) {
      this._effectivePathParameters = this._computeEffectivePath(value, this.endpointParameters);
    }
  }

  get endpointParameters() {
    return this._endpointParameters;
  }

  set endpointParameters(value) {
    if (this._sop('endpointParameters', value)) {
      this._effectivePathParameters = this._computeEffectivePath(this.baseUriParameters, value);
    }
  }

  constructor() {
    super();
    this.headerLevel = 2;
  }

  _sop(prop, value) {
    const key = '_' + prop;
    const oldValue = this[key];
    if (oldValue === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, oldValue);
    return true;
  }
  /**
   * Handler for amf model change from `raml-aware`
   * @param {CustomEvent} e
   */
  _apiChangedHandler(e) {
    const { value } = e.detail;
    setTimeout(() => {
      this.amf = value;
      // For some reson this value is not reflected in the render function
      // unles it is delayed
    });
  }
  /**
   * Computes combined array of base uri parameters and selected endpoint
   * parameters so the element can render single documentation table.
   *
   * @param {?Array} base Base uri parameetrs
   * @param {?Array} endpoint Endpoint's uri parameters
   * @return {Array} Combined array. Can be empty array if arguments does not
   * contain values.
   */
  _computeEffectivePath(base, endpoint) {
    let result = [];
    if (base && base.length) {
      result = result.concat(base);
    }
    if (endpoint && endpoint.length) {
      result = result.concat(endpoint);
    }
    return result;
  }

  // Computes a label for the section toggle buttons.
  _computeToggleActionLabel(opened) {
    return opened ? 'Hide' : 'Show';
  }

  // Computes class for the toggle's button icon.
  _computeToggleIconClass(opened) {
    let clazz = 'toggle-icon';
    if (opened) {
      clazz += ' opened';
    }
    return clazz;
  }
  /**
   * Toggles URI parameters view.
   * Use `pathOpened` property instead.
   */
  toggleUri() {
    this.pathOpened = !this.pathOpened;
  }
  /**
   * Toggles `queryOpened` value.
   */
  toggleQuery() {
    this.queryOpened = !this.queryOpened;
  }
}
window.customElements.define('api-parameters-document', ApiParametersDocument);

/**
 * Port of `@polymer/iron-menubar-behavior`.
 *
 * A mixin that implement accessible menubar.
 *
 * Note, by default the mixin works with LitElement. If used with different class
 * make sure that attributes are reflected to properties correctly.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 * @appliesMixin AnypointMenuMixin
 */
const AnypointMenubarMixin = (base) => class extends AnypointMenuMixin(base) {
  get _isRTL() {
    return window.getComputedStyle(this).direction === 'rtl';
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.getAttribute('role') === 'menu') {
      this.setAttribute('role', 'menubar');
    }
  }

  _onUpKey(e) {
    this.focusedItem.click();
    e.preventDefault();
  }

  _onDownKey(e) {
    this.focusedItem.click();
    e.preventDefault();
  }

  _onLeftKey(e) {
    if (this._isRTL) {
      this._focusNext();
    } else {
      this._focusPrevious();
    }
    e.preventDefault();
  }

  _onRightKey(e) {
    if (this._isRTL) {
      this._focusPrevious();
    } else {
      this._focusNext();
    }
    e.preventDefault();
  }

  _onKeydown(e) {
    if (e.key === 'ArrowLeft') {
      this._onLeftKey(e);
    } else if (e.key === 'ArrowRight') {
      this._onRightKey(e);
    } else {
      super._onKeydown(e);
    }
  }
};

class AnypointTabs extends AnypointMenubarMixin(ArcResizableMixin(LitElement)) {
  static get styles() {
    return css`
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;
        height: 48px;
        font-size: 1rem;
        font-weight: 500;
        overflow: hidden;
        user-select: none;
        /* NOTE: Both values are needed, since some phones require the value to be "transparent". */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;
      }

      :host(:dir(rtl)) {
        flex-direction: row-reverse;
      }

      #tabsContainer {
        position: relative;
        height: 100%;
        white-space: nowrap;
        overflow: hidden;
        flex: 1 1 auto;
      }

      #tabsContent {
        height: 100%;
        flex-basis: auto;
      }

      #tabsContent.scrollable {
        position: absolute;
        white-space: nowrap;
      }

      #tabsContent:not(.scrollable),
      #tabsContent.fit-container {
        display: flex;
        flex-direction: row;
      }

      #tabsContent.fit-container {
        min-width: 100%;
      }

      #tabsContent.fit-container > ::slotted(*) {
        /* IE - prevent tabs from compressing when they should scroll. */
        flex: 1 0 auto;
      }

      .hidden {
        display: none;
      }

      .not-visible {
        opacity: 0;
        cursor: default;
      }

      anypoint-icon-button {
        width: 40px;
        height: 40px;
        /* padding: 12px; */
        margin: 0 4px;
      }

      .icon {
        width: 24px;
        height: 24px;
        display: block;
      }

      #selectionBar {
        position: absolute;
        height: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border-bottom: 2px solid var(--anypoint-tabs-selection-bar-color, var(--accent-color));
        -webkit-transform: scale(0);
        transform: scale(0);
        transform-origin: left center;
        transition: transform 0.15s cubic-bezier(0.4, 0.0, 1, 1);
        z-index: var(--anypoint-tabs-selection-bar-zindex);
      }

      #selectionBar.align-bottom {
        top: 0;
        bottom: auto;
      }

      #selectionBar.expand {
        transition-duration: 0.15s;
        transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
      }

      #selectionBar.contract {
        transition-duration: 0.18s;
        transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
      }

      #tabsContent > ::slotted(*) {
        height: 100%;
      }

      #tabsContent:not(.fit-container) > ::slotted(*) {
        flex: none;
      }

      :host([compatibility]) ::slotted(anypoint-tab) {
        text-transform: none;
      }
    `;
  }

  static get properties() {
    return {
      /**
       * If true, the bottom bar to indicate the selected tab will not be shown.
       */
      noBar: { type: Boolean },
      /**
       * If true, the slide effect for the bottom bar is disabled.
       */
      noSlide: { type: Boolean },
      /**
       * If true, tabs are scrollable and the tab width is based on the label
       * width.
       */
      scrollable: { type: Boolean },
      /**
       * If true, tabs expand to fit their container. This currently only applies
       * when scrollable is true.
       */
      fitContainer: { type: Boolean },
      /**
       * If true, dragging on the tabs to scroll is disabled.
       */
      disableDrag: { type: Boolean },
      /**
       * If true, scroll buttons (left/right arrow) will be hidden for scrollable
       * tabs.
       */
      hideScrollButtons: { type: Boolean },

      /**
       * If true, the tabs are aligned to bottom (the selection bar appears at the
       * top).
       */
      alignBottom: { type: Boolean },

      /**
       * If true, tabs are automatically selected when focused using the
       * keyboard.
       */
      autoselect: { type: Boolean },

      /**
       * The delay (in milliseconds) between when the user stops interacting
       * with the tabs through the keyboard and when the focused item is
       * automatically selected (if `autoselect` is true).
       */
      autoselectDelay: { type: Number },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },

      _leftHidden: { type: Boolean },
      _rightHidden: { type: Boolean }
    };
  }

  get legacy() {
    return this._compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get compatibility() {
    return this._compatibility;
  }

  set compatibility(value) {
    const old = this._compatibility;
    if (old === value) {
      return;
    }
    this._compatibility = value;
    this._compatibilityChanged(value);
    this.requestUpdate('compatibility', old);
  }

  get _contentClass() {
    const { scrollable, fitContainer } = this;
    // return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') :
    //                     ' fit-container';
    let klas = '';
    if (scrollable) {
      klas = 'scrollable';
    }
    if (fitContainer) {
      if (klas) {
        klas += ' ';
      }
      klas += 'fit-container';
    }
    return klas;
  }

  get _selectionClass() {
    const { noBar, alignBottom } = this;
    if (noBar) {
      return 'hidden';
    } else if (alignBottom) {
      return 'align-bottom';
    }
    return '';
  }

  get _leftButtonClass() {
    const { _leftHidden, scrollable, hideScrollButtons } = this;
    return this._computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons);
  }

  get _rightButtonClass() {
    const { _rightHidden, scrollable, hideScrollButtons } = this;
    return this._computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons);
  }

  get _tabsContainer() {
    if (!this.__tabsContainer) {
      this.__tabsContainer = this.shadowRoot.querySelector('#tabsContainer');
    }
    return this.__tabsContainer;
  }

  get _tabsContent() {
    if (!this.__tabsContent) {
      this.__tabsContent = this.shadowRoot.querySelector('#tabsContent');
    }
    return this.__tabsContent;
  }

  get _selectionBar() {
    if (!this.__selectionBar) {
      this.__selectionBar = this.shadowRoot.querySelector('#selectionBar');
    }
    return this.__selectionBar;
  }

  get _tabContainerScrollSize() {
    const node = this._tabsContainer;
    if (!node) {
      return 0;
    }
    return Math.max(0, node.scrollWidth - node.offsetWidth);
  }

  constructor() {
    super();
    this._sizingHandler = this._sizingHandler.bind(this);
    this._itemsHandler = this._itemsHandler.bind(this);
    this._selectHandler = this._selectHandler.bind(this);
    this._deselectHandler = this._deselectHandler.bind(this);
    this._blurHandler = this._blurHandler.bind(this);
    this._touchStart = this._touchStart.bind(this);
    this._touchEnd = this._touchEnd.bind(this);
    this._touchMove = this._touchMove.bind(this);

    this._holdJob = null;
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
    this.selectable = 'anypoint-tab';
    this.autoselectDelay = 0;

    this._step = 10;
    this._holdDelay = 1;
    this._leftHidden = false;
    this._rightHidden = false;

    this._touchstartConfig = {
      handleEvent: this._touchStart,
      passive: true
    };
    this._touchendConfig = {
      handleEvent: this._touchEnd,
      passive: true
    };
    this._touchmoveConfig = {
      handleEvent: this._touchMove,
      passive: true
    };
  }

  connectedCallback() {
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'tablist');
    }
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('resize', this._sizingHandler);
    this.addEventListener('iron-resize', this._sizingHandler);
    this.addEventListener('items-changed', this._itemsHandler);
    this.addEventListener('select', this._selectHandler);
    this.addEventListener('deselect', this._deselectHandler);
    this.addEventListener('blur', this._blurHandler, true);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.__selectionBar = null;
    this.__tabsContainer = null;
    this.removeEventListener('resize', this._sizingHandler);
    this.removeEventListener('iron-resize', this._sizingHandler);
    this.removeEventListener('items-changed', this._itemsHandler);
    this.removeEventListener('select', this._selectHandler);
    this.removeEventListener('deselect', this._deselectHandler);
    this.removeEventListener('blur', this._blurHandler);
    this._cancelPendingActivation();
  }

  _itemsHandler(e) {
    this._sizingHandler();
    if (!this.compatibility) {
      return;
    }
    const items = e.detail.value || [];
    items.forEach((item) => {
      item.noink = true;
    });
  }
  // compatibility

  _sizingHandler() {
    if (this.__resizeDebounce) {
      return;
    }
    this.__resizeDebounce = true;
    setTimeout(() => this._updateResized(), 10);
  }

  _updateResized() {
    this.__resizeDebounce = false;
    this._scroll();
    this._tabChanged(this.selectedItem);
    if (!this._previousTab) {
      this._previousTab = this.selectedItem;
    }
  }

  _selectHandler(e) {
    const { detail } = e;
    this._tabChanged(detail.item, this._previousTab);
    this._previousTab = detail.item;
    if (this._deselectTimer) {
      clearTimeout(this._deselectTimer);
    }
  }

  _deselectHandler() {
    if (this._deselectTimer) {
      return;
    }
    this._deselectTimer = setTimeout(() => this._updateDeselect(), 1);
  }

  _blurHandler(e) {
    if (e.target === this._pendingActivationItem) {
      this._cancelPendingActivation();
    }
  }

  _updateDeselect() {
    this._deselectTimer = null;
    this._tabChanged(null, this._previousTab);
    this._previousTab = null;
  }

  _scroll(dx) {
    if (!this.scrollable || this.disableDrag) {
      return;
    }
    dx = dx || 0;
    this._affectScroll(dx);
  }

  _affectScroll(dx) {
    const node = this._tabsContainer;
    node.scrollLeft += dx;
    const scrollLeft = node.scrollLeft;
    this._leftHidden = scrollLeft === 0;
    this._rightHidden = scrollLeft === this._tabContainerScrollSize;
  }

  _tabChanged(tab, old) {
    // This is a port of a great work of the Polymer team.
    const bar = this._selectionBar;
    if (!bar) {
      return;
    }
    if (!tab) {
      // Remove the bar without animation.
      bar.classList.remove('expand');
      bar.classList.remove('contract');
      this._positionBar(0, 0);
      return;
    }

    const containerRect = this._tabsContent.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const tabRect = tab.getBoundingClientRect();
    const tabOffsetLeft = tabRect.left - containerRect.left;

    this._pos = {
      width: this._calcPercent(tabRect.width, containerWidth),
      left: this._calcPercent(tabOffsetLeft, containerWidth)
    };

    if (this.noSlide || !old) {
      // Position the bar without animation.
      bar.classList.remove('expand');
      bar.classList.remove('contract');
      this._positionBar(this._pos.width, this._pos.left);
      return;
    }

    const oldRect = old.getBoundingClientRect();
    const oldIndex = this.items.indexOf(old);
    const index = this.items.indexOf(tab);
    const m = 5;

    // bar animation: expand
    bar.classList.add('expand');

    let moveRight = oldIndex < index;
    const isRTL = this._isRTL;
    if (isRTL) {
      moveRight = !moveRight;
    }

    if (moveRight) {
      this._positionBar(
          this._calcPercent(tabRect.left + tabRect.width - oldRect.left, containerWidth) - m,
          this._left);
    } else {
      this._positionBar(
          this._calcPercent(oldRect.left + oldRect.width - tabRect.left, containerWidth) - m,
          this._calcPercent(tabOffsetLeft, containerWidth) + m);
    }

    if (this.scrollable) {
      this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
    }
  }

  _positionBar(width, left) {
    width = width || 0;
    left = left || 0;

    this._width = width;
    this._left = left;
    this._selectionBar.style.transform = `translateX(${left}%) scaleX(${width / 100})`;
  }

  _calcPercent(w, w0) {
    return 100 * w / w0;
  }

  _activateHandler(e) {
    this._cancelPendingActivation();
    super._activateHandler(e);
  }

  _onKeydown(e) {
    super._onKeydown(e);
    if (this.autoselect && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
      this._scheduleActivation(this.focusedItem, this.autoselectDelay);
    }
  }

  _scheduleActivation(item, delay) {
    this._pendingActivationItem = item;
    this._pendingActivationTimeout =
        setTimeout(() => this._delayedActivation(), delay);
  }

  _delayedActivation() {
    const item = this._pendingActivationItem;
    this._pendingActivationItem = undefined;
    this._pendingActivationTimeout = undefined;
    item.dispatchEvent(new CustomEvent(this.activateEvent, { bubbles: true, cancelable: true }));
  }

  _cancelPendingActivation() {
    if (this._pendingActivationTimeout !== undefined) {
      this.clearTimeout(this._pendingActivationTimeout);
      this._pendingActivationItem = undefined;
      this._pendingActivationTimeout = undefined;
    }
  }

  _onBarTransitionEnd() {
    const bar = this._selectionBar;
    const cl = bar.classList;
    if (cl.contains('expand')) {
      cl.remove('expand');
      cl.add('contract');
      this._positionBar(this._pos.width, this._pos.left);
      // bar animation done
    } else if (cl.contains('contract')) {
      cl.remove('contract');
    }
  }

  _compatibilityChanged(value) {
    const items = this.items || [];
    items.forEach((item) => {
      item.noink = value;
    });
  }

  _scrollToSelectedIfNeeded(tabWidth, tabOffsetLeft) {
    const node = this._tabsContainer;
    let left = tabOffsetLeft - node.scrollLeft;
    if (left < 0) {
      node.scrollLeft += left;
    } else {
      left += (tabWidth - node.offsetWidth);
      if (left > 0) {
        node.scrollLeft += left;
      }
    }
  }

  _computeScrollButtonClass(isHidden, scrollable, hideScrollButtons) {
    if (!scrollable || hideScrollButtons) {
      return 'hidden';
    }
    if (isHidden) {
      return 'not-visible';
    }
    return '';
  }

  _onScrollButtonUp() {
    clearInterval(this._holdJob);
    this._holdJob = null;
  }

  _onLeftScrollButtonDown() {
    this._scrollToLeft();
    this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
  }

  _onRightScrollButtonDown() {
    this._scrollToRight();
    this._holdJob =
        setInterval(this._scrollToRight.bind(this), this._holdDelay);
  }

  _scrollToLeft() {
    this._affectScroll(-this._step);
  }

  _scrollToRight() {
    this._affectScroll(this._step);
  }

  _touchMove(e) {
    const touches = e.changedTouches;
    const touch = touches && touches[0];
    if (!touch) {
      return;
    }
    const ddx = this.__lastTouchX - touch.clientX;
    this.__lastTouchX = touch.clientX;
    this._scroll(ddx);
  }

  _touchStart(e) {
    const touches = e.touches;
    const touch = touches && touches[0];
    if (!touch) {
      return;
    }
    this.__lastTouchX = touch.clientX;
  }

  _touchEnd() {
    this.__lastTouchX = 0;
  }

  _leftButtonTemplate(scrollable) {
    if (!scrollable) {
      return '';
    }
    return html`<anypoint-icon-button
      aria-label="Activate to move tabs left"
      class="${this._leftButtonClass}"
      @mouseup="${this._onScrollButtonUp}"
      @mousedown="${this._onLeftScrollButtonDown}" tabindex="-1">
      <svg viewBox="0 0 24 24"
        preserveAspectRatio="xMidYMid meet"
        focusable="false" style="pointer-events: none; display: block;"
        class="icon">
        <g><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
      </svg>
    </anypoint-icon-button>`;
  }

  _rightButtonTemplate(scrollable) {
    if (!scrollable) {
      return '';
    }
    return html`<anypoint-icon-button
      aria-label="Activate to move tabs right"
      class="${this._rightButtonClass}"
      @mouseup="${this._onScrollButtonUp}"
      @mousedown="${this._onRightScrollButtonDown}" tabindex="-1">
      <svg viewBox="0 0 24 24"
        preserveAspectRatio="xMidYMid meet"
        focusable="false" style="pointer-events: none; display: block;"
        class="icon">
        <g><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
      </svg>
    </anypoint-icon-button>`;
  }

  _selectionTemplate() {
    return html`<div
      id="selectionBar"
      class="${this._selectionClass}"
      @transitionend="${this._onBarTransitionEnd}"></div>`;
  }

  render() {
    const {
      _contentClass,
      _touchstartConfig,
      _touchmoveConfig,
      _touchendConfig,
      scrollable
    } = this;
    const startEvent = scrollable ? _touchstartConfig : undefined;
    const moveEvent = scrollable ? _touchmoveConfig : undefined;
    const endEvent = scrollable ? _touchendConfig : undefined;
    return html`
      ${this._leftButtonTemplate(scrollable)}
      <div
        id="tabsContainer"
        @touchstart="${startEvent}"
        @touchmove="${moveEvent}"
        @touchend="${endEvent}">
      <div id="tabsContent" class="${_contentClass}">
        ${this._selectionTemplate()}
        <slot></slot>
      </div>
    </div>
    ${this._rightButtonTemplate(scrollable)}
    `;
  }
}

window.customElements.define('anypoint-tabs', AnypointTabs);

class AnypointTab extends AnypointButton {
  static get styles() {
    return [
      AnypointButton.styles,
      css`
      :host {
        overflow: hidden;
        vertical-align: middle;
        margin: 0;
      }

      .tab-content {
        height: 100%;
        transition: opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
      }

      :host(:not(.selected)) > .tab-content {
        opacity: 0.8;
      }

      :host(:focus) .tab-content {
        opacity: 1;
        font-weight: 700;
      }

      :host([link]) {
        padding: 0;
      }

      paper-ripple {
        color: var(--anypoint-tab-ink, var(--accent-color));
      }

      .tab-content > ::slotted(a) {
        flex: 1 1 auto;
        height: 100%;
      }`
    ];
  }

  static get properties() {
    return {
      /**
       * If true, the tab will forward keyboard clicks (enter/space) to
       * the first anchor element found in its descendants
       */
      link: { type: Boolean, reflect: true }
    };
  }

  constructor() {
    super();
    this._clickHandler = this._clickHandler.bind(this);
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'tab');
    }
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('click', this._clickHandler);
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('click', this._clickHandler);
  }

  _clickHandler(e) {
    if (this.link) {
      const slot = this.shadowRoot.querySelector('slot');
      const nodes = slot.assignedNodes();
      let target;
      for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].localName === 'a') {
          target = nodes[i];
          break;
        }
      }
      if (!target) {
        return;
      }
      // Don't get stuck in a loop delegating
      // the listener from the child anchor
      if (e.target === target) {
        return;
      }
      target.click();
    }
  }

  render() {
    const { noink, legacy } = this;
    const stopRipple = !!noink || !!legacy;
    return html`
      <div class="tab-content">
        <slot></slot>
      </div>
      <paper-ripple .noink="${stopRipple}"></paper-ripple>`;
  }
}

window.customElements.define('anypoint-tab', AnypointTab);

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

const template$1 = html$1`
<dom-module id="prism-theme-default">
  <template>
    <style>
    /**
    * prism.js default theme for JavaScript, CSS and HTML
    * Based on dabblet (http://dabblet.com)
    * @author Lea Verou
    */
    code[class*="language-"],
    pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
    }

    pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
    code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background: #b3d4fc;
    }

    pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
    code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
    }

    @media print {
    code[class*="language-"],
    pre[class*="language-"] {
      text-shadow: none;
    }
    }

    /* Code blocks */
    pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
    }

    :not(pre) > code[class*="language-"],
    pre[class*="language-"] {
    background: #f5f2f0;
    }

    /* Inline code */
    :not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
    }

    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
    color: slategray;
    }

    .token.punctuation {
    color: #999;
    }

    .namespace {
    opacity: .7;
    }

    .token.property,
    .token.tag,
    .token.boolean,
    .token.number,
    .token.constant,
    .token.symbol,
    .token.deleted {
    color: #905;
    }

    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin,
    .token.inserted {
    color: #690;
    }

    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string {
    color: #a67f59;
    background: hsla(0, 0%, 100%, .5);
    }

    .token.atrule,
    .token.attr-value,
    .token.keyword {
    color: #07a;
    }

    .token.function {
    color: #DD4A68;
    }

    .token.regex,
    .token.important,
    .token.variable {
    color: #e90;
    }

    .token.important,
    .token.bold {
    font-weight: bold;
    }
    .token.italic {
    font-style: italic;
    }

    .token.entity {
    cursor: help;
    }
    </style>
  </template>
</dom-module>`;

document.head.appendChild(template$1.content);

class ApiSchemaRender extends LitElement {
  /**
   * This is rather dirty hack to import Polymer's `prism-theme-default`.
   * The theme inserts `dom-module` with styles to the head section upon import.
   * This method reads the content of the theme and creates CSSResult instance
   * of it.
   * @return {CSSResult}
   */
  static getPrismTheme() {
    const theme = document.head.querySelector('dom-module#prism-theme-default');
    if (!theme) {
      return;
    }
    const tpl = theme.querySelector('template');
    if (!tpl) {
      return;
    }
    const clone = tpl.content.cloneNode(true);
    const style = clone.querySelector('style');
    return unsafeCSS(style.innerText);
  }

  static get styles() {
    const styles = css`:host {
      display: block;
      background-color: var(--code-background-color, #f5f2f0);
    }

    #output {
      white-space: pre-wrap;
      font-family: var(--arc-font-code-family, initial);
    }`;
    const prism = ApiSchemaRender.getPrismTheme();
    const result = [styles];
    if (prism) {
      result[result.length] = prism;
    }
    return result;
  }

  render() {
    return html`<code id="output" part="markdown-html" class="markdown-html"></code>`;
  }

  static get properties() {
    return {
      /**
       * Data to render.
       */
      code: { type: String },

      type: { type: String }
    };
  }

  get code() {
    return this._code;
  }

  set code(value) {
    const old = this._code;
    this._code = value;
    this.requestUpdate('code', old);
    this._codeChanged(value);
  }

  get type() {
    return this.__type;
  }

  get _type() {
    return this.__type;
  }

  set _type(value) {
    const old = this.__type;
    this.__type = value;
    this.requestUpdate('type', old);
    this._typeChanged(value);
  }

  get output() {
    return this.shadowRoot.querySelector('#output');
  }

  firstUpdated() {
    if (this.code) {
      this._codeChanged(this.code);
    }
    if (this.type) {
      this._typeChanged(this.type);
    }
  }
  /**
   * Handles highlighting when code changed.
   * Note that the operation is async.
   * @param {String} code
   */
  _codeChanged(code) {
    const output = this.output;
    if (!output) {
      return;
    }
    if (!code) {
      output.innerHTML = '';
      return;
    }
    let isJson;
    try {
      JSON.parse(code);
      isJson = true;
    } catch (_) {
      isJson = false;
    }
    this._type = isJson ? 'json' : 'xml';
    setTimeout(() => {
      this.output.innerHTML = this.highlight(code);
    });
  }
  /**
   * Dispatches `syntax-highlight` custom event
   * @param {String} code Code to highlight
   * @return {String} Highlighted code.
   */
  highlight(code) {
    const ev = new CustomEvent('syntax-highlight', {
      bubbles: true,
      composed: true,
      detail: {
        code,
        lang: this.type || 'xml'
      }
    });
    this.dispatchEvent(ev);
    return ev.detail.code;
  }

  _clearTypeAttribute() {
    const output = this.output;
    const type = output.dataset.type;
    if (!type) {
      return;
    }
    const attr = 'language-' + type;
    output.removeAttribute(attr);
  }

  _typeChanged(type) {
    const output = this.output;
    if (!output) {
      return;
    }
    this._clearTypeAttribute();
    if (!type) {
      return;
    }
    const attr = 'language-' + type;
    output.setAttribute(attr, 'true');
    output.dataset.type = type;
  }
}
window.customElements.define('api-schema-render', ApiSchemaRender);

/**
 * `api-schema-document`
 *
 * A component to render XML schema with examples.
 *
 * Note, if AMF contains unresolved properties (reference-id without resolving
 * the value) this element will resolve it. `amf` must be set on this
 * element to resolve the references.
 *
 * ## Styling
 *
 * `<api-schema-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-schema-document` | Mixin applied to this elment | `{}`
 * `api-schema-render` | Mixin applied to schema renderer element | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiSchemaDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
    }`;
  }

  render() {
    return html`<prism-highlighter></prism-highlighter>
    ${this.aware ?
      html`<raml-aware @api-changed="${this._apiChanged}" .scope="${this.aware}"></raml-aware>` : undefined}

    ${this._schemaOnly ? this._schemaOnlyTemplate() : undefined}
    ${this._exampleOnly ? this._exampleOnlyTemplate() : undefined}
    ${this._schemaAndExample ? this._schemaAndExampleTemplate() : undefined}`;
  }

  _exampleOnlyTemplate() {
    const items = this._examples;
    if (!items || !items.length) {
      return;
    }
    return items.map((item) => html`<api-schema-render
      .code="${this._computeExampleValue(item)}"></api-schema-render>`);
  }

  _schemaAndExampleTemplate() {
    return html`
    <anypoint-tabs
      class="schemas"
      .selected="${this.selectedPage}"
      ?compatibility="${this.compatibility}"
      @selected-changed="${this._selectedPageChanged}">
      <anypoint-tab>Schema</anypoint-tab>
      <anypoint-tab>Examples</anypoint-tab>
    </anypoint-tabs>
    ${this._renderSelectedPage()}`;
  }

  _renderSelectedPage() {
    switch (this.selectedPage) {
      case 0: return this._schemaOnlyTemplate();
      case 1: return this._exampleOnlyTemplate();
      default: return '';
    }
  }

  _schemaOnlyTemplate() {
    return html`<api-schema-render .code="${this._raw}"></api-schema-render>`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: String,
      /**
       * AMF's shape object object.
       * Values for sheba and examples are computed from this model.
       */
      shape: Object,
      /**
       * Computed `http://www.w3.org/ns/shacl#raw`
       */
      _raw: String,
      /**
       * Computed list of examples
       */
      _examples: Array,

      /**
       * Computed value, true when data contains example only
       */
      _exampleOnly: { type: Boolean },
      /**
       * Computed value, true when data contains xml schema only
       */
      _schemaOnly: { type: Boolean },
      /**
       * Computed value, true when data contains example and schema information
       */
      _schemaAndExample: { type: Boolean },
      /**
       * Currently selected tab.
       * Relevant when the example contains both example and schema.
       */
      selectedPage: { type: Number },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean }
    };
  }

  get shape() {
    return this._shape;
  }

  set shape(value) {
    const old = this._shape;
    this._shape = value;
    this.requestUpdate('shape', old);
    this._schemaChanged(value);
  }

  constructor() {
    super();
    this.selectedPage = 0;
  }

  _apiChanged(e) {
    this.amf = e.detail.value;
  }

  _selectedPageChanged(e) {
    this.selectedPage = e.detail.value;
  }
  /**
   * Comnputes besic properties for the view.
   * @param {Object} schema `shape` value
   */
  _schemaChanged(schema) {
    this._examples = undefined;
    this._raw = undefined;
    let exampleOnly = false;
    let schemaOnly = false;
    let schemaAndExample = false;
    let raw;
    let examples;

    if (schema) {
      schema = this._resolve(schema);
      if (this._hasType(schema, this.ns.w3.shacl.name + 'SchemaShape') ||
        this._hasType(schema, this.ns.raml.vocabularies.shapes + 'AnyShape') ||
        this._hasType(schema, this.ns.raml.vocabularies.shapes + 'ScalarShape') ||
        this._hasType(schema, this.ns.w3.shacl.name + 'NodeShape')) {
        raw = this._getValue(schema, this.ns.raml.vocabularies.document + 'raw');
        if (!raw) {
          raw = this._getValue(schema, this.ns.w3.shacl.name + 'raw');
        }
        const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
        const exs = this._ensureArray(schema[key]);
        examples = this._processExamples(exs);
      }
    }
    exampleOnly = !!(examples && examples.length && !raw);
    schemaOnly = !!(!examples && raw);
    schemaAndExample = !!(raw && examples && examples.length);
    this._exampleOnly = exampleOnly;
    this._schemaOnly = schemaOnly;
    this._schemaAndExample = schemaAndExample;
    this._examples = examples;
    this._raw = raw;
  }

  _processExamples(examples) {
    if (!examples || !examples.length) {
      return;
    }
    return examples.map((item) => this._resolve(item));
  }

  _computeExampleValue(item) {
    item = this._resolve(item);
    let raw = this._getValue(item, this.ns.raml.vocabularies.document + 'raw');
    if (!raw) {
      raw = this._getValue(item, this.ns.w3.shacl.name + 'raw');
    }
    return raw;
  }
}
window.customElements.define('api-schema-document', ApiSchemaDocument);

/**
 * `api-body-document`
 *
 * A component to render HTTP method body documentation based on AMF model.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiBodyDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      css`:host {
        display: block;
        font-size: var(--arc-font-body1-font-size);
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
      }

      [hidden] {
        display: none !important;
      }

      .section-title-area {
        display: flex;
        flex-direction: row;
        align-items: center;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        border-bottom: 1px var(--api-body-document-title-border-color, #e5e5e5) solid;
      }

      .section-title-area .table-title {
        flex: 1;
        flex-basis: 0.000000001px;
        font-size: var(--api-body-document-title-narrow-font-size, initial);
      }

      .toggle-button {
        outline: none;
      }

      .toggle-icon {
        margin-left: 8px;
        transform: rotateZ(0deg);
        transition: transform 0.3s ease-in-out;
      }

      .toggle-icon.opened {
        transform: rotateZ(-180deg);
      }

      .table-title {
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
      }

      :host([narrow]) .table-title {
        font-size: var(--api-body-document-title-narrow-font-size, initial);
      }

      .type-title {
        font-size: var(--arc-font-body2-font-size);
        font-weight: var(--arc-font-body2-font-weight);
        line-height: var(--arc-font-body2-line-height);
      }

      .body-name {
        font-weight: var(--api-body-document-any-info-font-weight, 500);
        font-size: 1.1rem;
      }

      anypoint-button[active] {
        background-color: var(--api-body-document-media-button-background-color, #CDDC39);
      }

      .media-type-selector {
        margin: 20px 0;
      }

      .markdown-html {
        margin-bottom: 28px;
        margin-top: 28px;
        color: var(--api-body-document-description-color, rgba(0, 0, 0, 0.74));
      }

      .markdown-html[data-with-title] {
        margin-top: 0;
      }

      .examples {
        margin-top: 12px;
        border: 1px var(--api-body-document-examples-border-color, transparent) solid;
      }

      .examples,
      api-schema-document {
        background-color: var(--code-background-color);
      }

      .examples-section-title {
        font-size: 16px;
        padding: 16px 12px;
        margin: 0;
        color: var(--api-body-document-examples-title-color);
      }

      api-resource-example-document,
      api-schema-document {
        padding: 8px;
        color: var(--api-body-document-code-color, initial);
        word-break: break-all;
      }

      .media-type-label {
        font-weight: var(--api-body-document-media-type-label-font-weight, 500);
        margin-left: 8px;
      }

      .media-toggle {
        outline: none;
        color: var(--api-body-document-toggle-view-color, var(--arc-toggle-view-icon-color, rgba(0, 0, 0, 0.74)));
      }

      .any-info,
      .any-info-description {
        color: var(--api-body-document-description-color, rgba(0, 0, 0, 0.74));
      }

      .any-info {
        font-size: var(--api-body-document-any-info-font-size, 16px);
      }

      arc-marked {
        background-color: transparent;
        padding: 0px;
      }

      .icon {
        display: block;
        width: 24px;
        height: 24px;
        fill: currentColor;
      }`
    ];
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * Set to true to open the body view.
       * Autormatically updated when the view is toggled from the UI.
       */
      opened: { type: Boolean },
      /**
       * AMF model for body as a `http://raml.org/vocabularies/http#payload`
       * type.
       * @type {Array<Object>}
       */
      body: { type: Array },
      /**
       * List of discovered media types in the `body`.
       * @type {Array<Object>}
       */
      _mediaTypes: { type: Array },
      /**
       * Computed value. True when mediaTypes has more than one item.
       */
      _renderMediaSelector: { type: Boolean },
      /**
       * Currently selected media type.
       * It is an index of a media type in `mediaTypes` array.
       * It is set to `0` each time the body changes.
       */
      selected: { type: Number },
      /**
       * A body model for selected media type.
       * Computed automatically when selection change.
       */
      _selectedBody: { type: Object },
      /**
       * Selected body ID.
       * It is computed here and passed to the type document to render
       * examples.
       */
      _selectedBodyId: { type: String },
      /**
       * Computed AMF schema object for the body.
       */
      _selectedSchema: { type: Object },
      /**
       * Name of the selected media type.
       */
      _selectedMediaType: { type: String },
      /**
       * True if selected body is a structured object
       */
      _isObject: { type: Boolean },
      /**
       * True if selected body is a schema (JSON, XML, ...) data
       */
      _isSchema: { type: Boolean },
      /**
       * Computed value, true if the body is of "any" type.
       */
      _isAnyType: { type: Boolean },
      /**
       * Name of the resource type if any.
       */
      _typeName: { type: String },
      /**
       * Computed value, true if `typeName` is set.
       */
      _hasTypeName: { type: Boolean },
      /**
       * Body name, if defined
       */
      _bodyName: { type: String },
      /**
       * Name of the resource type if any.
       */
      _description: { type: String },
      /**
       * Set to render a mobile friendly view.
       */
       narrow: {
         type: Boolean,
         reflect: true
       },
       /**
        * Enables compatibility with Anypoint components.
        */
       compatibility: { type: Boolean },
       /**
        * Type of the header in the documentation section.
        * Should be in range of 1 to 6.
        *
        * @default 2
        */
       headerLevel: { type: Number },
       /**
        * When enabled it renders external types as links and dispatches
        * `api-navigation-selection-changed` when clicked.
        */
       graph: { type: Boolean },
       _hasObjectExamples: { type: Boolean },
       _hasAnyExamples: { type: Boolean }
    };
  }
  get _mediaTypes() {
    return this.__mediaTypes;
  }
  set _mediaTypes(value) {
    if (this._sop('_mediaTypes', value)) {
      this._renderMediaSelector = this._computeRenderMediaSelector(value);
    }
  }
  get _selectedBody() {
    return this.__selectedBody;
  }
  set _selectedBody(value) {
    if (this._sop('_selectedBody', value)) {
      this._selectedBodyChanged(value);
    }
  }
  get _selectedSchema() {
    return this.__selectedSchema;
  }
  set _selectedSchema(value) {
    if (this._sop('_selectedSchema', value)) {
      this._selectedSchemaChanged(value);
    }
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    if (this._sop('selected', value)) {
      this._selectedBody = this._computeSelectedBody(value, this.body);
      this._selectedMediaType = this._computeSelectedMediaName(value, this.body);
    }
  }

  get body() {
    return this._body;
  }

  set body(value) {
    if (this._sop('body', value)) {
      this._selectedBody = this._computeSelectedBody(this.selected, value);
      this._selectedMediaType = this._computeSelectedMediaName(this.selected, value);
      this._bodyChanged();
    }
  }

  get amf() {
    return this._amf;
  }

  set amf(value) {
    if (this._sop('amf', value)) {
      this._bodyChanged();
    }
  }
  /**
   * Sets observable property that causes render action.
   * @param {String} prop Property name
   * @param {any} value Value to set
   * @return {Boolean} True when the property has been updated.
   */
  _sop(prop, value) {
    const key = '_' + prop;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }

  constructor() {
    super();
    this._renderMediaSelector = false;
    this._hasObjectExamples = false;
    this._hasAnyExamples = false;
    this.headerLevel = 2;
  }

  _bodyChanged() {
    if (this.__bodyChangedDebounce) {
      return;
    }
    this.__bodyChangedDebounce = true;
    setTimeout(() => {
      this.__bodyChangedDebounce = false;
      this.__bodyChanged(this.body);
    });
  }

  /**
   * Computes basic view values when body change.
   *
   * @param {Object} body
   */
  __bodyChanged(body) {
    if (!body) {
      return;
    }
    this.selected = -1;
    const media = this._computeMediaTypes(body);
    this._mediaTypes = media;
    this.selected = 0;
  }

  _selectedBodyChanged(value) {
    this._selectedBodyId = value && value['@id'];
    this._selectedSchema = this._computeSelectedSchema(value);
    this._hasObjectExamples = false;
    this._hasAnyExamples = false;
  }
  /**
   * Computes list of media types in the `body`
   * @param {Array} body Current value of the body.
   * @return {Array<Object>}
   */
  _computeMediaTypes(body) {
    const result = [];
    body.forEach((item) => {
      const label = this._getValue(item, this.ns.raml.vocabularies.http + 'mediaType');
      if (label) {
        result.push({
          label
        });
      }
    });
    return result.length ? result : undefined;
  }
  /**
   * Computes value for `renderMediaSelector` properety.
   * @param {Object} types `mediaTypes` change record.
   * @return {Boolean}
   */
  _computeRenderMediaSelector(types) {
    return !!(types && types.length && types.length > 1);
  }
  /**
   * Computes if `selected` equals current item index.
   *
   * @param {Number} selected
   * @param {Number} index
   * @return {Boolean}
   */
  _mediaTypeActive(selected, index) {
    return selected === index;
  }
  /**
   * Handler for media type type button click.
   * Sets `selected` property.
   *
   * @param {ClickEvent} e
   */
  _selectMediaType(e) {
    const { target } = e;
    const index = Number(target.dataset.index);
    if (index !== index) {
      return;
    }
    if (index !== this.selected) {
      this.selected = index;
    }
    setTimeout(() => {
      target.active = true;
    });
  }
  /**
   * Computes value of `http://raml.org/vocabularies/http#schema` for body.
   * @param {Number} selected Index of currently selected media type in
   * `mediaTypes` array
   * @param {Array<Object>} body List of body in request.
   * @return {Object|undefined}
   */
  _computeSelectedBody(selected, body) {
    if (!body || (!selected && selected !== 0)) {
      return;
    }
    return body[selected];
  }

  _computeSelectedSchema(selectedBody) {
    if (!selectedBody) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = selectedBody[key];
    if (!schema) {
      return;
    }
    if (schema instanceof Array) {
      schema = schema[0];
    }
    return this._resolve(schema);
  }
  /**
   * Computes value for `selectedMediaType` property.
   * @param {Number} selected Currently selected media type index in the selector.
   * @param {Array<Object>} body List of bodies.
   * @return {String} Content type value.
   */
  _computeSelectedMediaName(selected, body) {
    if (!body || (!selected && selected !== 0)) {
      return;
    }
    const data = body[selected];
    return this._getValue(data, this.ns.raml.vocabularies.http + 'mediaType');
  }
  /**
   * Handler for body value change. Computes basic view control properties.
   * @param {Object} body Currently computed body.
   */
  _selectedSchemaChanged(body) {
    this._typeName = this._computeTypeName(body);
    this._bodyName = this._getValue(body, this.ns.schema.schemaName);
    this._description = this._computeDescription(body);
    let isObject = false;
    let isSchema = false;
    let isAnyType = false;
    let isAnd = false;
    if (this._hasType(body, this.ns.w3.shacl.name + 'NodeShape') ||
      this._hasType(body, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      isObject = true;
    } else if (this._hasType(body, this.ns.w3.shacl.name + 'SchemaShape') ||
      this._hasType(body, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      isSchema = true;
    } else if (this._hasType(body, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      isObject = true;
    } else if (this._hasType(body, this.ns.raml.vocabularies.shapes + 'AnyShape')) {
      const key = this._getAmfKey(this.ns.w3.shacl.name + 'and');
      if (key in body) {
        isAnd = true;
      } else {
        isAnyType = true;
      }
    }
    this._isObject = isObject || isAnd;
    this._isSchema = isSchema;
    this._isAnyType = isAnyType;
  }
  // Computes a label for the section toggle buttons.
  _computeToggleActionLabel(opened) {
    return opened ? 'Hide' : 'Show';
  }
  // Computes class for the toggle's button icon.
  _computeToggleIconClass(opened) {
    let clazz = 'toggle-icon';
    if (opened) {
      clazz += ' opened';
    }
    return clazz;
  }
  /**
   * Toggles URI parameters view.
   * Use `pathOpened` property instead.
   */
  toggle() {
    this.opened = !this.opened;
  }
  /**
   * Computes `typeName` as a name of body in the AMF model.
   *
   * @param {Object} body Currently selected body.
   * @return {String|undefined}
   */
  _computeTypeName(body) {
    let value = this._getValue(body, this.ns.w3.shacl.name + 'name');
    if (value && (value === 'schema' || value.indexOf('amf_inline_type') === 0)) {
      value = undefined;
    }
    return value;
  }

  _apiChangedHandler(e) {
    const { value } = e.detail;
    this.amf = value;
  }

  _hasExamplesHandler(e) {
    const { value } = e.detail;
    this._hasAnyExamples = value;
  }
  /**
   * A template to render for "Any" AMF model.
   * @return {TemplateResult}
   */
  _anyTypeTemplate() {
    const {
      compatibility,
      _bodyName,
      _description,
      _typeName,
      _hasAnyExamples,
      _selectedBody,
      _selectedMediaType,
      _selectedBodyId
    } = this;
    const hasBodyName = !!_bodyName;
    const hasDescription = !!_description;
    const hasTypeName = !!_typeName;

    return html`
    ${hasBodyName ? html`<div class="body-name type-title">${_bodyName}</div>` : undefined}
    ${hasDescription ? html`<arc-marked .markdown="${_description}">
      <div slot="markdown-html" class="markdown-html" part="markdown-html" ?data-with-title="${hasTypeName}"></div>
    </arc-marked>` : undefined}
    <p class="any-info">Any instance of data is allowed.</p>
    <p class="any-info-description">
      The API file specifies body for this request but it does not specify the data model.
    </p>
    <section class="examples" ?hidden="${!_hasAnyExamples}">
      <div class="examples-section-title">Examples</div>
      <api-resource-example-document
        .amf="${this.amf}"
        .examples="${_selectedBody}"
        .mediaType="${_selectedMediaType}"
        .typeName="${_typeName}"
        .payloadId="${_selectedBodyId}"
        ?compatibility="${compatibility}"
        @has-examples-changed="${this._hasExamplesHandler}"></api-resource-example-document>
    </section>`;
  }
  /**
   * A template to render for any AMF model\ that is different than "any".
   * @return {TemplateResult}
   */
  _typedTemplate() {
    const {
      compatibility,
      graph,
      _bodyName,
      _description,
      _typeName,
      _selectedSchema,
      _selectedMediaType,
      _selectedBodyId,
      _renderMediaSelector,
      _isObject,
      _isSchema,
      amf,
      narrow
    } = this;
    const hasBodyName = !!_bodyName;
    const hasDescription = !!_description;
    const hasTypeName = !!_typeName;

    return html`
    <div class="media-type-selector">
      <span>Media type:</span>
      ${_renderMediaSelector ?
        this._mediaTypesTemplate() :
        html`<span class="media-type-label">${_selectedMediaType}</span>`}
    </div>
    ${hasBodyName ? html`<div class="body-name type-title">${_bodyName}</div>` : undefined}
    ${hasTypeName ? html`<div class="type-title">${_typeName}</div>` : undefined}
    ${hasDescription ? html`
    <arc-marked .markdown="${_description}">
      <div slot="markdown-html" class="markdown-html" part="markdown-html" ?data-with-title="${hasTypeName}"></div>
    </arc-marked>` : undefined}

    ${_isObject ?
      html`<api-type-document
      .amf="${amf}"
      .selectedBodyId="${_selectedBodyId}"
      .type="${_selectedSchema}"
      .narrow="${narrow}"
      .mediaType="${_selectedMediaType}"
      ?compatibility="${compatibility}"
      ?graph="${graph}"></api-type-document>` : undefined}
    ${_isSchema ?
      html`<api-schema-document
        .amf="${amf}"
        .shape="${_selectedSchema}"
        ?compatibility="${compatibility}"></api-schema-document>` :
      undefined}`;
  }

  _mediaTypesTemplate() {
    const items = this._mediaTypes;
    if (!items || !items.length) {
      return;
    }
    const selected = this.selected;
    return items.map((item, index) =>
      html`<anypoint-button
        class="media-toggle"
        data-index="${index}"
        title="Select ${item.label} media type"
        .active="${selected === index}"
        ?compatibility="${this.compatibility}"
        toggles
        @click="${this._selectMediaType}">${item.label}</anypoint-button>`);
  }

  render() {
    const { opened, _isAnyType, aware, compatibility, headerLevel } = this;
    const iconClass = this._computeToggleIconClass(opened);
    return html`
    ${aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" .scope="${aware}"></raml-aware>` : undefined}

    <div class="section-title-area" @click="${this.toggle}" title="Toogle body details">
      <div class="table-title" role="heading" aria-level="${headerLevel}">Body</div>
      <div class="title-area-actions">
        <anypoint-button
          class="toggle-button"
          ?compatibility="${compatibility}">
          ${this._computeToggleActionLabel(opened)}
          <span class="icon ${iconClass}">${expandMore}</span>
        </anypoint-button>
      </div>
    </div>

    <iron-collapse .opened="${opened}">
      ${_isAnyType ? this._anyTypeTemplate() : this._typedTemplate()}
    </iron-collapse>`;
  }
}
window.customElements.define('api-body-document', ApiBodyDocument);

/**
 * `api-headers-document`
 *
 * A documentation for API headers.
 *
 * It uses [AMF](https://github.com/mulesoft/amf) json/ld model to render
 * the view.
 *
 * ## Example
 *
 * ```html
 * <api-headers-document headers="[...]" opened></api-headers-document>
 * ```
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 */
class ApiHeadersDocument extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
    }

    [hidden] {
      display: none !important;
    }

    .section-title-area {
      display: flex;
      flex-direction: row;
      align-items: center;
      cursor: pointer;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      border-bottom: 1px var(--api-headers-document-title-border-color, #e5e5e5) solid;
    }

    .toggle-icon {
      margin-left: 8px;
      transform: rotateZ(0deg);
      transition: transform 0.3s ease-in-out;
    }

    .toggle-icon.opened {
      transform: rotateZ(-180deg);
    }

    .headers-title {
      flex: 1;
      flex-basis: 0.000000001px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: var(--arc-font-subhead-font-size);
      font-weight: var(--arc-font-subhead-font-weight);
      line-height: var(--arc-font-subhead-line-height);
    }

    .no-info {
      font-style: var(--no-info-message-font-style, italic);
      font-size: var(--no-info-message-font-size, 16px);
      color: var(--no-info-message-color, rgba(0, 0, 0, 0.74));
    }

    :host([narrow]) .headers-title {
      font-size: var(--api-headers-document-title-narrow-font-size, 17px);
    }`;
  }

  render() {
    const { aware, opened, headers, amf, narrow, compatibility, headerLevel, graph } = this;
    const hasHeaders = !!(headers && headers.length);
    return html`
    ${aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" .scope="${aware}"></raml-aware>` : undefined}

    <div class="section-title-area" @click="${this.toggle}" title="Toogle headers details">
      <div class="headers-title" role="heading" aria-level="${headerLevel}">Headers</div>
      <div class="title-area-actions">
        <anypoint-button class="toggle-button" ?compatibility="${compatibility}">
          ${this._computeToggleActionLabel(opened)}
          <iron-icon icon="arc:expand-more" class="${this._computeToggleIconClass(opened)}"></iron-icon>
        </anypoint-button>
      </div>
    </div>

    <iron-collapse .opened="${opened}">
      ${hasHeaders ?
        html`<api-type-document
          .amf="${amf}"
          .type="${headers}"
          ?narrow="${narrow}"
          ?graph="${graph}"></api-type-document>` :
        html`<p class="no-info">Headers are not required by this endpoint</p>`}
    </iron-collapse>`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * Generated AMF json/ld model form the API spec.
       * The element assumes the object of the first array item to be a
       * type of `"http://raml.org/vocabularies/document#Document`
       * on AMF vocabulary.
       *
       * It is only usefult for the element to resolve references.
       *
       * @type {Object|Array}
       */
      amf: { type: Object },
      /**
       * The headers AMF model Array.
       */
      headers: { type: Array },
      /**
       * Set to true to open the view.
       * Autormatically set when the view is toggle from the UI.
       */
      opened: { type: Boolean },
      /**
       * A property passed to the type document element to render
       * a mogile friendly view.
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * Type of the header in the documentation section.
       * Should be in range of 1 to 6.
       *
       * @default 2
       */
      headerLevel: { type: Number },
      /**
       * Passed to `api-type-document`. Enables internal links rendering for types.
       */
      graph: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  constructor() {
    super();
    this.headerLevel = 2;
  }
  /**
   * Handler for amf model change from `raml-aware`
   * @param {CustomEvent} e
   */
  _apiChangedHandler(e) {
    const { value } = e.detail;
    setTimeout(() => {
      this.amf = value;
      // For some reson this value is not reflected in the render function
      // unles it is delayed
    });
  }

  // Computes a label for the section toggle buttons.
  _computeToggleActionLabel(opened) {
    return opened ? 'Hide' : 'Show';
  }

  // Computes class for the toggle's button icon.
  _computeToggleIconClass(opened) {
    let clazz = 'toggle-icon';
    if (opened) {
      clazz += ' opened';
    }
    return clazz;
  }
  /**
   * Toggles the view.
   * Use `opened` property instead.
   */
  toggle() {
    this.opened = !this.opened;
  }
}
window.customElements.define('api-headers-document', ApiHeadersDocument);

/**
 * `api-responses-document`
 *
 * A documentation for method responses based on AMF model.
 *
 * It renders a selector of available status codes in the responses array.
 * This is computed from `returns` property which must be an array
 * as a value of AMF's `http://www.w3.org/ns/hydra/core#returns` property
 * of the `method` shape.
 *
 * Status codes are sorted before rendering.
 *
 * In the documentation part it renders annotations (AMF custom proeprties)
 * added to the response, headers and body.
 *
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin ApiElements.AmfHelperMixin
 */
class ApiResponsesDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      css`:host {
        display: block;
        font-size: var(--arc-font-body1-font-size);
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
      }

      arc-marked {
        margin-top: 8px;
        padding: 0;
      }

      .no-info {
        font-style: italic;
      }

      .codes-selector {
        border-bottom: 1px #e5e5e5 solid;
      }`
    ];
  }

  _codesSelectorTemplate() {
    const { codes, selected } = this;
    if (!codes || !codes.length) {
      return '';
    }
    return html`
    <div class="codes-selector">
      <anypoint-tabs
        .selected="${selected}"
        ?compatibility="${this.compatibility}"
        @selected-changed="${this._tabsHandler}">
        ${codes.map((item) => html`<anypoint-tab>${item}</anypoint-tab>`)}
      </anypoint-tabs>
    </div>`;
  }

  render() {
    const {
      _description,
      _payload,
      _headers,
      _hasCustomProperties,
      aware,
      _selectedResponse,
      amf,
      narrow,
      compatibility,
      graph
    } = this;
    const hasDescription = !!_description;
    const hasPayload = !!(_payload && _payload.length);
    const hasHeaders = !!(_headers && _headers.length);
    const noDocs = this._computeNoDocs(_hasCustomProperties, hasHeaders, hasPayload, hasDescription);
    return html`
    ${aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" .scope="${aware}"></raml-aware>` : undefined}
    ${this._codesSelectorTemplate()}
    ${_hasCustomProperties ? html`<api-annotation-document ?legacy="${compatibility}" .shape="${_selectedResponse}"></api-annotation-document>`:undefined}
    ${_description ? html`<arc-marked .markdown="${_description}">
      <div slot="markdown-html" class="markdown-body"></div>
    </arc-marked>` : undefined}
    ${hasHeaders ? html`<api-headers-document
      opened
      .amf="${amf}"
      .headers="${_headers}"
      ?compatibility="${compatibility}"
      ?narrow="${narrow}"
      ?graph="${graph}"></api-headers-document>` : undefined}
    ${hasPayload ? html`<api-body-document
      .amf="${amf}"
      .body="${_payload}"
      ?narrow="${narrow}"
      ?compatibility="${compatibility}"
      ?graph="${graph}"
      opened></api-body-document>` : undefined}
    ${noDocs ? html`<p class="no-info">No description provided</p>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * The `returns` property of the method AMF model.
       *
       * @type {Array<Object>}
       */
      returns: { type: Array },
      /**
       * Computed value of status codes from `returns` property.
       *
       * @type {Array<String>}
       */
      _codes: { type: Array },
      /**
       * Selected index of a status code from the selector.
       */
      selected: { type: Number },
      /**
       * Currently selected response object as AMF model os a type of
       * `http://raml.org/vocabularies/http#Response`
       */
      _selectedResponse: { type: Object },
      /**
       * Computed value of method description from `method` property.
       */
      _description: { type: String },
      /**
       * Computed value of AMF payload definition from `expects`
       * property.
       */
      _payload: { type: Object },
      /**
       * Computed value of AMF payload definition from `expects`
       * property.
       */
      _headers: { type: Object },
      /**
       * Computed value from current `_selectedResponse`. True if the model
       * contains custom properties (annotations in RAML).
       */
      _hasCustomProperties: { type: Boolean },
      /**
       * Set to render a mobile friendly view.
       */
       narrow: { type: Boolean },
       /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * When enabled it renders external types as links and dispatches
       * `api-navigation-selection-changed` when clicked.
       */
      graph: { type: Boolean }
    };
  }

  get legacy() {
    return this._compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get returns() {
    return this._returns;
  }

  set returns(value) {
    const old = this._returns;
    if (old === value) {
      return;
    }
    this._returns = value;
    this.requestUpdate('returns', old);
    this.__amfChanged();
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    if (old === value) {
      return;
    }
    this._selected = value;
    this.requestUpdate('selected', old);
    this._selectedResponse = this._computeSelectedResponse();
  }
  /**
   * List of recognized codes.
   * @return {Array<String>}
   */
  get codes() {
    return this._codes;
  }

  get _codes() {
    return this.__codes;
  }

  set _codes(value) {
    const old = this.__codes;
    if (old === value) {
      return;
    }
    this.__codes = value;
    this._codesChanged(value);
    this.requestUpdate('_codes', old);
    this.dispatchEvent(new CustomEvent('codes-changed'), {
      detail: {
        value
      }
    });
  }

  get _selectedResponse() {
    return this.__selectedResponse;
  }

  set _selectedResponse(value) {
    const old = this.__selectedResponse;
    if (old === value) {
      return;
    }
    this.__selectedResponse = value;
    this.requestUpdate('_selectedResponse', old);
    this._description = this._computeDescription(value);
    this._payload = this._computePayload(value);
    this._headers = this._computeHeaders(value);
    this._hasCustomProperties = this._computeHasCustomProperties(value);
  }

  async __amfChanged() {
    await this.updateComplete;
    this._codes = this._computeCodes();
    this._selectedResponse = this._computeSelectedResponse();
  }
  /**
   * Computes list of status codes for the selector.
   *
   * @return {Array<String>}
   */
  _computeCodes() {
    const { returns } = this;
    if (!returns || !returns.length) {
      return;
    }
    const codes = [];
    returns.forEach((item) => {
      const value = this._getValue(item, this.ns.w3.hydra.core + 'statusCode');
      if (value) {
        codes.push(value);
      }
    });
    codes.sort();
    return codes;
  }
  /**
   * Computes value for `_selectedResponse` property.
   * Codes are sorted so it has to match status code with entry in returns
   * array
   * @return {Object}
   */
  _computeSelectedResponse() {
    const { selected, _codes, returns } = this;
    if (!returns || !_codes || (!selected && selected !== 0)) {
      return;
    }
    const status = _codes[selected];
    return returns.find((item) => this._statusMatches(item, status));
  }
  /**
   * Checks if given `item` matches `statusCode`
   *
   * @param {Object} item Response AMF model
   * @param {String} status Status code as string
   * @return {Boolean}
   */
  _statusMatches(item, status) {
    if (!item) {
      return false;
    }
    const value = this._getValue(item, this.ns.w3.hydra.core + 'statusCode');
    return value === status;
  }
  /**
   * Sets `selected` 0 when codes changes.
   * It only sets selection if there's actually a value to render.
   * It prohibits from performing additional computations for nothing.
   *
   * @param {?Array} codes
   */
  _codesChanged(codes) {
    if (codes && codes.length) {
      this.selected = 0;
    }
  }

  _computeNoDocs(hasCustomProperties, hasHeaders, hasPayload, hasDescription) {
    return !(hasCustomProperties || hasHeaders || hasPayload || hasDescription);
  }

  _apiChangedHandler(e) {
    const { value } = e.detail;
    this.amf = value;
  }

  _tabsHandler(e) {
    this.selected = e.detail.value;
  }
}
window.customElements.define('api-responses-document', ApiResponsesDocument);

/**
http://prismjs.com/download.html?themes=prism&languages=markup+css+clike+javascript

prism.js default theme for JavaScript, CSS and HTML
Based on dabblet (http://dabblet.com)
@author Lea Verou

Modified for ARC.
*/

var httpStyles = css`:host {
  display: block;
  position: relative;
  width: 100%;
}

.code {
  display: block;
  position: relative;
  white-space: pre-wrap;
  word-break: break-all;
  padding-top: 20px; /* Padding for the copy button. */

  background-color: var(--http-code-snippet-container-background-color);
  padding: var(--http-code-snippet-container-padding, 8px);
}

.copy-button,
anypoint-icon-button {
  position: absolute;
  top: 0px;
  right: 0px;
  z-index: 1;
}

.copy-button {
  text-transform: uppercase;
  border: none;
  cursor: pointer;
  background: #e0e0e0;
}

.label {
  font-weight: 500;
}

.value {
  margin-left: 8px;
}

.line {
  word-break: break-all;
  white-space: pre-wrap;
}

.line.indent {
  margin-left: var(--http-code-snippet-indent, 12px);
}

.line.indent-2 {
  margin-left: var(--http-code-snippet-indent-2, 24px);
}

.copy-button {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

code[class*="language-"],
pre[class*="language-"] {
  font-family: var(--arc-font-code-family);
  webkit-font-smoothing: var(--arc-font-font-smoothing);
  color: var(--code-color, black);
  text-shadow: 0 1px white;
  text-shadow: var(--http-code-snippet-code-text-shadow, 0 1px white);
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  word-spacing: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection,
pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection,
code[class*="language-"] ::-moz-selection {
  text-shadow: none;
  background: var(--http-code-snippet-code-selection-background-color, #b3d4fc);
}

pre[class*="language-"]::selection,
pre[class*="language-"] ::selection,
code[class*="language-"]::selection,
code[class*="language-"] ::selection {
  text-shadow: none;
  background: var(--http-code-snippet-code-selection-background-color, #b3d4fc);
}

@media print {
  code[class*="language-"],
  pre[class*="language-"] {
    text-shadow: none;
  }
}
/* Code blocks */

pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
}

/* Inline code */

:not(pre)>code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: var(--http-code-snippet-code-cdata-color, slategray);
}

.token.punctuation {
  color: var(--code-punctuation-value-color, #999);
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: var(--code-type-number-value-color, #905);
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: var(--code-type-text-value-color, #690);
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: var(--code-punctuation-value-color, #a67f59);
  background: transparent !important;
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: var(--http-code-snippet-code-keyword-color, #07a);
}

.token.function {
  color: var(--http-code-snippet-code-function-color, #DD4A68);
}

.token.regex,
.token.important,
.token.variable {
  color: var(--http-code-snippet-variable-color, #e90);
}

.token.important,
.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}`;

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
const URI_CACHE = {};
/**
 * `base-code-snippet`
 *
 * A class to be used to extend other code snippets elements.
 *
 * Each child class has to have `lang` property to be used to recognize the
 * syntax. If syntax is different than the default PrismJs set then it has to
 * be imported into the DOM.
 *
 * Each child class must implement `_processCommand()` function which results
 * to a code to highlight. It takes 4 attributes (in order): url, method,
 * headers, and payload.
 * Mind that all atguments are optional.
 *
 * If the child class implements it's own template, it should contain
 * `<code></code>` inside the template where the highlighted value is
 * added.
 *
 * Parent element, presumably `http-code-snippets`, or main document
 * must include `prism-element/prism-highlighter.html` in it's DOM.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 */
class BaseCodeSnippet extends LitElement {
  static get _httpStyles() {
    return httpStyles;
  }

  static get styles() {
    return BaseCodeSnippet._httpStyles;
  }

  render() {
    return html`<button class="copy-button" title="Copy to clipboard" @click="${this._copyToClipboard}">Copy</button>
    <code class="code language-snippet"></code>`;
  }

  static get properties() {
    return {
      /**
       * Request URL
       */
      url: { type: String },
      /**
       * HTTP method
       */
      method: { type: String },
      /**
       * Parsed HTTP headers.
       * Each item contains `name` and `value` properties.
       * @type {Array<Object>}
       */
      headers: { type: Array },
      /**
       * HTTP body (the message)
       */
      payload: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean }
    };
  }

  get url() {
    return this._url;
  }

  get method() {
    return this._method;
  }

  get headers() {
    return this._headers;
  }

  get payload() {
    return this._payload;
  }

  set url(value) {
    this._setProp('url', value);
  }

  set method(value) {
    this._setProp('method', value);
  }

  set headers(value) {
    this._setProp('headers', value);
  }

  set payload(value) {
    this._setProp('payload', value);
  }

  get _code() {
    return this.shadowRoot.querySelector('code');
  }

  _setProp(prop, value) {
    if (this._sop(prop, value)) {
      this._valuesChanged();
    }
  }

  _sop(prop, value) {
    const key = '_' + prop;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.__valuesDebouncer) {
      this._valuesChanged();
    }
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this._clearValueTimeout();
  }
  /**
   * Clears timeout from the debouncer if set.
   */
  _clearValueTimeout() {
    if (this.__valuesDebouncer) {
      clearTimeout(this.__valuesDebouncer);
      this.__valuesDebouncer = undefined;
    }
  }
  /**
   * Computes code value with debouncer.
   */
  _valuesChanged() {
    this._clearValueTimeout();
    this.__valuesDebouncer = setTimeout(() => {
      this.__valuesDebouncer = undefined;
      this._processCommand();
    });
  }
  /**
   * Processes command by calling, respectively, `_computeCommand()` and
   * `_highlight()`. The result is added to the `<code>` block in the template.
   */
  _processCommand() {
    const { url, method, headers, payload } = this;
    let code = this._computeCommand(url, method, headers, payload);
    if (!code) {
      code = '';
    } else {
      code = this._highlight(code, this.lang);
    }
    this._code.innerHTML = code;
  }

  _computeCommand() {}

  _highlight(code, lang) {
    const e = new CustomEvent('syntax-highlight', {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: {
        code,
        lang
      }
    });
    this.dispatchEvent(e);
    return e.detail.code || code;
  }
  /**
   * Reads the host, port and path from the url.
   * This function uses URI library to parse the URL so you have to
   * include this library from bower_components if the element want to use it.
   *
   * @param {String} url
   * @return {Object}
   */
  urlDetails(url) {
    if (URI_CACHE[url]) {
      return URI_CACHE[url];
    }
    url = url || this.url;
    const result = {
      path: '',
      port: '',
      hostValue: ''
    };
    if (!url) {
      return result;
    }
    let uri;
    try {
      uri = new URL(url);
    } catch (e) {
      if (url[0] === '/') {
        result.path = url;
        result.post = 80;
      }
      return result;
    }
    let host = uri.hostname;
    if (host) {
      host = decodeURIComponent(host);
    }
    let port = uri.port;
    if (!port) {
      if (uri.protocol === 'https:') {
        port = 443;
      } else {
        port = 80;
      }
    }
    result.port = port;
    result.hostValue = host;
    const query = uri.search;
    let path = uri.pathname;
    if (!path) {
      path = '/';
    } else {
      path = decodeURIComponent(path);
    }
    if (query) {
      path += query;
    }
    result.path = path;
    URI_CACHE[url] = result;
    return result;
  }

  _copyToClipboard() {
    const code = this._code;
    if (!code) {
      return;
    }
    const content = code.innerText;
    if (this._beforeCopy(content)) {
      return;
    }
    const el = document.createElement('textarea');
    el.value = content;
    el.setAttribute('readonly', '');
    el.style.position = 'absolute';
    el.style.left = '-9999px';
    document.body.appendChild(el);
    const selected = document.getSelection().rangeCount > 0 ?
      document.getSelection().getRangeAt(0) : false;
    el.select();
    try {
      document.execCommand('copy');
    } catch (err) {
    }
    document.body.removeChild(el);
    document.getSelection().removeAllRanges();
    if (selected) {
      document.getSelection().addRange(selected);
    }
  }
  /**
   * Sends the `content-copy` event.
   * If the event is canceled then the logic from this element won't be
   * executed. Useful if current platform doesn't support `execCommand('copy')`
   * and has other way to manage clipboard.
   *
   * @param {String} value The value to dispatch with the event.
   * @return {Boolean} True if handler executed copy function.
   */
  _beforeCopy(value) {
    const ev = new CustomEvent('content-copy', {
      detail: {
        value
      },
      bubbles: true,
      cancelable: true,
      composed: true
    });
    this.dispatchEvent(ev);
    return ev.defaultPrevented;
  }
}
window.customElements.define('base-code-snippet', BaseCodeSnippet);

!function(t){t.languages.http={"request-line":{pattern:/^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\s(?:https?:\/\/|\/)\S+\sHTTP\/[0-9.]+/m,inside:{property:/^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b/,"attr-name":/:\w+/}},"response-status":{pattern:/^HTTP\/1.[01] \d+.*/m,inside:{property:{pattern:/(^HTTP\/1.[01] )\d+.*/i,lookbehind:!0}}},"header-name":{pattern:/^[\w-]+:(?=.)/m,alias:"keyword"}};var a,e,n,i=t.languages,s={"application/javascript":i.javascript,"application/json":i.json||i.javascript,"application/xml":i.xml,"text/xml":i.xml,"text/html":i.html,"text/css":i.css},p={"application/json":!0,"application/xml":!0};for(var r in s)if(s[r]){a=a||{};var T=p[r]?(n=(e=r).replace(/^[a-z]+\//,""),"(?:"+e+"|\\w+/(?:[\\w.-]+\\+)+"+n+"(?![+\\w.-]))"):r;a[r]={pattern:RegExp("(content-type:\\s*"+T+"[\\s\\S]*?)(?:\\r?\\n|\\r){2}[\\s\\S]*","i"),lookbehind:!0,inside:{rest:s[r]}};}a&&t.languages.insertBefore("http","header-name",a);}(Prism);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `raw-http-snippet`
 *
 * Code snippet to display raw HTTP message
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/raw.html Raw demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class RawHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'http';
  }

  /**
   * Computes bas command for cURL.
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete cURL command for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    const urlData = this.urlDetails(url);
    let result = `${method} ${urlData.path} HTTP/1.1\n`;
    if (urlData.hostValue) {
      result += `Host: ${urlData.hostValue}:${urlData.port}\n`;
    }
    result += this._genHeadersPart(headers);
    result += this._genPayloadPart(payload);
    return result;
  }

  _genHeadersPart(headers) {
    let result = '';
    if (headers && headers instanceof Array) {
      for (let i = 0, len = headers.length; i < len; i++) {
        const h = headers[i];
        result += `${h.name}: ${h.value}\n`;
      }
    }
    return result;
  }

  _genPayloadPart(payload) {
    let result = '';
    if (payload) {
      result += '\n';
      result += payload;
      result += '\n\n';
    }
    return result;
  }
}
window.customElements.define('raw-http-snippet', RawHttpSnippet);

!function(e){var t="\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b",n={environment:{pattern:RegExp("\\$"+t),alias:"constant"},variable:[{pattern:/\$?\(\([\s\S]+?\)\)/,greedy:!0,inside:{variable:[{pattern:/(^\$\(\([\s\S]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,greedy:!0,inside:{variable:/^\$\(|^`|\)$|`$/}},{pattern:/\$\{[^}]+\}/,greedy:!0,inside:{operator:/:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,punctuation:/[\[\]]/,environment:{pattern:RegExp("(\\{)"+t),lookbehind:!0,alias:"constant"}}},/\$(?:\w+|[#?*!@$])/],entity:/\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/};e.languages.bash={shebang:{pattern:/^#!\s*\/.*/,alias:"important"},comment:{pattern:/(^|[^"{\\$])#.*/,lookbehind:!0},"function-name":[{pattern:/(\bfunction\s+)\w+(?=(?:\s*\(?:\s*\))?\s*\{)/,lookbehind:!0,alias:"function"},{pattern:/\b\w+(?=\s*\(\s*\)\s*\{)/,alias:"function"}],"for-or-select":{pattern:/(\b(?:for|select)\s+)\w+(?=\s+in\s)/,alias:"variable",lookbehind:!0},"assign-left":{pattern:/(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,inside:{environment:{pattern:RegExp("(^|[\\s;|&]|[<>]\\()"+t),lookbehind:!0,alias:"constant"}},alias:"variable",lookbehind:!0},string:[{pattern:/((?:^|[^<])<<-?\s*)(\w+?)\s*(?:\r?\n|\r)(?:[\s\S])*?(?:\r?\n|\r)\2/,lookbehind:!0,greedy:!0,inside:n},{pattern:/((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s*(?:\r?\n|\r)(?:[\s\S])*?(?:\r?\n|\r)\3/,lookbehind:!0,greedy:!0},{pattern:/(["'])(?:\\[\s\S]|\$\([^)]+\)|`[^`]+`|(?!\1)[^\\])*\1/,greedy:!0,inside:n}],environment:{pattern:RegExp("\\$?"+t),alias:"constant"},variable:n.variable,function:{pattern:/(^|[\s;|&]|[<>]\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,lookbehind:!0},keyword:{pattern:/(^|[\s;|&]|[<>]\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\s;|&])/,lookbehind:!0},builtin:{pattern:/(^|[\s;|&]|[<>]\()(?:\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\s;|&])/,lookbehind:!0,alias:"class-name"},boolean:{pattern:/(^|[\s;|&]|[<>]\()(?:true|false)(?=$|[)\s;|&])/,lookbehind:!0},"file-descriptor":{pattern:/\B&\d\b/,alias:"important"},operator:{pattern:/\d?<>|>\||\+=|==?|!=?|=~|<<[<-]?|[&\d]?>>|\d?[<>]&?|&[>&]?|\|[&|]?|<=?|>=?/,inside:{"file-descriptor":{pattern:/^\d/,alias:"important"}}},punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,number:{pattern:/(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,lookbehind:!0}};for(var a=["comment","function-name","for-or-select","assign-left","string","environment","function","keyword","builtin","boolean","file-descriptor","operator","punctuation","number"],r=n.variable[1].inside,s=0;s<a.length;s++)r[a[s]]=e.languages.bash[a[s]];e.languages.shell=e.languages.bash;}(Prism);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `curl-http-snippet`
 *
 * A snippet for curl command in bash.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/curl.html cURL demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class CurlHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'bash';
  }
  /**
   * Computes command for cURL.
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete cURL command for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    url = url || '';
    method = method || 'GET';
    let result = `curl "${url}" \\\n`;
    if (method !== 'GET') {
      result += `  -X ${method} \\\n`;
    }
    if (payload) {
      let quot = '';
      try {
        payload = JSON.stringify(payload);
      } catch (_) {
        quot = '"';
      }
      result += `  -d ${quot}${payload}${quot} \\\n`;
    }
    if (headers && headers instanceof Array) {
      for (let i = 0, len = headers.length; i < len; i++) {
        const h = headers[i];
        result += `  -H "${h.name}: ${h.value}" `;
        if (i + 1 !== len) {
          result += '\\\n';
        }
      }
    }
    if (result.substr(-2) === '\\\n') {
      result = result.substr(0, result.length - 3);
    }
    return result;
  }
}
window.customElements.define('curl-http-snippet', CurlHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `raw-http-snippet`
 *
 * A snippet for requests made in JavaScript using XHR object.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/xhr.html XHR demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class XhrHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'javascript';
  }

  /**
   * Computes code for JavaScript (XHR API).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    const hasHeaders = !!(headers && headers instanceof Array && headers.length);
    const hasPayload = !!payload;
    let result = 'var xhr = new XMLHttpRequest();\n';
    result += 'xhr.addEventListener(\'load\', function(e) {\n';
    result += '  var response = e.target.responseText;\n';
    result += '  console.log(response);\n';
    result += '});\n';
    result += 'xhr.addEventListener(\'error\', function(e) {\n';
    result += '  console.error(\'Request errored with status\', e.target.status);\n';
    result += '});\n';
    result += `xhr.open('${method}', '${url}');\n`;
    if (hasHeaders) {
      headers.forEach((h) => {
        result += `xhr.setRequestHeader('${h.name}','${h.value}');\n`;
      });
    }
    if (hasPayload) {
      result += 'var body = \'\';\n';
      const re = /'/g;
      payload.split('\n').forEach((line) => {
        result += 'body += \'' + line.replace(re, '\\\'') + '\\n\';\n';
      });
      result += 'xhr.send(body);\n';
    } else {
      result += 'xhr.send();\n';
    }
    return result;
  }
}
window.customElements.define('xhr-http-snippet', XhrHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `fetch-js-http-snippet`
 *
 * A snippet for requests made in JavaScript using Fetch API.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/fetch-js.html Fetch (JavaScript) demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class FetchJsHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'javascript';
  }

  /**
   * Computes code for JavaScript (Fetch API).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    const hasHeaders = !!(headers && headers instanceof Array && headers.length);
    const hasPayload = !!payload;
    const hasInit = hasHeaders || hasPayload || !!(method && method !== 'GET');
    let result = '';

    if (hasInit) {
      if (hasHeaders) {
        result += this._createHeaders(headers);
      }
      if (hasPayload) {
        result += this._createPayload(payload);
      }
      result += 'const init = {\n';
      result += `  method: '${method}'`;
      if (hasHeaders) {
        result += `,\n  headers`;
      }
      if (hasPayload) {
        result += `,\n  body`;
      }
      result += '\n';
      result += '}\n\n';
    }

    result += `fetch('${url}'`;
    if (hasInit) {
      result += ', init';
    }
    result += ')\n';
    result += '.then((response) => {\n';
    result += '  return response.json(); // or .text() or .blob() ...\n';
    result += '})\n';
    result += '.then((text) => {\n';
    result += '  // text is the response body\n';
    result += '})\n';
    result += '.catch((e) => {\n';
    result += '  // error in e.message\n';
    result += '});';
    return result;
  }

  _createHeaders(headers) {
    let result = 'const headers = new Headers();\n';
    for (let i = 0, len = headers.length; i < len; i++) {
      const h = headers[i];
      result += `headers.append('${h.name}', '${h.value}');\n`;
    }
    result += '\n';
    return result;
  }

  _createPayload(payload) {
    return `const body = \`${payload}\`;\n\n`;
  }
}
window.customElements.define('fetch-js-http-snippet', FetchJsHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `node-http-snippet`
 *
 * A set of code snippets for Python requests.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/python.html Python demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class NodeHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'javascript';
  }

  /**
   * Computes code for JavaScript (Node).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    let result = 'const http = require(\'http\');\n';
    const data = this.urlDetails(url);
    result += 'const init = {\n';
    result += `  host: '${data.hostValue}',\n`;
    result += `  path: '${data.path}',\n`;
    result += `  port: ${data.port},\n`;
    result += `  method: '${method}',\n`;
    result += this._genHeadersPart(headers);
    result += '};\n';
    result += 'const callback = function(response) {\n';
    result += '  let result = Buffer.alloc(0);\n';
    result += '  response.on(\'data\', function(chunk) {\n';
    result += '    result = Buffer.concat([result, chunk]);\n';
    result += '  });\n';
    result += '  \n';
    result += '  response.on(\'end\', function() {\n';
    result += '    // result has response body buffer\n';
    result += '    console.log(str.toString());\n';
    result += '  });\n';
    result += '};\n';
    result += '\n';
    result += 'const req = http.request(init, callback);\n';
    result += this._genPayloadPart(payload);
    result += 'req.end();\n';
    return result;
  }

  _genHeadersPart(headers) {
    let result = '';
    if (headers && headers instanceof Array && headers.length) {
      result += '  headers: {\n';
      for (let i = 0, len = headers.length; i < len; i++) {
        const h = headers[i];
        result += `    '${h.name}': '${h.value}'`;
        if (i + 1 !== len) {
          result += ',';
        }
        result += '\n';
      }
      result += '  }\n';
    }
    return result;
  }

  _genPayloadPart(payload) {
    let result = '';
    if (payload) {
      result += `const body = \`${payload}\`;\n`;
      result += 'req.write(body);\n';
    }
    return result;
  }
}
window.customElements.define('node-http-snippet', NodeHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `javascript-http-snippet`
 *
 * A set of code snippets for JavaScript requests.
 *
 * ## Styling
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--http-code-snippets` | Mixin applied to this elment | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/javascript.html JavaScript demo
 * @memberof ApiElements
 */
class JavascriptHttpSnippets extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
    }`;
  }

  _renderPage(selected) {
    const { url, method, payload, headers } = this;
    switch (selected) {
      case 0: return html`<fetch-js-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></fetch-js-http-snippet>`;
      case 1: return html`<node-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></node-http-snippet>`;
      case 2: return html`<xhr-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></xhr-http-snippet>`;
    }
  }

  render() {
    const { selected, compatibility } = this;
    return html`
    <anypoint-tabs
      ?compatibility="${compatibility}"
      .selected="${selected}"
      @selected-changed="${this._selectedCHanged}">
      <anypoint-tab>Fetch</anypoint-tab>
      <anypoint-tab>Node</anypoint-tab>
      <anypoint-tab>XHR</anypoint-tab>
    </anypoint-tabs>
    ${this._renderPage(selected)}
    `;
  }
  static get properties() {
    return {
      selected: { type: Number },
      /**
       * Request URL
       */
      url: { type: String },
      /**
       * HTTP method
       */
      method: { type: String },
      /**
       * Parsed HTTP headers.
       * Each item contains `name` and `value` properties.
       * @type {Array<Object>}
       */
      headers: { type: Array },
      /**
       * HTTP body (the message)
       */
      payload: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true }
    };
  }
  constructor() {
    super();
    this.selected = 0;
  }
  /**
   * Handler for `selected-changed` event dispatched on anypoint-tabs.
   * @param {CustomEvent} e
   */
  _selectedCHanged(e) {
    const { value } = e.detail;
    this.selected = value;
  }
}
window.customElements.define('javascript-http-snippets', JavascriptHttpSnippets);

Prism.languages.python={comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},"string-interpolation":{pattern:/(?:f|rf|fr)(?:("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,greedy:!0,inside:{interpolation:{pattern:/((?:^|[^{])(?:{{)*){(?!{)(?:[^{}]|{(?!{)(?:[^{}]|{(?!{)(?:[^{}])+})+})+}/,lookbehind:!0,inside:{"format-spec":{pattern:/(:)[^:(){}]+(?=}$)/,lookbehind:!0},"conversion-option":{pattern:/![sra](?=[:}]$)/,alias:"punctuation"},rest:null}},string:/[\s\S]+/}},"triple-quoted-string":{pattern:/(?:[rub]|rb|br)?("""|''')[\s\S]+?\1/i,greedy:!0,alias:"string"},string:{pattern:/(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,greedy:!0},function:{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)\w+/i,lookbehind:!0},decorator:{pattern:/(^\s*)@\w+(?:\.\w+)*/i,lookbehind:!0,alias:["annotation","punctuation"],inside:{punctuation:/\./}},keyword:/\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,builtin:/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,boolean:/\b(?:True|False|None)\b/,number:/(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,operator:/[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,punctuation:/[{}[\];(),.:]/},Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest=Prism.languages.python,Prism.languages.py=Prism.languages.python;

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `raw-http-snippet`
 *
 * A snippet for requests made in Python using the Requests library.
 *
 * ## Styling
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/requests-python.html Python > request demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class RequestsPythonHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'python';
  }

  /**
   * Computes code for Python (Request lib).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String|undefined} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    let result = 'import requests\n\n';
    const hasHeaders = !!(headers && headers instanceof Array && headers.length);
    const hasPayload = !!payload;
    result += `url = '${url}'\n`;
    if (hasHeaders) {
      result += this._getHeaders(headers);
      if (!hasPayload) {
        result += '\n';
      }
    }
    if (hasPayload) {
      result += this._getPayload(payload);
    }
    result += this._getConnection(method, hasPayload, hasHeaders);
    result += this._getFooter();
    return result;
  }

  /**
   * @param {Array<Object>} headers List of headers
   * @return {String} Headers variable definition
   */
  _getHeaders(headers) {
    let result = 'headers = {';
    for (let i = 0, len = headers.length; i < len; i++) {
      const h = headers[i];
      result += `'${h.name}': '${h.value}'`;
      if (i + 1 !== len) {
        result += ',';
      }
    }
    result += '}\n';
    return result;
  }
  /**
   * @param {String} payload HTTP body
   * @return {String} Body variable definition
   */
  _getPayload(payload) {
    let result = 'body = """';
    result += payload;
    result += '"""\n\n';
    return result;
  }

  /**
   * Computes value of connection definition
   * @param {String} method HTTP request method
   * @param {Boolean} hasPayload True if the request contains payload message
   * @param {Boolean} hasHeaders True if the request contains headers
   * @return {String}
   */
  _getConnection(method, hasPayload, hasHeaders) {
    const lowerMethod = String(method).toLowerCase();
    let result = `req = requests.${lowerMethod}(url`;
    if (hasHeaders) {
      result += ', headers=headers';
    }
    if (hasPayload) {
      result += ', data=body';
    }
    result += ')\n\n';
    return result;
  }
  /**
   * @return {String} Returns ending of the code definition
   */
  _getFooter() {
    let result = 'print(req.status_code)\n';
    result += 'print(req.headers)\n';
    result += 'print(req.text)';
    return result;
  }
}
window.customElements.define('requests-python-http-snippet', RequestsPythonHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `python-27-http-snippet`
 *
 * A snippet for requests made in Python 2.7 using native library.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/python-27.html Python 2.7 demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class Python27HttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'python';
  }

  /**
   * Computes code for Python (2.7).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    let result = 'import httplib\n\n';
    const hasHeaders = !!(headers && headers instanceof Array && headers.length);
    const hasPayload = !!payload;

    if (hasHeaders) {
      result += this._getHeaders(headers);
      if (!hasPayload) {
        result += '\n';
      }
    }
    if (hasPayload) {
      result += this._getPayload(payload);
    }
    result += this._getConnection(url, method, hasPayload, hasHeaders);
    result += this._getFooter();
    return result;
  }
  /**
   * @param {Array<Object>} headers List of headers
   * @return {String} Headers variable definition
   */
  _getHeaders(headers) {
    let result = 'headers = {';
    for (let i = 0, len = headers.length; i < len; i++) {
      const h = headers[i];
      result += `'${h.name}': '${h.value}'`;
      if (i + 1 !== len) {
        result += ',';
      }
    }
    result += '}\n';
    return result;
  }
  /**
   * @param {String} payload HTTP body
   * @return {String} Body variable definition
   */
  _getPayload(payload) {
    let result = 'body = """';
    result += payload;
    result += '"""\n\n';
    return result;
  }
  /**
   * Computes value of connection definition
   * @param {String} url HTTP request url
   * @param {String} method HTTP request method
   * @param {Boolean} hasPayload True if the request contains payload message
   * @param {Boolean} hasHeaders True if the request contains headers
   * @return {String}
   */
  _getConnection(url, method, hasPayload, hasHeaders) {
    const data = this.urlDetails(url);
    let clazz = 'HTTP';
    if (data.port === 443 || data.port === '443') {
      clazz += 'S';
    }
    let result = `conn = httplib.${clazz}Connection('${data.hostValue}')\n`;
    result += `conn.request('${method}','${data.path}'`;
    if (hasPayload) {
      result += ', body';
    }
    if (hasHeaders) {
      result += ', headers';
    }
    result += ')\n';
    return result;
  }
  /**
   * @return {String} Returns ending of the code definition
   */
  _getFooter() {
    let result = 'res = conn.getresponse()\n';
    result += '\n';
    result += 'print(res.status, res.reason)\n';
    result += 'print(res.read())\n';
    result += 'print(res.getheaders())';
    return result;
  }
}
window.customElements.define('python-27-http-snippet', Python27HttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `raw-http-snippet`
 *
 * A snippet for requests made in Python 3.1 using native library.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/python-31.html Python 3.1 demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class Python31HttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'python';
  }

  /**
   * Computes code for Python (3.1).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String|undefined} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    let result = 'import http.client\n\n';
    const hasHeaders = !!(headers && headers instanceof Array && headers.length);
    const hasPayload = !!payload;

    if (hasHeaders) {
      result += this._getHeaders(headers);
      if (!hasPayload) {
        result += '\n';
      }
    }
    if (hasPayload) {
      result += this._getPayload(payload);
    }
    result += this._getConnection(url, method, hasPayload, hasHeaders);
    result += this._getFooter();
    return result;
  }

  /**
   * @param {Array<Object>} headers List of headers
   * @return {String} Headers variable definition
   */
  _getHeaders(headers) {
    let result = 'headers = {';
    for (let i = 0, len = headers.length; i < len; i++) {
      const h = headers[i];
      result += `'${h.name}': '${h.value}'`;
      if (i + 1 !== len) {
        result += ',';
      }
    }
    result += '}\n';
    return result;
  }
  /**
   * @param {String} payload HTTP body
   * @return {String} Body variable definition
   */
  _getPayload(payload) {
    let result = 'body = """';
    result += payload;
    result += '"""\n\n';
    return result;
  }

  /**
   * Computes value of connection definition
   * @param {String} url HTTP request url
   * @param {String} method HTTP request method
   * @param {Boolean} hasPayload True if the request contains payload message
   * @param {Boolean} hasHeaders True if the request contains headers
   * @return {String}
   */
  _getConnection(url, method, hasPayload, hasHeaders) {
    const data = this.urlDetails(url);
    let clazz = 'HTTP';
    if (data.port === 443 || data.port === '443') {
      clazz += 'S';
    }
    let result = `conn = http.client.${clazz}Connection('${data.hostValue}')\n`;
    result += `conn.request('${method}','${data.path}'`;
    if (hasPayload) {
      result += ', body';
    }
    if (hasHeaders) {
      result += ', headers';
    }
    result += ')\n';
    return result;
  }
  /**
   * @return {String} Returns ending of the code definition
   */
  _getFooter() {
    let result = 'res = conn.getresponse()\n';
    result += '\n';
    result += 'data = res.read()\n';
    result += 'print(res.status, res.reason)\n';
    result += 'print(data.decode(\'utf-8\'))\n';
    result += 'print(res.getheaders())';
    return result;
  }
}
window.customElements.define('python-31-http-snippet', Python31HttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `raw-http-snippet`
 *
 * A set of code snippets for Python requests.
 *
 * ## Styling
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--http-code-snippets` | Mixin applied to this elment | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/python.html Python demo
 * @memberof ApiElements
 */
class PythonHttpSnippets extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
    }`;
  }

  _renderPage(selected) {
    const { url, method, payload, headers } = this;
    switch (selected) {
      case 0: return html`<requests-python-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></requests-python-http-snippet>`;
      case 1: return html`<python-27-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></python-27-http-snippet>`;
      case 2: return html`<python-31-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></python-31-http-snippet>`;
    }
  }

  render() {
    const { selected, compatibility } = this;
    return html`
    <anypoint-tabs
      ?compatibility="${compatibility}"
      .selected="${selected}"
      @selected-changed="${this._selectedCHanged}">
      <anypoint-tab>Requests</anypoint-tab>
      <anypoint-tab>Python 2.7</anypoint-tab>
      <anypoint-tab>Python 3.1</anypoint-tab>
    </anypoint-tabs>
    ${this._renderPage(selected)}
    `;
  }

  static get properties() {
    return {
      selected: { type: Number },
      /**
       * Request URL
       */
      url: { type: String },
      /**
       * HTTP method
       */
      method: { type: String },
      /**
       * Parsed HTTP headers.
       * Each item contains `name` and `value` properties.
       * @type {Array<Object>}
       */
      headers: { type: Array },
      /**
       * HTTP body (the message)
       */
      payload: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean }
    };
  }

  constructor() {
    super();
    this.selected = 0;
  }
  /**
   * Handler for `selected-changed` event dispatched on anypoint-tabs.
   * @param {CustomEvent} e
   */
  _selectedCHanged(e) {
    const { value } = e.detail;
    this.selected = value;
  }
}
window.customElements.define('python-http-snippets', PythonHttpSnippets);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `c-curl-http-snippet`
 *
 * A snippet for requests made in C using curl library.
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/c-curl.html C curl demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class CcurlHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'clike';
  }

  get _codeHeaders() {
    return '#include <stdio.h>\n#include <curl/curl.h>\n\n';
  }

  /**
   * Computes code for C with curl.
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    let result = this._codeHeaders;
    result += 'int main(void)\n{\n';
    result += '\tCURL *curl;\n\tCURLcode res;\n\n';
    result += '\tcurl = curl_easy_init();\n';
    result += `\tcurl_easy_setopt(curl, CURLOPT_URL, "${url}");\n`;
    result += `\tcurl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "${method}");\n`;
    result += '\t/* if redirected, tell libcurl to follow redirection */\n';
    result += '\tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\n';
    if (headers && headers instanceof Array) {
      result += '\tstruct curl_slist *headers = NULL;\n';
      headers.forEach((h) => {
        result += `\theaders = curl_slist_append(headers, "${h.name}: ${h.value}");\n`;
      });
      result += '\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n';
    }
    if (payload) {
      result += '\n';
      payload = String(payload);
      const re = /"/g;
      result += '\tchar *body ="';
      payload.split('\n').map(function(line) {
        result += line.replace(re, '\\"');
      });
      result += '";\n';
      result += '\tcurl_easy_setopt(curl, CURLOPT_POSTFIELDS, body);\n';
    }
    result += '\n\t/* Perform the request, res will get the return code */\n';
    result += '\tres = curl_easy_perform(curl);\n';
    result += '\tif (res != CURLE_OK) {\n';
    result += '\t\tfprintf(stderr, "curl_easy_perform() failed: %s\\n"';
    result += ', curl_easy_strerror(res));\n';
    result += '\t}\n';
    result += '\t/* Clean up after yourself */\n';
    result += '\tcurl_easy_cleanup(curl);\n';
    result += '\treturn 0;\n';
    result += '}\n';
    result += '/* See: http://stackoverflow.com/a/2329792/1127848 of how ';
    result += 'to read data from the response. */';
    return result;
  }
}
window.customElements.define('c-curl-http-snippet', CcurlHttpSnippet);

!function(e){var t=/\b(?:abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while|var|null|exports|module|open|opens|provides|requires|to|transitive|uses|with)\b/,a=/\b[A-Z](?:\w*[a-z]\w*)?\b/;e.languages.java=e.languages.extend("clike",{"class-name":[a,/\b[A-Z]\w*(?=\s+\w+\s*[;,=())])/],keyword:t,function:[e.languages.clike.function,{pattern:/(\:\:)[a-z_]\w*/,lookbehind:!0}],number:/\b0b[01][01_]*L?\b|\b0x[\da-f_]*\.?[\da-f_p+-]+\b|(?:\b\d[\d_]*\.?[\d_]*|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,operator:{pattern:/(^|[^.])(?:<<=?|>>>?=?|->|([-+&|])\2|[?:~]|[-+*/%&|^!=<>]=?)/m,lookbehind:!0}}),e.languages.insertBefore("java","class-name",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0},namespace:{pattern:/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)[a-z]\w*(\.[a-z]\w*)+/,lookbehind:!0,inside:{punctuation:/\./}},generics:{pattern:/<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,inside:{"class-name":a,keyword:t,punctuation:/[<>(),.:]/,operator:/[?&|]/}}});}(Prism);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `java-platform-http-snippet`
 *
 * A snippet for requests made in Java using the platform functions
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/java-platform.html Java Platform demo
 * @demo demo/java.html Java demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class JavaPlatformHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'java';
  }

  /**
   * Computes code for Java (patform).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    url = String(url);
    let result = `URL url = new URL("${url}");\n`;
    let klass = 'Http';
    if (url.indexOf('https') === 0) {
      klass += 's';
    }
    klass += 'URLConnection';
    result += `${klass} con = (${klass}) url.openConnection();\n`;
    result += `con.setRequestMethod("${method}");\n`;
    result += this._genHeadersPart(headers);
    result += this._genPayloadPart(payload);
    result += '\n';
    result += 'int status = con.getResponseCode();\n';
    result += 'BufferedReader in = new BufferedReader(';
    result += 'new InputStreamReader(con.getInputStream()));\n';
    result += 'String inputLine;\n';
    result += 'StringBuffer content = new StringBuffer();\n';
    result += 'while((inputLine = in.readLine()) != null) {\n';
    result += '\tcontent.append(inputLine);\n';
    result += '}\n';
    result += 'in.close();\n';
    result += 'con.disconnect();\n';
    result += 'System.out.println("Response status: " + status);\n';
    result += 'System.out.println(content.toString());';
    return result;
  }

  _genHeadersPart(headers) {
    let result = '';
    if (headers && headers.length) {
      headers.forEach((h) => {
        result += `con.setRequestProperty("${h.name}", "${h.value}");\n`;
      });
    }
    return result;
  }

  _genPayloadPart(payload) {
    let result = '';
    if (payload) {
      result += '\n/* Payload support */\n';
      result += 'con.setDoOutput(true);\n';
      result += 'DataOutputStream out = new DataOutputStream(con.getOutputStream());\n';
      const list = this._payloadToList(payload);
      list.forEach((line) => {
        result += `out.writeBytes("${line}\\n");\n`;
      });
      result += 'out.flush();\n';
      result += 'out.close();\n';
    }
    return result;
  }

  _payloadToList(payload) {
    return payload.split('\n').map((item) => item.replace(/"/g, '\\"'));
  }
}
window.customElements.define('java-platform-http-snippet', JavaPlatformHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `java-spring-http-snippet`
 *
 * A snippet for requests made in Java using the spring functions
 *
 * ### Styling
 *
 * See `http-code-snippets` for styling documentation.
 *
 * @customElement
 * @polymer
 * @demo demo/java-spring.html Java Spring demo
 * @demo demo/java.html Java demo
 * @memberof ApiElements
 * @extends BaseCodeSnippet
 */
class JavaSpringHttpSnippet extends BaseCodeSnippet {
  get lang() {
    return 'java';
  }
  /**
   * Computes code for Java (Spring).
   * @param {String} url
   * @param {String} method
   * @param {Array<Object>|undefined} headers
   * @param {String} payload
   * @return {String} Complete code for given arguments
   */
  _computeCommand(url, method, headers, payload) {
    if (!url || !method) {
      return '';
    }
    let result = `RestTemplate rest = new RestTemplate();\n`;
    result += 'HttpHeaders headers = new HttpHeaders();\n';
    result += this._genHeadersPart(headers);
    result += this._genPayloadPart(payload);
    result += '\n';
    result += 'HttpEntity<String> requestEntity = new HttpEntity<String>(body, headers);\n';
    result += 'ResponseEntity<String> responseEntity = rest.exchange(';
    result += `"${url}", HttpMethod.${method}, requestEntity, String.class);\n`;
    result += 'int status = responseEntity.getStatusCode();\n';
    result += 'String response = responseEntity.getBody();\n';
    result += 'System.out.println("Response status: " + status);\n';
    result += 'System.out.println(response);';
    return result;
  }

  _genHeadersPart(headers) {
    let result = '';
    if (headers && headers.length) {
      headers.forEach((h) => {
        result += `headers.add("${h.name}", "${h.value}");\n`;
      });
    }
    return result;
  }

  _genPayloadPart(payload) {
    let result = '';
    if (payload) {
      result += '\nStringBuilder sb = new StringBuilder();\n';
      const list = this._payloadToList(payload);
      list.forEach((line) => {
        result += `sb.append("${line}\\n");\n`;
      });
      result += 'String body = sb.toString();\n';
    } else {
      result += 'String body = "";\n';
    }
    return result;
  }

  _payloadToList(payload) {
    return payload.split('\n').map((item) => item.replace(/"/g, '\\"'));
  }
}
window.customElements.define('java-spring-http-snippet', JavaSpringHttpSnippet);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `javascript-http-snippet`
 *
 * A set of code snippets for Java requests.
 *
 * @customElement
 * @polymer
 * @demo demo/java.html Java demo
 * @memberof ApiElements
 */
class JavatHttpSnippets extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
    }`;
  }

  _renderPage(selected) {
    const { url, method, payload, headers } = this;
    switch (selected) {
      case 0: return html`<java-platform-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></java-platform-http-snippet>`;
      case 1: return html`<java-spring-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></java-spring-http-snippet>`;
    }
  }

  render() {
    const { selected, compatibility } = this;
    return html`
    <anypoint-tabs
      ?compatibility="${compatibility}"
      .selected="${selected}"
      @selected-changed="${this._selectedCHanged}">
      <anypoint-tab>Platform</anypoint-tab>
      <anypoint-tab>Spring</anypoint-tab>
    </anypoint-tabs>
    ${this._renderPage(selected)}`;
  }

  static get properties() {
    return {
      selected: { type: Number },
      /**
       * Request URL
       */
      url: { type: String },
      /**
       * HTTP method
       */
      method: { type: String },
      /**
       * Parsed HTTP headers.
       * Each item contains `name` and `value` properties.
       * @type {Array<Object>}
       */
      headers: { type: Array },
      /**
       * HTTP body (the message)
       */
      payload: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true }
    };
  }
  constructor() {
    super();
    this.selected = 0;
  }
  /**
   * Handler for `selected-changed` event dispatched on anypoint-tabs.
   * @param {CustomEvent} e
   */
  _selectedCHanged(e) {
    const { value } = e.detail;
    this.selected = value;
  }
}
window.customElements.define('java-http-snippets', JavatHttpSnippets);

/**
 * `http-code-snippets`
 *
 * Code snippets to display code implementatyion examples for a HTTP request
 *
 * ## Polyfills
 *
 * This component requires `advanced-rest-client/URL` (or other) polyfill for
 * URL object. This spec is not supported in Safari 9 and IE 11.
 * If you are targeting this browsers install ind include this dependency.
 *
 * This component does not include polyfills.
 *
 * ## Styling
 *
 * See http-code-snippets-style.js file for styling definition.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 */
class HttpCodeSnippets extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
    }`;
  }

  render() {
    const { selected, scrollable, compatibility } = this;
    return html`
    <prism-highlighter></prism-highlighter>
    <anypoint-tabs
      .selected="${selected}"
      ?scrollable="${scrollable}"
      fitcontainer
      ?compatibility="${compatibility}"
      @selected-changed="${this._selectedCHanged}">
      <anypoint-tab>cURL</anypoint-tab>
      <anypoint-tab>HTTP</anypoint-tab>
      <anypoint-tab>JavaScript</anypoint-tab>
      <anypoint-tab>Python</anypoint-tab>
      <anypoint-tab>C</anypoint-tab>
      <anypoint-tab>Java</anypoint-tab>
    </anypoint-tabs>
    ${this._snippetTemplate()}`;
  }

  _snippetTemplate() {
    const { selected, url, method, payload, _headersList: headers, compatibility } = this;
    switch (selected) {
      case 0: return html`<curl-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></curl-http-snippet>`;
      case 1: return html`<raw-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></raw-http-snippet>`;
      case 2: return html`<javascript-http-snippets
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"
        ?compatibility="${compatibility}"></javascript-http-snippets>`;
      case 3: return html`<python-http-snippets
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"
        ?compatibility="${compatibility}"></python-http-snippets>`;
      case 4: return html`<c-curl-http-snippet
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"></c-curl-http-snippet>`;
      case 5: return html`<java-http-snippets
        .url="${url}"
        .method="${method}"
        .payload="${payload}"
        .headers="${headers}"
        ?compatibility="${compatibility}"></java-http-snippets>`;
    }
  }

  static get properties() {
    return {
      /**
       * Currently selected tab for the platform row.
       */
      selected: { type: Number },
      /**
       * Computed list of headers from `headers` property.
       * It is an array of objects where each object contains `name` and `value`
       * properties.
       * @type {Array<Object>}
       */
      _headersList: { type: Array },
      // Passed to `anypoint-tabs` `scrollable` property
      scrollable: { type: Boolean },
      /**
       * Request URL
       */
      url: { type: String },
      /**
       * HTTP method
       */
      method: { type: String },
      /**
       * Parsed HTTP headers.
       * Each item contains `name` and `value` properties.
       */
      headers: { type: String },
      /**
       * HTTP body (the message)
       */
      payload: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true }
    };
  }

  get headers() {
    return this._headers;
  }

  set headers(value) {
    const old = this._headers;
    if (old === value) {
      return;
    }
    this._headers = value;
    this._headersList = this.headersToList(value);
  }

  constructor() {
    super();
    this.selected = 0;
  }
  /**
   * Handler for `selected-changed` event dispatched on anypoint-tabs.
   * @param {CustomEvent} e
   */
  _selectedCHanged(e) {
    const { value } = e.detail;
    this.selected = value;
  }
  /**
   * Computes a list of headers from a headers string.
   * @param {?String} headers
   * @return {Array} Headers as a list od maps. Can be empty.
   */
  headersToList(headers) {
    headers = headers || this.headers;
    if (!headers || !headers.trim() || typeof headers !== 'string') {
      return [];
    }
    const result = [];
    headers = headers.replace('\\n', '\n');
    headers = headers.split(/\n(?=[^ \t]+)/gim);
    for (let i = 0, len = headers.length; i < len; i++) {
      const line = headers[i].trim();
      if (line === '') {
        continue;
      }
      const sepPosition = line.indexOf(':');
      if (sepPosition === -1) {
        result[result.length] = {
          name: line,
          value: ''
        };
        continue;
      }
      const name = line.substr(0, sepPosition);
      const value = line.substr(sepPosition + 1).trim();
      const obj = {
        name: name,
        value: value
      };
      result.push(obj);
    }
    return result;
  }
}
window.customElements.define('http-code-snippets', HttpCodeSnippets);

/**
 * `api-oauth2-settings-document`
 *
 * Documentation view for AMF OAuth2 security settings.
 *
 * Settings can be passed by setting the `settings` property to AMF's
 * settings property of Security Scheme.
 *
 * ```html
 * <api-oauth2-settings-document
 *  amf-model="{...}"
 *  settings="{...}"></api-oauth1-settings-document>
 * ```
 *
 * It is also possible to set corresponding properties directly.
 *
 * ```html
 * <api-oauth2-settings-document
 *  amf-model="{...}"
 *  access-token-uri="https://..."
 *  authorization-uri="https://..."
 *  authorization-grants='["implicit"]'></api-oauth1-settings-document>
 * ```
 *
 * ## Styling
 *
 * `<api-oauth2-settings-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-oauth2-settings-document` | Mixin applied to this elment | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiOauth2SettingsDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
    }

    h4 {
      font-size: var(--arc-font-subhead-font-size);
      font-weight: var(--arc-font-subhead-font-weight);
      line-height: var(--arc-font-subhead-line-height);
      user-select: text;
    }

    ul {
      maring: 0;
      padding: 0;
    }

    .settings-value {
      background: var(--code-background-color, #f5f2f0);
      display: block;
      padding: 1em;
      margin: .5em 0;
      user-select: text;
    }

    .settings-list-value {
      background: var(--code-background-color, #f5f2f0);
      display: block;
      padding: 1em;
      user-select: text;
    }`;
  }

  render() {
    const { accessTokenUri, authorizationUri, authorizationGrants, scopes } = this;
    // const hasCustomProperties = this._computeHasCustomProperties(settings);
    return html`
    ${accessTokenUri ? html`<h4 data-type="access-token-uri">Access token URI</h4>
    <code class="settings-value">${accessTokenUri}</code>` : undefined}

    ${authorizationUri ? html`<h4 data-type="authorization-uri">Authorization URI</h4>
    <code class="settings-value">${authorizationUri}</code>` : undefined}

    ${authorizationGrants && authorizationGrants.length ? html`<h4 data-type="authorization-grants">Authorization grants</h4>
    <ul>
    ${authorizationGrants.map((item) => html`<li class="settings-list-value">${item}</li>`)}
    </ul>` : undefined}

    ${scopes && scopes.length ? html`<h4 data-type="authorization-scopes">Authorization scopes</h4>
    <ul>
    ${scopes.map((item) => html`<li class="settings-list-value">${item.label}</li>`)}
    </ul>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * OAuth2 settings scheme of AMF.
       * When this property changes it resets other properties.
       * @type {Object}
       */
      settings: { type: Object },
      /**
       * Access token URI value.
       * This property is updated when `settings` property chnage.
       */
      accessTokenUri: { type: String },
      /**
       * Authorization URI value.
       * This property is updated when `settings` property chnage.
       */
      authorizationUri: { type: String },
      /**
       * List of OAuth2 authorization grants.
       * This property is updated when `settings` property chnage.
       * @type {Array<String>}
       */
      authorizationGrants: { type: Array },
      /**
       * List of OAuth2 authorization scopes.
       * This property is updated when `settings` property chnage.
       *
       * Each array item must have `label` and optional `description`
       * properties.
       * @type {Array<Object>}
       */
      scopes: { type: Array }
    };
  }

  get settings() {
    return this._settings;
  }

  set settings(value) {
    const old = this._settings;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._settings = value;
    this._settingsChanged(value);
  }
  /**
   * Called automatically when `settings` property change (whole object,
   * not sub property).
   * Sets values of all other properties to the one found in the AMF.
   *
   * @param {Object} settings AMF settings to process.
   */
  _settingsChanged(settings) {
    const accessTokenUri = this._computeAccessTokenUri(settings);
    const authorizationUri = this._computeAuthorizationUri(settings);
    let authorizationGrants = this._computeAuthorizationGrants(settings);
    let scopes = this._computeScopes(settings);
    if (authorizationGrants && !(authorizationGrants instanceof Array)) {
      authorizationGrants = [authorizationGrants];
    }
    if (scopes && !(scopes instanceof Array)) {
      scopes = [scopes];
    }

    this.accessTokenUri = accessTokenUri;
    this.authorizationUri = authorizationUri;
    this.authorizationGrants = authorizationGrants;
    this.scopes = scopes;
  }
  /**
   * Computes value for `accessTokenUri` property.
   * @param {Object} settings OAuth2 settings from AMF model.
   * @return {String|undefined}
   */
  _computeAccessTokenUri(settings) {
    return this._getValue(settings, this.ns.raml.vocabularies.security + 'accessTokenUri');
  }
  /**
   * Computes value for `authorizationUri` property.
   * @param {Object} settings OAuth2 settings from AMF model.
   * @return {String|undefined}
   */
  _computeAuthorizationUri(settings) {
    return this._getValue(settings, this.ns.raml.vocabularies.security + 'authorizationUri');
  }
  /**
   * Computes value for `authorizationGrants` property.
   * @param {Object} settings OAuth2 settings from AMF model.
   * @return {Array<String>|undefined}
   */
  _computeAuthorizationGrants(settings) {
    return this._getValueArray(settings, this.ns.raml.vocabularies.security + 'authorizationGrant');
  }
  /**
   * Computes value for `scopes` property.
   * @param {Object} settings OAuth2 settings from AMF model.
   * @return {Array<Object>|undefined}
   */
  _computeScopes(settings) {
    if (!this._hasProperty(settings, this.ns.raml.vocabularies.security + 'scope')) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.security + 'scope');
    const scopes = this._ensureArray(settings[key]);
    return scopes.map((item) => {
      return {
        description: this._computeDescription(item),
        label: this._getValue(item, this.ns.raml.vocabularies.security + 'name')
      };
    });
  }
}
window.customElements.define('api-oauth2-settings-document', ApiOauth2SettingsDocument);

/**
 * `api-oauth1-settings-document`
 *
 * Documentation view for AMF OAuth2 security settings.
 *
 * Settings can be passed by setting the `settings` property to AMF's
 * settings property of Security Scheme.
 *
 * ```html
 * <api-oauth1-settings-document
 *  amf-model="{...}"
 *  settings="{...}"></api-oauth1-settings-document>
 * ```
 *
 * It is also possible to set corresponding properties directly.
 *
 * ```html
 * <api-oauth1-settings-document
 *  amf-model="{...}"
 *  request-token-uri="https://..."
 *  authorization-uri="https://..."
 *  signatures='["RSA-SHA1"]'></api-oauth1-settings-document>
 * ```
 *
 * ## Styling
 *
 * `<api-oauth1-settings-document>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-oauth1-settings-document` | Mixin applied to this elment | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiOauth1SettingsDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
    }

    h4 {
      font-size: var(--arc-font-subhead-font-size);
      font-weight: var(--arc-font-subhead-font-weight);
      line-height: var(--arc-font-subhead-line-height);
    }

    .settings-value {
      background: var(--code-background-color, #f5f2f0);
      display: block;
      padding: 1em;
      margin: .5em 0;
    }`;
  }

  render() {
    const { requestTokenUri, authorizationUri, tokenCredentialsUri, signatures } = this;
    return html`
    ${requestTokenUri ? html`<h4 data-type="request-token-uri">Request token URI</h4>
    <code class="settings-value">${requestTokenUri}</code>` : undefined}

    ${authorizationUri ? html`<h4 data-type="authorization-uri">Authorization URI</h4>
    <code class="settings-value">${authorizationUri}</code>` : undefined}

    ${tokenCredentialsUri ? html`<h4 data-type="token-credentials-uri">Token credentials URI</h4>
    <code class="settings-value">${tokenCredentialsUri}</code>` : undefined}

    ${signatures && signatures.length ? html`
      <h4 data-type="signatures">Supported signatures</h4>
      <ul>
      ${signatures.map((item) => html`<li>${item}</li>`)}
      </ul>
      ` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * OAuth1 settings scheme of AMF.
       * When this property changes it resets other properties.
       * @type {Object}
       */
      settings: { type: Object },
      /**
       * The request token URI from the settings model.
       * Automatically set when `settings` property change.
       */
      requestTokenUri: { type: String },
      /**
       * The authorization endpoint URI.
       * Automatically set when `settings` property change.
       */
      authorizationUri: { type: String },
      /**
       * Token credentials endpoint URI.
       * Automatically set when `settings` property change.
       */
      tokenCredentialsUri: { type: String },
      /**
       * List of signatures used by this authorization server.
       * Automatically set when `settings` property change.
       * @type {Array<String>}
       */
      signatures: { type: Array }
    };
  }

  get settings() {
    return this._settings;
  }

  set settings(value) {
    const old = this._settings;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._settings = value;
    this._settingsChanged(value);
  }

  /**
   * Called automatically when `settings` property change (whole object,
   * not sub property).
   * Sets values of all other properties to the one found in the AMF.
   *
   * @param {Object} settings AMF settings to process.
   */
  _settingsChanged(settings) {
    const requestTokenUri = this._computeRequestTokenUri(settings);
    const authorizationUri = this._computeAuthorizationUri(settings);
    const tokenCredentialsUri = this._computeTokenCredentialsUri(settings);
    const signatures = this._computeSignatures(settings);

    this.requestTokenUri = requestTokenUri;
    this.authorizationUri = authorizationUri;
    this.tokenCredentialsUri = tokenCredentialsUri;
    this.signatures = signatures;
  }
  /**
   * If passed argument is an array it returns first object from it. Otherwise
   * it returns the object.
   * @param {any} result
   * @return {any}
   */
  _deArray(result) {
    if (result instanceof Array) {
      result = result[0];
    }
    return result;
  }
  /**
   * Computes value of request token endpoint URI.
   * @param {Object} settings AMF settings to process.
   * @return {String|undefined} Request token URI value
   */
  _computeRequestTokenUri(settings) {
    const result = this._getValue(settings, this.ns.raml.vocabularies.security + 'requestTokenUri');
    return this._deArray(result);
  }
  /**
   * Computes value of authorization endpoint URI.
   * @param {Object} settings AMF settings to process.
   * @return {String|undefined} Authorization URI value
   */
  _computeAuthorizationUri(settings) {
    const result = this._getValue(settings, this.ns.raml.vocabularies.security + 'authorizationUri');
    return this._deArray(result);
  }
  /**
   * Computes value of token credentials endpoint URI.
   * @param {Object} settings AMF settings to process.
   * @return {String|undefined} Token credentials URI value
   */
  _computeTokenCredentialsUri(settings) {
    const result = this._getValue(settings, this.ns.raml.vocabularies.security + 'tokenCredentialsUri');
    return this._deArray(result);
  }
  /**
   * Computes value of OAuth1 signatures.
   * @param {Object} settings AMF settings to process.
   * @return {Array<String>|undefined} List of signatures.
   */
  _computeSignatures(settings) {
    return this._getValueArray(settings, this.ns.raml.vocabularies.security + 'signature');
  }
}
window.customElements.define('api-oauth1-settings-document', ApiOauth1SettingsDocument);

/**
 * `api-security-documentation`
 *
 * Documentation view for AMF security description
 *
 * ## Styling
 *
 * `<api-security-documentation>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-security-documentation` | Mixin applied to this elment | `{}`
 * `--arc-font-headline` | Theme mixin, Applied to H1 element | `{}`
 * `--api-security-documentation-title` | Mixin applied to the H1 element | `{}`
 * `--api-security-documentation-title-narrow` | Mixin applied to the H1 element in narrow layout | `{}`
 * `--arc-font-title` | Theme mixin, applied to h2 element | `{}`
 * `--api-security-documentation-main-section-title` | Mixin applied to main sections title element | `{}`
 * `--api-security-documentation-main-section-title-narrow` | Mixin applied to main sections title element in narrow layout | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiSecurityDocumentation extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      css`:host {
        display: block;
      }

      h2 {
        font-size: var(--arc-font-headline-font-size);
        font-weight: var(--arc-font-headline-font-weight);
        letter-spacing: var(--arc-font-headline-letter-spacing);
        line-height: var(--arc-font-headline-line-height);
      }

      h3 {
        font-size: var(--arc-font-title-font-size);
        font-weight: var(--arc-font-title-font-weight);
        line-height: var(--arc-font-title-line-height);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      :host([narrow]) h1 {
        font-size: 20px;
        margin: 0;
      }

      :host([narrow]) h2 {
        font-size: 18px;
      }

      arc-marked {
        padding: 0;
      }`
    ];
  }

  render() {
    const { description, aware, type, security, settings, amf, queryParameters, headers, responses, narrow } = this;
    const hasCustomProperties = this._computeHasCustomProperties(security);
    let hasOauth1Settings = false;
    let hasOauth2Settings = false;
    if (settings) {
      hasOauth1Settings = this._computeHasOA1Settings(settings);
      hasOauth2Settings = this._computeHasOA2Settings(settings);
    }
    return html`
    ${aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" .scope="${aware}"></raml-aware>` : undefined}

    <section class="title">
      <h2>${type}</h2>
    </section>

    ${hasCustomProperties ? html`<api-annotation-document
      .shape="${security}"></api-annotation-document>`:undefined}

    ${description ? html`<arc-marked .markdown="${description}">
      <div slot="markdown-html" class="markdown-body"></div>
    </arc-marked>`:undefined}

    ${hasOauth1Settings ? html`<h3 class="settings-title">Settings</h3>
      <api-oauth1-settings-document
      .amf="${amf}"
      .settings="${settings}"></api-oauth1-settings-document>` : undefined}

    ${hasOauth2Settings ? html`<h3 class="settings-title">Settings</h3>
      <api-oauth2-settings-document
      .amf="${amf}"
      .settings="${settings}"></api-oauth2-settings-document>` : undefined}

    ${queryParameters && queryParameters.length ?
      html`<api-parameters-document
        .amf="${amf}"
        queryopened
        .queryParameters="${queryParameters}"
        ?narrow="${narrow}"></api-parameters-document>` :
      undefined}

    ${headers && headers.length ?
      html`<api-headers-document
        opened
        .amf="${amf}"
        .headers="${headers}"
        ?narrow="${narrow}"></api-headers-document>` :
      undefined}

    ${responses && responses.length ?
      html`<section class="response-documentation">
        <h3>Responses</h3>
        <api-responses-document
          .amf="${amf}"
          .returns="${responses}"
          ?narrow="${narrow}"></api-responses-document>
      </section>` :
      undefined}`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * A security definition to render.
       * This should be AMF's type of `http://raml.org/vocabularies/security#SecurityScheme`.
       *
       * @type {Object}
       */
      security: { type: Object },
      /**
       * Computed value, scheme of the security
       */
      _scheme: { type: Object },
      /**
       * Security scheme type name.
       * The value is updated automatically when `security` property change.
       */
      type: { type: String },
      /**
       * Security scheme description.
       * The value is updated automatically when `security` property change.
       */
      description: { type: String },
      /**
       * AMF headers model.
       * List of headers to apply to this scheme.
       * This value is updated automatically when `security` property change.
       * @type {Array<Object>}
       */
      headers: { type: Array },
      /**
       * AMF query parameters model.
       * List of query parameters to apply to this scheme.
       * This value is updated automatically when `security` property change.
       * @type {Array<Object>}
       */
      queryParameters: { type: Array },
      /**
       * AMF responses model.
       * List of responses applied to this security scheme.
       * This value is updated automatically when `security` property change.
       * @type {Array<Object>}
       */
      responses: { type: Array },
      /**
       * AMF settings model for a security scheme.
       * This value is updated automatically when `security` property change.
       * @type {Object}
       */
      settings: { type: Object },
      /**
       * Set to render a mobile friendly view.
       */
       narrow: { type: Boolean, reflect: true }
    };
  }

  get amf() {
    return this._amf;
  }

  set amf(value) {
    const old = this._amf;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._amf = value;
    this._scheme = this._computeScheme(this.security);
    this.requestUpdate('amf', old);
  }

  get security() {
    return this._security;
  }

  set security(value) {
    const old = this._security;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._security = value;
    this._scheme = this._computeScheme(value);
    this.requestUpdate('security', old);
  }

  get _scheme() {
    return this.__scheme;
  }

  set _scheme(value) {
    const old = this.__scheme;
    if (old === value) {
      return;
    }
    this.__scheme = value;
    this._schemeChanged(value);
  }
  /**
   * Computes value of security scheme's scheme model.
   * @param {Array|Object} security AMF security description.
   * @return {Object} Security's scheme model.
   */
  _computeScheme(security) {
    if (!security) {
      return;
    }
    if (security instanceof Array) {
      security = security[0];
    }
    if (this._hasType(security, this.ns.raml.vocabularies.security + 'SecurityScheme')) {
      return security;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.security + 'scheme');
    let scheme = security[key];
    if (!scheme) {
      return;
    }
    if (scheme instanceof Array) {
      scheme = scheme[0];
    }
    return scheme;
  }
  /**
   * Computes values for prroperties like `type`, `description`, `headers`,
   * `queryParameters`, `responses` and `settings` when `scheme` property
   * change.
   * @param {Object} scheme Scheme model to process.
   */
  _schemeChanged(scheme) {
    this.type = this._computeType(scheme);
    this.description = this._computeDescription(scheme);
    let headers = this._computeHeaders(scheme);
    if (headers && !(headers instanceof Array)) {
      headers = [headers];
    }
    this.headers = headers;
    let queryParameters = this._computeQueryParameters(scheme);
    if (queryParameters && !(queryParameters instanceof Array)) {
      queryParameters = [queryParameters];
    }
    this.queryParameters = queryParameters;
    let responses = this._computeResponses(scheme);
    if (responses && !(responses instanceof Array)) {
      responses = [responses];
    }
    this.responses = responses;
    this.settings = this._computeSettings(scheme);
  }
  /**
   * Computes value for security type.
   * @param {Object} shape Scheme model.
   * @return {String|undefined}
   */
  _computeType(shape) {
    return this._getValue(shape, this.ns.raml.vocabularies.security + 'type');
  }
  /**
   * Computes scheme's settings model.
   * @param {Object} shape Scheme model.
   * @return {Object|undefined} Settings model
   */
  _computeSettings(shape) {
    return this._computePropertyObject(shape, this.ns.raml.vocabularies.security + 'settings');
  }
  /**
   * @param {Object|undefined} settings Computed settings object
   * @return {Boolean} True if this settings represents OAuth 2 settings
   */
  _computeHasOA2Settings(settings) {
    if (!settings) {
      return false;
    }
    return this._hasType(settings, this.ns.raml.vocabularies.security + 'OAuth2Settings');
  }
  /**
   * @param {Object|undefined} settings Computed settings object
   * @return {Boolean}
   */
  _computeHasOA1Settings(settings) {
    if (!settings) {
      return false;
    }
    return this._hasType(settings, this.ns.raml.vocabularies.security + 'OAuth1Settings');
  }

  _apiChangedHandler(e) {
    const { value } = e.detail;
    this.amf = value;
  }
}
window.customElements.define('api-security-documentation', ApiSecurityDocumentation);

/**
 * `api-method-documentation`
 *
 * Renders documentation for a method for an endpoint.
 *
 * This element works with [AMF](https://github.com/mulesoft/amf) data model.
 * To properly compute all the information relevant to method documentation
 * set the following properties:
 *
 * - amf - as AMF's WebApi data model
 * - endpoint - As AMF's EndPoint data model
 * - method - As AMF's SupportedOperation property
 *
 * When set, this will automatically populate the wiew with data.
 *
 * ## Updating API's base URI
 *
 * By default the component render the documentation as it is defined
 * in the AMF model. Sometimes, however, you may need to replace the base URI
 * of the API with something else. It is useful when the API does not
 * have base URI property defined (therefore this component render relative
 * paths instead of URIs) or when you want to manage different environments.
 *
 * To update base URI value either update `baseUri` property or use
 * `iron-meta` with key `ApiBaseUri`. First method is easier but the second
 * gives much more flexibility since it use a
 * [monostate pattern](http://wiki.c2.com/?MonostatePattern)
 * to manage base URI property.
 *
 * When the component constructs the funal URI for the endpoint it does the
 * following:
 * - if `baseUri` is set it uses this value as a base uri for the endpoint
 * - else if `iron-meta` with key `ApiBaseUri` exists and contains a value
 * it uses it uses this value as a base uri for the endpoint
 * - else if `amf` is set then it computes base uri value from main
 * model document
 * Then it concatenates computed base URI with `endpoint`'s path property.
 *
 * ### Example
 *
 * ```html
 * <iron-meta key="ApiBaseUri" value="https://domain.com"></iron-meta>
 * ```
 *
 * To update value of the `iron-meta`:
 * ```javascript
 * new Polymer.IronMeta({key: 'ApiBaseUri'}).value = 'https://other.domain';
 * ```
 *
 * Note: The element will not get notified about the change in `iron-meta`.
 * The change will be reflected whehn `amf` or `endpoint` property chnage.
 *
 * ## Styling
 *
 * `<api-method-documentation>` provides the following custom properties and
 * mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-method-documentation` | Mixin applied to this elment | `{}`
 * `--arc-font-headline` | Theme mixin, Applied to H1 element | `{}`
 * `--api-method-documentation-title` | Mixin applied to the H1 element | `{}`
 * `--api-method-documentation-title-narrow` | Mixin applied to the H1 element
 * in narrow layout | `{}`
 * `--arc-font-title` | Theme mixin, applied to h2 element | `{}`
 * `--api-method-documentation-main-section-title` | Mixin applied to main
 * sections title element (reqyest and response) | `{}`
 * `--api-method-documentation-main-section-title-narrow` | Mixin applied to
 * main sections title element (reqyest and response) in narrow layout | `{}`
 * `--api-method-documentation-subsection-title` | Mixin applied to sub section
 * titles | `{}`
 * `--api-method-documentation-subsection-title-narrow` | Mixin applied to
 * sub section titles in narrow layout | `{}`
 * `--api-method-documentation-title-method-font-weight` | Font weight of method name title. | `500`
 * `--arc-font-code1` | Theme mixin, applied to the URL area | `{}`
 * `--api-method-documentation-url-font-size` | Font size of endpoin URL | `16px`
 * `--api-method-documentation-url-background-color` | Background color of
 * the URL section | `#424242`
 * `--api-method-documentation-url-font-color` | Font color of the URL area | `#fff`
 * `--api-method-documentation-try-it-background-color` | Background color
 * of the Try it button | `--primary-color`
 * `--api-method-documentation-try-it-color` | Color of the Try it button |
 * `--primary-action-color` or `#fff`
 * `--api-method-documentation-try-it-background-color-hover` | Background
 * color of the Try it button when hovered | `--primary-color`
 * `--api-method-documentation-try-it-color-hover` | Color of the Try it
 * button when hovered | `--primary-action-color` or `#fff`
 * `--api-method-documentation-bottom-navigation-border-color` | Color of
 * the top border of the bottom navigartion | `#546E7A`
 * `--api-method-documentation-bottom-navigation-color` | Color of of the
 * bottom navigartion (icon + text) | `#546E7A`
 * `--api-method-documentation-main-sections` | Mixin applied to both request
 * and response sections | `{}`
 * `--api-method-documentation-docs-sections` | Mixin applied to each
 * documentation block | `{}`
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiMethodDocumentation extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      labelStyles,
      css`:host {
        display: block;
        font-size: var(--arc-font-body1-font-size, inherit);
        font-weight: var(--arc-font-body1-font-weight, inherit);
        line-height: var(--arc-font-body1-line-height, inherit);
      }

      [hidden] {
        display: none !important;
      }

      .title {
        font-size: var(--arc-font-headline-font-size);
        letter-spacing: var(--arc-font-headline-letter-spacing);
        line-height: var(--arc-font-headline-line-height);
        font-weight: var(--api-method-documentation-title-method-font-weight,
          var(--arc-font-headline-font-weight, 500));
        text-transform: capitalize;
      }

      .heading2 {
        font-size: var(--arc-font-title-font-size);
        font-weight: var(--arc-font-title-font-weight);
        line-height: var(--arc-font-title-line-height);
        margin: 0.84em 0;
      }

      .heading3 {
        flex: 1;
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
      }

      .title-area {
        flex-direction: row;
        display: flex;
        align-items: center;
      }

      :host([narrow]) .title-area {
        margin-bottom: 24px;
      }

      :host([narrow]) .title-area {
        margin-top: 12px;
      }

      :host([narrow]) .title {
        font-size: 20px;
        margin: 0;
      }

      :host([narrow]) .heading2 {
        font-size: 18px;
      }

      :host([narrow]) .heading3 {
        font-size: 17px;
      }

      .title {
        flex: 1;
      }

      .url-area {
        flex: 1;
        display: flex;
        flex-direction: row;
        align-items: center;
        font-family: var(--arc-font-code-family);
        font-size: var(--api-method-documentation-url-font-size, 16px);
        margin-bottom: 40px;
        margin-top: 20px;
        background-color: var(--code-background-color);
        color: var(--code-color);
        padding: 8px;
        border-radius: var(--api-method-documentation-url-border-radius, 4px);
        position: relative;
      }

      .section-title-area {
        display: flex;
        flex-direction: row;
        align-items: center;
        border-bottom: 1px var(--api-parameters-document-title-border-color, #e5e5e5) solid;
        cursor: pointer;
        user-select: none;
      }

      .url-value {
        flex: 1;
        margin-left: 12px;
        word-break: break-all;
      }

      .method-value {
        text-transform: uppercase;
        white-space: nowrap;
      }

      .toggle-icon {
        margin-left: 8px;
        transform: rotateZ(0deg);
        transition: transform 0.3s ease-in-out;
      }

      .toggle-icon.opened {
        transform: rotateZ(-180deg);
      }

      http-code-snippets {
        margin-bottom: 40px;
      }

      .bottom.action {
        display: flex;
        flex-direction: row;
        justify-content: flex-end;
        margin-top: 20px;
      }

      arc-marked {
        margin: 8px 0;
        padding: 0px;
      }

      .markdown-body {
        margin-bottom: 28px;
        color: var(--api-method-documentation-description-color, rgba(0, 0, 0, 0.74));
      }

      .summary {
        color: var(--api-method-documentation-description-color, rgba(0, 0, 0, 0.74));
        font-size: 1.1rem;
      }

      .method-label {
        margin-bottom: 0;
      }

      .bottom-nav,
      .bottom-link {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      .bottom-nav {
        padding: 32px 0;
        margin: 16px 0;
        border-top: 1px var(--api-method-documentation-bottom-navigation-border-color, #cfd8dc) solid;
        color: var(--api-method-documentation-bottom-navigation-color, #000);
        font-size: 18px;
      }

      .bottom-link {
        cursor: pointer;
        max-width: 50%;
        word-break: break-all;
      }

      .bottom-link.previous {
        margin-right: 12px;
      }

      .bottom-link.next {
        margin-left: 12px;
      }

      .nav-separator {
        flex: 1;
      }

      api-security-documentation {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px var(--api-headers-document-title-border-color, #e5e5e5) dashed;
      }

      api-security-documentation:last-of-type {
        margin-bottom: 0;
        border-bottom: none;
        padding-bottom: 0;
      }

      .extensions {
        font-style: italic;
        margin: 12px 0;
      }

      .request-documentation,
      .response-documentation {
        background-color: var(--api-method-documentation-section-background-color, initial);
        padding: var(--api-method-documentation-section-padding, 0px);
      }

      .icon {
        display: block;
        width: 24px;
        height: 24px;
        fill: currentColor;
      }`
    ];
  }


  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * AMF method definition as a `http://www.w3.org/ns/hydra/core#supportedOperation`
       * object.
       */
      method: { type: Object },
      /**
       * Method's endpoint definition as a
       * `http://raml.org/vocabularies/http#endpoint` of AMF model.
       */
      endpoint: { type: Object },
      /**
       * The try it button is not rendered when set.
       */
      noTryIt: { type: Boolean },
      /**
       * Computed value from the method model, name of the method.
       * It is either a `displayName` or HTTP method name
       */
      methodName: { type: String },
      /**
       * HTTP method name string.
       *
       * It is computed from `endpoint`.
       */
      httpMethod: { type: String },
      /**
       * A property to set to override AMF's model base URI information.
       * When this property is set, the `endpointUri` property is recalculated.
       */
      baseUri: { type: String },
      /**
       * Computed value, API version name
       */
      apiVersion: { type: String },
      /**
       * Endpoint URI to display in main URL field.
       * This value is computed when `amf`, `endpoint` or `baseUri` change.
       */
      endpointUri: { type: String },
      /**
       * Computed value of method description from `method` property.
       */
      description: { type: String },
      /**
       * Computed value from current `method`. True if the model contains
       * custom properties (annotations in RAML).
       */
      hasCustomProperties: { type: Boolean },
      /**
       * Computed value of `http://www.w3.org/ns/hydra/core#expects`
       * of AMF model from current `method`
       */
      expects: { type: Object },
      /**
       * Computed value of the `http://raml.org/vocabularies/http#server`
       * from `amf`
       */
      server: { type: Object },
      /**
       * API base URI parameters defined in AMF api model
       *
       * @type {Array|undefined}
       */
      serverVariables: { type: Array },
      /**
       * Endpoint's path parameters.
       *
       * @type {Array|undefined}
       */
      endpointVariables: { type: Array },
      /**
       * Computed value if server and endpoint definition of API model has
       * defined any variables.
       */
      hasPathParameters: { type: Boolean },
      /**
       * Computed value of method's query parameters.
       */
      queryParameters: { type: Array },
      /**
       * Computed value, true when either has path or query parameters.
       * This renders `api-parameters-document` if true.
       */
      hasParameters: { type: Boolean },
      /**
       * Computed value of AMF payload definition from `expects`
       * property.
       */
      payload: { type: Array },
      /**
       * Computed value of AMF payload definition from `expects`
       * property.
       */
      headers: { type: Array },
      /**
       * Computed value of AMF response definition from `returns`
       * property.
       */
      returns: { type: Array },
      /**
       * Computed value of AMF security definition from `method`
       * property.
       */
      security: { type: Array },
      /**
       * If set it will renders the view in the narrow layout.
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * Model to generate a link to previous HTTP method.
       * It should contain `id` and `label` properties
       */
      previous: { type: Object },
      /**
       * Model to generate a link to next HTTP method.
       * It should contain `id` and `label` properties
       */
      next: { type: Object },
      /**
       * When set code snippets are rendered.
       */
      _snippetsOpened: { type: Boolean },
      /**
       * When set security details are rendered.
       */
      securityOpened: { type: Boolean },
      /**
       * When set it renders code examples section is the documentation
       */
      renderCodeSnippets: { type: Boolean },

      /**
       * When set it renders security documentation when applicable
       */
      renderSecurity: { type: Boolean },
      /**
       * List of traits and resource types, if any.
       *
       * @type {Array<Object>}
       */
      extendsTypes: { type: Array },
      /**
       * List of traits appied to this endpoint
       *
       * @type {Array<Object>}
       */
      traits: { type: Array },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * When enabled it renders external types as links and dispatches
       * `api-navigation-selection-changed` when clicked.
       */
      graph: { type: Boolean },
      /**
       * OAS summary field.
       */
      methodSummary: { type: String },

      _renderSnippets: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get method() {
    return this._method;
  }

  set method(value) {
    const old = this._method;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._method = value;
    this._methodChanged();
  }

  get endpoint() {
    return this._endpoint;
  }

  set endpoint(value) {
    const old = this._endpoint;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._endpoint = value;
    this._endpointChanged();
  }

  get baseUri() {
    return this._baseUri;
  }

  set baseUri(value) {
    const old = this._baseUri;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._baseUri = value;
    this.endpointUri = this._computeEndpointUri(this.server, this.endpoint, value, this.apiVersion);
  }

  get expects() {
    return this._expects;
  }

  set expects(value) {
    const old = this._expects;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._expects = value;
    this.requestUpdate('expects', old);
    this._expectsChanged(value);
  }

  get _titleHidden() {
    if (!this.noTryIt) {
      return false;
    }
    const { methodName, httpMethod } = this;
    if (!methodName || !httpMethod) {
      return true;
    }
    if (methodName.toLowerCase() === httpMethod.toLowerCase()) {
      return true;
    }
    return false;
  }

  __amfChanged() {
    if (this.__amfProcessingDebouncer) {
      return;
    }
    this.__amfProcessingDebouncer = true;
    setTimeout(() => this._processModelChange());
  }

  _methodChanged() {
    if (this.__methodProcessingDebouncer) {
      return;
    }
    this.__methodProcessingDebouncer = true;
    setTimeout(() => this._processMethodChange());
  }

  _endpointChanged() {
    if (this.__endpointProcessingDebouncer) {
      return;
    }
    this.__endpointProcessingDebouncer = true;
    setTimeout(() => this._processEndpointChange());
  }

  _processModelChange() {
    this.__amfProcessingDebouncer = false;
    const { amf } = this;
    const apiVersion = this.apiVersion = this._computeApiVersion(amf);
    const server = this.server = this._computeServer(amf);
    this.endpointUri = this._computeEndpointUri(server, this.endpoint, this.baseUri, apiVersion);
    const serverVariables = this.serverVariables = this._computeServerVariables(server);
    const hasPathParameters = this.hasPathParameters =
      this._computeHasPathParameters(serverVariables, this.endpointVariables);
    this.hasParameters = hasPathParameters || !(this.queryParameters && this.queryParameters.length);
  }

  _processMethodChange() {
    this.__methodProcessingDebouncer = false;
    const { method } = this;
    this.methodName = this._computeMethodName(method);
    this.httpMethod = this._computeHttpMethod(method);
    this.description = this._computeDescription(method);
    this.hasCustomProperties = this._computeHasCustomProperties(method);
    this.expects = this._computeExpects(method);
    this.returns = this._computeReturns(method);
    this.security = this._computeSecurity(method);
    const extendsTypes = this.extendsTypes = this._computeExtends(method);
    this.traits = this._computeTraits(extendsTypes);
    this.methodSummary = this._getValue(method, this.ns.raml.vocabularies.http + 'guiSummary');
  }

  _processEndpointChange() {
    this.__endpointProcessingDebouncer = false;
    const { endpoint } = this;
    this.endpointUri = this._computeEndpointUri(this.server, endpoint, this.baseUri, this.apiVersion);
    this._processEndpointVariables();
  }

  _expectsChanged(expects) {
    if (!this.endpointVariables) {
      this._processEndpointVariables();
    }
    this.headers = this._computeHeaders(expects);
    this.payload = this._computePayload(expects);
    const queryParameters = this.queryParameters = this._computeQueryParameters(expects);
    this.hasParameters = this.hasPathParameters || !!(queryParameters && queryParameters.length);
  }

  _processEndpointVariables() {
    const endpointVariables = this.endpointVariables = this._computeEndpointVariables(this.endpoint, this.expects);
    const hasPathParameters = this.hasPathParameters =
      this._computeHasPathParameters(this.serverVariables, endpointVariables);
    this.hasParameters = hasPathParameters || !!(this.queryParameters && this.queryParameters.length);
  }

  /**
   * Computes value for `methodName` property.
   * It is either a `http://schema.org/name` or HTTP method name
   *
   * @param {Object} method AMF `supportedOperation` model
   * @return {String|undefined} Method friendly name
   */
  _computeMethodName(method) {
    let name = this._getValue(method, this.ns.schema.schemaName);
    if (!name) {
      name = this._getValue(method, this.ns.w3.hydra.core + 'method');
    }
    return name;
  }
  /**
   * Computes value for `httpMethod` property.
   *
   * @param {Object} method AMF `supportedOperation` model
   * @return {String|undefined} HTTP method name
   */
  _computeHttpMethod(method) {
    let name = this._getValue(method, this.ns.w3.hydra.core + 'method');
    if (name) {
      name = name.toUpperCase();
    }
    return name;
  }
  /**
   * Computes value for `hasPathParameters` property
   *
   * @param {?Array} sVars Current value of `serverVariables` property
   * @param {?Array} eVars Current value of `endpointVariables` property
   * @return {Boolean}
   */
  _computeHasPathParameters(sVars, eVars) {
    return !!((sVars && sVars.length) || (eVars && eVars.length));
  }
  /**
   * "Try it" button click handler. Dispatches `tryit-requested` custom event
   */
  _tryIt() {
    const { method } = this;
    if (!method) {
      return;
    }
    const id = method['@id'];
    this.dispatchEvent(new CustomEvent('tryit-requested', {
      bubbles: true,
      composed: true,
      detail: {
        id
      }
    }));
  }
  /**
   * Navigates to next method. Calls `_navigate` with id of previous item.
   */
  _navigatePrevious() {
    this._navigate(this.previous.id, 'method');
  }
  /**
   * Navigates to next method. Calls `_navigate` with id of next item.
   */
  _navigateNext() {
    this._navigate(this.next.id, 'method');
  }
  /**
   * Dispatches `api-navigation-selection-changed` so other components
   * can update their state.
   *
   * @param {String} id
   * @param {String} type
   */
  _navigate(id, type) {
    const e = new CustomEvent('api-navigation-selection-changed', {
      bubbles: true,
      composed: true,
      detail: {
        selected: id,
        type: type
      }
    });
    this.dispatchEvent(e);
  }
  /**
   * Toggles code snippets section.
   */
  _toggleSnippets() {
    const state = !this._snippetsOpened;
    if (state && !this._renderSnippets) {
      this._renderSnippets = true;
    }
    setTimeout(() => {
      this._snippetsOpened = state;
    });
  }

  _snippetsTransitionEnd() {
    if (!this._snippetsOpened) {
      this._renderSnippets = false;
    }
  }
  /**
   * Toggles security section.
   */
  _toggleSecurity() {
    this.securityOpened = !this.securityOpened;
  }

  /**
   * Computes example headers string for code snippets.
   * @param {Array} headers Headers model from AMF
   * @return {String|undefind} Computed example value for headers
   */
  _computeSnippetsHeaders(headers) {
    let result;
    if (headers && headers.length) {
      result = '';
      headers.forEach((item) => {
        const name = this._getValue(item, this.ns.schema.schemaName);
        const value = this._computePropertyValue(item) || '';
        result += `${name}: ${value}\n`;
      });
    }
    return result;
  }
  /**
   * Computes example payload string for code snippets.
   * @param {Array} payload Payload model from AMF
   * @return {String|undefind} Computed example value for payload
   */
  _computeSnippetsPayload(payload) {
    if (payload && payload instanceof Array) {
      payload = payload[0];
    }
    if (!payload) {
      return;
    }
    let mt = this._getValue(payload, this.ns.raml.vocabularies.http + 'mediaType');
    if (!mt) {
      mt = 'application/json';
    }
    const examples = this._exampleGenerator.generatePayloadExamples(payload, mt, {});
    if (!examples || !examples[0]) {
      return;
    }
    return examples[0].value;
  }
  /**
   * Tries to find an example value (whether it's default value or from an
   * example) to put it into snippet's values.
   *
   * @param {Object} item A http://raml.org/vocabularies/http#Parameter property
   * @return {String|undefined}
   */
  _computePropertyValue(item) {
    const skey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = item && item[skey];
    if (!schema) {
      return;
    }
    if (schema instanceof Array) {
      schema = schema[0];
    }
    let value = this._getValue(schema, this.ns.w3.shacl.name + 'defaultValue');
    if (!value) {
      const items = this._exampleGenerator.computeExamples(schema, null, { rawOnly: true });
      if (items) {
        value = items[0].value;
      }
    }
    return value;
  }
  // Computes a label for the section toggle buttons.
  _computeToggleActionLabel(opened) {
    return opened ? 'Hide' : 'Show';
  }
  // Computes class for the toggle's button icon.
  _computeToggleIconClass(opened) {
    let clazz = 'toggle-icon';
    if (opened) {
      clazz += ' opened';
    }
    return clazz;
  }
  /**
   * Computes list of "extends" from the shape.
   *
   * @param {Object} shape AMF shape to get `#extends` model from
   * @return {Array<Object>|undefined}
   */
  _computeExtends(shape) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'extends');
    return shape && this._ensureArray(shape[key]);
  }
  /**
   * Computes value for `traits` property
   *
   * @param {Array<Object>} types Result of calling `_computeExtends()` or
   * a list of `#extends` models.
   * @return {Array<Object>|undefined}
   */
  _computeTraits(types) {
    if (!types || !types.length) {
      return;
    }
    const data = types.filter((item) =>
      this._hasType(item, this.ns.raml.vocabularies.document + 'ParametrizedTrait'));
    return data.length ? data : undefined;
  }

  /**
   * Computes list of trait names to render it in the doc.
   *
   * @param {Array<Object>} traits AMF trait definition
   * @return {String|undefined} Trait name if defined.
   */
  _computeTraitNames(traits) {
    if (!traits || !traits.length) {
      return;
    }
    const names = traits.map((trait) => this._getValue(trait, this.ns.schema.schemaName));
    if (names.length === 2) {
      return names.join(' and ');
    }
    return names.join(', ');
  }

  _apiChanged(e) {
    this.amf = e.detail.value;
  }

  get _exampleGenerator() {
    if (!this.__exampleGenerator) {
      this.__exampleGenerator = document.createElement('api-example-generator');
    }
    this.__exampleGenerator.amf = this.amf;
    return this.__exampleGenerator;
  }

  render() {
    const {
      aware,
      hasCustomProperties,
      method
    } = this;
    return html`
    ${aware ? html`<raml-aware
      .scope="${aware}"
      @api-changed="${this._apiChanged}"></raml-aware>` : ''}

    ${this._getTitleTemplate()}
    ${this._getUrlTemplate()}
    ${this._getTraitsTemplate()}
    ${hasCustomProperties ? html`<api-annotation-document .shape="${method}"></api-annotation-document>` : ''}
    ${this._getDescriptionTemplate()}
    <section class="request-documentation">
      ${this._getCodeSnippetsTemplate()}
      ${this._getSecurityTemplate()}
      ${this._getParametersTemplate()}
      ${this._getHeadersTemplate()}
      ${this._getBodyTemplate()}
    </section>
    ${this._getReturnsTemplate()}
    ${this._getNavigationTemplate()}`;
  }

  _getTitleTemplate() {
    if (this._titleHidden) {
      return html``;
    }
    const {
      methodName,
      noTryIt,
      compatibility,
      methodSummary
    } = this;
    return html`
    <div class="title-area">
      <div role="heading" aria-level="1" class="title">${methodName}</div>
      ${noTryIt ? '' : html`<div class="action">
        <anypoint-button
          class="action-button"
          @click="${this._tryIt}"
          emphasis="high"
          ?compatibility="${compatibility}">Try it</anypoint-button>
      </div>`}
    </div>
    ${methodSummary ? html`<p class="summary">${methodSummary}</p>` : ''}
    `;
  }

  _getUrlTemplate() {
    const { httpMethod, endpointUri } = this;
    return html`<section class="url-area">
      <div class="method-value"><span class="method-label" data-method="${httpMethod}">${httpMethod}</span></div>
      <div class="url-value">${endpointUri}</div>
    </section>
    <clipboard-copy id="urlCopy" .content="${endpointUri}"></clipboard-copy>`;
  }

  _getTraitsTemplate() {
    const traits = this.traits;
    if (!traits || !traits.length) {
      return html``;
    }
    const value = this._computeTraitNames(traits);
    return html`<section class="extensions">
      <span>Mixes in
      <span class="trait-name">${value}</span>.
      </span>
    </section>`;
  }

  _getDescriptionTemplate() {
    const { description } = this;
    if (!description) {
      return html``;
    }
    return html`<arc-marked .markdown="${description}">
      <div slot="markdown-html" class="markdown-body"></div>
    </arc-marked>`;
  }

  _getCodeSnippetsTemplate() {
    if (!this.renderCodeSnippets) {
      return html``;
    }
    const {
      _snippetsOpened,
      _renderSnippets,
      endpointUri,
      httpMethod,
      headers,
      payload,
      compatibility
    } = this;
    const label = this._computeToggleActionLabel(_snippetsOpened);
    const iconClass = this._computeToggleIconClass(_snippetsOpened);
    return html`<section class="snippets">
      <div class="section-title-area" @click="${this._toggleSnippets}" title="Toogle code example details">
        <div class="heading3 table-title" role="heading" aria-level="2">Code examples</div>
        <div class="title-area-actions">
          <anypoint-button class="toggle-button" ?compatibility="${compatibility}">
            ${label}
            <span class="icon ${iconClass}">${expandMore}</span>
          </anypoint-button>
        </div>
      </div>
      <iron-collapse .opened="${_snippetsOpened}" @transitionend="${this._snippetsTransitionEnd}">
      ${_renderSnippets ? html`<http-code-snippets
        scrollable
        .url="${endpointUri}"
        .method="${httpMethod}"
        .headers="${this._computeSnippetsHeaders(headers)}"
        .payload="${this._computeSnippetsPayload(payload)}"></http-code-snippets>` : ''}
      </iron-collapse>
    </section>`;
  }

  _getSecurityTemplate() {
    const { renderSecurity, security } = this;
    if (!renderSecurity || !security || !security.length) {
      return html``;
    }
    const { securityOpened, compatibility, amf, narrow } = this;
    const label = this._computeToggleActionLabel(securityOpened);
    const iconClass = this._computeToggleIconClass(securityOpened);
    return html`<section class="security">
      <div class="section-title-area" @click="${this._toggleSecurity}" title="Toogle security details">
        <div class="heading3 table-title" role="heading" aria-level="2">Security</div>
        <div class="title-area-actions">
          <anypoint-button class="toggle-button security" ?compatibility="${compatibility}">
            ${label}
            <span class="icon ${iconClass}">${expandMore}</span>
          </anypoint-button>
        </div>
      </div>
      <iron-collapse .opened="${securityOpened}">
        ${security.map((item) => html`<api-security-documentation
          .amf="${amf}"
          .security="${item}"
          ?narrow="${narrow}"
          ?legacy="${compatibility}"></api-security-documentation>`)}
      </iron-collapse>
    </section>`;
  }

  _getParametersTemplate() {
    if (!this.hasParameters) {
      return;
    }
    const {
      serverVariables,
      endpointVariables,
      queryParameters,
      amf,
      narrow,
      compatibility,
      graph
    } = this;
    return html`<api-parameters-document
      .amf="${amf}"
      queryopened
      pathopened
      .baseUriParameters="${serverVariables}"
      .endpointParameters="${endpointVariables}"
      .queryParameters="${queryParameters}"
      ?narrow="${narrow}"
      ?legacy="${compatibility}"
      ?graph="${graph}"></api-parameters-document>`;
  }

  _getHeadersTemplate() {
    const { headers } = this;
    if (!headers || !headers.length) {
      return;
    }
    const {
      amf,
      narrow,
      compatibility,
      graph
    } = this;
    return html`<api-headers-document
      opened
      .amf="${amf}"
      ?narrow="${narrow}"
      ?compatibility="${compatibility}"
      ?graph="${graph}"
      .headers="${headers}"></api-headers-document>`;
  }

  _getBodyTemplate() {
    const { payload } = this;
    if (!payload || !payload.length) {
      return;
    }
    const {
      amf,
      narrow,
      compatibility,
      graph
    } = this;
    return html`<api-body-document
      opened
      .amf="${amf}"
      ?narrow="${narrow}"
      ?compatibility="${compatibility}"
      ?graph="${graph}"
      .body="${payload}"></api-body-document>`;
  }

  _getReturnsTemplate() {
    const { returns } = this;
    if (!returns || !returns.length) {
      return;
    }
    const {
      amf,
      narrow,
      compatibility,
      graph
    } = this;
    return html`<section class="response-documentation">
      <div class="heading2" role="heading" aria-level="1">Response</div>
      <api-responses-document
        .amf="${amf}"
        ?narrow="${narrow}"
        ?compatibility="${compatibility}"
        ?graph="${graph}"
        .returns="${returns}"></api-responses-document>
    </section>`;
  }

  _getNavigationTemplate() {
    const { next, previous } = this;
    if (!next && !previous) {
      return;
    }
    const { compatibility } = this;
    return html`<section class="bottom-nav">
      ${previous ? html`<div class="bottom-link previous" @click="${this._navigatePrevious}">
        <anypoint-icon-button title="${previous.label}" ?compatibility="${compatibility}">
          <span class="icon">${chevronLeft}</span>
        </anypoint-icon-button>
        <span class="nav-label">${previous.label}</span>
      </div>` : ''}
      <div class="nav-separator"></div>
      ${next ? html`<div class="bottom-link next" @click="${this._navigateNext}">
        <span class="nav-label">${next.label}</span>
        <anypoint-icon-button title="${next.label}" ?compatibility="${compatibility}">
          <span class="icon">${chevronRight}</span>
        </anypoint-icon-button>
      </div>` : ''}
    </section>`;
  }
  /**
   * Dispatched when the user requested the "Try it" view.
   * @event tryit-requested
   * @param {String} id ID of requested method in AMF model.
   * It might be required if the request for try it view comes from
   * a context where more than one method is rendered at the same time.
   */
  /**
   * Dispatched when the user requested previous / next
   *
   * @event api-navigation-selection-changed
   * @param {String} selected
   * @param {String} type
   */
}
window.customElements.define('api-method-documentation', ApiMethodDocumentation);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

const ERROR_MESSAGES = {
  CONTENT_TYPE_MISSING: 'Content-Type header is not defined',
  HEADER_NAME_EMPTY: 'Header name can\'t be empty',
  HEADER_NAME_WHITESPACES: 'Header name should not contain whitespaces',
  HEADER_VALUE_EMPTY: 'Header value should not be empty'
};
/**
 * Headers parser behavior to be impplemented with elements that needs to parse headers data.
 *
 * In most cases function defined in this behavior can work with the headers defined as a string,
 * array of objects (name, value keys) or as Header object.
 *
 * To calculate errors properly, set `isPayload` property when current request can carry a
 * payload.
 *
 * @polymer
 * @mixinFunction
 * @memberof ArcMixins
 */
const HeadersParserMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class HPBmixin extends base {
    static get properties() {
      return {
        /**
         * Set to true when the request can carry a payload.
         * It's required for calculating headers errors.
         */
        isPayload: Boolean
      };
    }

    /**
     * Filter array of headers and return not duplicated array of the same headers.
     * Duplicated headers should be appended to already found one using coma separator.
     *
     * @param {Array} headers
     *                Headers array to filter. All objects in headers array must have "name"
     *                and "value" keys.
     * @return {Array} An array of filtered headers.
     */
    filterHeaders(headers) {
      const _tmp = {};
      headers.forEach(function(header) {
        if (header.name in _tmp) {
          if (header.value) {
            _tmp[header.name] += ', ' + header.value;
          }
        } else {
          _tmp[header.name] = header.value;
        }
      });
      const result = [];
      Object.keys(_tmp).forEach((key) => {
        result[result.length] = {
          name: key,
          value: _tmp[key]
        };
      });
      return result;
    }
    /**
     * Parse headers array to Raw HTTP headers string.
     *
     * @param {Array|String|Headers} headersArray List of objects with "name" and "value"
     * properties.
     * @return {String} A HTTP representation of the headers.
     */
    headersToString(headersArray) {
      if (typeof headersArray === 'string') {
        return headersArray;
      }
      if (!(headersArray instanceof Array)) {
        headersArray = this.headersToJSON(headersArray);
      }
      if (headersArray.length === 0) {
        return '';
      }
      headersArray = this.filterHeaders(headersArray);
      return headersArray
          .map((header) => this.headerItemToString(header))
          .join('\n');
    }
    /**
     * Transforms a header model item to a string.
     * Array values are supported.
     *
     * @param {Object} header Object with name and value.
     * @return {String} Generated headers line
     */
    headerItemToString(header) {
      const key = header.name;
      let value = header.value;
      if (value instanceof Array) {
        value = value.join(',');
      }
      let result = '';
      if (key && key.trim() !== '') {
        result += key + ': ';
        if (value) {
          result += value;
        }
      }
      return result;
    }

    /**
     * Parse HTTP headers input from string to array of objects containing `name` and `value`
     * properties.
     *
     * @param {String|Headers} headers Raw HTTP headers input or Headers object
     * @return {Array<Object>} The array of objects where properties are `name` as a header
     * name and `value` as a header content.
     */
    headersToJSON(headers) {
      if (typeof headers === 'string') {
        return this._headersStringToJSON(headers);
      }
      return this._hedersToJSON(headers);
    }
    /**
     * Parse headers string to array of objects.
     * See `#toJSON` for more info.
     * @param {String} headersString
     * @return {Array<Object>}
     */
    _headersStringToJSON(headersString) {
      const result = [];
      if (!headersString) {
        return result;
      }
      if (typeof headersString !== 'string') {
        throw new Error('Headers must be an instance of String.');
      }
      if (headersString.trim() === '') {
        return result;
      }
      const headers = headersString.split(/\n(?=[^ \t]+)/gim);

      for (let i = 0, len = headers.length; i < len; i++) {
        const line = headers[i].trim();
        if (line === '') {
          continue;
        }
        const sepPosition = line.indexOf(':');
        if (sepPosition === -1) {
          result[result.length] = {
            name: line,
            value: ''
          };
          continue;
        }
        const name = line.substr(0, sepPosition);
        const value = line.substr(sepPosition + 1).trim();
        const obj = {
          name: name,
          value: value
        };
        result.push(obj);
      }
      return result;
    }
    /**
     * Parse Headers object to array of objects.
     * See `#toJSON` for more info.
     *
     * @param {Headers|Object} headers
     * @return {Array<Object>}
     */
    _hedersToJSON(headers) {
      const result = [];
      if (!headers) {
        return result;
      }
      headers = new Headers(headers);
      const _tmp = {};
      headers.forEach(function(value, name) {
        if (_tmp[name]) {
          _tmp[name] += ', ' + value;
        } else {
          _tmp[name] = value;
        }
      });
      return Object.keys(_tmp).map(function(key) {
        let value = _tmp[key];
        if (value && value.indexOf(',') !== -1) {
          value = value.split(',').map((part) => part.trim()).join(', ');
        }
        return {
          name: key,
          value: value
        };
      });
    }

    /**
     * Helper method for old system: combine headers list with encoding value.
     * Note that this function will update the original array.
     *
     * @param {Array} headers An array of headers
     * @param {String} encoding An encoding string from the old request.
     * @return {Boolean} True if encoding has been added to the array.
     */
    _oldCombine(headers, encoding) {
      if (!(headers instanceof Array)) {
        throw new Error('Headers must be an array');
      }
      encoding = String(encoding);
      const ct = headers.filter((item) => item.name.toLowerCase() === 'content-type');
      if (ct.length === 0) {
        headers.push({
          name: 'Content-Type',
          value: encoding.trim()
        });
        return true;
      }
      return false;
    }

    /**
     * Get the Content-Type value from the headers.
     *
     * @param {Array|String} headers Either HTTP headers string or list of headers.
     * @return {String|null} A content-type header value or null if not found
     */
    getContentType(headers) {
      if (typeof headers !== 'string') {
        headers = this.headersToString(headers);
      }
      headers = headers.trim();
      if (headers === '') {
        return null;
      }
      const re = /^content-type:\s?(.*)$/im;
      const match = headers.match(re);
      if (!match) {
        return null;
      }
      let ct = match[1].trim();
      if (ct.indexOf('multipart') === -1) {
        const index = ct.indexOf('; ');
        if (index > 0) {
          ct = ct.substr(0, index);
        }
      }
      return ct;
    }

    /**
     * Replace value for given header in the headers list.
     *
     * @param {Array|String|Object} headers A headers object. Can be string, array of objects or
     * Headers object.
     * @param {String} name Header name to be replaced.
     * @param {String} value Header value to be repleced.
     * @return {Array} Updated headers.
     */
    replaceHeaderValue(headers, name, value) {
      let origType = 'headers';
      if (headers instanceof Array) {
        origType = 'array';
      } else if (typeof headers === 'string') {
        origType = 'string';
      }
      if (origType !== 'array') {
        headers = this.headersToJSON(headers);
      }
      const _name = name.toLowerCase();
      let found = false;
      headers.forEach(function(header) {
        if (header.name.toLowerCase() === _name) {
          header.value = value;
          found = true;
        }
      });
      if (!found) {
        headers.push({
          name: name,
          value: value
        });
      }
      if (origType === 'array') {
        return headers;
      } else if (origType === 'string') {
        return this.headersToString(headers);
      }
      const obj = {};
      headers.forEach(function(header) {
        obj[header.name] = header.value;
      });
      return new Headers(obj);
    }
    /**
     * Get error message for given header string.
     * @param {Header|Array|String} input A headers to check.
     * @return {?String} An error message or null if the headers are valid.
     */
    getHeaderError(input) {
      if (!input) {
        if (this.isPayload) {
          return ERROR_MESSAGES.CONTENT_TYPE_MISSING;
        }
        return null;
      }
      if (!(input instanceof Array)) {
        input = this.headersToJSON(input);
      }
      const msg = [];
      let hasContentType = false;
      for (let i = 0, len = input.length; i < len; i++) {
        const name = input[i].name;
        const value = input[i].value;
        if (name.toLowerCase() === 'content-type') {
          hasContentType = true;
        }
        if (!name || !name.trim()) {
          msg[msg.length] = ERROR_MESSAGES.HEADER_NAME_EMPTY;
        } else if (/\s/.test(name)) {
          msg[msg.length] = ERROR_MESSAGES.HEADER_NAME_WHITESPACES;
        }
        if (!value || !value.trim()) {
          msg[msg.length] = ERROR_MESSAGES.HEADER_VALUE_EMPTY;
        }
      }
      if (this.isPayload && !hasContentType) {
        msg[msg.length] = ERROR_MESSAGES.CONTENT_TYPE_MISSING;
      }
      if (msg.length > 0) {
        return msg.join('\n');
      }
      return null;
    }
  }
  return HPBmixin;
});

/**
@license
Copyright 2017 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `ArcBehaviors.EventsTargetBehavior` is a behavior mixin that allows setting
 * up event listeners on a default or set node.
 *
 * By default the element listens on the `window` element for events. By setting
 * `eventsTarget` property on this element it removes all previously set
 * listeners and adds the same listeners to the node.
 * It also restores default state when the `eventsTarget` is removed.
 *
 * Implementations should implement two abstract methods:
 * `_attachListeners(node)` and `_detachListeners(node)`. Both of them will be
 * called with event target argument when it's required to either set or remove
 * listeners.
 *
 * ### Example (Polymer 2.x)
 *
 * ```javascript
 * class EventableElement extends EventsTargetMixin(HTMLElement) {
 *   _attachListeners: function(node) {
 *    mode.addEventListener('event', this._callback);
 *  }
 *
 *  _detachListeners: function(node) {
 *    mode.removeEventListener('event', this._callback);
 *  }
 * }
 * ```
 *
 * The mixin handles connectedCallback / disconnectedCallback and calls the
 * functions with required parameters.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 */
const EventsTargetMixin = (base) => class extends base {
  static get properties() {
    return {
      /**
       * Events handlers target. By default the element listens on
       * `window` object. If set, all events listeners will be attached to this
       * object instead of `window`.
       */
      eventsTarget: { type: Object },
      // An event target used to attach listeners.
      _oldEventsTarget: Object
    };
  }

  get eventsTarget() {
    return this._eventsTarget;
  }

  set eventsTarget(value) {
    const old = this._eventsTarget;
    if (old === value) {
      return;
    }
    this._eventsTarget = value;
    this._eventsTargetChanged(value);
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this._eventsTargetChanged(this.eventsTarget);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    if (this._oldEventsTarget) {
      this._detachListeners(this._oldEventsTarget);
    }
  }
  /**
   * Removes old handlers (if any) and attaches listeners on new event
   * event target.
   *
   * @param {?Node} eventsTarget Event target to set handlers on. If not set it
   * will set handlers on the `window` object.
   */
  _eventsTargetChanged(eventsTarget) {
    if (this._oldEventsTarget) {
      this._detachListeners(this._oldEventsTarget);
    }
    this._oldEventsTarget = eventsTarget || window;
    this._attachListeners(this._oldEventsTarget);
  }
  // To be implement by the element to set event listeners on the target
  _attachListeners() {}
  // To be implement by the element to remove event listeners from the target
  _detachListeners() {}
};

/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */
const ifDefined = directive((value) => (part) => {
    if (value === undefined && part instanceof AttributePart) {
        if (value !== part.value) {
            const name = part.committer.name;
            part.committer.element.removeAttribute(name);
        }
    }
    else {
        part.setValue(value);
    }
});

/**
Common styles for API forms.

Custom property | Description | Default
----------------|-------------|----------
`--api-form-action-button-color` | Color of the action button in the form. Action buttons should perform form's primary actions like "submit" or "add new". Use `--api-form-action-icon-*` for icons related styling | `--secondary-button-color` or `--accent-color`
`--api-form-action-button-background-color` | Similar to `--api-form-action-button-color` but it's background color | `--secondary-button-background`
`--api-form-action-button-hover-color` | Color of the action button in the form when hovering. | `--secondary-button-color` or `--accent-color`
`--api-form-action-button-hover-background-color` | Similar to `--api-form-action-button-hover-color` but it's background color | `--secondary-button-background`
`--hint-trigger-color` | Color of the form action icon button to dispay documentation for the item. | `rgba(0, 0, 0, 0.74)`
`--hint-trigger-hover-color` | Color of the form action icon button to dispay documentation for the item when hovered | `rgba(0, 0, 0, 0.74)`
`--api-form-action-icon-color` | Color of any other than documentation icon button in form row | `--icon-button-color` or `rgba(0, 0, 0, 0.74)`
`--api-form-action-icon-hover-color` | Color of any other than documentation icon button in form row when hovering | `--accent-color` or `rgba(0, 0, 0, 0.88)`
`--inline-documentation-background-color` | Background color of the documentation element. | `#FFF3E0`
`--inline-documentation-color` | Color of the documentation element | `rgba(0, 0, 0, 0.87)`
`--inline-documentation-font-size` | Font size of the documentaiton element | `13px`
*/

var formStyles = css`
.form-item {
  display: flex;
  flex-direction: row;
  align-items: center;
}

:host([narrow]) .form-item,
.narrow .form-item {
  display: block;
}

.form-item[data-optional] {
  display: none;
}

:host([optionalopened]) [data-optional] {
  display: flex;
  flex-direction: row;
}
/* styling form inline markdown */
arc-marked {
  background-color: var(--inline-documentation-background-color, #FFF3E0);
  padding: 4px;
  /* Default inputs margin */
  margin: 0 8px;
}
/* wrapped for arc-marked */
.docs {
  font-size: var(--arc-font-body1-font-size);
  font-weight: var(--arc-font-body1-font-weight);
  line-height: var(--arc-font-body1-line-height);
  color: var(--inline-documentation-color, rgba(0, 0, 0, 0.87));
  margin-right: 40px;
}

.markdown-body * {
  font-size: var(--inline-documentation-font-size, 13px) !important;
}

.markdown-body p:first-child {
  margin-top: 0;
  padding-top: 0;
}

.markdown-body p:last-child {
  margin-bottom: 0;
  padding-bottom: 0;
}`;

const GLOBAL_PATH_PARAMS = [];
const GLOBAL_QUERY_PARAMS = [];
const GLOBAL_OTHER_PARAMS = [];
/**
 * Generates a common key from data model item.
 *
 * @param {Object} data AMF type object model.
 * @return {String} Generated key to search for the item.
 */
function getKey(data) {
  let key = data.name + '-' + data.schema.type;
  if (data.schema.isEnum) {
    key += '-enum';
  }
  if (data.required) {
    key += '-required';
  }
  return key;
}
/**
 * Searches for a model value in cache store.
 *
 * @param {Object} data AMF model item.
 * @return {Object|undefined} Model item or undefined if not found.
 */
function getGlobalValue(data) {
  let store;
  switch (data.binding) {
    case 'query': store = GLOBAL_QUERY_PARAMS; break;
    case 'path': store = GLOBAL_PATH_PARAMS; break;
    default: store = GLOBAL_OTHER_PARAMS; break;
  }
  if (!store.length) {
    return;
  }
  const key = getKey(data);
  for (let i = 0, len = store.length; i < len; i++) {
    if (store[i].key === key) {
      return store[i].value;
    }
  }
}
/**
 * Appends a value item to the global params.
 *
 * @param {Object} data Model item to be added to the list.
 */
function appendGlobalValue(data) {
  const item = getGlobalValue(data);
  if (item) {
    return;
  }
  const key = getKey(data);
  const model = {
    key: key,
    value: data
  };
  switch (data.binding) {
    case 'query': GLOBAL_QUERY_PARAMS.push(model); break;
    case 'path': GLOBAL_PATH_PARAMS.push(model); break;
    default: GLOBAL_OTHER_PARAMS.push(model); break;
  }
}
/**
 * @license
 * Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
const NUMBER_INPUT_TYPES = ['number', 'integer', 'float'];
/**
 * An element to transform AMF LD model into a form view model.
 *
 * Note, this element does not include polyfills for `Promise` and `Array.from`.
 *
 * The model should be used to build a form view for request parameters
 * like header, query parameters, uri parameters or the body.
 *
 * ### Data model
 * - binding {String} - one of `path`, `query`, `header`
 * - name {String} - property (form) name
 * - required {Boolean} - is property required
 * - value {any} - Value of the property
 * - description {String} - The description of the property
 * - hasDescription {Boolean} - Flag describing if the property has a
 * description.
 * - properties {Array<Object>} - If the model is a type of object it is a list
 * of this model objects.
 * - schema {Object} - Property schma information
 * - schema.type {String} - Data type of the property
 * - schema.inputLabel {String} Label for the form control
 * - schema.inputType {String} - type attribute of the `input` element.
 * - schema.pattern {String} - Regex pattern of the property
 * - schema.minLength {Number} - String property minimum length
 * - schema.maxLength {Number} - String property maximum length
 * - schema.defaultValue {any} - Default value of the property
 * - schema.examples {Array<Object>} - List of examples for the form property.
 * - schema.multipleOf {Number} - For numeric values, a `step` attribute of
 * the `input` element.
 * Each object may contain `name` (may be undefined) and must contain `value`
 * property of the example.
 * - schema.minimum {Number} - For numeric values, minimum value of the property
 * - schema.maximum {Number} - For numeric values, maximum value of the property
 * - schema.isEnum {Boolean} - Flag describing enumerable value
 * - schema.enum {Array<any>} - Only if `schema.isEnum` is set. Values for enum
 * input.
 * - schema.isArray {Boolean} - Flag describing array value for the property
 * - schema.items {Object} - Lsit of items definitions
 * - schema.isBool {Boolean} - Flag describing boolean value for the property
 * - schema.isFile {Boolean} - Flag describing File value for the property
 * - schema.isObject {Boolean} - Flag describing Object value for the property
 * - schema.isNillable {Boolean} - True when it is an union and one of union
 * items is nil.
 * - schema.inputPlaceholder {?String} - A placeholder value for the input.
 * - schema.inputFloatLabel {Boolean} - Only if placeholder is set. Instructs
 * input control to float a label.
 * - schema.isUnion {Boolean} - Flag describing union value
 * - schema.anyOf {Array<Object>} - List of possible types of the union.
 * - schema.enabled {Boolean} - Always `true`
 * - schema.fileTypes {Array<String>} List of file types defined for a file
 * type.
 * - schema.readOnly {Boolean} - Nil types gets `readOnly` property
 * - schema.extendedDescription {String} - extended documentation that includes description,
 * patterns and examples.
 * - schema.hasExtendedDescription {Boolean} - True when extendedDescription is set.
 *
 * ## Example
 *
 * ```html
 * <api-view-model-transformer on-view-model-changed="_updateView"></api-view-model-transformer>
 * <script>
 * const amfModel = getAmfFromRamlOrOas();
 * const processor = document.querySelector('api-view-model-transformer');
 * processor.amf = amfModel;
 * processor.shape = extractHeadersForMethod(amfModel);
 * processor.addEventListener('view-model-changed', (e) => {
 *  console.log(e.detail.value);
 * });
 * </script>
 * ```
 *
 * This example uses `getAmfFromRamlOrOas()` function where you implement
 * the logic of getting AMF json/ld data. It can be stored in file or parsed
 * using AMF parsers. The `extractHeadersForMethod()` represents a logic to
 * extract properties that you want to transform. It can be headers, query
 * parameters or body type.
 *
 * @customElement
 * @memberof ApiElements
 * @appliesMixin EventsTargetMixin
 * @appliesMixin AmfHelperMixin
 */
class ApiViewModelTransformer extends AmfHelperMixin(EventsTargetMixin(LitElement)) {
  static get properties() {
    return {
      /**
       * An array of propertues for which view model is to be generated.
       * It accepts model for headers, query parameters, uri parameters and
       * body.
       * If `manualModel` is not set, assigning a value to this property will
       * trigger model computation. Otherwise call `computeViewModel()`
       * function manually to generate the model.
       */
      shape: { type: Array },
      /**
       * Generated view model from the `shape`
       *
       * @type {Array<Object>}
       */
      viewModel: { type: Array },
      /**
       * If set, assigning a value to `shape` will not trigger view model
       * computation.
       */
      manualModel: { type: Boolean },
      /**
       * The declarations model computed from the AMF object. It is used when the
       * transformer attempt to transform link value.
       *
       * If this property is not set then it dispatches `amf-resolve-link`
       * custom event.
       */
      _references: { type: Array },
      /**
       * Makes the model to always have `hasDescription` to false and
       * clears and documentation from ther model.
       */
      noDocs: { type: Boolean }
    };
  }

  get shape() {
    return this._shape;
  }

  set shape(value) {
    const old = this._shape;
    if (value === old) {
      return;
    }
    this._shape = value;
    this._shapeChanged(value);
  }

  get viewModel() {
    return this._viewModel;
  }

  set viewModel(value) {
    const old = this._viewModel;
    if (value === old) {
      return;
    }
    this._viewModel = value;
    this.dispatchEvent(new CustomEvent('view-model-changed', {
      composed: true,
      detail: {
        value
      }
    }));
  }

  /**
   * @return {Element} Instance of `api-example-generator` element.
   */
  get _exampleGenerator() {
    if (!this.__exampleGenerator) {
      this.__exampleGenerator = document.createElement('api-example-generator');
    }
    return this.__exampleGenerator;
  }

  constructor() {
    super();
    this._buildPropertyHandler = this._buildPropertyHandler.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('api-property-model-build', this._buildPropertyHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('api-property-model-build', this._buildPropertyHandler);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    if (this.__exampleGenerator) {
      delete this.__exampleGenerator;
    }
  }

  __amfChanged() {
    this._references = this._computeReferences(this.amf);
  }
  /**
   * Clears cache for computed models.
   * All computed models are kept in in-memory cache to another call for computation
   * of the same model will result with reference to already computed value.
   * This function clears all cached objects.
   *
   * Note, the memory won't be freed for objects that are in use.
   */
  clearCache() {
    GLOBAL_PATH_PARAMS.splice(0, GLOBAL_PATH_PARAMS.length);
    GLOBAL_QUERY_PARAMS.splice(0, GLOBAL_QUERY_PARAMS.length);
    GLOBAL_OTHER_PARAMS.splice(0, GLOBAL_OTHER_PARAMS.length);
  }
  /**
   * Called when either `shape` or `manualModel` propeties changed.
   * If `manualModel` is falsy then it calls `computeViewModel()` function.
   *
   * Note, this function won't be called when sub property of the model
   * change. For peformance rerasons it won't be supported.
   *
   * Note, `computeViewModel` is called asynchronusly so `amf`
   * property can be set.
   *
   * @param {Array} shape Model for shape
   */
  _shapeChanged(shape) {
    if (this.manualModel) {
      return;
    }
    this.computeViewModel(shape);
  }
  /**
   * Computes view model from AMF data model. This should not be called if
   * `manualModel` is not set. Use `shape` property instead.
   *
   * @param {?Array|Object} shape AMF type model. If not set it uses `shape`
   * property of the element.
   * @return {Array<Object>} A promise resolved to generated model.
   */
  computeViewModel(shape) {
    this.viewModel = undefined;
    if (!shape) {
      shape = this.shape;
    }
    if (!shape) {
      return;
    }
    if (shape instanceof Array) {
      shape = Array.from(shape);
    }
    const result = this._computeViewModel(shape);
    this.viewModel = result;
    return result;
  }
  /**
   * Conputes model for each item recursively. It allows browser to return
   * the event loop and prohibit ANR to show.
   *
   * @param {Array} items List of remanding AMF model items.
   * This shuld be copy of the model since this function removes items from
   * the list.
   * @return {Array<Object>} Promise resolved to the view model.
   */
  _computeViewModel(items) {
    let result = [];
    if (!items) {
      return result;
    }
    const isArray = items instanceof Array;
    if (isArray && !items.length) {
      return result;
    }

    if (isArray) {
      for (let i = 0, len = items.length; i < len; i++) {
        const item = items[i];
        const model = this.uiModelForAmfItem(item);
        if (model) {
          result.push(model);
        }
      }
    } else {
      if (this._hasType(items, this.ns.raml.vocabularies.data + 'Object')) {
        const data = this.modelForRawObject(items);
        if (data) {
          result = data;
        }
      } else if (this._hasType(items, this.ns.w3.shacl.name + 'NodeShape')) {
        result = this._processNodeSchape(items);
      } else if (this._hasType(items, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
        const data = this._uiModelForPropertyShape(items);
        if (data) {
          result[result.length] = data;
        }
      }
    }
    return result;
  }
  /**
   * Creates a UI model item from AMF json/ld model.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  uiModelForAmfItem(amfItem) {
    if (this._hasType(amfItem, this.ns.raml.vocabularies.http + 'Parameter')) {
      return this._uiModelForParameter(amfItem);
    }
    if (this._hasType(amfItem, this.ns.w3.shacl.name + 'PropertyShape')) {
      return this._uiModelForPropertyShape(amfItem);
    }
  }
  /**
   * Creates a model for a shacl's PropertyShape. It can be found, for example,
   * in `queryString` of security scheme settings.
   *
   * @param {Object} shape The shape to process
   * @return {Array<Object>} Generated view model for an item.
   */
  _processNodeSchape(shape) {
    this._resolve(shape);
    const key = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    const items = this._ensureArray(shape[key]);
    const result = [];
    if (!items) {
      return result;
    }
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      const model = this.uiModelForAmfItem(item);
      if (model) {
        result[result.length] = model;
      }
    }
    return result;
  }
  /**
   * Creates a UI model item from AMF json/ld model for a parameter.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  _uiModelForParameter(amfItem) {
    amfItem = this._resolve(amfItem);
    const result = {};
    result.binding = this._computeBinding(amfItem);
    result.name = this._computeFormName(amfItem);
    result.required = this._computeRequired(amfItem);
    result.schema = {};
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = amfItem[sKey];
    if (schema) {
      if (schema instanceof Array) {
        schema = schema[0];
      }
      const def = this._resolve(schema);
      result.schema.type = this._computeModelType(def);
      result.schema.isEnum = this._hasProperty(def, this.ns.w3.shacl.in);
      // Now check if there's cached model for this property
      // So far now it took only required steps to compute cache key of the
      // property.
      const cachedModel = getGlobalValue(result);
      if (cachedModel) {
        // Safe to return it.
        return cachedModel;
      }
      result.schema.enabled = true;
      result.schema.inputLabel = this._computeInputLabel(def, result.required, result.name);
      result.schema.pattern = this._computeShaclProperty(def, 'pattern');
      result.schema.minLength = this._computeShaclProperty(def, 'minLength');
      result.schema.maxLength = this._computeShaclProperty(def, 'maxLength');
      result.schema.defaultValue = this._computeDefaultValue(def);
      result.schema.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
      result.schema.minimum = this._computeShaclProperty(def, 'minInclusive');
      result.schema.maximum = this._computeShaclProperty(def, 'maxInclusive');
      result.schema.enum = result.schema.isEnum ? this._computeModelEnum(def) : undefined;
      result.schema.isArray = result.schema.type === 'array';
      result.schema.isBool = result.schema.type === 'boolean';
      result.schema.isObject = result.schema.type === 'object';
      result.schema.examples = this._computeModelExamples(def);
      result.schema.items = result.schema.isArray ? this._computeModelItems(def) : undefined;
      result.schema.inputType =
        this._computeModelInputType(result.schema.type, result.schema.items);
      result.schema.format = this._computeVocabularyShapeProperty(schema, 'format');
      result.schema.pattern = this._computeModelPattern(
        result.schema.type, result.schema.pattern, result.schema.format);
      result.schema.isNillable = result.schema.type === 'union' ? this._computeIsNillable(def) : false;
    }
    if (this.noDocs) {
      result.hasDescription = false;
    } else {
      result.description = this._computeDescription(amfItem);
      result.hasDescription = !!result.description;
    }
    const valueDelimiter = this._computeValueDelimiter(result.binding);
    const decodeValues = this._computeDecodeValues(result.binding);
    const processOptions = {
      name: result.name,
      required: result.required,
      valueDelimiter: valueDelimiter,
      decodeValues: decodeValues
    };
    this._processAfterItemCreated(result, processOptions);
    // store cache
    appendGlobalValue(result);
    return result;
  }
  /**
   * Creates a UI model item from AMF json/ld model for a parameter.
   * @param {Object} amfItem AMF model with schema for
   * `http://raml.org/vocabularies/http#Parameter`
   * @return {Object} UI data model.
   */
  _uiModelForPropertyShape(amfItem) {
    amfItem = this._resolve(amfItem);
    const result = {};
    result.binding = 'type';
    result.name = this._computeShaclProperty(amfItem, 'name');
    let def;
    if (this._hasType(amfItem, this.ns.raml.vocabularies.shapes + 'ScalarShape')) {
      def = amfItem;
    } else {
      const rangeKey = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'range');
      def = amfItem[rangeKey];
      if (!def) {
        return result;
      }
      if (def instanceof Array) {
        def = def[0];
      }
      def = this._resolve(def);
    }
    result.required = this._computeRequiredPropertyShape(amfItem);
    result.schema = {};
    result.schema.enabled = true;
    result.schema.type = this._computeModelType(def);
    result.schema.isEnum = this._hasProperty(def, this.ns.w3.shacl.in);
    // Now check if there's cached model for this property
    // So far now it took only required steps to compute cache key of the
    // property.
    const cachedModel = getGlobalValue(result);
    if (cachedModel) {
      // Safe to return it.
      return cachedModel;
    }
    result.schema.inputLabel = this._computeInputLabel(def, result.required, result.name);
    result.schema.pattern = this._computeShaclProperty(def, 'pattern');
    result.schema.minLength = this._computeShaclProperty(def, 'minLength');
    result.schema.maxLength = this._computeShaclProperty(def, 'maxLength');
    result.schema.defaultValue = this._computeDefaultValue(def);
    result.schema.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
    result.schema.minimum = this._computeShaclProperty(def, 'minInclusive');
    result.schema.maximum = this._computeShaclProperty(def, 'maxInclusive');
    result.schema.enum = this._computeModelEnum(def);
    result.schema.isEnum = !!result.schema.enum;
    result.schema.isArray = result.schema.type === 'array';
    result.schema.isObject = result.schema.type === 'object';
    result.schema.isBool = result.schema.type === 'boolean';
    result.schema.examples = this._computeModelExamples(def);
    result.schema.hasExamples = !!(result.schema.examples && result.schema.examples.length);
    result.schema.inputType = this._computeModelInputType(result.schema.type, result.schema.items);
    result.schema.format = this._computeVocabularyShapeProperty(def, 'format');
    result.schema.pattern = this._computeModelPattern(
      result.schema.type, result.schema.pattern, result.schema.format);
    result.schema.isNillable = result.schema.type === 'union' ? this._computeIsNillable(result) : false;

    if (this.noDocs) {
      result.hasDescription = false;
    } else {
      result.description = this._computeDescription(def);
      result.hasDescription = !!result.description;
    }
    if (result.schema.type === 'file') {
      result.schema.isFile = true;
      result.schema.fileTypes = this._getValueArray(def,
        this.ns.raml.vocabularies.shapes + 'fileType');
    } else {
      result.schema.isFile = false;
    }
    if (result.schema.isObject) {
      const props = [];
      const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
      const items = this._ensureArray(def[pKey]);
      if (items) {
        items.forEach((item) => {
          if (item instanceof Array) {
            item = item[0];
          }
          props.push(this.uiModelForAmfItem(item));
        });
      }
      result.properties = props;
    }
    this._processAfterItemCreated(result, {});
    // Store cache
    appendGlobalValue(result);
    return result;
  }
  /**
   * Creates a view model for an object definition. Object definition can be
   * part of trait or annotation properties description.
   *
   * @param {Object} model Model to extract data from.
   * @param {Object} processOptions
   * @return {Array} View model for items.
   */
  modelForRawObject(model, processOptions) {
    if (!processOptions) {
      processOptions = {};
    }
    const result = [];
    const keys = Object.keys(model);
    const dataKey = this._getAmfKey(this.ns.raml.vocabularies.data);
    keys.forEach((key) => {
      if (key.indexOf(dataKey) === -1) {
        return;
      }
      let item = model[key];
      if (item instanceof Array) {
        item = item[0];
      }
      item = this._uiModelForRawObject(key, item);
      if (item) {
        item = this._processAfterItemCreated(item, processOptions);
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Creates a view model from "raw" item (model before resolving).
   *
   * @param {String} key Key of the item in the model.
   * @param {String} model Item model
   * @return {Object} View model
   */
  _uiModelForRawObject(key, model) {
    let index = key.indexOf('#');
    if (index === -1) {
      index = key.indexOf(':');
    }
    let name;
    if (index === -1) {
      name = key;
    } else {
      name = key.substr(index + 1);
    }
    const result = {};
    result.binding = 'type';
    result.name = name;
    const dPrefix = this.ns.raml.vocabularies.data;
    const typeKey = this._getAmfKey(dPrefix + 'type');
    let type = this._computeRawModelValue(model[typeKey]);
    if (!type) {
      type = 'string';
    }
    const bracetIndex = type.indexOf('[]');
    let items;
    if (bracetIndex !== -1) {
      items = type.substr(0, bracetIndex);
      type = 'array';
    }

    if (this.noDocs) {
      result.hasDescription = false;
    } else {
      const descKey = this._getAmfKey(dPrefix + 'description');
      result.description = this._computeRawModelValue(model[descKey]);
      result.hasDescription = !!result.description;
    }

    result.required = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'required')]);
    result.schema = {};
    result.schema.enabled = true;
    result.schema.type = type || 'string';
    const displayName = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'displayName')]);
    result.schema.inputLabel = this._completeInputLabel(displayName, name, result.required);
    result.schema.minLength = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'minLength')]);
    result.schema.maxLength = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'maxLength')]);
    result.schema.defaultValue = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'default')]);
    result.schema.multipleOf = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'multipleOf')]);
    result.schema.minimum = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'minimum')]);
    result.schema.maximum = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'maximum')]);
    result.schema.enum = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'enum')]);
    let pattern = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'pattern')]);
    if (pattern instanceof Array) {
      pattern = '[' + pattern[0] + ']';
    }
    result.schema.pattern = pattern;
    result.schema.isEnum = !!result.schema.enum;
    result.schema.isArray = result.schema.type === 'array';
    result.schema.isBool = result.schema.type === 'boolean';
    // result.schema.examples = this._computeModelExamples(def);
    if (result.schema.isArray) {
      result.schema.items = items ? items : this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'items')]);
    }
    result.schema.inputType = this._computeModelInputType(result.schema.type, result.schema.items);
    result.schema.format = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'format')]);
    result.schema.pattern = this._computeModelPattern(result.schema.type, result.schema.pattern, result.schema.format);
    const example = this._computeRawModelValue(model[this._getAmfKey(dPrefix + 'example')]);
    if (example) {
      result.schema.examples = [example];
    }
    const examples = this._computeRawExamples(model[this._getAmfKey(dPrefix + 'examples')]);
    if (examples) {
      const existing = result.schema.examples || [];
      result.schema.examples = existing.concat(examples);
    }
    return result;
  }
  /**
   * Sets up additional properties like `value` or placeholder from
   * values read from the AMF model.
   *
   * @param {Object} item Computed UI model.
   * @param {Object} processOptions Model creation options
   * @return {Object}
   */
  _processAfterItemCreated(item, processOptions) {
    if (item.schema.type === 'null') {
      switch (item.binding) {
        case 'header':
        case 'query':
        case 'path':
          item.value = 'nil';
          break;
        default:
          item.value = 'null';
      }
      item.schema.readOnly = true;
    }
    if (item.schema.examples && item.schema.examples.length && item.schema.examples[0].value) {
      item.schema.inputPlaceholder = 'Example: ' +
        this._exampleAsValue(item.schema.examples[0].value, processOptions);
    }
    if (!item.schema.inputPlaceholder) {
      item.schema.inputPlaceholder = this._computeTypePlaceholder(item.schema.type, item.schema.format);
    }
    if (item.schema.inputPlaceholder) {
      item.schema.inputFloatLabel = true;
    }
    if (item.required && typeof item.schema.defaultValue !== 'undefined') {
      item.value = item.schema.isArray ?
        this.__parseArrayExample(item.schema.defaultValue, processOptions) :
        this._exampleAsValue(item.schema.defaultValue, processOptions);
    }
    if (typeof item.value === 'undefined' && item.required) {
      const examples = item.schema.examples;
      if (examples && examples.length) {
        item.value = this._exampleAsValue(examples[0].value, processOptions);
      }
      if ((typeof item.value === 'undefined' || item.value === '') && item.schema.isEnum) {
        item.value = this._exampleAsValue(item.schema.enum[0], processOptions);
      }
    }

    if (item.schema.isEnum && item.schema.examples && item.schema.examples.length === 1 &&
      !item.schema.examples[0].value) {
      delete item.schema.examples;
    }

    if (item.value && item.schema.isArray && typeof item.value === 'string') {
      const _v = this.__parseArrayExample(item.value, processOptions);
      item.value = _v instanceof Array ? _v : [_v];
    }

    if (item.schema.isArray && !item.value) {
      item.value = [''];
    }

    if (item.schema.isBool && typeof item.value === 'boolean') {
      item.value = String(item.value);
    }
    item.hasExtendedDescription = this._computeHasExtendedDocumentation(item);
    if (item.hasExtendedDescription) {
      item.extendedDescription = this._computeExtendedDocumentation(item);
    }
    return item;
  }
  /**
   * Completes computation of input label.
   *
   * @param {?String} displayName Value of the `displayName` property
   * @param {String} name Property name
   * @param {Boolean} required Is item required
   * @return {String} Common input label construction.
   */
  _completeInputLabel(displayName, name, required) {
    if (!displayName) {
      displayName = name || 'Input value';
    }
    if (required) {
      displayName += '*';
    }
    return displayName;
  }
  /**
   * Computes list of examples from the Raw data model.
   * @param {Object} model
   * @return {Array|undefined}
   */
  _computeRawExamples(model) {
    if (!model || !model[0]) {
      return;
    }
    const result = [];
    model = model[0];
    const keys = Object.keys(model);
    keys.forEach((key) => {
      const dKey = this._getAmfKey(this.ns.raml.vocabularies.data);
      if (key.indexOf(dKey) === -1) {
        return;
      }
      const symbol = key.indexOf('#') !== -1 ? '#' : ':';
      const name = key.split(symbol)[1];
      const value = this._computeRawModelValue(model[key]);
      if (value) {
        result.push({
          name: name,
          value: value,
          hasTitle: !!name
        });
      }
    });
    return result;
  }
  /**
   * Computes value of the `binding` property of the UI model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Binding property or undefined if not found.
   */
  _computeBinding(model) {
    const key = this.ns.raml.vocabularies.http + 'binding';
    return this._getValue(model, key);
  }
  /**
   * Computes fomm (parameter) name from AMF model.
   * @param {Object} model AMF item model
   * @return {String|undefined} Name property or undefined if not found.
   */
  _computeFormName(model) {
    const key = this.ns.schema.schemaName;
    return this._getValue(model, key);
  }
  /**
   * Computes `required` property from AMF model.
   * @param {Object} model AMF item model
   * @return {Boolean} True if the property is required.
   */
  _computeRequired(model) {
    const key = this.ns.w3.hydra.core + 'required';
    return this._getValue(model, key);
  }
  /**
   * Computes `minCount` property from AMF model for PropertyShape object.
   *
   * @param {Object} model AMF item model
   * @return {Boolean} True if `minCount` equals `1`
   */
  _computeRequiredPropertyShape(model) {
    const key = this.ns.w3.shacl.name + 'minCount';
    const result = this._getValue(model, key);
    return result === 1;
  }
  /**
   * Computes type of the model. It's RAML data type property.
   * @param {Object} shape Property schema.
   * @return {String} Type of the nproperty.
   */
  _computeModelType(shape) {
    if (!shape) {
      return;
    }
    const vsh = this.ns.raml.vocabularies.shapes;
    const sa = this.ns.w3.shacl.name;
    if (this._hasType(shape, vsh + 'UnionShape')) {
      return 'union';
    }
    if (this._hasType(shape, vsh + 'ArrayShape')) {
      return 'array';
    }
    if (this._hasType(shape, sa + 'NodeShape')) {
      return 'object';
    }
    if (this._hasType(shape, sa + 'PropertyShape')) {
      return 'object';
    }
    if (this._hasType(shape, vsh + 'FileShape')) {
      return 'file';
    }
    if (this._hasType(shape, vsh + 'NilShape')) {
      return 'null';
    }
    if (this._hasType(shape, vsh + 'AnyShape')) {
      return 'string';
    }
    if (this._hasType(shape, vsh + 'MatrixShape')) {
      return 'array';
    }
    if (this._hasType(shape, vsh + 'TupleShape')) {
      return 'object';
    }
    if (this._hasType(shape, vsh + 'ScalarShape')) {
      let dt = shape[this._getAmfKey(sa + 'datatype')];
      if (dt instanceof Array) {
        dt = dt[0];
      }
      let id = dt;
      if (typeof id !== 'string') {
        id = id['@id'];
      }
      const x = this.ns.w3.xmlSchema;
      switch (id) {
        case x + 'string':
        case this._getAmfKey(x + 'string'):
          return 'string';
        case x + 'integer':
        case this._getAmfKey(x + 'integer'):
          return 'integer';
        case x + 'long':
        case this._getAmfKey(x + 'long'):
          return 'long';
        case x + 'float':
        case this._getAmfKey(x + 'float'):
          return 'float';
        case x + 'double':
        case this._getAmfKey(x + 'double'):
          return 'double';
        case vsh + 'number':
        case this._getAmfKey(vsh + 'number'):
          return 'number';
        case x + 'boolean':
        case this._getAmfKey(x + 'boolean'):
          return 'boolean';
        case x + 'dateTime':
        case this._getAmfKey(x + 'dateTime'):
          return 'datetime';
        case vsh + 'dateTimeOnly':
        case this._getAmfKey(vsh + 'dateTimeOnly'):
          return 'datetime-only';
        case x + 'time':
        case this._getAmfKey(x + 'time'):
          return 'time';
        case x + 'date':
        case this._getAmfKey(x + 'date'):
          return 'date';
        case x + 'base64Binary':
        case this._getAmfKey(x + 'base64Binary'):
          return 'string';
        case vsh + 'password':
        case this._getAmfKey(vsh + 'password'):
          return 'password';
      }
    }
    return 'string';
  }
  /**
   * Computes type of the raw model.
   *
   * @param {Array} model Property schema.
   * @return {String|undefined} Type of the nproperty.
   */
  _computeRawModelValue(model) {
    if (!model) {
      return;
    }
    if (model instanceof Array) {
      model = model[0];
    }
    let dataType = model['@type'];
    if (dataType instanceof Array) {
      dataType = dataType[0];
    }
    switch (dataType) {
      case this._getAmfKey(this.ns.raml.vocabularies.data + 'Scalar'):
        return this._computeRawScalarValue(model);
      case this._getAmfKey(this.ns.raml.vocabularies.data + 'Array'):
        return this._computeRawArrayValue(model);
      case this._getAmfKey(this.ns.raml.vocabularies.shapes + 'FileShape'):
        return this._getValueArray(model, this.ns.raml.vocabularies.shapes + 'fileType');
    }
  }
  /**
   * Computes scalar value that has proper type.
   * @param {Object} item Shape to test for a value.
   * @return {String|Number|Boolean}
   */
  _computeRawScalarValue(item) {
    const valueKey = this._getAmfKey(this.ns.raml.vocabularies.data + 'value');
    let value = item[valueKey];
    if (!value) {
      return;
    }
    if (value instanceof Array) {
      value = value[0];
    }
    let type = value['@type'];
    if (type instanceof Array) {
      type = type[0];
    }
    value = value['@value'];
    const s = this.ns.w3.xmlSchema;
    switch (type) {
      case this._getAmfKey(s + 'number'):
      case this._getAmfKey(s + 'long'):
      case this._getAmfKey(s + 'integer'):
      case this._getAmfKey(s + 'float'):
      case this._getAmfKey(s + 'double'):
        return Number(value);
      case this._getAmfKey(s + 'boolean'):
        return value === 'false' ? false : true;
      default:
        return value;
    }
  }

  _computeRawArrayValue(item) {
    const key = this._getAmfKey('http://www.w3.org/1999/02/22-rdf-syntax-ns#member');
    const values = this._ensureArray(item[key]);
    if (!values) {
      return;
    }
    const result = [];
    values.forEach((value) => {
      const item = this._computeRawScalarValue(value);
      if (item) {
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Computes form input label value.
   *
   * @param {Object} def Property definition
   * @param {Boolean} required True if the property is required
   * @param {?String} name Property name
   * @return {String} Input display name.
   */
  _computeInputLabel(def, required, name) {
    const result = this._getValue(def, this.ns.schema.schemaName);
    return this._completeInputLabel(result, name, required);
  }
  /**
   * Computes the value of a property that namespace starts with
   * `http://www.w3.org/ns/shacl`.
   *
   * @param {Object} shape Property AMF definition
   * @param {String} property Name of the schema.
   * @return {any|undefined} Value of the property or undefined if not set.
   */
  _computeShaclProperty(shape, property) {
    const key = this.ns.w3.shacl.name + String(property);
    return this._getValue(shape, key);
  }
  /**
   * Computes the value of a property that namespace starts with
   * `http://raml.org/vocabularies/shapes`.
   *
   * @param {Object} shape Property AMF definition
   * @param {String} property Name of the schema.
   * @return {any|undefined} Value of the property or undefined if not set.
   */
  _computeVocabularyShapeProperty(shape, property) {
    const key = this.ns.raml.vocabularies.shapes + String(property);
    return this._getValue(shape, key);
  }
  /**
   * Computes default value for a shape.
   * @param {Object} shape Amf shape
   * @return {any|undefined} Default value for the model or undefined.
   */
  _computeDefaultValue(shape) {
    const vsh = this.ns.raml.vocabularies.shapes;
    const valueKey = this._getAmfKey(this.ns.w3.shacl.name + 'defaultValueStr');
    let value = shape[valueKey];
    if (!value) {
      return;
    }
    if (value instanceof Array) {
      value = value[0];
    }
    if (value['@value']) {
      value = value['@value'];
    }
    if (this._hasType(shape, vsh + 'ScalarShape')) {
      const dtKey = this._getAmfKey(this.ns.w3.shacl.name + 'datatype');
      let type = shape[dtKey];
      if (type instanceof Array) {
        type = type[0];
      }
      type = type['@id'];
      const s = this.ns.w3.xmlSchema;
      switch (type) {
        case s + 'number':
        case s + 'long':
        case s + 'integer':
        case s + 'float':
        case s + 'double':
        case this._getAmfKey(s + 'number'):
        case this._getAmfKey(s + 'long'):
        case this._getAmfKey(s + 'integer'):
        case this._getAmfKey(s + 'float'):
        case this._getAmfKey(s + 'double'):
          return Number(value);
        case s + 'boolean':
        case this._getAmfKey(s + 'boolean'):
          return value === 'false' ? false : true;
        default:
          return value;
      }
    } else if (this._hasType(shape, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      const valueKey = this._getAmfKey(this.ns.w3.shacl.name + 'defaultValue');
      let value2 = shape[valueKey];
      if (!value2) {
        return value;
      }
      if (value2 instanceof Array) {
        value2 = value2[0];
      }
      return this._computeRawArrayValue(value2);
    }
    return value;
  }
  /**
   * Computes enum values for the view model.
   * @param {Object} def Model definition.
   * @return {Array} List of values.
   */
  _computeModelEnum(def) {
    def = this._resolve(def);
    const key = this._getAmfKey(this.ns.w3.shacl.in);
    let model = def[key];
    if (!model) {
      return;
    }
    if (model instanceof Array) {
      model = model[0];
    }
    const result = [];
    const rdfKey = this._getAmfKey('http://www.w3.org/2000/01/rdf-schema#');
    Object.keys(model).forEach((key) => {
      if (key.indexOf(rdfKey) === -1) {
        return;
      }
      let shape = model[key];
      if (shape instanceof Array) {
        shape = shape[0];
      }
      const vKey = this._getAmfKey(this.ns.raml.vocabularies.data + 'value');
      const value = this._getValue(shape, vKey);
      if (value) {
        result.push(value);
      }
    });
    return result;
  }

  /**
   * Computes list of examples for the Property model.
   *
   * @param {Object} model AMF property model
   * @return {Array<Object>|undefined} List of examples or `undefined` if not
   * defined.
   */
  _computeModelExamples(model) {
    const gen = this._exampleGenerator;
    gen.amf = this.amf;
    return gen.computeExamples(model, 'application/json', {});
  }
  /**
   * Computes `items` property for AMF array property
   *
   * @param {Object} model AMF property model
   * @return {Object} Array definition model
   */
  _computeModelItems(model) {
    if (!this._hasType(model, this.ns.raml.vocabularies.shapes + 'ArrayShape')) {
      return;
    }
    model = this._resolve(model);
    const itKeys = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'items');
    let item = model[itKeys];
    if (!item) {
      return;
    }
    if (item instanceof Array) {
      item = item[0];
    }
    const type = this._computeModelType(item);
    // _computeModelType() always returns a value
    // TODO: add support for objects and unions.
    return type;
  }

  _computeValueDelimiter(binding) {
    switch (binding) {
      case 'header': return ':';
      case 'query': return '=';
      default: return '';
    }
  }

  _computeDecodeValues(binding) {
    switch (binding) {
      case 'query': return true;
      default: return false;
    }
  }
  /**
   * Parses a string from example or enum value to be used as default value.
   * @param {String} example Example value to process as a value
   * @param {Object} opts Options:
   * - name {String} Processed property name
   * - valueDelimiter {?String} either `:` for headers or `=` for query params
   * - decodeValues {Boolean} True to url decode value.
   * @return {[type]} [description]
   */
  _exampleAsValue(example, opts) {
    if (!example || typeof example !== 'string') {
      return example;
    }
    example = example.trim();
    if (opts.valueDelimiter && example.indexOf(opts.name + opts.valueDelimiter) === 0) {
      example = example.substr(opts.name.length + 1).trim();
    }
    if (opts.decodeValues) {
      try {
        example = decodeURIComponent(example.replace(/\+/g, ' '));
      } catch (e) {
      }
    }
    return example;
  }
  /**
   * Parses example in an array type.
   *
   * @param {String} example An array example
   * @param {Object} processOptions Options:
   * - name {String} Processed property name
   * - valueDelimiter {?String} either `:` for headers or `=` for query params
   * - decodeValues {Boolean} True to url decode value.
   * @return {Array} Array of examples or string if cannot parse
   */
  __parseArrayExample(example, processOptions) {
    try {
      const arr = JSON.parse(example);
      if (arr instanceof Array) {
        const result = [];
        arr.forEach((item) => {
          const ex = this._exampleAsValue(item, processOptions);
          if (ex) {
            result[result.length] = ex;
          }
        });
        return result.length ? result : undefined;
      }
    } catch (e) {
    }
    return this._exampleAsValue(example, processOptions);
  }

  /**
   * Computes rendered item input field type based on RAML definition.
   *
   * It will be either numeric or text. Type will be determined from
   * item's type or, in case of array, item's items property.
   *
   * @param {String} type Property data type.
   * @param {?Array} items Array items if any
   * @return {String} Input field type.
   */
  _computeModelInputType(type, items) {
    if (type === 'array') {
      if (typeof items === 'string') {
        return this.__computeInputType(items);
      }
      if (!items) {
        return 'text';
      }
      return this.__computeInputType(items.schema ? items.schema.type : items.type);
    }
    return this.__computeInputType(type);
  }

  __computeInputType(type) {
    if (type && NUMBER_INPUT_TYPES.indexOf(type) !== -1) {
      return 'number';
    } else if (type === 'boolean') {
      return 'boolean';
    } else if (type === 'date-only' || type === 'date') {
      return 'date';
    } /* else if (type === 'time-only' || type === 'time') {
      return 'time';
    } */
    return 'text';
  }
  /**
   * Computes pattern for the input.
   *
   * @param {String} modelType Type of the property item.
   * @param {String} pattern Pattern declared on the property
   * @param {?String} format For `datetime` type additional format value.
   * `rfc3339` is assumed by default
   * @return {String|undefined} Pattern or undefined if does not exists.
   */
  _computeModelPattern(modelType, pattern, format) {
    if (!pattern) {
      switch (modelType) {
        case 'time':
          pattern = '^[0-9]{2}:[0-9]{2}:[0-9]{2}\\.?[0-9]{0,3}$';
          break;
        case 'date':
          pattern = '^[0-9]{4}-[0-9]{2}-[0-9]{2}$';
          break;
        case 'datetime-only':
          pattern = '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\\.?[0-9]{0,3}$';
          break;
        case 'datetime':
          if (format === 'rfc2616') {
            pattern = '';
          } else {
            pattern = '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.*$';
          }
          break;
      }
    }
    return pattern;
  }
  /**
   * Computes a placeholder value for data and time inputs.
   *
   * @param {String} type Model type.
   * @param {?String} format For `datetime` type additional format value.
   * `rfc3339` is assumed by default
   * @return {String|undefined} Placeholder value.
   */
  _computeTypePlaceholder(type, format) {
    let value;
    switch (type) {
      case 'time':
        value = '00:00:00.000';
        break;
      case 'date':
        value = '0000-00-00';
        break;
      case 'datetime-only':
        value = '0000-00-00T00:00:00.000';
        break;
      case 'datetime':
        if (format === 'rfc2616') {
          value = 'Sun, 01 Jan 2000 00:00:00 GMT';
        } else {
          value = '0000-00-00T00:00:00Z+01:00';
        }
        break;
    }
    return value;
  }
  /**
   * Handler for the `api-property-model-build` custom event.
   * Builds a property view model using event detail object as a base object.
   *
   * All changes are applied to the `detail` object. Requesting element must
   * use the same object.
   *
   * @param {CustomEvent} e
   */
  _buildPropertyHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.buildProperty(e.detail);
  }
  /**
   * Builds empty view model without traversing AMF model.
   *
   * @param {?Object} defaults View model with default values. This values won't
   * be set.
   * @return {Object} Generated basic view model.
   */
  buildProperty(defaults) {
    if (!defaults) {
      defaults = {};
    }
    // defaults.name = defaults.name || 'property';
    defaults.schema = defaults.schema || {};
    defaults.schema.type = defaults.schema.type || 'string';
    defaults.schema.isEnum = defaults.schema.isEnum || false;
    defaults.schema.isArray = defaults.schema.isArray || false;
    defaults.schema.isBool = defaults.schema.isBool || false;
    defaults.schema.isFile = defaults.schema.type === 'file';
    defaults.schema.inputType = defaults.schema.inputType === 'text';
    defaults.hasDescription = !!defaults.description;
    defaults.schema.inputFloatLabel = (defaults.schema.inputFloatLabel ||
      defaults.schema.inputPlaceholder) || false;
    defaults.schema.inputType = this._computeModelInputType(defaults.schema.type,
      defaults.schema.items);
    defaults.schema.pattern = this._computeModelPattern(defaults.schema.type,
      defaults.schema.pattern);
    if (!defaults.schema.inputLabel) {
      defaults.schema.inputLabel = defaults.name || 'Parameter value';
    }
    this._processAfterItemCreated(defaults, {});
    return defaults;
  }

  /**
   * Computes if model item has documentation to display.
   * This would be extended documentation by adding additional description
   * properties that helps the user to input values into the editor.
   *
   * @param {Object} item Model item
   * @return {Boolean} True if documentation can be rendered.
   */
  _computeHasExtendedDocumentation(item) {
    const schema = item.schema || {};
    if (item.hasDescription || schema.pattern) {
      return true;
    }
    if (!(schema.examples || []).length) {
      return false;
    }
    if (schema.examples && schema.examples.length && schema.examples[0]) {
      let value = schema.examples[0].value;
      if (value instanceof Array) {
        value = value[0];
      }
      return value !== undefined && value !== '';
    }
    return false;
  }
  /**
   * Computes documentation as a markdown to be placed in the `marked-element`
   * @param {Object} item View model
   * @return {String} Generated documentation
   */
  _computeExtendedDocumentation(item) {
    let docs = '';
    if (item.description) {
      docs += item.description;
    }
    const { schema } = item;
    const items = [];
    if (schema.pattern) {
      items[items.length] = '- Pattern: `' + schema.pattern + '`';
    }
    if (schema.examples && schema.examples.length) {
      schema.examples.forEach((item) => {
        if (item.value === undefined || item.value === '') {
          return;
        }
        let result = '- Example';
        if (item.hasName) {
          result += ' ' + item.name;
        }
        let value;
        if (item.value instanceof Array) {
          value = item.value.join(', ');
        } else {
          value = item.value;
        }
        result += ': `' + value + '`';
        items[items.length] = result;
      });
    }
    if (docs && items.length) {
      docs += '\n\n\n';
    }
    return docs + items.join('\n');
  }
  /**
   * Returns `true` only when passed shape has `shapes#anyOf` array and
   * one of the union properties is of a type od NilShape.
   * @param {Object} shape Schape test for nillable union.
   * @return {Boolean}
   */
  _computeIsNillable(shape) {
    if (!shape) {
      return false;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const values = this._ensureArray(shape[key]);
    if (!values) {
      return false;
    }
    for (let i = 0, len = values.length; i < len; i++) {
      if (this._hasType(values[i], this.ns.raml.vocabularies.shapes + 'NilShape')) {
        return true;
      }
    }
    return false;
  }
}
window.customElements.define('api-view-model-transformer', ApiViewModelTransformer);

/**
 * `api-url-data-model`
 * An element to generate view model for api-url-editor and api-url-params-editor
 * elements from AMF model
 *
 * The component computes all required values from AMF's WebApi model.
 *
 * When using partial query model the `server`, `protocols`, and `version`
 * model must be set manually as partial model won't have this information.
 *
 * After reseting the model to full AMF WebApi model the values are updated.
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin AmfHelperMixin
 * @memberof ApiElements
 */
class ApiUrlDataModel extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`:host {display: none !important;}`;
  }

  render() {
    const { aware } = this;
    return html`
    ${aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" .scope="${aware}"></raml-aware>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * Name of the scope to use with `raml-aware`.
       * If this element is used with other aware elements, it updates
       * `webApi` when aware value change.
       */
      aware: { type: String },
      /**
       * A value to override API's base URI.
       */
      apiUri: { type: String },
      /**
       * The `@id` property of selected endpoint and method to compute
       * data models for.
       */
      selected: { type: String }
    };
  }

  get _transformer() {
    if (!this.__transformer) {
      this.__transformer = document.createElement('api-view-model-transformer');
    }
    this.__transformer.amf = this.amf;
    return this.__transformer;
  }
  /**
   * Computed value of server definition from the AMF model.
   *
   * @return {Object} AMF model part for server
   */
  get server() {
    return this._server;
  }

  set server(value) {
    const old = this._server;
    if (value === old) {
      return;
    }
    this._server = value;
    this._apiParameters = this._computeApiParameters(value, this.version);
    this._apiBaseUri = this._computeApiBaseUri(value, this.version, this.protocols, this.apiUri);
    this._endpointUri = this._computeEndpointUri(value, this.endpoint, this.apiUri, this.version);
  }
  /**
   * List of supported protocols.
   * Required to compute base URI in some cases.
   *
   * This value is computed when AMF model change.
   *
   * @return {Array<String>}
   */
  get protocols() {
    return this._protocols;
  }

  set protocols(value) {
    // Note, partial model requires this setter to work
    const old = this._protocols;
    if (value === old) {
      return;
    }
    this._protocols = value;
    this._apiBaseUri = this._computeApiBaseUri(this.server, this.version, value, this.apiUri);
  }
  /**
   * API version name.
   * Computed when AMF model change
   *
   * @return {String}
   */
  get version() {
    return this._version;
  }

  set version(value) {
    // Note, partial model requires this setter to work
    const old = this._version;
    if (value === old) {
      return;
    }
    this._version = value;
    this._apiParameters = this._computeApiParameters(this.server, value);
    this._apiBaseUri = this._computeApiBaseUri(this.server, value, this.protocols, this.apiUri);
    this._endpointUri = this._computeEndpointUri(this.server, this.endpoint, this.apiUri, value);
  }

  get selected() {
    return this._selected;
  }
  /**
   * The `@id` property of selected endpoint and method to compute
   * data models for.
   *
   * @param {String} value
   */
  set selected(value) {
    const old = this._selected;
    if (value === old) {
      return;
    }
    this._selected = value;
    this._computeModelEndpointModel();
    this._computeMethodAmf();
  }
  /**
   * @return {String} previously set `apiUri` value.
   */
  get apiUri() {
    return this._apiUri;
  }
  /**
   * A property to set to override AMF's model base URI information.
   * When this property is set, the `endpointUri` property is recalculated.
   *
   * @param {String} value
   */
  set apiUri(value) {
    const old = this._apiUri;
    if (value === old) {
      return;
    }
    this._apiUri = value;
    this._apiBaseUri = this._computeApiBaseUri(this.server, this.version, this.protocols, value);
    this._endpointUri = this._computeEndpointUri(this.server, this.endpoint, value, this.version);
  }
  /**
   * Computed view model for API uri parameters.
   *
   * @return {Array<Object>}
   */
  get apiParameters() {
    return this._apiParameters;
  }

  get _apiParameters() {
    return this.__apiParameters;
  }

  set _apiParameters(value) {
    const old = this.__apiParameters;
    if (old === value) {
      return;
    }
    this.__apiParameters = value;
    this._pathModel = this._computePathModel(this.endpoint, this.method, value);
    this.dispatchEvent(new CustomEvent('apiparameters-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {String} Computed value of API base URI.
   */
  get apiBaseUri() {
    return this._apiBaseUri;
  }

  get _apiBaseUri() {
    return this.__apiBaseUri;
  }

  set _apiBaseUri(value) {
    const old = this.__apiBaseUri;
    if (old === value) {
      return;
    }
    this.__apiBaseUri = value;
    this.dispatchEvent(new CustomEvent('apibaseuri-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * Computed model of HTTP method.
   *
   * @return {?Object} AMF's supported operation model for selected method (if any).
   */
  get method() {
    return this._method;
  }

  get _method() {
    return this.__method;
  }

  set _method(value) {
    const old = this.__method;
    if (old === value) {
      return;
    }
    this.__method = value;
    this._queryModel = this._computeQueryModel(value);
    this._pathModel = this._computePathModel(this.endpoint, value, this.apiParameters);
  }
  /**
   * @return {Array<Object>} Generated view model for query parameters.
   */
  get queryModel() {
    return this._queryModel;
  }

  get _queryModel() {
    return this.__queryModel;
  }

  set _queryModel(value) {
    const old = this.__queryModel;
    if (old === value) {
      return;
    }
    this.__queryModel = value;
    this.dispatchEvent(new CustomEvent('querymodel-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Array<Object>} Generated view model for path parameters
   */
  get pathModel() {
    return this._pathModel;
  }

  get _pathModel() {
    return this.__pathModel;
  }

  set _pathModel(value) {
    const old = this.__pathModel;
    if (old === value) {
      return;
    }
    this.__pathModel = value;
    this.dispatchEvent(new CustomEvent('pathmodel-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * Computed model of selected endpoint.
   * @return {Object} AMF model part describing an endpoint
   */
  get endpoint() {
    return this._endpoint;
  }

  get _endpoint() {
    return this.__endpoint;
  }

  set _endpoint(value) {
    const old = this.__endpoint;
    if (old === value) {
      return;
    }
    this.__endpoint = value;
    this._pathModel = this._computePathModel(value, this.method, this.apiParameters);
    this._endpointUri = this._computeEndpointUri(this.server, value, this.apiUri, this.version);
    this._endpointPath = this._computeEndpointPath(value);
  }
  /**
   * @return {String} Computed value of full endpoint URI when selection has been made.
   */
  get endpointUri() {
    return this._endpointUri;
  }

  get _endpointUri() {
    return this.__endpointUri;
  }

  set _endpointUri(value) {
    const old = this.__endpointUri;
    if (old === value) {
      return;
    }
    this.__endpointUri = value;
    this.dispatchEvent(new CustomEvent('endpointuri-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {String} Selected endponit relative path.
   */
  get endpointPath() {
    return this._endpointPath;
  }

  get _endpointPath() {
    return this.__endpointPath;
  }

  set _endpointPath(value) {
    const old = this.__endpointPath;
    if (old === value) {
      return;
    }
    this.__endpointPath = value;
    this.dispatchEvent(new CustomEvent('endpointpath-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Function} Previously registered handler for `apiparameters-changed` event
   */
  get onapiparameters() {
    return this['_onapiparameters-changed'];
  }
  /**
   * Registers a callback function for `apiparameters-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onapiparameters(value) {
    this._registerCallback('apiparameters-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `apibaseuri-changed` event
   */
  get onapibaseuri() {
    return this['_onapibaseuri-changed'];
  }
  /**
   * Registers a callback function for `apibaseuri-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onapibaseuri(value) {
    this._registerCallback('apibaseuri-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `querymodel-changed` event
   */
  get onquerymodel() {
    return this['_onquerymodel-changed'];
  }
  /**
   * Registers a callback function for `querymodel-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onquerymodel(value) {
    this._registerCallback('querymodel-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `pathmodel-changed` event
   */
  get onpathmodel() {
    return this['_onpathmodel-changed'];
  }
  /**
   * Registers a callback function for `pathmodel-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onpathmodel(value) {
    this._registerCallback('pathmodel-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `endpointuri-changed` event
   */
  get onendpointuri() {
    return this['_onendpointuri-changed'];
  }
  /**
   * Registers a callback function for `endpointuri-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onendpointuri(value) {
    this._registerCallback('endpointuri-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `endpointpath-changed` event
   */
  get onendpointpath() {
    return this['_onendpointpath-changed'];
  }
  /**
   * Registers a callback function for `endpointpath-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onendpointpath(value) {
    this._registerCallback('endpointpath-changed', value);
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.hasAttribute('aria-hidden')) {
      this.setAttribute('aria-hidden', 'true');
    }
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    if (this.__transformer) {
      this.__transformer = null;
    }
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }
  // overrides AmfHelperMixin.__amfChanged
  __amfChanged(amf) {
    this._computeModelEndpointModel();
    this._computeMethodAmf();
    this._amfChanged(amf);
  }
  /**
   * Computes values for `server`, `version`, and `protocol` properties if the
   * model is a web api model.
   * @param {Object} model The AMF model.
   */
  _amfChanged(model) {
    if (model instanceof Array) {
      model = model[0];
    }
    if (!model || !this._hasType(model, this.ns.raml.vocabularies.document + 'Document')) {
      return;
    }
    const server = this._computeServer(model);
    const version = this._computeApiVersion(model);
    const protocols = this._computeProtocols(model);
    this.server = server;
    this.protocols = protocols;
    this.version = version;
  }
  /**
   * Computes `apiBaseUri` property when `amf` change.
   *
   * @param {Object} server Server definition model
   * @param {?String} version API version number
   * @param {?Array<String>} protocols List of supported protocols.
   * @param {?String} apiUri A uri to override APIs base uri
   * @return {String}
   */
  _computeApiBaseUri(server, version, protocols, apiUri) {
    let uri = this._getBaseUri(apiUri, server, protocols);
    if (!uri) {
      return;
    }
    if (version && uri.indexOf('{version}') !== -1) {
      uri = uri.replace('{version}', version);
    }
    const lastIndex = uri.length - 1;
    if (uri[lastIndex] === '/') {
      uri = uri.substr(0, lastIndex);
    }
    return uri;
  }
  /**
   * Computes uri paramerters lsit for API base.
   * If `version` is set it eliminates it from the variables if it's set.
   *
   * @param {Object} server The `http://raml.org/vocabularies/http#server`
   * object
   * @param {?String} version API version number
   * @return {Array<Object>} A view model.
   */
  _computeApiParameters(server, version) {
    if (!server) {
      return [];
    }
    const variables = this._computeServerVariables(server);
    if (!variables || !variables.length) {
      return [];
    }
    if (version) {
      for (let i = variables.length - 1; i >=0; i--) {
        const name = this._getValue(variables[i], this.ns.schema.schemaName);
        if (name === 'version') {
          variables.splice(i, 1);
          break;
        }
      }
    }
    let model = this._transformer.computeViewModel(variables);
    if (model && model.length) {
      model = Array.from(model);
    } else {
      model = undefined;
    }
    return model;
  }
  /**
   * Computes combined list of path parameters from server definition
   * (RAML's base URI) and current path variables.
   * @param {Object} endpoint Endpoint model
   * @param {Object} method Method model
   * @param {?Array<Object>} apiParameters Current value of API parameters
   * @return {Array<Object>}
   */
  _computePathModel(endpoint, method, apiParameters) {
    if (!endpoint) {
      return;
    }
    let params = this._computeQueryParameters(endpoint);
    if (!params || !params.length) {
      params = this._uriParamsFromMethod(method);
      if (!params) {
        return apiParameters;
      }
    }
    let model = this._transformer.computeViewModel(params);
    if (!model) {
      model = [];
    }
    if (apiParameters && apiParameters[0]) {
      model = Array.from(apiParameters).concat(model);
    }
    return model;
  }
  /**
   * Finds URI parameters in method definition.
   * @param {Object} method Method model
   * @return {Array<Object>|undefined}
   */
  _uriParamsFromMethod(method) {
    if (!method) {
      return;
    }
    const request = this._computeExpects(method);
    if (!request) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'uriParameter');
    const params = this._ensureArray(request[key]);
    return params && params.length ? params : undefined;
  }
  /**
   * Computes value for `queryModel` property.
   *
   * @param {Object} method Supported operation model
   * @return {Array<Object>}
   */
  _computeQueryModel(method) {
    if (!method) {
      return [];
    }
    const request = this._computeExpects(method);
    if (!request) {
      return [];
    }
    const params = this._computeQueryParameters(request);
    if (!params) {
      return [];
    }
    let data = this._transformer.computeViewModel(params);
    if (data && data.length) {
      data = Array.from(data);
    } else {
      data = [];
    }
    return data;
  }
  /**
   * Computes endpoint's path value
   * @param {Object} endpoint Endpoint model
   * @return {String}
   */
  _computeEndpointPath(endpoint) {
    return this._getValue(endpoint, this.ns.raml.vocabularies.http + 'path');
  }
  /**
   * Computes value of endpoint model.
   *
   * The selection (id) can be for endpoint or for a method.
   * This tries endpoint first and then method.
   *
   * The operation result is set on `_endpoint` property.
   *
   * @param {Object} api WebApi or EndPoint AMF shape.
   * @param {String} id Endpoint/method selection
   */
  _computeModelEndpointModel() {
    const { selected } = this;
    let { amf } = this;
    if (!amf) {
      this._endpoint = undefined;
      return;
    }
    if (amf instanceof Array) {
      amf = amf[0];
    }
    if (this._hasType(amf, this.ns.raml.vocabularies.http + 'EndPoint')) {
      this._endpoint = amf;
      return;
    }
    const webApi = this._computeWebApi(amf);
    if (!webApi || !selected) {
      this._endpoint = undefined;
      return;
    }
    let model = this._computeEndpointModel(webApi, selected);
    if (model) {
      this._endpoint = model;
      return;
    }
    model = this._computeMethodModel(webApi, selected);
    if (!model) {
      this._endpoint = undefined;
      return;
    }
    const result = this._computeMethodEndpoint(webApi, model['@id']);
    this._endpoint = result;
  }

  _computeMethodAmf() {
    const { selected } = this;
    let { amf } = this;
    if (!amf || !selected) {
      this._method = undefined;
      return;
    }
    if (amf instanceof Array) {
      amf = amf[0];
    }
    if (this._hasType(amf, this.ns.raml.vocabularies.document + 'Document')) {
      const webApi = this._computeWebApi(amf);
      const model = this._computeMethodModel(webApi, selected);
      this._method = model;
      return;
    }
    const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
    const methods = this._ensureArray(amf[key]);
    if (!methods) {
      this._method = undefined;
      return;
    }
    for (let i = 0; i < methods.length; i++) {
      if (methods[i]['@id'] === selected) {
        this._method = methods[i];
        return;
      }
    }
    this._method = undefined;
  }

  _apiChangedHandler(e) {
    const { value } = e.detail;
    this.amf = value;
  }
}
window.customElements.define('api-url-data-model', ApiUrlDataModel);

let nextLabelID = 0;
/**
 * Use `AnypointInputMixin` to implement accessible inputs
 *
 * @mixinFunction
 * @appliesMixin ControlStateMixin
 * @param {Class} base
 * @return {Class}
 */
const AnypointInputMixin = (base) => class extends ValidatableMixin(ControlStateMixin(base)) {
  /**
   * For form-associated custom elements. Marks this custom element
   * as form enabled element.
   */
  static get formAssociated() {
    return true;
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * returns `<form>` element associated with this constol.
   */
  get form() {
    return this._internals && this._internals.form || null;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._value = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('value', old);
    }
    /* istanbul ignore else */
    if (this._internals) {
      this._internals.setFormValue(value);
    }
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get validationStates() {
    return this._validationStates;
  }

  set validationStates(value) {
    const old = this._validationStates;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._validationStates = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('validationStates', old);
    }
    this._hasValidationMessage = !!(value && value.length);
    this._validationStatesChanged(value);
    this.dispatchEvent(new CustomEvent('validationstates-changed', {
      detail: {
        value
      }
    }));
  }

  get hasValidationMessage() {
    return this._hasValidationMessage;
  }

  get _hasValidationMessage() {
    return this.__hasValidationMessage;
  }

  set _hasValidationMessage(value) {
    const old = this.__hasValidationMessage;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__hasValidationMessage = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('hasValidationMessage', old);
    }
    this.__hasValidationMessage = value;
    this.dispatchEvent(new CustomEvent('hasvalidationmessage-changed', {
      detail: {
        value
      }
    }));
  }

  get autofocus() {
    return this._autofocus;
  }

  set autofocus(value) {
    const old = this._autofocus;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._autofocus = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('autofocus', old);
    }
    this._autofocusChanged(value);
  }

  get autoValidate() {
    return this._autoValidate;
  }

  set autoValidate(value) {
    const old = this._autoValidate;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._autoValidate = value;
    this._autoValidateChanged(value);
  }

  get invalidMessage() {
    return this._invalidMessage;
  }

  set invalidMessage(value) {
    const old = this._invalidMessage;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._invalidMessage = value;
    /* istanbul ignore else */
    if (this.requestUpdate) {
      this.requestUpdate('invalidMessage', old);
    }
    this._hasValidationMessage = this.invalid && !!value;
  }

  get _patternRegExp() {
    let pattern;
    if (this.allowedPattern) {
      pattern = new RegExp(this.allowedPattern);
    } else {
      switch (this.type) {
        case 'number':
          pattern = /[0-9.,e-]/;
          break;
      }
    }
    return pattern;
  }
  /**
   * Returns a reference to the input element.
   */
  get inputElement() {
    return this.shadowRoot.querySelector('input,textarea');
  }

  static get properties() {
    return {
      /**
       * The value for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input>`'s `bindValue`
       * property, or the value property of your input that is `notify:true`.
       */
      value: { notify: true },
      /**
       * Set to true to prevent the user from entering invalid input.
       */
      preventInvalidInput: { type: Boolean },
      /**
       * Set this to specify the pattern allowed by `preventInvalidInput`.
       */
      allowedPattern: { type: String },
      /**
       * The type of the input. The supported types are `text`, `number` and `password`.
       */
      type: { type: String },
      /**
       * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
       */
      list: { type: String },
      /**
       * A pattern to validate the `input` with.
       */
      pattern: { type: String },

      /**
       * Sets the input as required.
       */
      required: { type: Boolean },
      /**
       * The error message to display when the input is invalid.
       */
      invalidMessage: { type: String },
      /**
       * Assistive text value.
       * Rendered beflow the input.
       */
      infoMessage: { type: String },
      /**
       * After calling `validate()` this will be populated by latest result of the test for each
       * validator. Result item will contain following properties:
       *
       * - validator {String} Name of the validator
       * - valid {Boolean} Result of the test
       * - message {String} Error message, populated only if `valid` equal `false`
       *
       * This property is `undefined` if `validator` is not set.
       */
      validationStates: { type: Array },
      /**
       * Value computed from `invalidMessage`, `invalid` and `validationStates`.
       * True if the validation message should be displayed.
       */
      _hasValidationMessage: { type: Boolean },
      /**
       * Set to true to auto-validate the input value.
       */
      autoValidate: { type: Boolean },
      /**
       * Name of the validator to use. See `ValidatorMixin`.
       */
      validator: { type: String },

      // HTMLInputElement attributes for binding if needed
      /**
       * Bind the `<input>`'s `autocomplete` property.
       * @default off
       */
      autocomplete: { type: String },
      /**
       * Binds this to the `<input>`'s `autofocus` property.
       */
      autofocus: { type: Boolean },
      /**
       * Binds this to the `<input>`'s `inputMode` property.
       */
      inputMode: { type: String },
      /**
       * The minimum length of the input value.
       * Binds this to the `<input>`'s `minLength` property.
       */
      minLength: { type: Number },
      /**
       * The maximum length of the input value.
       * Binds this to the `<input>`'s `maxLength` property.
       */
      maxLength: { type: Number },
      /**
       * The minimum (numeric or date-time) input value.
       * Binds this to the `<input>`'s `min` property.
       */
      min: { type: String },
      /**
       * The maximum (numeric or date-time) input value.
       * Can be a String (e.g. `"2000-01-01"`) or a Number (e.g. `2`).
       * Binds this to the `<input>`'s `max` property.
       */
      max: { type: String },
      /**
       * Limits the numeric or date-time increments.
       *
       * Binds this to the `<input>`'s `step` property.
       */
      step: { type: String },
      /**
       * Binds this to the `<input>`'s `name` property.
       */
      name: { type: String },
      /**
       * A placeholder string in addition to the label. If this is set, the label will always float.
       * Please, use with careful.
       */
      placeholder: { type: String },
      /**
       * Binds this to the `<input>`'s `readonly` property.
       * @default false
       */
      readOnly: { type: Boolean },
      /**
       * Binds this to the `<input>`'s `size` property.
       */
      size: { type: Number },
      /**
       * Binds this to the `<input>`'s `spellcheck` property.
       */
      spellcheck: { type: String },
      // Nonstandard attributes for binding if needed
      /**
       * Binds this to the `<input>`'s `autocapitalize` property.
       *
       * Possible values are:
       *
       * - `off` or `none`: No autocapitalization is applied (all letters default to lowercase)
       * - `on` or `sentences`: The first letter of each sentence defaults to a capital letter;
       *  all other letters default to lowercase
       * - `words`: The first letter of each word defaults to a capital letter; all other letters default to lowercase
       * - `characters`: All letters should default to uppercase
       *
       * @default none
       */
      autocapitalize: { type: String },
      /**
       * Binds this to the `<input>`'s `autocorrect` property.
       * @default off
       */
      autocorrect: { type: String },
      /**
       * Binds this to the `<input>`'s `results` property,
       * used with type=search.
       *
       * The maximum number of items that should be displayed in the
       * drop-down list of previous search queries. Safari only.
       */
      results: { type: Number },
      /**
       * Binds this to the `<input>`'s `accept` property,
       * used with type=file.
       */
      accept: { type: String },
      /**
       * Binds this to the`<input>`'s `multiple` property,
       * used with type=file.
       */
      multiple: { type: Boolean },

      _ariaLabelledBy: { type: String },
      /**
       * Enables outlined theme.
       */
      outlined: { type: Boolean, reflect: true },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * When set, it reduces height of the button and hides
       * the label when the value is provided.
       *
       * Use it carefully as user should be able to recognize the input
       * when the value is predefined.
       */
      noLabelFloat: { type: Boolean, reflect: true }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  constructor() {
    super();
    this.autoValidate = false;
    this.autocomplete = 'off';
    this.autocorrect = 'off';
    this._ariaLabelledBy = '';
    this._previousValidInput = '';
    this._patternAlreadyChecked = false;
    this._onKeydown = this._onKeydown.bind(this);

    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }
    /* istanbul ignore else */
    if (this.attachInternals) {
      this._internals = this.attachInternals();
    }
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('keydown', this._onKeydown);
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('keydown', this._onKeydown);
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * is called when for disabled state changed.
   * @param {Boolean} disabled Form disabled state
   */
  formDisabledCallback(disabled) {
    this.disabled = disabled;
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * is called when the form has been reset
   */
  formResetCallback() {
    this.value = '';
  }
  /**
   * When form-associated custom elements are supported in the browser it
   * is called when the form state has been restored
   *
   * @param {String} state Restored value
   */
  formStateRestoreCallback(state) {
    this.value = state;
  }

  firstUpdated() {
    this._updateAriaLabelledBy();
  }

  checkValidity() {
    return this._getValidity() && ((this._internals && this._internals.checkValidity()) || true);
  }
  /**
   * From `ValidatableMixin`
   * @param {Boolean} value Current invalid sate
   */
  _invalidChanged(value) {
    super._invalidChanged(value);
    this._hasValidationMessage = value && !!this.invalidMessage;
    this._ensureInvalidAlertSate(value);
  }

  _ensureInvalidAlertSate(invalid) {
    if (!this.invalidMessage) {
      return;
    }
    const node = this.shadowRoot.querySelector('p.invalid');
    if (!node) {
      return;
    }
    if (invalid) {
      node.setAttribute('role', 'alert');
    } else {
      node.removeAttribute('role');
    }
    setTimeout(() => {
      node.removeAttribute('role');
    }, 1000);
  }
  /**
   * Forward focus to inputElement. Overriden from ControlStateMixin.
   * @param {Event} event
   */
  _focusBlurHandler(event) {
    super._focusBlurHandler(event);
    // Forward the focus to the nested input.
    if (this.focused && !this._shiftTabPressed) {
      this.inputElement.focus();
      const type = this.type;
      const input = this.inputElement;
      const value = input.value;
      if (value && (type === 'text' || type === undefined)) {
        const index = value.length;
        input.selectionStart = index;
        input.selectionEnd = index;
      }
    }
    if (event.type === 'blur' && this.autoValidate) {
      this.validate();
    }
  }
  /**
   * Handler for the keydown event.
   * @param {KeyboardEvent} event
   */
  _onKeydown(event) {
    if (event.isComposing || event.keyCode === 229) {
      return;
    }
    if (event.key === 'Tab' && event.shiftKey) {
      this._onShiftTabDown(event);
      return;
    }
    const { type, preventInvalidInput } = this;
    if (!preventInvalidInput || ['number', 'file'].indexOf(type) !== -1) {
      return;
    }
    const regexp = this._patternRegExp;
    if (!regexp) {
      return;
    }
    // Handle special keys and backspace
    if (event.metaKey || event.ctrlKey || event.key === 'Backspace') {
      return;
    }
    // Check the pattern either here or in `_onInput`, but not in both.
    this._patternAlreadyChecked = true;
    const thisChar = event.key;
    if (this._isPrintable(event) && !regexp.test(thisChar)) {
      event.preventDefault();
      this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
    }
  }
  /**
   * Handler that is called when a shift+tab keypress is detected by the menu.
   *
   * @param {KeyboardEvent} e Event handled.
   */
  _onShiftTabDown(e) {
    if (e.target !== this) {
      return;
    }
    const oldTabIndex = this.getAttribute('tabindex');
    this._shiftTabPressed = true;
    this.setAttribute('tabindex', '-1');
    setTimeout(() => {
      this.setAttribute('tabindex', oldTabIndex);
      this._shiftTabPressed = false;
    }, 1);
  }
  /**
   * Calles when `autoValidate` changed
   * @param {Boolean} value
   */
  _autoValidateChanged(value) {
    if (value) {
      this.validate();
    }
  }
  /**
   * Restores the cursor to its original position after updating the value.
   * @param {string} newValue The value that should be saved.
   */
  updateValueAndPreserveCaret(newValue) {
    // Not all elements might have selection, and even if they have the
    // right properties, accessing them might throw an exception (like for
    // <input type=number>)
    const input = this.inputElement;
    try {
      const start = input.selectionStart;
      this.value = newValue;
      input.value = newValue;
      // The cursor automatically jumps to the end after re-setting the value,
      // so restore it to its original position.
      input.selectionStart = start;
      input.selectionEnd = start;
    } catch (e) {
      // Just set the value and give up on the caret.
      this.value = newValue;
    }
  }

  _updateAriaLabelledBy() {
    const slot = this.shadowRoot.querySelector('slot[name="label"]');
    const nodes = slot.assignedNodes();
    if (!nodes.length) {
      return;
    }
    let label;
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].nodeType === Node.ELEMENT_NODE) {
        label = nodes[i];
        break;
      }
    }
    if (!label) {
      this._ariaLabelledBy = '';
      return;
    }
    let labelledBy;
    if (label.id) {
      labelledBy = label.id;
    } else {
      labelledBy = 'anypoint-input-label-' + nextLabelID++;
      label.id = labelledBy;
    }
    this._ariaLabelledBy = labelledBy;
  }

  _onChange(event) {
    // In the Shadow DOM, the `change` event is not leaked into the
    // ancestor tree, so we must do this manually.
    // See https://w3c.github.io/webcomponents/spec/shadow/
    // #events-that-are-not-leaked-into-ancestor-trees.
    if (this.shadowRoot) {
      this.dispatchEvent(new CustomEvent(event.type, {
        detail: {
          sourceEvent: event
        },
        bubbles: event.bubbles,
        cancelable: event.cancelable
      }));
    }
  }

  _onInput(e) {
    let value = e.target.value;
    // Need to validate each of the characters pasted if they haven't
    // been validated inside `_onKeydown` already.
    let valid = true;
    if ((this.preventInvalidInput || this.allowedPattern) && !this._patternAlreadyChecked) {
      valid = this._checkPatternValidity(value);
      if (!valid) {
        this._announceInvalidCharacter('Invalid string of characters entered.');
        value = this._previousValidInput;
      }
    }
    this._patternAlreadyChecked = false;
    this._previousValidInput = value;
    const isNotFile = e.target.type !== 'file';
    if (isNotFile && e.target.value !== value) {
      e.target.value = value;
    }
    if (isNotFile) {
      this.value = value;
    }
    if (this.autoValidate) {
      this.validate();
    }
  }
  /**
   * Checks validity for oattern, if any
   * @param {?String} value The value to test for pattern
   * @return {Boolean}
   */
  _checkPatternValidity(value) {
    if (!value) {
      return true;
    }
    const regexp = this._patternRegExp;
    if (!regexp) {
      return true;
    }
    value = String(value);
    for (let i = 0; i < value.length; i++) {
      if (!regexp.test(value[i])) {
        return false;
      }
    }
    return true;
  }

  _announceInvalidCharacter(message) {
    this.dispatchEvent(new CustomEvent('iron-announce', {
      detail: {
        text: message
      },
      bubbles: true,
      composed: true
    }));
  }

  _isPrintable(event) {
    // What a control/printable character is varies wildly based on the browser.
    // - most control characters (arrows, backspace) do not send a `keypress` event
    //   in Chrome, but they *do* on Firefox
    // - in Firefox, when they do send a `keypress` event, control chars have
    //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
    // - printable characters always send a keypress event.
    // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
    //   always matches the charCode.
    // None of this makes any sense.

    // For these keys, ASCII code == browser keycode.
    const anyNonPrintable =
      (event.keyCode === 8) || // backspace
      (event.keyCode === 9) || // tab
      (event.keyCode === 13) || // enter
      (event.keyCode === 27); // escape

    // For these keys, make sure it's a browser keycode and not an ASCII code.
    const mozNonPrintable =
      (event.keyCode === 19) || // pause
      (event.keyCode === 20) || // caps lock
      (event.keyCode === 45) || // insert
      (event.keyCode === 46) || // delete
      (event.keyCode === 144) || // num lock
      (event.keyCode === 145) || // scroll lock
      (event.keyCode > 32 && event.keyCode < 41) || // page up/down, end, home, arrows
      (event.keyCode > 111 && event.keyCode < 124); // fn keys

    return !anyNonPrintable && !(event.charCode === 0 && mozNonPrintable);
  }
  /**
   * Called when `autofocus` property changed.
   * @param {Boolean} value Current `autofocus` value
   */
  _autofocusChanged(value) {
    // Firefox doesn't respect the autofocus attribute if it's applied after
    // the page is loaded (Chrome/WebKit do respect it), preventing an
    // autofocus attribute specified in markup from taking effect when the
    // element is upgraded. As a workaround, if the autofocus property is set,
    // and the focus hasn't already been moved elsewhere, we take focus.
    if (value && this.inputElement) {
      // In IE 11, the default document.activeElement can be the page's
      // outermost html element, but there are also cases (under the
      // polyfill?) in which the activeElement is not a real HTMLElement, but
      // just a plain object. We identify the latter case as having no valid
      // activeElement.
      const activeElement = document.activeElement;
      const isActiveElementValid = activeElement instanceof HTMLElement;

      // Has some other element has already taken the focus?
      const isSomeElementActive = isActiveElementValid &&
          activeElement !== document.body &&
          activeElement !== document.documentElement; /* IE 11 */
      if (!isSomeElementActive) {
        // No specific element has taken the focus yet, so we can take it.
        this.inputElement.focus();
      }
    }
  }

  /**
   * Returns true if `value` is valid. The validator provided in `validator`
   * will be used first, then any constraints.
   * @return {boolean} True if the value is valid.
   */
  validate() {
    if (!this.inputElement) {
      this.invalid = false;
      return true;
    }
    let valid = this._checkInputValidity();

    // Only do extra checking if the browser thought this was valid.
    if (valid) {
      // Empty, required input is invalid
      if (this.required && this.value === '') {
        valid = false;
      } else if (this.hasValidator()) {
        valid = super.validate(this.value);
      }
    }

    this.invalid = !valid;
    return valid;
  }
  /**
   * Because of the `value` property binding to the input element the value on
   * input element changes programatically which renders input element's validation
   * valiod even if it isn't. This function runs the steps as the regular input
   * validation would, including input validation.
   * @return {Boolean} True if the element is valid.
   */
  _checkInputValidity() {
    const { type, required } = this;
    const value = this.value;
    let valid = !required || (!!required && !!value);
    if (!valid) {
      return valid;
    }
    if (type === 'file') {
      return true;
    }
    valid = this.inputElement.checkValidity();
    if (!valid) {
      return valid;
    }
    valid = this._checkPatternValidity(value);
    if (!valid) {
      return valid;
    }
    const strValue = String(value);
    const { minLength, maxLength } = this;
    if (minLength && strValue.length < minLength) {
      return false;
    }
    if (maxLength && strValue.length > maxLength) {
      return false;
    }
    return true;
  }
  /**
   * Called when validation states changed.
   * Validation states are set by validatable mixin and is a result of calling
   * a custom validator. Each validator returns an object with `valid` and `message`
   * properties.
   *
   * See `ValidatableMixin` for more information.
   *
   * @param {?Array<Object>} states
   */
  _validationStatesChanged(states) {
    if (!states || !states.length) {
      return;
    }
    const parts = [];
    for (let i = 0, len = states.length; i < len; i++) {
      if (!states[i].valid) {
        parts[parts.length] = states[i].message;
      }
    }
    this.invalidMessage = parts.join('. ');
  }
  /**
   * Fired when the input changes due to user interaction.
   *
   * @event change
   */
};

var commonStyles = css`
:host {
  /* Default size of an <input> */
  width: 200px;
  display: block;
  text-align: left;
  cursor: default;
  outline: none;
  height: 56px;
  box-sizing: border-box;
  font-size: 1rem;
  position: relative;
  /* Anypoint UI controls margin in forms */
  margin: 16px 8px;
}

.hidden {
  display: none !important;
}

:host([disabled]) .input-container {
  opacity: var(--anypoint-input-disabled-opacity, 0.43);
  border-bottom: 1px dashed var(--anypoint-input-border-color, var(--secondary-text-color));
}

.input-container {
  display: inline-flex;
  flex-direction: row;
  align-items: center;

  position: relative;
  height: 100%;
  width: 100%;
  background-color: var(--anypoint-input-background-color, #F5F5F5);

  border: 1px var(--anypoint-input-border-color, transparent) solid;
  border-radius: 4px 4px 0 0;
  border-bottom-width: 1px;
  border-bottom-style: solid;
  border-bottom-color: var(--anypoint-input-border-bottom-color, #8e8e8e);
  transition: border-bottom-color 0.22s linear;
  transform-origin: center center;

  cursor: text;
}

:host([focused]) .input-container {
  border-bottom-color: var(--anypoint-input-focused-border-bottom-color, var(--accent-color));
}

:host([invalid]) .input-container {
  border-bottom-color: var(--anypoint-input-error-color, var(--error-color)) !important;
}

.input-label {
  position: relative;
  height: 100%;
  flex: 1;

  display: inline-flex;
  flex-direction: row;
  align-items: center;
}

.label {
  position: absolute;
  transition: transform 0.12s ease-in-out, max-width 0.12s ease-in-out;
  will-change: top;
  border-radius: 3px;
  margin: 0;
  padding: 0;
  left: 8px;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  z-index: 1;
  will-change: transform;
  max-width: calc(100% - 16px);
  text-overflow: clip;
  color: var(--anypoint-input-label-color, #616161);
  transform-origin: left top;
}

:host([invalid]) .label {
  color: var(--anypoint-input-error-color, var(--error-color)) !important;
}

.input-element {
  position: relative;
  width: 100%;
  height: 100%;
  border: none;
  outline: none;
  background-color: transparent;
  padding: 7px 8px 0 8px;
  box-sizing: border-box;
  color: var(--anypoint-input-input-color, inherit);
  font-size: 1rem;
  box-shadow: none;
}

.label.resting {
  top: calc(100% / 2 - 8px);
}

.label.floating {
  transform: translateY(-80%) scale(0.75);
  max-width: calc(100% + 20%);
}

.assistive-info {
  overflow: hidden;
  height: 20px;
}

.invalid,
.info {
  padding: 0;
  margin: 0 0 0 8px;
  font-size: .875rem;
  transition: transform 0.12s ease-in-out;
}

.info {
  color: var(--anypoint-input-info-message-color, #616161);
}

.info.label-hidden {
  transform: translateY(-200%);
}

.invalid {
  color: var(--anypoint-input-error-color, var(--error-color));
}

.invalid.label-hidden,
.invalid.info-offset.label-hidden {
  transform: translateY(-200%);
}

.invalid.info-offset {
  transform: translateY(-12px);
}

/* Outlined theme */
:host([outlined]) .input-container {
  border: 1px var(--anypoint-input-border-color, #8e8e8e) solid;
  background-color: var(--anypoint-input-background-color, #fff);
  border-radius: 4px;
  transition: border-bottom-color 0.22s linear;
}

:host([outlined]) .input-element {
  padding-top: 0px;
}

:host([outlined]) .label.resting {
  margin-top: 0;
  top: calc(100% / 2 - 8px);
}

:host([outlined]) .label.floating {
  background-color: var(--anypoint-input-label-background-color, white);
  transform: translateY(-125%) scale(0.75);
  max-width: 120%;
  padding: 0 2px;
  left: 6px;
}

:host([outlined]) .label.floating.with-prefix {
  left: -22px;
}

/* Anypoint compatibility theme */

:host([compatibility]) {
  height: 40px;
  margin-top: 20px;
}

:host([compatibility]) .input-container {
  border: none;
  border-left: 2px var(--anypoint-input-border-color, #8e8e8e) solid;
  border-right: 2px var(--anypoint-input-border-color, #8e8e8e) solid;
  border-radius: 0;
  box-sizing: border-box;
}

:host([compatibility][focused]) .input-container,
:host([compatibility]:hover) .input-container {
  border-left-color: var(--anypoint-input-compatibility-focus-border-color, #58595a);
  border-right-color: var(--anypoint-input-compatibility-focus-border-color, #58595a);
  background-color: var(--anypoint-input-compatibility-focus-background-color, #f9fafb);
}

:host([compatibility][invalid]) .input-container {
  border-left-color: var(--anypoint-input-error-color, var(--error-color));
  border-right-color: var(--anypoint-input-error-color, var(--error-color));
}

:host([compatibility]) .input-element {
  padding: 0 10px;
}

:host([compatibility]) .label {
  font-size: .935rem;
  left: -2px;
  top: -18px;
  transform: none;
  font-weight: 500;
  color: var(--anypoint-input-compatibility-label-color, #616161);
}

:host([compatibility]) .label.with-prefix {
  left: -34px;
}

:host([compatibility]) .invalid,
:host([compatibility]) .info {
  margin-left: 0px;
}

:host([nolabelfloat][compatibility]) {
  margin-top: 0px;
}

:host([nolabelfloat][compatibility]) .label.resting {
  top: calc(100% / 2 - 8px);
  left: 10px;
}

/* No label float */
:host([nolabelfloat]) .input-element {
  padding-top: 0px;
}
`;

const floatTypes = ['date', 'color', 'datetime-local', 'file', 'month', 'time', 'week'];

class AnypointInput extends AnypointInputMixin(LitElement) {
  static get styles() {
    return [
      commonStyles,
      css`
      .input-element[type="datetime-local"] {
        /* For default 200px width this type expands outside the border */
        width: calc(100% - 40px);
        margin: 0 8px;
        padding: 0;
      }

      .prefixes ::slotted(*) {
        margin: 0 0 0 8px;
      }

      .suffixes ::slotted(*) {
        margin: 0 8px 0 0;
      }

      :host([nolabelfloat]) {
        height: 40px;
      }
      `
    ];
  }

  get _prefixed() {
    return this.querySelector('[slot=prefix]');
  }

  get _labelClass() {
    const labelFloating = !!this.value || floatTypes.indexOf(this.type) !== -1 || !!this.placeholder || this.focused;
    let klas = 'label';
    if (this._prefixed) {
      klas += ' with-prefix';
    }
    if (labelFloating && this.noLabelFloat) {
      klas += ' hidden';
    } else {
      klas += labelFloating ? ' floating' : ' resting';
    }
    return klas;
  }

  get _infoAddonClass() {
    let klas = 'info';
    const isInavlidWithMessage = !!this.invalidMessage && this.invalid;
    if (isInavlidWithMessage) {
      klas += ' label-hidden';
    }
    return klas;
  }

  get _errorAddonClass() {
    let klas = 'invalid';
    if (!this.invalid) {
      klas += ' label-hidden';
    }
    if (this.infoMessage) {
      klas += ' info-offset';
    }
    return klas;
  }

  get _inputType() {
    if (this.type) {
      return this.type;
    }
    return 'text';
  }

  get bindValue() {
    return this.value || '';
  }
  /**
   * Retargets an event that does not bubble
   *
   * @param {Event} e The event to retarget
   */
  _retargetEvent(e) {
    this.dispatchEvent(new CustomEvent(e.type));
  }

  render() {
    return html`
    <div class="input-container">
      ${this._prefixTemplate()}
      <div class="input-label">
        ${this._labelTemplate()}
        ${this._inputTemplate()}
      </div>
      ${this._suffixTemplate()}
    </div>
    ${this._assistiveTemplate()}
    `;
  }

  _suffixTemplate() {
    return html`<div class="suffixes">
      <slot name="suffix"></slot>
    </div>`;
  }

  _prefixTemplate() {
    return html`<div class="prefixes">
      <slot name="prefix"></slot>
    </div>`;
  }

  _assistiveTemplate() {
    const {
      invalidMessage,
      infoMessage,
      _errorAddonClass,
      _infoAddonClass,
    } = this;
    return html`<div class="assistive-info">
    ${infoMessage ? html`<p class="${_infoAddonClass}">${this.infoMessage}</p>` : undefined}
    ${invalidMessage ?
      html`<p class="${_errorAddonClass}">${invalidMessage}</p>` :
      undefined}
    </div>`;
  }

  _labelTemplate() {
    const {
      _labelClass,
      _ariaLabelledBy
    } = this;
    return html`<div class="${_labelClass}" id="${_ariaLabelledBy}">
      <slot name="label"></slot>
    </div>`;
  }

  _inputTemplate() {
    const {
      _ariaLabelledBy,
      disabled,
      pattern,
      required,
      autocomplete,
      autofocus,
      inputMode,
      minLength,
      maxLength,
      min,
      max,
      step,
      name,
      placeholder,
      readOnly,
      list,
      size,
      autocapitalize,
      autocorrect,
      results,
      accept,
      multiple,
      spellcheck,
      bindValue,
      _inputType
    } = this;
    return html`<input
      class="input-element"
      aria-labelledby="${_ariaLabelledBy}"
      ?disabled="${disabled}"
      type="${_inputType}"
      pattern="${ifDefined(pattern)}"
      ?required="${required}"
      autocomplete="${ifDefined(autocomplete)}"
      ?autofocus="${autofocus}"
      inputmode="${ifDefined(inputMode)}"
      minlength="${ifDefined(minLength ? minLength : undefined)}"
      maxlength="${ifDefined(maxLength ? maxLength: undefined)}"
      min="${ifDefined(min)}"
      max="${ifDefined(max)}"
      step="${ifDefined(step)}"
      name="${ifDefined(name)}"
      placeholder="${ifDefined(placeholder)}"
      ?readonly="${readOnly}"
      list="${ifDefined(list)}"
      size="${ifDefined(size)}"
      autocapitalize="${ifDefined(autocapitalize)}"
      autocorrect="${ifDefined(autocorrect)}"
      tabindex="-1"
      results="${ifDefined(results)}"
      accept="${ifDefined(accept)}"
      ?multiple="${multiple}"
      spellcheck="${ifDefined(spellcheck)}"
      .value="${bindValue}"
      @change="${this._onChange}"
      @input="${this._onInput}"
      @search="${this._retargetEvent}"/>`;
  }
}

window.customElements.define('anypoint-input', AnypointInput);

/**
 * `api-url-editor`
 * An AMF powered url editor for the HTTP request editor.
 *
 * The element is regular input element that is adjusted to work with URL
 * data.
 * It supports validation for URL values that may contain variables.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @appliesMixin EventsTargetMixin
 * @appliesMixin ValidatableMixin
 * @memberof ApiElements
 */
class ApiUrlEditor extends EventsTargetMixin(ValidatableMixin(LitElement)) {
  static get styles() {
    return css`:host {
      display: flex;
    }

    anypoint-input {
      flex: 1;
    }`;
  }

  render() {
    const {
      noLabelFloat,
      disabled,
      readOnly,
      invalid,
      outlined,
      compatibility,
      value,
      required
    } = this;
    return html`
    <anypoint-input
      ?nolabelfloat="${noLabelFloat}"
      ?disabled="${disabled}"
      ?readonly="${readOnly}"
      ?invalid="${invalid}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}"
      ?required="${required}"
      invalidmessage="The URL is invalid"
      type="url"
      .value="${value}"
      @blur="${this._onElementBlur}"
      @input="${this.__userInputHandler}">
      <label slot="label">Request URL</label>
    </anypoint-input>`;
  }

  get inputElement() {
    return this.shadowRoot.querySelector('anypoint-input');
  }

  static get properties() {
    return {
      /**
       * When set the input label won't float when focused/has input
       */
      noLabelFloat: { type: Boolean },
      /**
       * Renders input element disabled.
       */
      disabled: { type: Boolean },
      /**
       * When set the input is marked as required input.
       */
      required: { type: Boolean },
      /**
       * Makes the input element read only.
       */
      readOnly: { type: Boolean },
      /**
       * A value produced by this editor - the URL.
       */
      value: { type: String },
      /**
       * Value or RAML's base URI property.
       *
       * Note, the element doesn't check if `baseUri` is relative or not.
       * Hosting application have to take care of that.
       */
      baseUri: { type: String },
      /**
       * Currently selected endpoint relative URI.
       * It is available in RAML definition.
       */
      endpointPath: { type: String },
      /**
       * Computed value, sum of `baseUri` and `endpointPath`
       */
      _fullUri: { type: String },
      /**
       * The query properties model.
       * Use `api-url-data-model` to compute model for the view.
       */
      queryModel: { type: Array },
      /**
       * The URI properties model.
       * Use `api-url-data-model` to compute model for the view.
       */
      pathModel: { type: Array },
      /**
       * Computed, ordered list of URL variables in the URI string.
       */
      _urlParams: { type: Array },
      /**
       * Computed regexp for the current `_fullUri` value to search for the
       * URI parameters.
       */
      _urlSearchRegexp: { type: RegExp },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._value = value;
    this.requestUpdate('value', old);
    this._onValueChanged(value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get baseUri() {
    return this._baseUri;
  }

  set baseUri(value) {
    const old = this._baseUri;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._baseUri = value;
    this._fullUri = this._computeFullUrl(value, this.endpointPath);
  }

  get endpointPath() {
    return this._endpointPath;
  }

  set endpointPath(value) {
    const old = this._endpointPath;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._endpointPath = value;
    this._fullUri = this._computeFullUrl(this.baseUri, value);
  }

  get _fullUri() {
    return this.__fullUri;
  }

  set _fullUri(value) {
    const old = this.__fullUri;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this.__fullUri = value;
    this._urlParams = this._computeUrlParams(value);
    this._urlSearchRegexp = this._computeUrlRegexp(value);
    this._computeValue(this.queryModel, this.pathModel, value);
  }

  get queryModel() {
    return this._queryModel;
  }

  set queryModel(value) {
    const old = this._queryModel;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._queryModel = value;
    this._computeValue(value, this.pathModel, this._fullUri);
    this.dispatchEvent(new CustomEvent('querymodel-changed', {
      detail: {
        value
      }
    }));
  }

  get pathModel() {
    return this._pathModel;
  }

  set pathModel(value) {
    const old = this._pathModel;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._pathModel = value;
    this._computeValue(this.queryModel, value, this._fullUri);
    this.dispatchEvent(new CustomEvent('pathmodel-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Function} Previously registered handler for `value-changed` event
   */
  get onvalue() {
    return this['_onvalue-changed'];
  }
  /**
   * Registers a callback function for `value-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onvalue(value) {
    this._registerCallback('value-changed', value);
  }

  constructor() {
    super();
    this._extValueChangedHandler = this._extValueChangedHandler.bind(this);
    this._focusHandler = this._focusHandler.bind(this);
    this._queryParamChangeHandler = this._queryParamChangeHandler.bind(this);
    this._uriParamChangeHandler = this._uriParamChangeHandler.bind(this);
  }

  firstUpdated() {
    this._elementReady = true;
    // If there's an initial input, validate it.
    if (this.value) {
      this.validate();
    }
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('focus', this._focusHandler);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('focus', this._focusHandler);
  }

  _attachListeners(node) {
    node.addEventListener('url-value-changed', this._extValueChangedHandler);
    node.addEventListener('uri-parameter-changed', this._uriParamChangeHandler);
    node.addEventListener('query-parameter-changed', this._queryParamChangeHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('url-value-changed', this._extValueChangedHandler);
    node.removeEventListener('uri-parameter-changed', this._uriParamChangeHandler);
    node.removeEventListener('query-parameter-changed', this._queryParamChangeHandler);
  }

  _focusHandler() {
    const node = this.inputElement;
    if (node) {
      node.inputElement.focus();
    }
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }
  /**
   * Computes endpoint's full URI with (possibly) variables in it.
   *
   * @param {String} baseUri API base URI
   * @param {String} endpointPath Endpoint relative URI to `baseUri`
   * @return {String} A full URI for the endpoint.
   */
  _computeFullUrl(baseUri, endpointPath) {
    if (!endpointPath) {
      endpointPath = '/';
    }
    if (endpointPath[0] !== '/') {
      endpointPath = '/' + endpointPath;
    }
    if (!baseUri) {
      return endpointPath;
    }
    if (baseUri[baseUri.length - 1] === '/') {
      baseUri = baseUri.substr(0, baseUri.length - 1);
    }
    return baseUri + endpointPath;
  }
  /**
   * Computes url value from current `baseUri` and query/uri models.
   *
   * @param {Array} queryModel Query parameters model
   * @param {Array} pathModel Uri parameters model.
   * @param {String} uri Current endpoint uri.
   */
  async _computeValue(queryModel, pathModel, uri) {
    if (!uri) {
      this.value = '';
      return;
    }
    uri = this._applyUriParams(uri, pathModel);
    uri = this._applyQueryParams(uri, queryModel);
    this.value = uri;
    await this.updateComplete;
    this.validate();
  }
  /**
   * Creates a map of serialized values from a model.
   * It is a replacemenet for `iron-form` serialize function which
   * can't be used here because this function is called before local DOM
   * is ready and therefore form is not set.
   *
   * @param {Array} model Model to compute.
   * @return {Map} Map of serialized values.
   */
  _formValuesFromModel(model) {
    const result = new Map();
    if (!model || !model.length) {
      return result;
    }
    model.forEach((item) => {
      const value = this._valueFormModelItem(item);
      if (value !== undefined) {
        result.set(item.name, value);
      }
    });
    return result;
  }
  /**
   * Extracts value from the model item.
   * If the item is required it is alwats returned (even  if it is empty string).
   * If value is not required and not present then it returns `undefined`.
   *
   * @param {Object} item Model item
   * @return {String} Model value
   */
  _valueFormModelItem(item) {
    if (item.schema && item.schema.enabled === false) {
      return;
    }
    let value = item.value;
    if (!value && item.required) {
      if (value !== 0 && value !== false && value !== null) {
        value = '';
      }
    } else if (!item.required) {
      if (!value && value !== 0 && value !== false && value !== null) {
        value = undefined;
      }
    }
    return value;
  }
  /**
   * Applies URI parameters to the URL.
   *
   * @param {String} url An URL to apply the params to
   * @param {Array} model Uri parameters model.
   * @return {String} The URL.
   */
  _applyUriParams(url, model) {
    if (!model) {
      return url;
    }
    const uriParams = this._formValuesFromModel(model);
    for (let [name, value] of uriParams) {
      if (!value) {
        continue;
      }
      value = String(value);
      if (value.trim() === '') {
        continue;
      }
      if (name[0] === '+' || name[0] === '#') {
        value = encodeURI(value);
      } else {
        value = this._wwwFormUrlEncodePiece(value);
      }
      const re = this._createUrlReplaceRegex(name);
      url = url.replace(re, value);
    }
    return url;
  }
  /**
   * Creates a RegExp object to replace template variable from the base string
   * @param {String} name Name of the parameter to be replaced
   * @return {RegExp}
   */
  _createUrlReplaceRegex(name) {
    if (name[0] === '+' || name[0] === '#') {
      name = '\\' + name;
    }
    return new RegExp('{' + name + '}');
  }
  /**
   * Applies query parameters to the URL.
   * Query parameters that are not required by the API spec and don't have value
   * are removed from the URL. Parameters that are required and don't have
   * value are set to the URL but with empty value.
   *
   * @param {String} url An URL to apply the params to
   * @param {Array} model Query parameters model.
   * @return {String} The URL.
   */
  _applyQueryParams(url, model) {
    if (!model) {
      return url;
    }
    let params = this._formValuesFromModel(model);
    const items = this._computeQueryItems(params);
    params = this._wwwFormUrlEncode(items);
    if (!params) {
      return url;
    }
    url += (url.indexOf('?') === -1) ? '?' : '&';
    url += params;
    return url;
  }
  /**
   * Computes query parameters list of items containing `name` and `value`
   * properties to use to build query string.
   *
   * This function may change the `params` map.
   *
   * @param {Object} params Map of query model properties.
   * @return {Array} List of query parameters.
   */
  _computeQueryItems(params) {
    const items = [];
    for (const [name, value] of params) {
      if (value === undefined) {
        continue;
      }
      let isArray = false;
      if (value instanceof Array) {
        isArray = true;
        if (!value.length || (value.length === 1 && !value[0])) {
          continue;
        }
      }
      if (isArray) {
        for (let i = 0, len = value.length; i < len; i++) {
          if (value || value === 0 || value === false) {
            items.push({
              name: name,
              value: value[i]
            });
          }
        }
      } else {
        items.push({
          name: name,
          value: value
        });
      }
    }
    return items;
  }
  /**
   * @param {Array} object The list of objects to encode as
   * x-www-form-urlencoded string. Each entry should have `name` and `value`
   * properties.
   * @return {string} .
   */
  _wwwFormUrlEncode(object) {
    if (!object || !object.length) {
      return '';
    }
    const pieces = object.map((item) => {
      return this._wwwFormUrlEncodePiece(item.name) + '=' +
        this._wwwFormUrlEncodePiece(item.value);
    });
    return pieces.join('&');
  }
  /**
   * @param {*} str A key or value to encode as x-www-form-urlencoded.
   * @return {string} .
   */
  _wwwFormUrlEncodePiece(str) {
    // Spec says to normalize newlines to \r\n and replace %20 spaces with +.
    // jQuery does this as well, so this is likely to be widely compatible.
    if (!str) {
      return '';
    }
    return encodeURIComponent(str.toString()
        .replace(/\r?\n/g, '\r\n'))
        .replace(/%20/g, '+');
  }
  /**
   * Updates URI / query parameters model from user input.
   *
   * @param {Event} e Input event
   */
  __userInputHandler(e) {
    const value = e.target.value;
    let matches;
    const uriParams = this._urlParams;
    const uriRegexp = this._urlSearchRegexp;
    if (uriParams && uriRegexp) {
      matches = value.match(uriRegexp);
      if (matches) {
        matches.shift();
        this._applyUriValues(matches, uriParams);
      }
    }
    const matchesNew = value.match(/[^&?]*?=[^&?]*/g);
    if (matchesNew) {
      const params = {};
      matchesNew.forEach((item) => this._applyQueryParamToObject(item, params));
      this._applyQueryParamsValues(params);
    }

    this.value = value;
    this.validate();
  }
  /**
   * Applies query parameter values to an object.
   * Repeated parameters will have array value intead of string value.
   *
   * @param {String} param Query parameter value as string. Eg `name=value`
   * @param {Object} obj Target for values
   */
  _applyQueryParamToObject(param, obj) {
    if (!param || !obj || typeof param !== 'string') {
      return;
    }
    const parts = param.split('=');
    const name = parts[0];
    if (name in obj) {
      if (!(obj[name] instanceof Array)) {
        obj[name] = [obj[name]];
      }
      obj[name].push(parts[1]);
    } else {
      obj[name] = parts[1];
    }
  }
  /**
   * Applies values from the `values` array to the uri parametes which names are in the `names`
   * array.
   * Both lists are ordered list of paramerters.
   *
   * @param {Array<String>} values Values for the parameters
   * @param {Array<String>} names List of variables names (uri parameters).
   */
  _applyUriValues(values, names) {
    let changed = false;
    for (let i = 0, len = names.length; i < len; i++) {
      const value = values[i];
      if (value && value[0] === '{') {
        // This is still a variable
        continue;
      }
      const name = names[i];
      const index = this._findModelIndex(name, 'path');
      if (index !== -1) {
        if (this.pathModel[index].value !== value) {
          this.pathModel[index].value = value;
          changed = true;
        }
      }
    }
    if (changed) {
      this.pathModel = [...this.pathModel];
    }
  }
  /**
   * Applies query parameters values to the render list.
   *
   * @param {Object} map A map where keys are names of the parameters in the
   * `queryModel` list
   */
  _applyQueryParamsValues(map) {
    if (!map) {
      return;
    }
    const keys = Object.keys(map);
    let changed = false;
    keys.forEach((key) => {
      const value = map[key];
      if (value && value[0] === '{') {
        // This is still a variable
        return;
      }
      const index = this._findModelIndex(key, 'query');
      if (index !== -1) {
        if (this.queryModel[index].value !== value) {
          this.queryModel[index].value = value;
          changed = true;
        }
      }
    });
    if (changed) {
      this.queryModel = [...this.queryModel];
      changed = true;
    }
  }

  _findModelIndex(name, type) {
    const model = this[type + 'Model'];
    if (!model) {
      return -1;
    }
    return model.findIndex((item) => item.name === name);
  }
  /**
   * A handler that is called on input
   */
  _onValueChanged() {
    if (!this._elementReady || this.__cancelValueChange) {
      return;
    }
    this.fire('url-value-changed', {
      value: this.value
    });
    this.validate();
  }

  _onElementBlur() {
    this.validate();
  }
  /**
   * A handler for the `url-value-changed` event.
   * If this element is not the source of the event then it will update the `value` property.
   * It's to be used besides the Polymer's data binding system.
   *
   * @param {CustomEvent} e
   */
  _extValueChangedHandler(e) {
    if (e.composedPath()[0] === this) {
      return;
    }
    this.__cancelValueChange = true;
    this.value = e.detail.value;
    this.__cancelValueChange = false;
  }

  _getValidity() {
    const value = this.value;
    if (value === undefined) {
      return true;
    }
    if (!this.required && !value) {
      return true;
    }
    if (!value && this.required) {
      return false;
    }
    if (!value) {
      return true;
    }
    if (typeof value !== 'string') {
      return false;
    }
    if (value.indexOf('{') !== -1 && value.indexOf('}') !== -1) {
      return false;
    }
    if (!this.shadowRoot) {
      return true;
    }
    return this.inputElement.validate();
  }
  /**
   * Creates a regular expression from the `_fullUri` to match the
   * parameters in the `value` url.
   *
   * @param {String} url Enpoint's absolute URL with (possibly) parameters.
   * @return {String} A RegExp that can be used to search for parameters values.
   */
  _computeUrlRegexp(url) {
    if (!url) {
      return null;
    }
    url = url.replace('?', '\\?');
    url = url.replace(/(\.|\/)/g, '\\$1');
    url = url.replace(/{[\w\\+]+}/g, '([a-zA-Z0-9\\$\\-_\\.~\\+!\'\\(\\)\\*\\{\\}]+)');
    url += '.*';
    return new RegExp(url);
  }
  /**
   * Computes ordered list of parameters applied to the `_fullUri`.
   * For example the URL: `http://{environment}.domain.com/{apiVersion}/`
   *
   * will be mapped to
   * ```
   * [
   *   "environment",
   *   "apiVersion"
   * ]
   * ```
   *
   * @param {String} url The URL to test for the parameters.
   * @return {Array|null} An ordered list of parameters or null if none found.
   */
  _computeUrlParams(url) {
    if (!url) {
      return null;
    }
    let paramsNames = url.match(/\{[\w\\+]+\}/g);
    if (paramsNames) {
      paramsNames = paramsNames.map((item) => item.substr(1, item.length - 2));
    }
    return paramsNames;
  }

  fire(type, detail) {
    const e = new CustomEvent(type, {
      bubbles: true,
      composed: true,
      cancelable: false,
      detail
    });
    this.dispatchEvent(e);
    return e;
  }

  /**
   * Handler for the `query-parameter-changed` custom event.
   * Updates model value from the event
   *
   * @param {CustomEvent} e
   */
  _queryParamChangeHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    this._appyEventValues(e.detail, 'query');
  }
  /**
   * Handler for the `uri-parameter-changed` custom event.
   * Updates model value from the event
   *
   * @param {CustomEvent} e
   */
  _uriParamChangeHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    this._appyEventValues(e.detail, 'path');
  }

  /**
   * Applies values from the change event to a model.
   *
   * @param {Object} detail Detail event object
   * @param {String} type `uri` or `query`
   */
  _appyEventValues(detail, type) {
    if (detail.isCustom) {
      // dealing with custom properties with possible name change is a mess.
      // It won't be processed via event's API and values should be passed via
      // queryModel.
      return;
    }
    const modelPath = `${type}Model`;
    const model = this[modelPath] || [];
    const index = model.findIndex((item) => item.name === detail.name);
    if (index === -1) {
      if (detail.removed || detail.enabled === false) {
        return;
      }
      const item = this._buildPropertyItem(detail.name, detail.value);
      model.push(item);
    } else {
      if (detail.removed) {
        model.splice(index, 1);
      } else {
        const item = model[index];
        if (item.value === detail.value) {
          return;
        }
        item.value = detail.value;
      }
    }
    this[modelPath] = [...model];
  }

  _buildPropertyItem(name, value) {
    const item = {
      name,
      value,
      schema: {
        type: 'string'
      }
    };
    // api-view-model-transformer handles this event. If it's not in the DOM then it
    // uses the base item object.
    const e = new CustomEvent('api-property-model-build', {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: item
    });
    this.dispatchEvent(e);
    return item;
  }
}

window.customElements.define('api-url-editor', ApiUrlEditor);

/**
 * Use `CheckedElementMixin` to implement an element that can be checked like native checkbox.
 *
 * @mixinFunction
 * @memberof AnypointBasics
 */
const CheckedElementMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class CheckedElementMixin extends ValidatableMixin(base) {
    static get properties() {
      return {
        /**
         * Gets or sets the state, `true` is checked and `false` is unchecked.
         */
        checked: { type: Boolean, reflect: true },
        /**
         * If true, the button toggles the active state with each click or press
         * of the spacebar.
         */
        toggles: { type: Boolean },
        /**
         * The name of this form element.
         */
        name: { type: String },
        /**
         * The value of this form control
         * @type {*}
         */
        value: { type: String },
        /**
         * Set to true to mark the input as required. If used in a form, a
         * custom element that uses this mixin should also use
         * AnypointValidatableMixin and define a custom validation method.
         * Otherwise, a `required` element will always be considered valid.
         * It's also strongly recommended to provide a visual style for the element
         * when its value is invalid.
         */
        required: { type: Boolean },
        /**
         * Disabled state of the control
         */
        disabled: { type: Boolean, reflect: true }
      };
    }

    constructor() {
      super();
      this.value = 'on';
    }

    get required() {
      return this._required || false;
    }

    set required(value) {
      if (this._setChanged('required', value)) {
        this._requiredChanged(value);
      }
    }

    get value() {
      return this._value || false;
    }

    set value(value) {
      if (this._setChanged('value', value)) {
        this._valueChanged(value);
      }
    }

    get checked() {
      return this._checked || false;
    }

    set checked(value) {
      if (this._setChanged('checked', value)) {
        this._checkedChanged(value);
      }
    }

    _setChanged(prop, value) {
      const key = `_${prop}`;
      const old = this[key];
      if (value === old) {
        return false;
      }
      this[key] = value;
      if (this.requestUpdate) {
        this.requestUpdate(prop, old);
      }
      return true;
    }
    /**
     * @return {Boolean} false if the element is required and not checked, and true
     * otherwise.
     */
    _getValidity() {
      return this.disabled || !this.required || this.checked;
    }
    /**
     * Updates the `aria-required` label when `required` is changed.
     * @param {Boolean} required
     */
    _requiredChanged(required) {
      if (required) {
        this.setAttribute('aria-required', 'true');
      } else {
        this.removeAttribute('aria-required');
      }
    }
    /**
     * Fire `iron-changed`for compatybility with iron elements, `change` event
     * for consistency with HTML elements, and `checked-changed` for Polymer.
     * @param {Boolean} value
     */
    _checkedChanged(value) {
      this.active = value;
      this.dispatchEvent(new CustomEvent('change'));
      this.dispatchEvent(new CustomEvent('iron-change'));
      this.dispatchEvent(new CustomEvent('checked-changed', {
        composed: true,
        detail: {
          value
        }
      }));
    }
    /**
     * Reset value to 'on' if it is set to `undefined`.
     * @param {*} value
     */
    _valueChanged(value) {
      if (value === undefined || value === null) {
        this.value = 'on';
      }
    }
  }
  return CheckedElementMixin;
});

/**
 * `anypoint-checkbox`
 * Anypoint styled checkbox
 *
 * `<anypoint-checkbox>` is a button that can be either checked or unchecked.
 * User can tap the checkbox to check or uncheck it.  Usually you use checkboxes
 * to allow user to select multiple options from a set.
 * Avoid using a single checkbox as an option selector and use toggle button intead.
 *
 * ### Example
 *
 * ```html
 * <anypoint-checkbox>label</anypoint-checkbox>
 * <anypoint-checkbox checked>label</anypoint-checkbox>
 * ```
 *
 * ### Using with forms
 *
 * ```
 * npm i --save @polymer/iron-form
 * ```
 *
 * ```html
 * <script type="module">
 * import 'node_modules/@polymer/iron-form';
 * </script>
 * <iron-form>
 *  <form>
 *    <anypoint-checkbox name="subscribe" value="newsletetr">Subsceribe to our newsletter</anypoint-checkbox>
 *    <anypoint-checkbox name="tems" value="accepted" checked>Agree to terms and conditions</anypoint-checkbox>
 *    <anypoint-checkbox name="disabled" value="noop" disabled>This is never included</anypoint-checkbox>
 *  </form>
 * </iron-form>
 * <script>
 * const values = document.querySelector('iron-form').serializeForm();
 * console.log(values);
 * </script>
 * ```
 *
 * ### Styling
 *
 * `<anypoint-checkbox>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--anypoint-checkbox-input-border-bolor` | Border color of the checkbox input square | `--anypoint-color-aluminum4`
 * `--anypoint-checkbox-label-color` | A color of the label. | ` --anypoint-color-steel1`
 * `--anypoint-checkbox-label` | Mixin applied to the label | ``
 * `--anypoint-checkbox-label-checked-color` | Color of checked label | `--anypoint-color-steel1`
 * `--anypoint-checkbox-label-checked` | Mixin applie dto checked label | ``
 * `--anypoint-checkbox-unchecked-color` | Color of a label of unchecked checkbox | `--anypoint-color-steel1`
 * `--anypoint-checkbox-error-color` | Color of error state | `--anypoint-color-danger`
 * `--anypoint-checkbox-label-spacing` | Spacing between the label and the checkbox | `0`
 *
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof AnypointUi
 */
class AnypointCheckbox extends ButtonStateMixin(ControlStateMixin(CheckedElementMixin(LitElement))) {
  static get styles() {
    return css`:host {
      display: inline-flex;
      align-items: center;
      white-space: nowrap;
      cursor: pointer;
      line-height: 0;
      -webkit-tap-highlight-color: transparent;
    }

    :host([hidden]) {
      display: none !important;
    }

    :host([disabled]),
    :host([formdisabled]) {
      cursor: auto;
      pointer-events: none;
      user-select: none;
    }

    :host(:focus) {
      outline: none;
    }

    .hidden {
      display: none !important;
    }

    .checkboxContainer {
      display: inline-block;
      position: relative;
      vertical-align: middle;
      padding: 12px;
    }

    .checkboxContainer:hover:before,
      :host([focused]) .checkboxContainer:before {
      top: 0%;
      left: 0%;
      width: 100%;
      height: 100%;
      opacity: .04;
      background-color: var(--anypoint-checkbox-checked-color, var(--anypoint-color-primary));
      pointer-events: none;
      content: "";
      border-radius: 50%;
      position: absolute;
    }

    :host([disabled]) .checkboxContainer:before,
    :host([formdisabled]) .checkboxContainer:before {
      display: none;
    }

    :host([focused]) .checkboxContainer:before {
      opacity: .12;
    }

    .checkbox {
      position: relative;
      box-sizing: border-box;
      pointer-events: none;
      border-width: 1px;
      border-style: solid;
      border-color: var(--anypoint-checkbox-input-border-color, var(--anypoint-color-aluminum4));
      border-radius: 2px;
      -webkit-transition: box-shadow .3s linear;
      transition: box-shadow .3s linear;
      display: inline-block;
      vertical-align: text-top;
      width: 20px;
      height: 20px;
      -webkit-transition: background-color .17s ease-out;
      transition: background-color .17s ease-out;
    }

    .checkmark {
      transition: top .15s ease-in-out, height .2s ease-in-out, width .3s ease-in-out;
      will-change: top, width, height;
      position: absolute;
      display: block;
      left: 4px;
    }

    :host([checked]) .checkmark {
      border-color: var(--anypoint-checkbox-checkmark-color, var(--anypoint-color-tertiary));
      border-style: none none solid solid;
      border-width: 3px;
      height: 5px;
      top: 3px;
      transform: rotate(-45deg);
      width: 8px;
      background: transparent;
    }

    .checkboxLabel {
      position: relative;
      display: inline-block;
      vertical-align: middle;
      white-space: normal;
      line-height: normal;
      color: var(--anypoint-checkbox-label-color, var(--anypoint-color-steel1));
    }

    :host-context([dir="rtl"]) .checkboxLabel {
      padding-right: var(--anypoint-checkbox-label-spacing, 5px);
      padding-left: 0;
    }

    :host([checked]) .checkbox,
    :host(:not([checked])[indeterminate]) .checkbox {
      background-color: var(--anypoint-checkbox-checked-color, var(--anypoint-color-primary));
      border-color: var(--anypoint-checkbox-checked-input-border-color, var(--anypoint-color-primary));
    }

    :host(:not([checked])[indeterminate]) .checkmark {
      background-color: var(--anypoint-checkbox-checkmark-color, var(--anypoint-color-tertiary));
      height: 3px;
      width: 10px;
      top: calc(50% - 1px);
      border: none;
    }


    :host([checked]) .checkboxLabel {
      color: var(--anypoint-checkbox-label-checked-color,
        var(--anypoint-checkbox-label-color, var(--anypoint-color-steel1)));
    }

    .checkboxLabel[hidden] {
      display: none;
    }

    :host([disabled]) .checkbox,
    :host([formdisabled]) .checkbox {
      opacity: 0.5;
      border-color: var(--anypoint-checkbox-unchecked-color,
        var(--anypoint-checkbox-label-color, var(--anypoint-color-steel1)));
    }

    :host([disabled][checked]) .checkbox,
    :host([formdisabled][checked]) .checkbox {
      background-color: var(--anypoint-checkbox-unchecked-color,
        var(--anypoint-checkbox-label-color, var(--anypoint-color-steel1)));
      opacity: 0.5;
    }

    :host([disabled]) .checkboxLabel,
    :host([formdisabled]) .checkboxLabel {
      opacity: 0.65;
    }

    /* invalid state */
    .checkbox.invalid:not(.checked),
    :host(:invalid) .checkbox {
      border-color: var(--anypoint-checkbox-error-color, var(--anypoint-color-danger));
    }`;
  }

  render() {
    const { checked, invalid, indeterminate } = this;
    return html`
      <div class="checkboxContainer">
        <div class="checkbox ${this._computeCheckboxClass(checked, invalid)}">
          <div class="checkmark ${this._computeCheckmarkClass(checked, indeterminate)}"></div>
        </div>
      </div>
      <label class="checkboxLabel"><slot></slot></label>`;
  }

  static get formAssociated() {
    return true;
  }

  get form() {
    return this._internals && this._internals.form;
  }

  static get properties() {
    return {
      ariaActiveAttribute: { type: String },

      indeterminate: { type: Boolean, reflect: true },

      formDisabled: { type: Boolean, reflect: true }
    };
  }

  constructor() {
    super();
    this.ariaActiveAttribute = 'aria-checked';
    this.checked = false;
    /* to work with iron-form */
    this._hasIronCheckedElementBehavior = true;
    if (this.attachInternals) {
      this._internals = this.attachInternals();
    }
  }

  connectedCallback() {
    // button state mixin sets role to checkbox
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'checkbox');
    }
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.hasAttribute('aria-checked')) {
      this.setAttribute('aria-checked', 'false');
    }
    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }
  }

  _computeCheckboxClass(checked, invalid) {
    let className = '';
    if (checked) {
      className += 'checked ';
    }
    if (invalid) {
      className += 'invalid';
    }
    return className.trim();
  }

  _computeCheckmarkClass(checked, indeterminate) {
    if (!checked && indeterminate) {
      return '';
    }
    return checked ? '' : 'hidden';
  }
  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged() {
    if (this.disabled || this.indeterminate) {
      return;
    }
    this.checked = this.active;
  }

  _clickHandler() {
    if (this.disabled) {
      return;
    }
    if (this.indeterminate) {
      this.indeterminate = false;
    }
    this.active = !this.active;
  }

  _checkedChanged(value) {
    super._checkedChanged(value);
    if (this.indeterminate) {
      this.indeterminate = false;
    }
    this.setAttribute('aria-checked', value ? 'true' : 'false');
    if (this._internals) {
      this._internals.setFormValue(value ? this.value : '');

      if (!this.matches(':disabled') && this.hasAttribute('required') && !value) {
        this._internals.setValidity({
          customError: true
        }, 'This field is required.');
      } else {
        this._internals.setValidity({});
      }
    } else {
      this.validate();
    }
  }

  _spaceKeyDownHandler(e) {
    if (this.indeterminate) {
      this.indeterminate = false;
    }
    super._spaceKeyDownHandler(e);
  }

  checkValidity() {
    return this._internals ? this._internals.checkValidity() :
      this.required ? this.checked : true;
  }

  formDisabledCallback(disabled) {
    this.formDisabled = disabled;
  }

  formResetCallback() {
    this.checked = false;
    this._internals.setFormValue('');
  }

  formStateRestoreCallback(state) {
    this._internals.setFormValue(state);
    this.checked = !!state;
  }
  /**
   * Fired when the checked state changes due to user interaction.
   *
   * @event change
   */
  /**
   * Fired when the checked state changes.
   *
   * @event iron-change
   */
}

window.customElements.define('anypoint-checkbox', AnypointCheckbox);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * A behavior to be implemented to elements that processes AMF data via form
 * data model and displays forms from the model.
 *
 * It contains common methods used in forms.
 *
 * Use `api-form-styles` from this package to include common styles.
 *
 * @mixinFunction
 * @param {Class} base
 * @return {Class}
 */
const ApiFormMixin = (base) => class extends base {
  static get properties() {
    return {
      /**
       * View model to use to render the form.
       */
      model: { type: Array },
      /**
       * Set to true to show optional parameters (not required by the API).
       */
      optionalOpened: {
        type: Boolean,
        reflect: true
      },
      /**
       * Computed value from `allowHideOptional` and view model.
       * `true` if current model has any optional property.
       */
      hasOptional: { type: Boolean },
      /**
       * If set it computes `hasOptional` property and shows checkbox in the
       * form to show / hide optional properties.
       */
      allowHideOptional: { type: Boolean },
      /**
       * Computed flag to determine if optional checkbox can be rendered
       */
      renderOptionalCheckbox: { type: Boolean },
      /**
       * If set, enable / disable param checkbox is rendered next to each
       * form item.
       */
      allowDisableParams: { type: Boolean },
      /**
       * When set, renders "add custom" item button.
       * If the element is to be used withouth AMF model this should always
       * be enabled. Otherwise users won't be able to add a parameter.
       */
      allowCustom: { type: Boolean },
      /**
       * Renders items in "narrow" view
       */
      narrow: { type: Boolean },
      /**
       * Computed value. The form renders empty message (if supported by
       * the form element). It occurs when model is not set and allowCustom
       * is not set
       */
      renderEmptyMessage: { type: Boolean }
    };
  }

  get model() {
    return this._model;
  }

  set model(value) {
    if (this._sop('model', value)) {
      this._notifyChanged('model', value);
      this.renderEmptyMessage = this._computeRenderEmptyMessage(this.allowCustom, value);
      this.hasOptional = this._computeHasOptionalParameters(this.allowHideOptional, value);
    }
  }

  get allowCustom() {
    return this._allowCustom;
  }

  set allowCustom(value) {
    if (this._sop('allowCustom', value)) {
      this.renderEmptyMessage = this._computeRenderEmptyMessage(value, this.model);
    }
  }

  get allowHideOptional() {
    return this._allowHideOptional;
  }

  set allowHideOptional(value) {
    if (this._sop('allowHideOptional', value)) {
      this.hasOptional = this._computeHasOptionalParameters(value, this.model);
      this.renderOptionalCheckbox = this._computeRenderCheckbox(value, this.hasOptional);
    }
  }

  get hasOptional() {
    return this._hasOptional;
  }

  set hasOptional(value) {
    if (this._sop('hasOptional', value)) {
      this._notifyChanged('hasOptional', value);
      this.renderOptionalCheckbox = this._computeRenderCheckbox(this.allowHideOptional, value);
    }
  }

  constructor() {
    super();
    this.renderEmptyMessage = true;
  }

  _sop(prop, value) {
    const key = `_${prop}`;
    const old = this[key];
    if (old === value) {
      return false;
    }
    this[key] = value;
    if (this.requestUpdate) {
      this.requestUpdate(prop, old);
    }
    return true;
  }

  _notifyChanged(prop, value) {
    this.dispatchEvent(new CustomEvent(prop + '-changed', {
      composed: true,
      detail: {
        value
      }
    }));
  }
  /**
   * Computes class name for each form item depending on the item state.
   *
   * @param {Object} item Model item
   * @param {Boolean} allowHideOptional
   * @param {Boolean} optionalOpened True if optional parameters are rendered.
   * @param {Boolean} allowDisableParams
   * @return {String}
   */
  computeFormRowClass(item, allowHideOptional, optionalOpened, allowDisableParams) {
    let clazz = 'param-value';
    if (item && item.required) {
      clazz += ' required';
    } else if (allowHideOptional) {
      clazz += ' optional';
    }
    if (optionalOpened) {
      clazz += ' with-optional';
    }
    if (allowDisableParams) {
      clazz += ' has-enable-button';
    }
    return clazz;
  }
  /**
   * Toggles visibility of optional parameters.
   */
  toggleOptionalParams() {
    if (!this.allowHideOptional) {
      return;
    }
    this.optionalOpened = !this.optionalOpened;
  }

  /**
   * Returns a reference to the form element, if the DOM is ready.
   * This only works with `iron-form` that is in the DOM.
   *
   * @return {IronForm} Iron form element. It may be `undefined` if local
   * DOM is not yet initialized.
   */
  _getForm() {
    if (!this.__form && this.shadowRoot) {
      this.__form = this.shadowRoot.querySelector('iron-form');
    }
    return this.__form;
  }
  /**
   * Validates the form. It uses `iron-form`'s `validate()` function to
   * perform the validation.
   * @return {Boolean} Validation result or `true` if DOM is not yet ready.
   */
  _getValidity() {
    const form = this._getForm();
    if (!form) {
      return true;
    }
    return form.validate();
  }
  /**
   * Link to the form's serialize function.
   * @return {Object} Serialized form values or `undefined` if DOM is not ready.
   * Note, `undefined` is returned **only** if DOM is not yet ready.
   */
  serializeForm() {
    const form = this._getForm();
    if (!form) {
      return;
    }
    return form.serializeForm();
  }
  /**
   * Computes if any of the parameters are required.
   * It iterates over the model to find any first element that has `required`
   * propeerty set to `false`.
   *
   * @param {Boolean} allowHideOptional State of `allowHideOptional` property.
   * If `false` this function always returns `false`.
   * @param {Object} model Current model
   * @return {Boolean} `true` if model has at leas one alement that is not required.
   */
  _computeHasOptionalParameters(allowHideOptional, model) {
    if (!allowHideOptional || !model) {
      return false;
    }
    return model.some((item) => item.required === false);
  }
  /**
   * Computes value for `renderOptionalCheckbox` property.
   *
   * @param {Boolean} render Value of `allowHideOptional` property
   * @param {Boolean} has Value of `hasOptional` property.
   * @return {Boolean} True if both values are `true`.
   */
  _computeRenderCheckbox(render, has) {
    return render && has;
  }
  /**
   * Computes if given model item is a custom property (not generated by
   * AMF model transformation).
   * @param {Object} model Model item.
   * @return {Boolean} `true` if `isCustom` property is set on model's schema
   * property.
   */
  _computeIsCustom(model) {
    if (!model || !model.schema || !model.schema.isCustom) {
      return false;
    }
    return true;
  }
  /**
   * Adds empty custom property to the list.
   *
   * It dispatches `api-property-model-build` custom event that is handled by
   * `api-view-model-transformer` to build model item.
   * This assumem that the transformer element is already in the DOM.
   *
   * After the transformation the element pushes or sets the data to the
   * `model`.
   *
   * @param {String} binding Value if the `binding` property.
   * @param {Object} opts Additional options:
   * - inputLabel {String} - Forces a label of the input
   */
  addCustom(binding, opts) {
    if (!opts) {
      opts = {};
    }
    const e = new CustomEvent('api-property-model-build', {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {
        name: opts.name || '',
        value: opts.value || '',
        binding: binding,
        schema: {
          enabled: true,
          isCustom: true,
          inputLabel: opts.inputLabel || undefined
        }
      }
    });
    this.dispatchEvent(e);
    const model = this.model || [];
    this.model = [...model, e.detail];
    this.optionalOpened = true;
  }
  /**
   * Removes custom item from the UI.
   * This can only be called from `dom-repeat` element so it contain's
   * `model` property.
   *
   * @param {CustomEvent} e
   */
  _removeCustom(e) {
    const index = Number(e.currentTarget.dataset.index);
    if (index !== index) {
      return;
    }
    const model = this.model;
    if (!model || !model.length) {
      return;
    }
    model.splice(index, 1);
    this.model = Array.from(model);
  }
  /**
   * Computes if model item is optional.
   * The items is always optional if is not required and when `hasOptional`
   * is set to `true`.
   *
   * @param {Boolean} hasOptional [description]
   * @param {Object} model Model item.
   * @return {Boolean} `true` if the model item is optional in the form.
   */
  computeIsOptional(hasOptional, model) {
    if (!hasOptional) {
      return false;
    }
    if (!model || !model.required) {
      return true;
    }
    return false;
  }
  /**
   * Computes value for `renderEmptyMessage`.
   *
   * @param {Boolean} allowCustom True if the form allows to add custom values.
   * @param {?Array} model Current model
   * @return {Boolean} `true` when allowCustom is falsy set and model is empty
   */
  _computeRenderEmptyMessage(allowCustom, model) {
    return !allowCustom && !model;
  }
};

/**
 * An element that renders a form input to edit API type value.
 *
 * This element is to replace deprecated `raml-type-form-input` that has
 * the same functionality but works with RAML data only.
 *
 * **If you need an element that works with Polymer 1.0, use old `raml-type-form-input` element**
 *
 * It accespt ARC view model generated by either `api-headers-editr`
 * or `api-url-data-model`. The model is generated using
 * `api-view-model-transformer` that transforms AMF `json/ld` API model
 * into data model consumable by ARC UI elements.
 *
 * Also, use mixins and variables for `anypoint-input`, `paper-dropdown-menu`,
 * `anypoint-listbox`, and `anypoint-item` to style this element.
 *
 * @customElement
 * @memberof ApiElements
 * @appliesMixin IronValidatableBehavior
 * @polymer
 * @demo demo/index.html
 */
class ApiPropertyFormItem extends ValidatableMixin(LitElement) {
  static get styles() {
    return css`
    :host {
      display: inline-block;
      position: relative;
      /* <input> width */
      min-width: 200px;
    }

    :host([isarray]) .content {
      padding-left: 8px;
      border-left: 1px var(--raml-type-form-input-array-border-color, rgba(0, 0, 0, 0.14)) solid;
    }

    :host(:not([isarray])) .content {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    .action-icon {
      color: var(--from-row-action-icon-color, var(--icon-button-color, rgba(0, 0, 0, 0.74)));
      transition: opacity 0.2s ease-in-out, color 0.2s ease-in-out;
    }

    .action-icon:hover {
      color: var(--from-row-action-icon-color-hover, var(--accent-color, rgba(0, 0, 0, 0.88)));
    }

    .array-item {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    anypoint-input,
    anypoint-dropdown-menu {
      flex: 1;
      width: auto;
    }

    anypoint-button iron-icon {
      margin-right: 12px;
    }

    .nil-option {
      margin-left: 8px;
    }

    .array-label {
      margin-left: 8px;
    }`;
  }

  _enumTemplate() {
    const { model, name, readOnly, disabled, value, outlined, compatibility, _nilEnabled } = this;
    const values = model.schema.enum || [];
    return html`
    <anypoint-dropdown-menu
      name="${name}"
      ?required="${!_nilEnabled && model.required}"
      autovalidate
      data-type="enum"
      ?disabled="${readOnly || disabled || _nilEnabled}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}">
      <label slot="label">${model.schema.inputLabel}</label>
      <anypoint-listbox
        slot="dropdown-content"
        attrforselected="data-value"
        .selected="${value}"
        ?compatibility="${compatibility}"
        @selected-changed="${this._listSelectionHandler}">
        ${values.map((item) => html`<anypoint-item data-value="${item}">${item}</anypoint-item>`)}
      </anypoint-listbox>
    </anypoint-dropdown-menu>`;
  }

  _booleanTemplate() {
    const { model, name, readOnly, disabled, value, outlined, compatibility, _nilEnabled } = this;
    const bindValue = (value === true || value === 'true') ? 'true' : 'false';
    return html`
    <anypoint-dropdown-menu
      name="${name}"
      ?required="${!_nilEnabled && model.required}"
      autovalidate
      data-type="boolean"
      ?disabled="${readOnly || disabled || _nilEnabled}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}">
      <label slot="label">${model.schema.inputLabel}</label>
      <anypoint-listbox
        slot="dropdown-content"
        attrforselected="data-value"
        .selected="${bindValue}"
        ?compatibility="${compatibility}"
        @selected-changed="${this._listSelectionHandler}">
        <anypoint-item data-value="true">True</anypoint-item>
        <anypoint-item data-value="false">False</anypoint-item>
      </anypoint-listbox>
    </anypoint-dropdown-menu>`;
  }

  _inputTemplate() {
    const { model, name, noLabelFloat, readOnly, disabled, value, outlined, compatibility, _nilEnabled } = this;
    if (!model) {
      return;
    }
    if (!model.schema) {
      model.schema = {};
    }
    return html`<anypoint-input
      .value="${value}"
      ?required="${!_nilEnabled && model.required}"
      .pattern="${model.schema.pattern}"
      .name="${name}"
      autovalidate
      .type="${model.schema.inputType}"
      .min="${model.schema.minimum}"
      .max="${model.schema.maximum}"
      .maxLength="${model.schema.maxLength}"
      .minLength="${model.schema.minLength}"
      .placeholder="${model.schema.inputPlaceholder}"
      ?nolabelfloat="${noLabelFloat}"
      ?readonly="${readOnly}"
      ?disabled="${disabled || _nilEnabled}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}"
      data-type="input"
      @input="${this._inputHandler}"
      @change="${this._inputChangeHandler}"
      invalidmessage="${`${name} is invalid. Check documentation.`}">
      <label slot="label">${model.schema.inputLabel}</label>
      </anypoint-input>`;
  }

  _arrayTemplate() {
    const { model, name, readOnly, disabled, _arrayValue, outlined, compatibility, _nilEnabled } = this;
    const values = _arrayValue || [];
    const itemLabel = model.schema.inputLabel || 'Parameter value';
    return html`
    <label class="array-label">${itemLabel}</label>

    ${values.map((item, index) => html`
    <div class="array-item">
      <anypoint-input
        .value="${item.value}"
        ?required="${!_nilEnabled && model.required}"
        .pattern="${model.schema.pattern}"
        .name="${name}"
        autovalidate
        .type="${model.schema.inputType}"
        .min="${model.schema.minimum}"
        .max="${model.schema.maximum}"
        .maxLength="${model.schema.maxLength}"
        .minLength="${model.schema.minLength}"
        nolabelfloat
        ?readonly="${readOnly}"
        ?disabled="${disabled || _nilEnabled}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        data-type="array"
        data-index="${index}"
        @input="${this._arrayValueHandler}"
        invalidmessage="${`${name} is invalid. Check documentation.`}">
        <label slot="label">${itemLabel}<label>
      </anypoint-input>
      ${index ? html`<anypoint-icon-button
        class="action-icon"
        data-index="${index}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        @click="${this._removeArrayValue}"
        title="Remove array value"
        ?disabled="${this.readOnly || disabled}">
        <iron-icon icon="arc:remove-circle-outline"></iron-icon>
      </anypoint-icon-button>` : undefined}
    </div>`)}
    <div class="add-action">
      <anypoint-button
        @click="${this.addEmptyArrayValue}"
        title="Add array velue button"
        ?disabled="${readOnly || disabled}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}">
        <iron-icon class="action-icon" icon="arc:add-circle-outline" alt="Add array value icon"></iron-icon>
        Add array value
      </anypoint-button>
    </div>
    `;
  }

  render() {
    const { readOnly, disabled, _isEnum, _isBoolean, _isInput, _isArray, _isNillable } = this;
    return html`
    <div class="content">
      ${_isEnum ? this._enumTemplate() : undefined}
      ${_isBoolean ? this._booleanTemplate() : undefined}
      ${_isInput ? this._inputTemplate() : undefined}
      ${_isArray ? this._arrayTemplate() : undefined}

      ${_isNillable ? html`<anypoint-checkbox
        ?disabled="${readOnly || disabled}"
        class="nil-option"
        @checked-changed="${this._nillableChanged}">Nil</anypoint-checkbox>` : undefined}
    </div>`;
  }

  static get properties() {
    return {
      /**
       * View model generated for this view.
       *
       * @type {Array<Object>}
       */
      model: { type: Array },
      /**
       * Name of the form item
       */
      name: { type: String, reflect: true },
      /**
       * When set, prohibits inputs to have floating labels
       */
      noLabelFloat: { type: Boolean },
      /**
       * Enables outlined theme.
       */
      outlined: { type: Boolean, reflect: true },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Input's value.
       */
      value: { type: String },
      // Computed value, True if current item is a dropdown with values.
      _isEnum: { type: Boolean },
      // Computed value, True if current item is an regular input
      _isInput: { type: Boolean },
      // Computed value, True if current item is an array object
      _isArray: { type: Boolean },
      // Computed value, True if current item is an union with nill value.
      _isNillable: { type: Boolean },
      _nilEnabled: { type: Boolean },
      // Computed value, True if current item is a boolean value
      _isBoolean: { type: Boolean },
      // A value of an array item (only if `isArray` is set)
      _arrayValue: { type: Array },
      /**
       * Set to indicate that the consol is required
       */
      required: { type: Boolean, reflect: true },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set the editor renders form controls disabled.
       */
      disabled: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get model() {
    return this._model;
  }

  set model(value) {
    const old = this._model;
    /* istanbul ignore if */
    if (value === old) {
      return;
    }
    this._model = value;
    this._modelChanged(value);
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (value === old) {
      return;
    }
    if (value === undefined || value === null || value === 'undefined') {
      value = '';
    }
    this._value = value;
    this.requestUpdate('value', old);
    this._isArrayChanged(this._isArray, value);
    const opts = {
      detail: {
        value
      }
    };
    this.dispatchEvent(new CustomEvent('changed', opts));
    this.dispatchEvent(new CustomEvent('value-changed', opts));
  }

  get _isArray() {
    return this.__isArray;
  }

  set _isArray(value) {
    const old = this.__isArray;
    /* istanbul ignore if */
    if (value === old) {
      return;
    }
    this.__isArray = value;
    this._isArrayChanged(value, this.value);
    if (value) {
      this.setAttribute('isarray', '');
    } else {
      this.removeAttribute('isarray');
    }
  }

  get _isNillable() {
    return this.__isNillable;
  }

  set _isNillable(value) {
    const old = this.__isNillable;
    /* istanbul ignore if */
    if (value === old) {
      return;
    }
    this.__isNillable = value;
    if (value) {
      this.setAttribute('isnillable', '');
    } else {
      this.removeAttribute('isnillable');
    }
  }

  constructor() {
    super();
    this._isInput = true;
    this.value = '';
  }

  /**
   * Resets UI state variables
   */
  _resetStates() {
    this._isEnum = false;
    this._isInput = false;
    this._isArray = false;
    this._isBoolean = false;
    this._isNillable = false;
  }

  // Sets the template depending on model configuration
  _modelChanged(model) {
    this._resetStates();
    if (!model) {
      return;
    }
    const schema = model.schema;
    switch (true) {
      case schema.isEnum:
        this._isEnum = true;
        break;
      case schema.isArray:
        this._prepareArraySchema(model);
        break;
      case schema.isBool:
        this._isBoolean = true;
        break;
      default:
        this._isInput = true;
    }
    this._isNillable = !!schema.isNillable;
  }
  /**
   * Sets `arrayValue` from model's value.
   *
   * @param {Object} model ARC amf view model.
   */
  _prepareArraySchema(model) {
    this._isArray = true;
    let value;
    if (model.value && model.value instanceof Array) {
      value = model.value.map((item) => {
        return {
          value: item
        };
      });
    } else {
      value = [];
    }
    this._arrayValue = value;
  }

  // Sets array values if needed
  _isArrayChanged(isArray) {
    if (this.__internalChange) {
      return;
    }
    const v = this.value;
    if (!v || !isArray) {
      this._arrayValue = undefined;
      return;
    }
    this._arrayValue = this._itemsForArray(v);
  }
  /**
   * The `dom-repeat` requires an object to properly support changes.
   * In order to do this simple values has to be transformed into objects.
   *
   * @param {Array<String>} value An array of values.
   * @return {Array}
   */
  _itemsForArray(value) {
    let result = [];
    if (value instanceof Array) {
      result = value.map(function(item) {
        return {
          value: item
        };
      });
    } else {
      result.push({
        value
      });
    }
    return result;
  }
  // Handles array value change and sets the `value` property.
  _arrayValueChanged() {
    let arr = this._arrayValue;
    if (arr) {
      arr = arr.map((item) => item.value);
    }
    this.__internalChange = true;
    this.value = arr;
    this.__internalChange = false;
  }
  /**
   * Adds new element to the array value.
   * @return {Number} Index of the value in the values array.
   * Note that the index may change over time if the user remove any value.
   */
  addEmptyArrayValue() {
    const items = this._arrayValue || [];
    items.push({
      value: ''
    });
    this._arrayValue = [...items];
    return this._arrayValue.length - 1;
  }
  /**
   * Removes an array value for given index.
   * @param {Number} index A position of the value in the array
   */
  removeArrayValue(index) {
    const value = this._arrayValue;
    value.splice(index, 1);
    this._arrayValue = [...value];
    this._arrayValueChanged();
  }

  // Removes item from array value.
  _removeArrayValue(e) {
    const index = Number(e.currentTarget.dataset.index);
    if (index !== index) {
      return;
    }
    this.removeArrayValue(index);
  }
  /**
   * Fallback validator if form validator is unavailable.
   *
   * @return {Boolean} True if the constrol is valid.
   */
  _defaultValidator() {
    const m = this.model;
    if (!m) {
      return true;
    }
    if (!m.required) {
      return true;
    }
    return !!m.value;
  }
  /**
   * Returns input(s) depending on model type.
   * @return {Element|NodeList|undefined} Returns an element for input, enum, and
   * boolean types. Returns NodeList for array type. Returns undefined when model is not set
   * or DOM is not ready.
   */
  _getInputElement() {
    if (this._isInput) {
      return this.shadowRoot.querySelector('anypoint-input[data-type="input"]');
    }
    if (this._isBoolean) {
      return this.shadowRoot.querySelector('anypoint-dropdown-menu[data-type="boolean"]');
    }
    if (this._isEnum) {
      return this.shadowRoot.querySelector('anypoint-dropdown-menu[data-type="enum"]');
    }
    if (this._isArray) {
      return this.shadowRoot.querySelectorAll('anypoint-input[data-type="array"]');
    }
  }
  /**
   * Overrides `ValidatableMixin._getValidity`.
   * If the element is set to be `NIL` value it always returns true.
   * Otherwise it calls `_getInputsValidity()` for input validation result.
   * @return {Boolean} Validation result
   */
  _getValidity() {
    if (this._nilEnabled) {
      return true;
    }
    return this._getInputsValidity();
  }
  /**
   * Validates the inputs and returns validation state.
   * @return {Boolean}
   */
  _getInputsValidity() {
    const node = this._getInputElement();
    if (!node) {
      return this._defaultValidator();
    }
    if (this._isArray) {
      for (let i = 0; i < node.length; i++) {
        if (!node[i].validate()) {
          return false;
        }
      }
      return true;
    }
    return node.validate();
  }
  /**
   * Controls value and input state when "nil" checkbox's value change.
   * @param {CustomEvent} e
   */
  async _nillableChanged(e) {
    const { value } = e.detail;
    this._nilEnabled = value;
    if (value) {
      this._oldNilValue = this.value;
      this.value = 'nil';
    } else {
      if (this._oldNilValue) {
        this.value = this._oldNilValue;
        this._oldNilValue = undefined;
      } else if (this.value === 'nil') {
        this.value = '';
      }
    }
    await this.updateComplete;
    this._getInputsValidity();
  }

  _listSelectionHandler(e) {
    if (this._isBoolean) {
      this.value = e.target.selected === 'true' ? true : false;
    } else {
      this.value = e.target.selected;
    }
  }

  _inputHandler(e) {
    this.value = e.target.value;
  }

  _inputChangeHandler(e) {
    // in FF input event won't fire for number type and when using arrow up/down.
    this.value = e.target.value;
  }

  _arrayValueHandler(e) {
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    const value = this._arrayValue;
    value[index].value = e.target.value;
    this._arrayValue = [...value];
    this._arrayValueChanged();
  }
}

window.customElements.define('api-property-form-item', ApiPropertyFormItem);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/*
iron-request can be used to perform XMLHttpRequests.

    <iron-request id="xhr"></iron-request>
    ...
    this.$.xhr.send({url: url, body: params});
*/
Polymer({
  is: 'iron-request',

  hostAttributes: {hidden: true},

  properties: {

    /**
     * A reference to the XMLHttpRequest instance used to generate the
     * network request.
     *
     * @type {XMLHttpRequest}
     */
    xhr: {
      type: Object,
      notify: true,
      readOnly: true,
      value: function() {
        return new XMLHttpRequest();
      }
    },

    /**
     * A reference to the parsed response body, if the `xhr` has completely
     * resolved.
     *
     * @type {*}
     * @default null
     */
    response: {
      type: Object,
      notify: true,
      readOnly: true,
      value: function() {
        return null;
      }
    },

    /**
     * A reference to the status code, if the `xhr` has completely resolved.
     */
    status: {type: Number, notify: true, readOnly: true, value: 0},

    /**
     * A reference to the status text, if the `xhr` has completely resolved.
     */
    statusText: {type: String, notify: true, readOnly: true, value: ''},

    /**
     * A promise that resolves when the `xhr` response comes back, or rejects
     * if there is an error before the `xhr` completes.
     * The resolve callback is called with the original request as an argument.
     * By default, the reject callback is called with an `Error` as an argument.
     * If `rejectWithRequest` is true, the reject callback is called with an
     * object with two keys: `request`, the original request, and `error`, the
     * error object.
     *
     * @type {Promise}
     */
    completes: {
      type: Object,
      readOnly: true,
      notify: true,
      value: function() {
        return new Promise(function(resolve, reject) {
          this.resolveCompletes = resolve;
          this.rejectCompletes = reject;
        }.bind(this));
      }
    },

    /**
     * An object that contains progress information emitted by the XHR if
     * available.
     *
     * @default {}
     */
    progress: {
      type: Object,
      notify: true,
      readOnly: true,
      value: function() {
        return {};
      }
    },

    /**
     * Aborted will be true if an abort of the request is attempted.
     */
    aborted: {
      type: Boolean,
      notify: true,
      readOnly: true,
      value: false,
    },

    /**
     * Errored will be true if the browser fired an error event from the
     * XHR object (mainly network errors).
     */
    errored: {type: Boolean, notify: true, readOnly: true, value: false},

    /**
     * TimedOut will be true if the XHR threw a timeout event.
     */
    timedOut: {type: Boolean, notify: true, readOnly: true, value: false}
  },

  /**
   * Succeeded is true if the request succeeded. The request succeeded if it
   * loaded without error, wasn't aborted, and the status code is  200, and
   * < 300, or if the status code is 0.
   *
   * The status code 0 is accepted as a success because some schemes - e.g.
   * file:// - don't provide status codes.
   *
   * @return {boolean}
   */
  get succeeded() {
    if (this.errored || this.aborted || this.timedOut) {
      return false;
    }
    var status = this.xhr.status || 0;

    // Note: if we are using the file:// protocol, the status code will be 0
    // for all outcomes (successful or otherwise).
    return status === 0 || (status >= 200 && status < 300);
  },

  /**
   * Sends an HTTP request to the server and returns a promise (see the
   * `completes` property for details).
   *
   * The handling of the `body` parameter will vary based on the Content-Type
   * header. See the docs for iron-ajax's `body` property for details.
   *
   * @param {{
   *   url: string,
   *   method: (string|undefined),
   *   async: (boolean|undefined),
   *   body:
   * (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object),
   *   headers: (Object|undefined),
   *   handleAs: (string|undefined),
   *   jsonPrefix: (string|undefined),
   *   withCredentials: (boolean|undefined),
   *   timeout: (number|undefined),
   *   rejectWithRequest: (boolean|undefined)}} options -
   *   - url The url to which the request is sent.
   *   - method The HTTP method to use, default is GET.
   *   - async By default, all requests are sent asynchronously. To send
   * synchronous requests, set to false.
   *   -  body The content for the request body for POST method.
   *   -  headers HTTP request headers.
   *   -  handleAs The response type. Default is 'text'.
   *   -  withCredentials Whether or not to send credentials on the request.
   * Default is false.
   *   -  timeout - Timeout for request, in milliseconds.
   *   -  rejectWithRequest Set to true to include the request object with
   * promise rejections.
   * @return {Promise}
   */
  send: function(options) {
    var xhr = this.xhr;

    if (xhr.readyState > 0) {
      return null;
    }

    xhr.addEventListener('progress', function(progress) {
      this._setProgress({
        lengthComputable: progress.lengthComputable,
        loaded: progress.loaded,
        total: progress.total
      });

      // Webcomponents v1 spec does not fire *-changed events when not connected
      this.fire('iron-request-progress-changed', {value: this.progress});
    }.bind(this));

    xhr.addEventListener('error', function(error) {
      this._setErrored(true);
      this._updateStatus();
      var response =
          options.rejectWithRequest ? {error: error, request: this} : error;
      this.rejectCompletes(response);
    }.bind(this));

    xhr.addEventListener('timeout', function(error) {
      this._setTimedOut(true);
      this._updateStatus();
      var response =
          options.rejectWithRequest ? {error: error, request: this} : error;
      this.rejectCompletes(response);
    }.bind(this));

    xhr.addEventListener('abort', function() {
      this._setAborted(true);
      this._updateStatus();
      var error = new Error('Request aborted.');
      var response =
          options.rejectWithRequest ? {error: error, request: this} : error;
      this.rejectCompletes(response);
    }.bind(this));

    // Called after all of the above.
    xhr.addEventListener('loadend', function() {
      this._updateStatus();
      this._setResponse(this.parseResponse());

      if (!this.succeeded) {
        var error = new Error(
            'The request failed with status code: ' + this.xhr.status);
        var response =
            options.rejectWithRequest ? {error: error, request: this} : error;
        this.rejectCompletes(response);
        return;
      }

      this.resolveCompletes(this);
    }.bind(this));

    this.url = options.url;
    var isXHRAsync = options.async !== false;
    xhr.open(options.method || 'GET', options.url, isXHRAsync);

    var acceptType = {
      'json': 'application/json',
      'text': 'text/plain',
      'html': 'text/html',
      'xml': 'application/xml',
      'arraybuffer': 'application/octet-stream'
    }[options.handleAs];
    var headers = options.headers || Object.create(null);
    var newHeaders = Object.create(null);
    for (var key in headers) {
      newHeaders[key.toLowerCase()] = headers[key];
    }
    headers = newHeaders;

    if (acceptType && !headers['accept']) {
      headers['accept'] = acceptType;
    }
    Object.keys(headers).forEach(function(requestHeader) {
      if (/[A-Z]/.test(requestHeader)) {
        Base._error('Headers must be lower case, got', requestHeader);
      }
      xhr.setRequestHeader(requestHeader, headers[requestHeader]);
    }, this);

    if (isXHRAsync) {
      xhr.timeout = options.timeout;

      var handleAs = options.handleAs;

      // If a JSON prefix is present, the responseType must be 'text' or the
      // browser wont be able to parse the response.
      if (!!options.jsonPrefix || !handleAs) {
        handleAs = 'text';
      }

      // In IE, `xhr.responseType` is an empty string when the response
      // returns. Hence, caching it as `xhr._responseType`.
      xhr.responseType = xhr._responseType = handleAs;

      // Cache the JSON prefix, if it exists.
      if (!!options.jsonPrefix) {
        xhr._jsonPrefix = options.jsonPrefix;
      }
    }

    xhr.withCredentials = !!options.withCredentials;


    var body = this._encodeBodyObject(options.body, headers['content-type']);

    xhr.send(
        /**
           @type {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|
                   null|string|undefined}
         */
        (body));

    return this.completes;
  },

  /**
   * Attempts to parse the response body of the XHR. If parsing succeeds,
   * the value returned will be deserialized based on the `responseType`
   * set on the XHR.
   *
   * @return {*} The parsed response,
   * or undefined if there was an empty response or parsing failed.
   */
  parseResponse: function() {
    var xhr = this.xhr;
    var responseType = xhr.responseType || xhr._responseType;
    var preferResponseText = !this.xhr.responseType;
    var prefixLen = (xhr._jsonPrefix && xhr._jsonPrefix.length) || 0;

    try {
      switch (responseType) {
        case 'json':
          // If the xhr object doesn't have a natural `xhr.responseType`,
          // we can assume that the browser hasn't parsed the response for us,
          // and so parsing is our responsibility. Likewise if response is
          // undefined, as there's no way to encode undefined in JSON.
          if (preferResponseText || xhr.response === undefined) {
            // Try to emulate the JSON section of the response body section of
            // the spec: https://xhr.spec.whatwg.org/#response-body
            // That is to say, we try to parse as JSON, but if anything goes
            // wrong return null.
            try {
              return JSON.parse(xhr.responseText);
            } catch (_) {
              console.warn('Failed to parse JSON sent from ' + xhr.responseURL);
              return null;
            }
          }

          return xhr.response;
        case 'xml':
          return xhr.responseXML;
        case 'blob':
        case 'document':
        case 'arraybuffer':
          return xhr.response;
        case 'text':
        default: {
          // If `prefixLen` is set, it implies the response should be parsed
          // as JSON once the prefix of length `prefixLen` is stripped from
          // it. Emulate the behavior above where null is returned on failure
          // to parse.
          if (prefixLen) {
            try {
              return JSON.parse(xhr.responseText.substring(prefixLen));
            } catch (_) {
              console.warn('Failed to parse JSON sent from ' + xhr.responseURL);
              return null;
            }
          }
          return xhr.responseText;
        }
      }
    } catch (e) {
      this.rejectCompletes(new Error('Could not parse response. ' + e.message));
    }
  },

  /**
   * Aborts the request.
   */
  abort: function() {
    this._setAborted(true);
    this.xhr.abort();
  },

  /**
   * @param {*} body The given body of the request to try and encode.
   * @param {?string} contentType The given content type, to infer an encoding
   *     from.
   * @return {*} Either the encoded body as a string, if successful,
   *     or the unaltered body object if no encoding could be inferred.
   */
  _encodeBodyObject: function(body, contentType) {
    if (typeof body == 'string') {
      return body;  // Already encoded.
    }
    var bodyObj = /** @type {Object} */ (body);
    switch (contentType) {
      case ('application/json'):
        return JSON.stringify(bodyObj);
      case ('application/x-www-form-urlencoded'):
        return this._wwwFormUrlEncode(bodyObj);
    }
    return body;
  },

  /**
   * @param {Object} object The object to encode as x-www-form-urlencoded.
   * @return {string} .
   */
  _wwwFormUrlEncode: function(object) {
    if (!object) {
      return '';
    }
    var pieces = [];
    Object.keys(object).forEach(function(key) {
      // TODO(rictic): handle array values here, in a consistent way with
      //   iron-ajax params.
      pieces.push(
          this._wwwFormUrlEncodePiece(key) + '=' +
          this._wwwFormUrlEncodePiece(object[key]));
    }, this);
    return pieces.join('&');
  },

  /**
   * @param {*} str A key or value to encode as x-www-form-urlencoded.
   * @return {string} .
   */
  _wwwFormUrlEncodePiece: function(str) {
    // Spec says to normalize newlines to \r\n and replace %20 spaces with +.
    // jQuery does this as well, so this is likely to be widely compatible.
    if (str === null || str === undefined || !str.toString) {
      return '';
    }

    return encodeURIComponent(str.toString().replace(/\r?\n/g, '\r\n'))
        .replace(/%20/g, '+');
  },

  /**
   * Updates the status code and status text.
   */
  _updateStatus: function() {
    this._setStatus(this.xhr.status);
    this._setStatusText(
        (this.xhr.statusText === undefined) ? '' : this.xhr.statusText);
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
The `iron-ajax` element exposes network request functionality.

    <iron-ajax
        auto
        url="https://www.googleapis.com/youtube/v3/search"
        params='{"part":"snippet", "q":"polymer", "key": "YOUTUBE_API_KEY",
"type": "video"}' handle-as="json" on-response="handleResponse"
        debounce-duration="300"></iron-ajax>

With `auto` set to `true`, the element performs a request whenever
its `url`, `params` or `body` properties are changed. Automatically generated
requests will be debounced in the case that multiple attributes are changed
sequentially.

Note: The `params` attribute must be double quoted JSON.

You can trigger a request explicitly by calling `generateRequest` on the
element.

@demo demo/index.html
*/
Polymer({

  is: 'iron-ajax',

  /**
   * Fired before a request is sent.
   *
   * @event iron-ajax-presend
   */

  /**
   * Fired when a request is sent.
   *
   * @event request
   */

  /**
   * Fired when a request is sent.
   *
   * @event iron-ajax-request
   */

  /**
   * Fired when a response is received.
   *
   * @event response
   */

  /**
   * Fired when a response is received.
   *
   * @event iron-ajax-response
   */

  /**
   * Fired when an error is received.
   *
   * @event error
   */

  /**
   * Fired when an error is received.
   *
   * @event iron-ajax-error
   */

  hostAttributes: {hidden: true},

  properties: {
    /**
     * The URL target of the request.
     */
    url: {type: String},

    /**
     * An object that contains query parameters to be appended to the
     * specified `url` when generating a request. If you wish to set the body
     * content when making a POST request, you should use the `body` property
     * instead.
     */
    params: {
      type: Object,
      value: function() {
        return {};
      }
    },

    /**
     * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
     * Default is 'GET'.
     */
    method: {type: String, value: 'GET'},

    /**
     * HTTP request headers to send.
     *
     * Example:
     *
     *     <iron-ajax
     *         auto
     *         url="http://somesite.com"
     *         headers='{"X-Requested-With": "XMLHttpRequest"}'
     *         handle-as="json"></iron-ajax>
     *
     * Note: setting a `Content-Type` header here will override the value
     * specified by the `contentType` property of this element.
     */
    headers: {
      type: Object,
      value: function() {
        return {};
      }
    },

    /**
     * Content type to use when sending data. If the `contentType` property
     * is set and a `Content-Type` header is specified in the `headers`
     * property, the `headers` property value will take precedence.
     *
     * Varies the handling of the `body` param.
     */
    contentType: {type: String, value: null},

    /**
     * Body content to send with the request, typically used with "POST"
     * requests.
     *
     * If body is a string it will be sent unmodified.
     *
     * If Content-Type is set to a value listed below, then
     * the body will be encoded accordingly.
     *
     *    * `content-type="application/json"`
     *      * body is encoded like `{"foo":"bar baz","x":1}`
     *    * `content-type="application/x-www-form-urlencoded"`
     *      * body is encoded like `foo=bar+baz&x=1`
     *
     * Otherwise the body will be passed to the browser unmodified, and it
     * will handle any encoding (e.g. for FormData, Blob, ArrayBuffer).
     *
     * @type
     * (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object)
     */
    body: {type: Object, value: null},

    /**
     * Toggle whether XHR is synchronous or asynchronous. Don't change this
     * to true unless You Know What You Are Doing.
     */
    sync: {type: Boolean, value: false},

    /**
     * Specifies what data to store in the `response` property, and
     * to deliver as `event.detail.response` in `response` events.
     *
     * One of:
     *
     *    `text`: uses `XHR.responseText`.
     *
     *    `xml`: uses `XHR.responseXML`.
     *
     *    `json`: uses `XHR.responseText` parsed as JSON.
     *
     *    `arraybuffer`: uses `XHR.response`.
     *
     *    `blob`: uses `XHR.response`.
     *
     *    `document`: uses `XHR.response`.
     */
    handleAs: {type: String, value: 'json'},

    /**
     * Set the withCredentials flag on the request.
     */
    withCredentials: {type: Boolean, value: false},

    /**
     * Set the timeout flag on the request.
     */
    timeout: {type: Number, value: 0},

    /**
     * If true, automatically performs an Ajax request when either `url` or
     * `params` changes.
     */
    auto: {type: Boolean, value: false},

    /**
     * If true, error messages will automatically be logged to the console.
     */
    verbose: {type: Boolean, value: false},

    /**
     * The most recent request made by this iron-ajax element.
     *
     * @type {Object|undefined}
     */
    lastRequest: {type: Object, notify: true, readOnly: true},

    /**
     * The `progress` property of this element's `lastRequest`.
     *
     * @type {Object|undefined}
     */
    lastProgress: {type: Object, notify: true, readOnly: true},

    /**
     * True while lastRequest is in flight.
     */
    loading: {type: Boolean, notify: true, readOnly: true},

    /**
     * lastRequest's response.
     *
     * Note that lastResponse and lastError are set when lastRequest finishes,
     * so if loading is true, then lastResponse and lastError will correspond
     * to the result of the previous request.
     *
     * The type of the response is determined by the value of `handleAs` at
     * the time that the request was generated.
     *
     * @type {Object}
     */
    lastResponse: {type: Object, notify: true, readOnly: true},

    /**
     * lastRequest's error, if any.
     *
     * @type {Object}
     */
    lastError: {type: Object, notify: true, readOnly: true},

    /**
     * An Array of all in-flight requests originating from this iron-ajax
     * element.
     */
    activeRequests: {
      type: Array,
      notify: true,
      readOnly: true,
      value: function() {
        return [];
      }
    },

    /**
     * Length of time in milliseconds to debounce multiple automatically
     * generated requests.
     */
    debounceDuration: {type: Number, value: 0, notify: true},

    /**
     * Prefix to be stripped from a JSON response before parsing it.
     *
     * In order to prevent an attack using CSRF with Array responses
     * (http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/)
     * many backends will mitigate this by prefixing all JSON response bodies
     * with a string that would be nonsensical to a JavaScript parser.
     *
     */
    jsonPrefix: {type: String, value: ''},

    /**
     * By default, iron-ajax's events do not bubble. Setting this attribute will
     * cause its request and response events as well as its iron-ajax-request,
     * -response,  and -error events to bubble to the window object. The vanilla
     * error event never bubbles when using shadow dom even if this.bubbles is
     * true because a scoped flag is not passed with it (first link) and because
     * the shadow dom spec did not used to allow certain events, including
     * events named error, to leak outside of shadow trees (second link).
     * https://www.w3.org/TR/shadow-dom/#scoped-flag
     * https://www.w3.org/TR/2015/WD-shadow-dom-20151215/#events-that-are-not-leaked-into-ancestor-trees
     */
    bubbles: {type: Boolean, value: false},

    /**
     * Changes the [`completes`](iron-request#property-completes) promise chain
     * from `generateRequest` to reject with an object
     * containing the original request, as well an error message.
     * If false (default), the promise rejects with an error message only.
     */
    rejectWithRequest: {type: Boolean, value: false},

    _boundHandleResponse: {
      type: Function,
      value: function() {
        return this._handleResponse.bind(this);
      }
    }
  },

  observers:
      ['_requestOptionsChanged(url, method, params.*, headers, contentType, ' +
       'body, sync, handleAs, jsonPrefix, withCredentials, timeout, auto)'],

  created: function() {
    this._boundOnProgressChanged = this._onProgressChanged.bind(this);
  },

  /**
   * The query string that should be appended to the `url`, serialized from
   * the current value of `params`.
   *
   * @return {string}
   */
  get queryString() {
    var queryParts = [];
    var param;
    var value;

    for (param in this.params) {
      value = this.params[param];
      param = window.encodeURIComponent(param);

      if (Array.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          queryParts.push(param + '=' + window.encodeURIComponent(value[i]));
        }
      } else if (value !== null) {
        queryParts.push(param + '=' + window.encodeURIComponent(value));
      } else {
        queryParts.push(param);
      }
    }

    return queryParts.join('&');
  },

  /**
   * The `url` with query string (if `params` are specified), suitable for
   * providing to an `iron-request` instance.
   *
   * @return {string}
   */
  get requestUrl() {
    var queryString = this.queryString;
    var url = this.url || '';

    if (queryString) {
      var bindingChar = url.indexOf('?') >= 0 ? '&' : '?';
      return url + bindingChar + queryString;
    }

    return url;
  },

  /**
   * An object that maps header names to header values, first applying the
   * the value of `Content-Type` and then overlaying the headers specified
   * in the `headers` property.
   *
   * @return {Object}
   */
  get requestHeaders() {
    var headers = {};
    var contentType = this.contentType;
    if (contentType == null && (typeof this.body === 'string')) {
      contentType = 'application/x-www-form-urlencoded';
    }
    if (contentType) {
      headers['content-type'] = contentType;
    }
    var header;

    if (typeof this.headers === 'object') {
      for (header in this.headers) {
        headers[header] = this.headers[header].toString();
      }
    }

    return headers;
  },

  _onProgressChanged: function(event) {
    this._setLastProgress(event.detail.value);
  },

  /**
   * Request options suitable for generating an `iron-request` instance based
   * on the current state of the `iron-ajax` instance's properties.
   *
   * @return {{
   *   url: string,
   *   method: (string|undefined),
   *   async: (boolean|undefined),
   *   body:
   * (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object),
   *   headers: (Object|undefined),
   *   handleAs: (string|undefined),
   *   jsonPrefix: (string|undefined),
   *   withCredentials: (boolean|undefined)}}
   */
  toRequestOptions: function() {
    return {
      url: this.requestUrl || '',
      method: this.method,
      headers: this.requestHeaders,
      body: this.body,
      async: !this.sync,
      handleAs: this.handleAs,
      jsonPrefix: this.jsonPrefix,
      withCredentials: this.withCredentials,
      timeout: this.timeout,
      rejectWithRequest: this.rejectWithRequest,
    };
  },

  /**
   * Performs an AJAX request to the specified URL.
   *
   * @return {!IronRequestElement}
   */
  generateRequest: function() {
    var request = /** @type {!IronRequestElement} */ (
        document.createElement('iron-request'));
    var requestOptions = this.toRequestOptions();

    this.push('activeRequests', request);

    request.completes.then(this._boundHandleResponse)
        .catch(this._handleError.bind(this, request))
        .then(this._discardRequest.bind(this, request));

    var evt = this.fire(
        'iron-ajax-presend',
        {request: request, options: requestOptions},
        {bubbles: this.bubbles, cancelable: true});

    if (evt.defaultPrevented) {
      request.abort();
      request.rejectCompletes(request);
      return request;
    }

    if (this.lastRequest) {
      this.lastRequest.removeEventListener(
          'iron-request-progress-changed', this._boundOnProgressChanged);
    }

    request.addEventListener(
        'iron-request-progress-changed', this._boundOnProgressChanged);

    request.send(requestOptions);
    this._setLastProgress(null);
    this._setLastRequest(request);
    this._setLoading(true);

    this.fire(
        'request',
        {request: request, options: requestOptions},
        {bubbles: this.bubbles, composed: true});

    this.fire(
        'iron-ajax-request',
        {request: request, options: requestOptions},
        {bubbles: this.bubbles, composed: true});

    return request;
  },

  _handleResponse: function(request) {
    if (request === this.lastRequest) {
      this._setLastResponse(request.response);
      this._setLastError(null);
      this._setLoading(false);
    }
    this.fire('response', request, {bubbles: this.bubbles, composed: true});
    this.fire(
        'iron-ajax-response', request, {bubbles: this.bubbles, composed: true});
  },

  _handleError: function(request, error) {
    if (this.verbose) {
      Base._error(error);
    }

    if (request === this.lastRequest) {
      this._setLastError({
        request: request,
        error: error,
        status: request.xhr.status,
        statusText: request.xhr.statusText,
        response: request.xhr.response
      });
      this._setLastResponse(null);
      this._setLoading(false);
    }

    // Tests fail if this goes after the normal this.fire('error', ...)
    this.fire(
        'iron-ajax-error',
        {request: request, error: error},
        {bubbles: this.bubbles, composed: true});

    this.fire(
        'error',
        {request: request, error: error},
        {bubbles: this.bubbles, composed: true});
  },

  _discardRequest: function(request) {
    var requestIndex = this.activeRequests.indexOf(request);

    if (requestIndex > -1) {
      this.splice('activeRequests', requestIndex, 1);
    }
  },

  _requestOptionsChanged: function() {
    this.debounce('generate-request', function() {
      if (this.url == null) {
        return;
      }

      if (this.auto) {
        this.generateRequest();
      }
    }, this.debounceDuration);
  },

});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
`<iron-form>` is a wrapper around the HTML `<form>` element, that can
validate and submit both custom and native HTML elements. Note that this
is a breaking change from iron-form 1.0, which was a type extension.

It has two modes: if `allow-redirect` is true, then after the form submission
you will be redirected to the server response. Otherwise, if it is false, it
will use an `iron-ajax` element to submit the form contents to the server.

  Example:

    <iron-form>
      <form method="get" action="/form/handler">
        <input type="text" name="name" value="Batman">
        <input type="checkbox" name="donuts" checked> I like donuts<br>
        <paper-checkbox name="cheese" value="yes" checked></paper-checkbox>
      </form>
    </iron-form>

By default, a native `<button>` element will submit this form. However, if you
want to submit it from a custom element's click handler, you need to explicitly
call the `iron-form`'s `submit` method.

  Example (using `<paper-button>` for the form `<iron-form id="myForm">`):

    <paper-button raised on-click="submitForm">Submit</paper-button>

    function submitForm() {
      this.$.myForm.submit();
    }

  or (using `<button>` for a form in the same document):

    <button raised onclick="submitForm()">Submit</button>

    function submitForm() {
      document.getElementById('myForm').submit();
    }

If you are not using the `allow-redirect` mode, then you also have the option of
customizing the request sent to the server. To do so, you can listen to the
`iron-form-presubmit` event, and modify the form's
[`iron-ajax`](https://elements.polymer-project.org/elements/iron-ajax) object.
However, If you want to not use `iron-ajax` at all, you can cancel the event and
do your own custom submission:

  Example of modifying the request, but still using the build-in form
submission:

    form.addEventListener('iron-form-presubmit', function() {
      this.request.method = 'put';
      this.request.params['extraParam'] = 'someValue';
    });

  Example of bypassing the build-in form submission:

    form.addEventListener('iron-form-presubmit', function(event) {
      event.preventDefault();
      var firebase = new Firebase(form.getAttribute('action'));
      firebase.set(form.serializeForm());
    });

Note that if you're dynamically creating this element, it's mandatory that you
first create the contained `<form>` element and all its children, and only then
attach it to the `<iron-form>`:

  var wrapper = document.createElement('iron-form');
  var form = document.createElement('form');
  var input = document.createElement('input');
  form.appendChild(input);
  document.body.appendChild(wrapper);
  wrapper.appendChild(form);

@element iron-form
@hero hero.svg
@demo demo/index.html
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        display: block;
      }
    </style>

    <!-- This form is used to collect the elements that should be submitted -->
    <slot></slot>

    <!-- This form is used for submission -->
    <form id="helper" action\$="[[action]]" method\$="[[method]]" enctype\$="[[enctype]]"></form>
`,

  is: 'iron-form',

  properties: {
    /*
     * Set this to true if you don't want the form to be submitted through an
     * ajax request, and you want the page to redirect to the action URL
     * after the form has been submitted.
     */
    allowRedirect: {type: Boolean, value: false},
    /**
     * HTTP request headers to send. See PolymerElements/iron-ajax for
     * more details. Only works when `allowRedirect` is false.
     */
    headers: {
      type: Object,
      value: function() {
        return {};
      }
    },
    /**
     * Set the `withCredentials` flag on the request. See
     * PolymerElements/iron-ajax for more details. Only works when
     * `allowRedirect` is false.
     */
    withCredentials: {type: Boolean, value: false},
  },

  /**
   * Fired if the form cannot be submitted because it's invalid.
   *
   * @event iron-form-invalid
   */

  /**
   * Fired after the form is submitted.
   *
   * @event iron-form-submit
   */

  /**
   * Fired before the form is submitted.
   *
   * @event iron-form-presubmit
   */

  /**
   * Fired after the form is reset.
   *
   * @event iron-form-reset
   */

  /**
   * Fired after the form is submitted and a response is received. An
   * IronRequestElement is included as the event.detail object.
   *
   * @event iron-form-response
   */

  /**
   * Fired after the form is submitted and an error is received. An
   * error message is included in event.detail.error and an
   * IronRequestElement is included in event.detail.request.
   *
   * @event iron-form-error
   */

  /**
   * @return {void}
   */
  attached: function() {
    // We might have been detached then re-attached.
    // Avoid searching again for the <form> if we already found it.
    if (this._form) {
      return;
    }
    // Search for the `<form>`, if we don't find it, observe for
    // mutations.
    this._form = dom(this).querySelector('form');
    if (this._form) {
      this._init();
      // Since some elements might not be upgraded yet at this time,
      // we won't be able to look into their shadowRoots for submittables.
      // We wait a tick and check again for any missing submittable default
      // values.
      this.async(this._saveInitialValues.bind(this), 1);
    } else {
      this._nodeObserver = dom(this).observeNodes(function(mutations) {
        for (var i = 0; i < mutations.addedNodes.length; i++) {
          if (mutations.addedNodes[i].tagName === 'FORM') {
            this._form = mutations.addedNodes[i];
            // At this point in time, all custom elements are expected
            // to be upgraded, hence we'll be able to traverse their
            // shadowRoots.
            this._init();
            dom(this).unobserveNodes(this._nodeObserver);
            this._nodeObserver = null;
          }
        }
      }.bind(this));
    }
  },

  /**
   * @return {void}
   */
  detached: function() {
    if (this._nodeObserver) {
      dom(this).unobserveNodes(this._nodeObserver);
      this._nodeObserver = null;
    }
  },

  _init: function() {
    this._form.addEventListener('submit', this.submit.bind(this));
    this._form.addEventListener('reset', this.reset.bind(this));

    // Save the initial values.
    this._defaults = this._defaults || new WeakMap();
    this._saveInitialValues();
  },

  /**
   * Saves the values of all form elements that will be used when resetting
   * the form. Initially called asynchronously on attach. Any time you
   * call this function, the previously saved values for a form element will
   * be overwritten.
   *
   * This function is useful if you are dynamically adding elements to
   * the form, or if your elements are asynchronously setting their values.
   * @return {void}
   */
  saveResetValues: function() {
    this._saveInitialValues(true);
  },

  /**
   * @param {boolean=} overwriteValues
   * @return {void}
   */
  _saveInitialValues: function(overwriteValues) {
    var nodes = this._getValidatableElements();
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!this._defaults.has(node) || overwriteValues) {
        // Submittables are expected to have `value` property,
        // that's what gets serialized.
        var defaults = {value: node.value};
        if ('checked' in node) {
          defaults.checked = node.checked;
        }
        // In 1.x iron-form would reset `invalid`, so
        // keep it here for backwards compat.
        if ('invalid' in node) {
          defaults.invalid = node.invalid;
        }
        this._defaults.set(node, defaults);
      }
    }
  },

  /**
   * Validates all the required elements (custom and native) in the form.
   * @return {boolean} True if all the elements are valid.
   */
  validate: function() {
    // If you've called this before distribution happened, bail out.
    if (!this._form) {
      return false;
    }

    if (this._form.getAttribute('novalidate') === '')
      return true;

    // Start by making the form check the native elements it knows about.
    var valid = this._form.checkValidity();
    var elements = this._getValidatableElements();

    // Go through all the elements, and validate the custom ones.
    for (var el, i = 0; el = elements[i], i < elements.length; i++) {
      // This is weird to appease the compiler. We assume the custom element
      // has a validate() method, otherwise we can't check it.
      var validatable = /** @type {{validate: (function() : boolean)}} */ (el);
      if (validatable.validate) {
        valid = !!validatable.validate() && valid;
      }
    }
    return valid;
  },

  /**
   * Submits the form.
   *
   * @param {Event=} event
   * @return {void}
   */
  submit: function(event) {
    // We are not using this form for submission, so always cancel its event.
    if (event) {
      event.preventDefault();
    }

    // If you've called this before distribution happened, bail out.
    if (!this._form) {
      return;
    }

    if (!this.validate()) {
      this.fire('iron-form-invalid');
      return;
    }

    // Remove any existing children in the submission form (from a previous
    // submit).
    this.$.helper.textContent = '';

    var json = this.serializeForm();

    // If we want a redirect, submit the form natively.
    if (this.allowRedirect) {
      // If we're submitting the form natively, then create a hidden element for
      // each of the values.
      for (var element in json) {
        this.$.helper.appendChild(
            this._createHiddenElement(element, json[element]));
      }

      // Copy the original form attributes.
      this.$.helper.action = this._form.getAttribute('action');
      this.$.helper.method = this._form.getAttribute('method') || 'GET';
      this.$.helper.contentType = this._form.getAttribute('enctype') ||
          'application/x-www-form-urlencoded';

      this.$.helper.submit();
      this.fire('iron-form-submit');
    } else {
      this._makeAjaxRequest(json);
    }
  },

  /**
   * Resets the form to the default values.
   *
   * @param {Event=} event
   * @return {void}
   */
  reset: function(event) {
    // We are not using this form for submission, so always cancel its event.
    if (event)
      event.preventDefault();

    // If you've called this before distribution happened, bail out.
    if (!this._form) {
      return;
    }

    // Ensure the native form fired the `reset` event.
    // User might have bound `<button on-click="_resetIronForm">`, or directly
    // called `ironForm.reset()`. In these cases we want to first reset the
    // native form.
    if (!event || event.type !== 'reset' || event.target !== this._form) {
      this._form.reset();
      return;
    }

    // Load the initial values.
    var nodes = this._getValidatableElements();
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (this._defaults.has(node)) {
        var defaults = this._defaults.get(node);
        for (var propName in defaults) {
          node[propName] = defaults[propName];
        }
      }
    }

    this.fire('iron-form-reset');
  },

  /**
   * Serializes the form as will be used in submission. Note that `serialize`
   * is a Polymer reserved keyword, so calling `someIronForm`.serialize()`
   * will give you unexpected results.
   * @return {!Object<string, *>} An object containing name-value pairs for elements that
   *                  would be submitted.
   */
  serializeForm: function() {
    // Only elements that have a `name` and are not disabled are submittable.
    var elements = this._getSubmittableElements();
    var json = {};
    for (var i = 0; i < elements.length; i++) {
      var values = this._serializeElementValues(elements[i]);
      for (var v = 0; v < values.length; v++) {
        this._addSerializedElement(json, elements[i].name, values[v]);
      }
    }
    return json;
  },

  _handleFormResponse: function(event) {
    this.fire('iron-form-response', event.detail);
  },

  _handleFormError: function(event) {
    this.fire('iron-form-error', event.detail);
  },

  _makeAjaxRequest: function(json) {
    // Initialize the iron-ajax element if we haven't already.
    if (!this.request) {
      this.request = document.createElement('iron-ajax');
      this.request.addEventListener(
          'response', this._handleFormResponse.bind(this));
      this.request.addEventListener('error', this._handleFormError.bind(this));
    }

    // Native forms can also index elements magically by their name (can't make
    // this up if I tried) so we need to get the correct attributes, not the
    // elements with those names.
    this.request.url = this._form.getAttribute('action');
    this.request.method = this._form.getAttribute('method') || 'GET';
    this.request.contentType = this._form.getAttribute('enctype') ||
        'application/x-www-form-urlencoded';
    this.request.withCredentials = this.withCredentials;
    this.request.headers = this.headers;

    if (this._form.method.toUpperCase() === 'POST') {
      this.request.body = json;
    } else {
      this.request.params = json;
    }

    // Allow for a presubmit hook
    var event = this.fire('iron-form-presubmit', {}, {cancelable: true});
    if (!event.defaultPrevented) {
      this.request.generateRequest();
      this.fire('iron-form-submit', json);
    }
  },

  _getValidatableElements: function() {
    return this._findElements(
        this._form, true /* ignoreName */, false /* skipSlots */);
  },

  _getSubmittableElements: function() {
    return this._findElements(
        this._form, false /* ignoreName */, false /* skipSlots */);
  },

  /**
   * Traverse the parent element to find and add all submittable nodes to
   * `submittable`.
   * @param  {!Node} parent The parent node
   * @param  {!boolean} ignoreName  Whether the name of the submittable nodes should be disregarded
   * @param  {!boolean} skipSlots  Whether to skip traversing of slot elements
   * @param  {!Array<!Node>=} submittable Reference to the array of submittables
   * @return {!Array<!Node>}
   * @private
   */
  _findElements: function(parent, ignoreName, skipSlots, submittable) {
    submittable = submittable || [];
    var nodes = dom(parent).querySelectorAll('*');
    for (var i = 0; i < nodes.length; i++) {
      // An element is submittable if it is not disabled, and if it has a
      // name attribute.
      if (!skipSlots &&
          (nodes[i].localName === 'slot' || nodes[i].localName === 'content')) {
        this._searchSubmittableInSlot(submittable, nodes[i], ignoreName);
      } else {
        this._searchSubmittable(submittable, nodes[i], ignoreName);
      }
    }
    return submittable;
  },

  /**
   * Traverse the distributed nodes of a slot or content element
   * and add all submittable nodes to `submittable`.
   * @param  {!Array<!Node>} submittable Reference to the array of submittables
   * @param  {!Node} node The slot or content node
   * @param  {!boolean} ignoreName  Whether the name of the submittable nodes should be disregarded
   * @return {void}
   * @private
   */
  _searchSubmittableInSlot: function(submittable, node, ignoreName) {
    var assignedNodes = dom(node).getDistributedNodes();

    for (var i = 0; i < assignedNodes.length; i++) {
      if (assignedNodes[i].nodeType === Node.TEXT_NODE) {
        continue;
      }

      // Note: assignedNodes does not contain <slot> or <content> because
      // getDistributedNodes flattens the tree.
      this._searchSubmittable(submittable, assignedNodes[i], ignoreName);
      var nestedAssignedNodes = dom(assignedNodes[i]).querySelectorAll('*');
      for (var j = 0; j < nestedAssignedNodes.length; j++) {
        this._searchSubmittable(
            submittable, nestedAssignedNodes[j], ignoreName);
      }
    }
  },

  /**
   * Traverse the distributed nodes of a slot or content element
   * and add all submittable nodes to `submittable`.
   * @param  {!Array<!Node>} submittable Reference to the array of submittables
   * @param  {!Node} node The node to be
   * @param  {!boolean} ignoreName  Whether the name of the submittable nodes should be disregarded
   * @return {void}
   * @private
   */
  _searchSubmittable: function(submittable, node, ignoreName) {
    if (this._isSubmittable(node, ignoreName)) {
      submittable.push(node);
    } else if (node.root) {
      this._findElements(
          node.root, ignoreName, true /* skipSlots */, submittable);
    }
  },

  /**
   * An element is submittable if it is not disabled, and if it has a
   * 'name' attribute. If we ignore the name, check if is validatable.
   * This allows `_findElements` to decide if to explore an element's shadowRoot
   * or not: an element implementing `validate()` is considered validatable, and
   * we don't search for validatables in its shadowRoot.
   * @param {!Node} node
   * @param {!boolean} ignoreName
   * @return {boolean}
   * @private
   */
  _isSubmittable: function(node, ignoreName) {
    return (
        !node.disabled &&
        (ignoreName ? node.name || typeof node.validate === 'function' :
                      node.name));
  },

  _serializeElementValues: function(element) {
    // We will assume that every custom element that needs to be serialized
    // has a `value` property, and it contains the correct value.
    // The only weird one is an element that implements
    // IronCheckedElementBehaviour, in which case like the native checkbox/radio
    // button, it's only used when checked. For native elements, from
    // https://www.w3.org/TR/html5/forms.html#the-form-element. Native
    // submittable elements: button, input, keygen, object, select, textarea;
    // 1. We will skip `keygen and `object` for this iteration, and deal with
    // them if they're actually required.
    // 2. <button> and <textarea> have a `value` property, so they behave like
    //    the custom elements.
    // 3. <select> can have multiple options selected, in which case its
    //    `value` is incorrect, and we must use the values of each of its
    //    `selectedOptions`
    // 4. <input> can have a whole bunch of behaviours, so it's handled
    // separately.
    // 5. Buttons are hard. The button that was clicked to submit the form
    //    is the one who's name/value gets sent to the server.
    var tag = element.tagName.toLowerCase();
    if (tag === 'button' ||
        (tag === 'input' &&
         (element.type === 'submit' || element.type === 'reset'))) {
      return [];
    }

    if (tag === 'select') {
      return this._serializeSelectValues(element);
    } else if (tag === 'input') {
      return this._serializeInputValues(element);
    } else {
      if (element['_hasIronCheckedElementBehavior'] && !element.checked)
        return [];
      return [element.value];
    }
  },

  _serializeSelectValues: function(element) {
    var values = [];

    // A <select multiple> has an array of options, some of which can be
    // selected.
    for (var i = 0; i < element.options.length; i++) {
      if (element.options[i].selected) {
        values.push(element.options[i].value);
      }
    }
    return values;
  },

  _serializeInputValues: function(element) {
    // Most of the inputs use their 'value' attribute, with the exception
    // of radio buttons, checkboxes and file.
    var type = element.type.toLowerCase();

    // Don't do anything for unchecked checkboxes/radio buttons.
    // Don't do anything for file, since that requires a different request.
    if (((type === 'checkbox' || type === 'radio') && !element.checked) ||
        type === 'file') {
      return [];
    }
    return [element.value];
  },

  _createHiddenElement: function(name, value) {
    var input = document.createElement('input');
    input.setAttribute('type', 'hidden');
    input.setAttribute('name', name);
    input.setAttribute('value', value);
    return input;
  },

  _addSerializedElement: function(json, name, value) {
    // If the name doesn't exist, add it. Otherwise, serialize it to
    // an array,
    if (json[name] === undefined) {
      json[name] = value;
    } else {
      if (!Array.isArray(json[name])) {
        json[name] = [json[name]];
      }
      json[name].push(value);
    }
  }
});

/**
 * Renders form and input elements for query / uri model.
 *
 * Handles creation of form elements, validation, and rendering documentation.
 *
 * This element **requires** you to set `form-type` attribute to either
 * `uri` or `query` to distinguish type of form. Also, set `form-title`
 * property to render a title. It is useful when adding two forms right after
 * each other.
 *
 * ## Optional parameters
 *
 * By default the element renders all form valus. For better user experience,
 * set `allow-hide-optional` attribute to hide parameters that are optional.
 * It also renders checkbox to toggle optional parameters.
 *
 * You can also style inputs as defined in
 * [api-property-form-item](https://github.com/advanced-rest-client/api-property-form-item)
 * element documentation.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin ValidatableMixin
 * @appliesMixin ApiFormMixin
 */
class ApiUrlParamsForm extends ValidatableMixin(ApiFormMixin(LitElement)) {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      css`:host {
        display: block;
      }

      .param-value .input {
        display: flex;
        flex-direction: row;
        flex: 1;
      }

      .has-enable-button .docs {
        margin-left: 32px;
      }

      .value-input {
        display: flex;
        flex-direction: row;
        align-items: center;
        flex: 1;
      }

      api-property-form-item,
      api-url-params-custom-input {
        flex: 1;
      }

      [hidden] {
        display: none !important;
      }

      .enable-checkbox {
        margin-right: 8px;
      }

      .params-title {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      .params-title ::slotted(*) {
        margin: 0.83em 8px;
        letter-spacing: 0.1rem;
        font-size: 20px;
        font-weight: 200;
      }

      :host([compatibility]) .params-title ::slotted(*) {
        font-size: 18px;
        font-weight: 400;
        letter-spacing: initial;
      }

      .custom-row {
        display: flex;
        flex-direction: row;
        flex: 1;
      }

      .custom-row.narrow {
        flex-direction: column;
      }

      .custom-row anypoint-input,
      .custom-row api-property-form-item {
        flex: 1;
        width: auto;
      }

      [data-optional] {
        display: none;
      }

      :host([optionalopened]) [data-optional] {
        display: flex;
        flex-direction: column;
      }

      /* Array items */
      .value-input.is-array {
        align-items: flex-start;
      }

      .is-array .enable-checkbox {
        margin-top: 8px;
      }

      .is-array api-property-form-item {
        margin-top: 8px;
      }

      .is-array .hint-icon {
        margin-top: 8px;
      }
      `
    ];
  }

  _customInputTemplate(item, index) {
    const {
      readOnly,
      compatibility,
      outlined,
      narrow
    } = this;
    return html`
    <div class="custom-row${narrow ? ' narrow' : ''}">
      <anypoint-input
        data-index="${index}"
        .value="${item.name}"
        @value-changed="${this._nameChangeHandler}"
        class="param-name"
        type="text"
        required
        autovalidate
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        .readOnly="${readOnly}"
        invalidmessage="Parameter name is required">
        <label slot="label">Parameter name</label>
      </anypoint-input>
      <api-property-form-item
        data-index="${index}"
        .name="${item.name}"
        .value="${item.value}"
        @value-changed="${this._valueChangeHandler}"
        .model="${item}"
        .readOnly="${readOnly}"
        ?narrow="${narrow}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"></api-property-form-item>
    </div>`;
  }

  _formRowTemplate(item, index) {
    const {
      allowHideOptional,
      optionalOpened,
      allowDisableParams,
      readOnly,
      disabled,
      compatibility,
      outlined,
      narrow,
      noDocs
    } = this;
    const rowClass = this.computeFormRowClass(item, allowHideOptional, optionalOpened, allowDisableParams);
    const hasDocs = this._computeHasDocumentation(noDocs, item);
    const renderDocs = !noDocs && hasDocs && !!item.docsOpened;
    return html`<div class="${rowClass}" ?data-optional="${!item.required}">
      <div class="value-input${item.schema.isArray ? ' is-array' : ''}">
      ${allowDisableParams ? html`
        <anypoint-checkbox
          class="enable-checkbox"
          ?checked="${item.schema.enabled}"
          data-index="${index}"
          ?data-array="${item.schema.isArray}"
          @checked-changed="${this._enableCheckedHandler}"
          title="Enable or disable this parameter"
          aria-label="Toggle to enable or disable this parameter"
          ?disabled="${readOnly || disabled}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"></anypoint-checkbox>` : undefined}

        ${item.schema.isCustom ? this._customInputTemplate(item, index) :
          html`<api-property-form-item
            data-index="${index}"
            name="${item.name}"
            .value="${item.value}"
            @value-changed="${this._valueChangeHandler}"
            .model="${item}"
            ?required="${item.required}"
            .readOnly="${readOnly}"
            .disabled=${disabled}
            ?narrow="${narrow}"
            .noDocs="${noDocs}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"
            ></api-property-form-item>`}
        ${hasDocs ? html`<anypoint-icon-button
          data-index="${index}"
          class="hint-icon"
          title="Toggle documentation"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          ?disabled="${disabled}"
          @click="${this._toggleItemDocs}">
          <iron-icon icon="arc:help"></iron-icon>
        </anypoint-icon-button>` : undefined}

        ${item.schema.isCustom ? html`<anypoint-icon-button
          title="Remove this parameter"
          aria-label="Press to remove parameter ${name}"
          class="action-icon delete-icon"
          data-index="${index}"
          @click="${this._removeCustom}"
          slot="suffix"
          ?disabled="${readOnly || disabled}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}">
          <iron-icon icon="arc:remove-circle-outline"></iron-icon>
        </anypoint-icon-button>` : undefined}
      </div>

      ${renderDocs ? html`<arc-marked .markdown="${this._computeDocumentation(item)}">
        <div slot="markdown-html" class="markdown-body"></div>
      </arc-marked>` : undefined}
    </div>`;
  }

  render() {
    const {
      renderOptionalCheckbox,
      optionalOpened,
      allowCustom,
      readOnly,
      disabled
    } = this;
    let { model } = this;
    if (!model) {
      model = [];
    }
    return html`
    <div class="params-title">
      <slot name="title"></slot>
    </div>
    ${renderOptionalCheckbox ? html`<div class="optional-checkbox">
      <anypoint-checkbox
        class="toggle-checkbox"
        .checked="${optionalOpened}"
        @checked-changed="${this._optionalHanlder}"
        title="Toggles optional parameters">Show optional parameters</anypoint-checkbox>
    </div>` : undefined}
    <iron-form>
      <form enctype="application/json">
      ${model.map((item, index) => this._formRowTemplate(item, index))}
      </form>
    </iron-form>
    ${allowCustom ? html`<div class="add-action">
      <anypoint-button
        class="action-button"
        @click="${this.add}"
        title="Add new parameter"
        aria-label="Press to create a new parameter"
        ?disabled="${readOnly || disabled}">
        <iron-icon
          class="action-icon"
          icon="arc:add-circle-outline"
          alt="Add parameter icon"></iron-icon>
        Add parameter
      </anypoint-button>
    </div>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
      /**
       * If set it renders a narrow layout
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * When set, renders add custom parameter button in query parameters
       * form
       */
      allowCustom: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }
  /**
   * Computes documentation as a markdown to be placed in the `marked-element`
   * @param {Object} item View model
   * @return {String}
   */
  _computeDocumentation(item) {
    return (item.extendedDescription ? item.extendedDescription : item.description) || '';
  }
  /**
   * Computes if model item has documentation to display.
   * @param {Boolean} noDocs If set it always cancels docs
   * @param {Object} item Model item
   * @return {Boolean} True if documentation can be rendered.
   */
  _computeHasDocumentation(noDocs, item) {
    if (noDocs) {
      return false;
    }
    return !!(item.hasDescription || item.hasExtendedDescription);
  }
  /**
   * Adds custom property to the list.
   */
  add() {
    this.addCustom('query');
  }

  // Overrides ValidatableMixin._getValidity. Will set the `invalid`
  // attribute automatically, which should be used for styling.
  _getValidity() {
    const form = this.shadowRoot.querySelector('iron-form');
    if (!form) {
      return true;
    }
    return form.validate();
  }

  _optionalHanlder(e) {
    this.optionalOpened = e.detail.value;
  }

  _enableCheckedHandler(e) {
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const { checked } = e.target;
    const old = this.model[index].schema.enabled;
    this.model[index].schema.enabled = checked;
    this._notifyChange(index, 'enabled', checked, old);
  }

  _nameChangeHandler(e) {
    if (!this.allowCustom) {
      return;
    }
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const item = this.model[index];
    if (!item.schema.isCustom) {
      return;
    }
    const { value } = e.detail;
    const old = this.model[index].name;
    this.model[index].name = value;
    this._notifyChange(index, 'name', value, old);
  }

  _valueChangeHandler(e) {
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const { value } = e.detail;
    const old = this.model[index].value;
    this.model[index].value = value;
    this._notifyChange(index, 'value', value, old);
  }

  _notifyChange(index, property, value, oldValue) {
    this.dispatchEvent(new CustomEvent('change', {
      detail: {
        index,
        property,
        value,
        oldValue
      }
    }));
  }

  _toggleItemDocs(e) {
    const index = Number(e.currentTarget.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    this.model[index].docsOpened = !this.model[index].docsOpened;
    this.requestUpdate();
  }
  /**
   * Overrides `ApiFormMixin._removeCustom`.
   * Calls the super method and dispatches `delete` event.
   * @param {Event} e
   */
  _removeCustom(e) {
    const index = Number(e.currentTarget.dataset.index);
    if (index !== index) {
      return;
    }
    const model = this.model;
    if (!model || !model.length) {
      return;
    }
    const item = model[index];
    super._removeCustom(e);
    this.dispatchEvent(new CustomEvent('delete', {
      detail: {
        name: item.name
      }
    }));
  }
}

window.customElements.define('api-url-params-form', ApiUrlParamsForm);

/**
 * `api-url-params-editor`
 * An element to render query / uri parameters form from AMF schema
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin ValidatableMixin
 * @appliesMixin EventsTargetMixin
 */
class ApiUrlParamsEditor extends ValidatableMixin(EventsTargetMixin(LitElement)) {
  static get styles() {
    return css`:host {
      display: block;
      margin: 8px 12px;
    }

    .empty-message {
      font-style: var(--no-info-message-font-style, italic);
      font-size: var(--no-info-message-font-size, 16px);
      color: var(--no-info-message-color, rgba(0, 0, 0, 0.74));
    }

    [hidden] {
      display: none !important;
    }`;
  }

  render() {
    const {
      uriModel,
      queryModel,
      noDocs,
      readOnly,
      disabled,
      compatibility,
      outlined,
      narrow,
      allowCustom,
      _hasParameters,
      _hasUriParameters,
      _hasQueryParameters
    } = this;
    return html`
    ${_hasParameters ? undefined : html`<section class="empty-message">
      <p>This endpoint doesn't declare query or URI parameters.</p>
    </section>`}

    ${_hasUriParameters ? html`<api-url-params-form
      id="uriParametersForm"
      @change="${this._uriFormChange}"
      form-type="uri"
      optionalopened
      .model="${uriModel}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?nodocs="${noDocs}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}"
      ?narrow="${narrow}">
      <div role="heading" aria-level="1" slot="title">URI parameters</div>
    </api-url-params-form>` : undefined}
    ${_hasQueryParameters ? html`<api-url-params-form
      id="queryParametersForm"
      @change="${this._queryFormChange}"
      @delete="${this._queryDeleted}"
      @model-changed="${this._queryModelChange}"
      form-type="query"
      allowhideoptional
      allowdisableparams
      ?allowcustom="${allowCustom}"
      .model="${queryModel}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?nodocs="${noDocs}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}"
      ?narrow="${narrow}">
      <div role="heading" aria-level="1" slot="title">Query parameters</div>
    </api-url-params-form>` : undefined}
    `;
  }

  static get properties() {
    return {
      /**
       * Computed by `api-view-model-transformer` qury parameters model.
       *
       * Note, this element won't accept AMF data.
       */
      queryModel: { type: Array },
      /**
       * Computed value if the `queryParameters` are set.
       * Use `raml-request-parameteres-model` to compute this value.
       */
      _hasQueryParameters: { type: Boolean },
      /**
       * Computed by `api-view-model-transformer` URI parameters model.
       *
       * Note, this element won't accept AMF data.
       */
      uriModel: { type: Array },
      /**
       * Computed value if the `uriParameters` are set.
       * Use `raml-request-parameteres-model` to compute this value.
       */
      _hasUriParameters: { type: Boolean },
      /**
       * Computed value if `uriParameters` or `queryParameters` are set.
       * Use `raml-request-parameteres-model` to compute this value.
       */
      _hasParameters: { type: Boolean },
      /**
       * Map of uri parameters produced by this element.
       */
      uriValue: { type: Object },
      /**
       * Map of query parameters produced by this element.
       */
      queryValue: { type: Object },
      /**
       * When set, renders add custom parameter button in query parameters
       * form
       */
      allowCustom: { type: Boolean },
      /**
       * Renders forms in "narrow" view
       */
      narrow: { type: Boolean },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set the editor disabled all controls
       */
      disabled: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get allowCustom() {
    return this._allowCustom;
  }

  set allowCustom(value) {
    /* istanbul ignore else  */
    if (this._sop('allowCustom', value)) {
      this._hasQueryParameters = this._computeHasData(this.queryModel, value);
      this._hasParameters = this._computeHasParameters(
          this._hasQueryParameters, this._hasUriParameters, value);
    }
  }

  get queryModel() {
    return this._queryModel;
  }

  set queryModel(value) {
    /* istanbul ignore else  */
    if (this._sop('queryModel', value)) {
      this._hasQueryParameters = this._computeHasData(value, this.allowCustom);
      this._hasParameters = this._computeHasParameters(
          this._hasQueryParameters, this._hasUriParameters, this.allowCustom);
      this._updateModelValue('query', value);
      this.dispatchEvent(new CustomEvent('querymodel-changed', {
        detail: {
          value
        }
      }));
    }
  }

  get uriModel() {
    return this._uriModel;
  }

  set uriModel(value) {
    /* istanbul ignore else  */
    if (this._sop('uriModel', value)) {
      this._hasUriParameters = this._computeHasData(value);
      this._hasParameters = this._computeHasParameters(
          this._hasQueryParameters, this._hasUriParameters, this.allowCustom);
      this._updateModelValue('uri', value);
      this.dispatchEvent(new CustomEvent('urimodel-changed', {
        detail: {
          value
        }
      }));
    }
  }

  get uriValue() {
    return this._uriValue;
  }

  set uriValue(value) {
    /* istanbul ignore else  */
    if (this._sop('uriValue', value)) {
      this.dispatchEvent(new CustomEvent('urivalue-changed', {
        detail: {
          value
        }
      }));
    }
  }

  get queryValue() {
    return this._queryValue;
  }

  set queryValue(value) {
    /* istanbul ignore else  */
    if (this._sop('queryValue', value)) {
      this.dispatchEvent(new CustomEvent('queryvalue-changed', {
        detail: {
          value
        }
      }));
    }
  }
  /**
   * @return {Function} Previously registered handler for `urivalue-changed` event
   */
  get onurivalue() {
    return this['_onurivalue-changed'];
  }
  /**
   * Registers a callback function for `urivalue-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onurivalue(value) {
    this._registerCallback('urivalue-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `queryvalue-changed` event
   */
  get onqueryvalue() {
    return this['_onqueryvalue-changed'];
  }
  /**
   * Registers a callback function for `queryvalue-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onqueryvalue(value) {
    this._registerCallback('queryvalue-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `urimodel-changed` event
   */
  get onurimodel() {
    return this['_onurimodel-changed'];
  }
  /**
   * Registers a callback function for `urimodel-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onurimodel(value) {
    this._registerCallback('urimodel-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `querymodel-changed` event
   */
  get onquerymodel() {
    return this['_onquerymodel-changed'];
  }
  /**
   * Registers a callback function for `querymodel-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onquerymodel(value) {
    this._registerCallback('querymodel-changed', value);
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }

  constructor() {
    super();
    this._queryParamChangeHandler = this._queryParamChangeHandler.bind(this);
    this._uriParamChangeHandler = this._uriParamChangeHandler.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('uri-parameter-changed', this._uriParamChangeHandler);
    node.addEventListener('query-parameter-changed', this._queryParamChangeHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('uri-parameter-changed', this._uriParamChangeHandler);
    node.removeEventListener('query-parameter-changed', this._queryParamChangeHandler);
  }

  /**
   * Handler for the `query-parameter-changed` custom event.
   * Updates model value from the event
   *
   * @param {CustomEvent} e
   */
  _queryParamChangeHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    this._appyEventValues(e.detail, 'query');
  }

  _uriParamChangeHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    this._appyEventValues(e.detail, 'uri');
  }
  /**
   * Applies values from the change event to a model.
   *
   * @param {Object} detail Detail event object
   * @param {String} type `uri` or `query`
   */
  _appyEventValues(detail, type) {
    const modelPath = `${type}Model`;
    const model = this[modelPath];
    if (!model || !model.length) {
      return;
    }
    const index = model.findIndex((item) => item.name === detail.name);
    if (index === -1) {
      return;
    }
    const item = model[index];
    item.value = detail.value;
    if (item.schema.enabled === false) {
      item.schema.enabled = true;
    }
    this[modelPath] = [...this[modelPath]];
  }
  /**
   * Computes boolean value if the argument exists and has items.
   *
   * @param {Array} model Current url model.
   * @param {Boolean} allowCustom
   * @return {Boolean}
   */
  _computeHasData(model, allowCustom) {
    if (allowCustom) {
      return true;
    }
    return !!(model instanceof Array && model.length);
  }
  /**
   * Computes value for `hasParameters` property.
   *
   * @param {Boolean} qp State of `_hasQueryParameters`
   * @param {Boolean} up State of `_hasUriParameters`
   * @param {Boolean} allowCustom
   * @return {Boolean} True if any of the arguments is true
   */
  _computeHasParameters(qp, up, allowCustom) {
    return !!(qp || up) || !!allowCustom;
  }

  /**
   * Overidden from ValidatableMixin. Will set the `invalid`
   * attribute automatically, which should be used for styling.
   * @return {Boolean}
   */
  _getValidity() {
    let validUri = true;
    let validUrl = true;
    if (this._hasUriParameters) {
      const uriForm = this.shadowRoot.querySelector('#uriParametersForm');
      validUri = uriForm ? uriForm.validate() : true;
    }
    if (this._hasQueryParameters) {
      const urlForm = this.shadowRoot.querySelector('#queryParametersForm');
      validUrl = urlForm ? urlForm.validate() : true;
    }
    return validUri && validUrl;
  }
  /**
   * Updates value for entire model.
   * @param {String} type Data model type. `query` or `uri`
   */
  _updateModelValue(type) {
    if (this.__ignoreValueProcessing) {
      // Simple optimisation to stop value processing when value was already
      // set.
      return;
    }
    const valuePath = `${type}Value`;
    const modelPath = `${type}Model`;
    const model = this[modelPath];

    if (!model || !model.length) {
      this[valuePath] = undefined;
      return;
    }
    const result = {};
    model.forEach((item) => {
      const enabled = item.schema && item.schema.enabled;
      if (enabled === false) {
        return;
      }
      result[item.name] = item.value;
    });
    this[valuePath] = result;
    this._asyncValidate();
  }

  _uriFormChange(e) {
    this._formChange('uri', e.detail);
  }

  _queryFormChange(e) {
    this._formChange('query', e.detail);
  }

  _formChange(type, detail) {
    const valuePath = `${type}Value`;
    const modelPath = `${type}Model`;
    const model = this[modelPath];
    const values = this[valuePath] || {};
    const { property, index } = detail;
    switch (property) {
      case 'enabled':
        this._updatePropertyEnabled(model, values, detail);
        break;
      case 'name':
        this._updatePropertyName(values, detail);
        break;
      case 'value':
        this._updatePropertyValue(values, model, detail);
        break;
    }
    this[valuePath] = Object.assign({}, values);
    this.__ignoreValueProcessing = true;
    this[modelPath] = [...this[modelPath]];
    this.__ignoreValueProcessing = false;
    this._asyncValidate();
    this._notifyChange(type, model[index]);
  }

  _updatePropertyEnabled(model, values, detail) {
    const { index, value } = detail;
    const item = model[index];
    if (value) {
      values[item.name] = item.value;
    } else {
      delete values[item.name];
    }
  }

  _updatePropertyName(values, detail) {
    const { value, oldValue } = detail;
    const currentValue = values[oldValue] || '';
    delete values[oldValue];
    values[value] = currentValue;
  }

  _updatePropertyValue(values, model, detail) {
    const { index, value } = detail;
    const item = model[index];
    values[item.name] = value;
  }

  _queryModelChange(e) {
    this.queryModel = e.detail.value;
    this._asyncValidate();
  }

  async _asyncValidate() {
    await this.updateComplete;
    setTimeout(() => {
      this.validate();
    });
  }
  /**
   * Handler for the `query` event dispatchd from the query form.
   * @param {CustomEvent} e
   */
  _queryDeleted(e) {
    const item = {
      name: e.detail.name,
      schema: {
        enabled: false
      }
    };
    this._notifyChange('query', item, true);
  }
  /**
   * Dispatches uri/query-parameter-changed custom event when model property change.
   * @param {String} type Model type, `uri` or `query`
   * @param {Object} item Changed item
   * @param {?Boolean} removed True if the item has been removed from the UI
   */
  _notifyChange(type, item, removed) {
    let enabled = item.schema && item.schema.enabled;
    let isCustom = item.schema && item.schema.isCustom;
    if (typeof enabled !== 'boolean') {
      enabled = true;
    }
    if (typeof isCustom !== 'boolean') {
      isCustom = false;
    }
    const detail = {
      name: item.name,
      isCustom
    };
    if (removed) {
      detail.removed = true;
    } else {
      detail.value = item.value;
      detail.enabled = enabled;
    }
    const ev = new CustomEvent(type + '-parameter-changed', {
      detail,
      cancelable: true,
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }
  /**
   * Fired when an URI parameter value change in this editor.
   *
   * @event uri-parameter-changed
   * @param {String} name The name of the parameter
   * @param {String} value The value of the parameter
   * @param {Boolean} enabled True if the parameter is enabled in the form.
   */
  /**
   * Fired when a query parameter value change in this editor.
   *
   * @event query-parameter-changed
   * @param {String} name The name of the parameter
   * @param {?String} value The value of the parameter
   * @param {?Boolean} enabled True if the parameter is enabled in the form.
   * @param {?Boolean} removed True when custom header has been removed.
   * When set `value` and `emabled` properties are not set.
   */
}

window.customElements.define('api-url-params-editor', ApiUrlParamsEditor);

/**
 * A mixin for the authorization panel that provides support for
 * AMF model.
 *
 * This is purely for code r1eadiness.
 *
 * @param {Class} base
 * @return {Class}
 * @mixinFunction
 */
const AuthorizationPanelAmfOverlay = (base) => class extends AmfHelperMixin(base) {
  static get properties() {
    return {
      /**
       * Security definition for an endpoint in AMF json/ld model.
       * It is `http://raml.org/vocabularies/security#security`
       * property of the `http://www.w3.org/ns/hydra/core#supportedOperation`
       * property of an endpoint.
       */
      securedBy: { type: Array },
      /**
       * List of currently available custom security schemes declared in
       * the AMF
       */
      customSchemes: { type: Array },
      /**
       * Computed value of validation state.
       * To be used with CSS selectors to style the element when the authorization
       * form is onvalid.
       *
       * Example:
       *
       * ```css
       * authorization-panel[invalid] {
       *  border: 1px red solid;
       * }
       * ```
       */
      invalid: { type: Boolean, reflect: true },
      /**
       * Computed value from the AMF model.
       * If authorization is required by endpoint defined in the model,
       * then internally this property is set to `true`.
       *
       * It can be `false` if `selected` is `none`, meaning RAML spec
       * allows no authorization.
       */
      _authRequired: { type: Boolean },
    };
  }

  get authRequired() {
    return this._authRequired;
  }

  get _authRequired() {
    return this.__authRequired;
  }

  set _authRequired(value) {
    if (this._sop('_authRequired', value)) {
      this.validate();
      this.dispatchEvent(new CustomEvent('authrequired-changed', {
        detail: {
          value
        }
      }));
    }
  }

  get securedBy() {
    return this._securedBy;
  }

  set securedBy(value) {
    if (this._sop('securedBy', value)) {
      this._securedByChanged();
    }
  }
  /**
   * Sets Observable Property.
   * @param {String} prop Property name to set
   * @param {any} value A value to set
   * @return {Boolean} True if property was changed.
   */
  _sop(prop, value) {
    const key = `_${prop}`;
    const old = this[key];
    /* istanbul ignore if */
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }
  /**
   * Overrides `AmfHelperMixin.__amfChanged`
   */
  __amfChanged() {
    this._securedByChanged();
  }
  /**
   * Validates current settings received from currently selected authorization
   * panel.
   *
   * @return {Boolean} Validation result.
   */
  validate() {
    const { settings, selected,  _authRequired } = this;
    const formValid = settings && settings.valid;
    let result;
    if (!settings && _authRequired) {
      result = false;
    } else if (!settings) {
      result = true;
    } else if ((selected === undefined || selected === -1) && _authRequired) {
      // valid by default
      result = true;
    } else if ((selected === undefined || selected === -1) && !_authRequired) {
      result = true;
    } else if (formValid === undefined && !_authRequired) {
      result = true;
    } else  if (formValid !== undefined) {
      result = formValid;
    } else {
      result = true;
    }
    this.invalid = !result;
    return result;
  }

  _securedByChanged() {
    if (this._amfDebouncer) {
      return;
    }
    // See https://github.com/anypoint-web-components/anypoint-selector/issues/1
    this.selected = -1;
    this.authMethods = undefined;
    this._amfDebouncer = true;
    setTimeout(() => {
      this._amfDebouncer = false;
      this._processAmfModel();
    });
  }
  /**
   * Restores component to it's initial state.
   * @return {Promise}
   */
  async restoreDefaults() {
    this._authRequired = false;
    this.authMethods = this._listAuthMethods();
    await this.updateComplete;
    this.selected = 0;
  }

  async _processAmfModel() {
    const secured = this.securedBy;
    if (!secured || !secured.length) {
      await this.restoreDefaults();
      return;
    }
    const supported = [];
    const secPrefix = this.ns.raml.vocabularies.security;
    let hasNull = false;
    for (let i = 0, len = secured.length; i < len; i++) {
      const item = secured[i];
      if (!this._hasType(item, secPrefix + 'ParametrizedSecurityScheme') &&
        !this._hasType(item, secPrefix + 'SecurityScheme')) {
        continue;
      }
      const shKey = this._getAmfKey(secPrefix + 'scheme');
      let scheme = item[shKey];
      if (!scheme) {
        hasNull = true;
        continue;
      }
      if (scheme instanceof Array) {
        scheme = scheme[0];
      }
      const type = this._getValue(scheme, secPrefix + 'type');
      if (!type) {
        hasNull = true;
        continue;
      }
      let name = this._getValue(scheme, this.ns.schema.displayName);
      if (!name) {
        if (type === 'x-custom') {
          name = this._getValue(item, secPrefix + 'name');
          if (!name) {
            name = 'Custom authorization';
          }
        } else {
          name = type;
        }
      }

      supported[supported.length] = {
        name: name,
        type: type
      };
    }
    if (hasNull) {
      supported.unshift({
        name: 'No authorization',
        type: 'none'
      });
    }
    this.authMethods = supported;
    const isRequired = !!(supported && supported.length) && !hasNull;
    this._authRequired = isRequired;
    this._analyticsEvent('authorization-panel', 'usage-amf', 'loaded');
    await this.updateComplete;
    this.selected = 0;
  }

  /**
   * Searches for AMF security description in the AMF model.
   *
   * @param {String} type Security scheme type as defined in RAML spec.
   * @param {?String} name Display name of the security scheme
   * @return {[type]} [description]
   */
  _computeAmfSettings(type, name) {
    const model = this.securedBy;
    if (!model) {
      return;
    }
    if (name === type) {
      name = undefined;
    }
    const secPrefix = this.ns.raml.vocabularies.security;
    for (let i = 0, len = model.length; i < len; i++) {
      const item = model[i];
      const shKey = this._getAmfKey(secPrefix + 'scheme');
      let scheme = item[shKey];
      if (!scheme) {
        continue;
      }
      if (scheme instanceof Array) {
        scheme = scheme[0];
      }
      const modelType = this._getValue(scheme, secPrefix + 'type');
      if (!modelType) {
        continue;
      }
      if (modelType === type) {
        if (!name) {
          return item;
        }
        let modelName = this._getValue(scheme, this.ns.schema.displayName);
        if (!modelName) {
          modelName = this._getValue(item, secPrefix + 'name');
        }
        if (modelName === name) {
          return item;
        }
      }
    }
  }

  /**
   * Finds a RAML method name from both RAML type or auth panel type.
   * @param {String} type
   * @return {String|undefined} RAML type name
   */
  _panelTypeToRamType(type) {
    switch (type) {
      case 'none':
      case 'No authorization':
        return 'none';
      case 'ntlm':
      case 'NTLM':
        return 'ntlm';
      case 'basic':
      case 'Basic Authentication':
        return 'Basic Authentication';
      case 'digest':
      case 'Digest Authentication':
        return 'Digest Authentication';
      case 'oauth1':
      case 'OAuth 1.0':
        return 'OAuth 1.0';
      case 'oauth2':
      case 'OAuth 2.0':
        return 'OAuth 2.0';
    }
  }
};

/**
@license
Copyright 2018 The Advanced REST client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * Base class for all authorization methods
 *
 * @appliesMixin EventsTargetMixin
 * @extends LitElement
 */
class AuthMethodBase extends EventsTargetMixin(LitElement) {
  static get properties() {
    return {
      /**
       * Setting passed to paper buttons.
       */
      noink: { type: Boolean },
      /**
       * WHen set it prohibits methods from rendering inline documentation.
       */
      noDocs: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set the inputs are disabled
       */
      disabled: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  constructor(type) {
    super();
    this.type = type;
  }
  /**
   * Restores settings from stored value.
   * Abstract to be overriten.
   * @abstract
   */
  restore() {}
  /**
   * Resets settings to default state
   * @abstract
   */
  reset() {}
  /**
   * Sets Observable Property.
   * @param {String} prop Property name to set
   * @param {any} value A value to set
   * @return {Boolean} True if property was changed.
   */
  _sop(prop, value) {
    const key = `_${prop}`;
    const old = this[key];
    /* istanbul ignore if */
    if (old === value) {
      return false;
    }
    this[key] = value;
    this.requestUpdate(prop, old);
    return true;
  }

  _notifyChanged(prop, value) {
    this.dispatchEvent(new CustomEvent(`${prop}-changed`, {
      detail: {
        value
      }
    }));
  }
  /**
   * Generates auth data model by calling `validate()` and `getSettings()` functions.
   *
   * @param {String} type Auth form type.
   * @return {Object} Gnerated data model
   */
  _createModel(type) {
    return {
      settings: this.getSettings(),
      type,
      valid: this.validate()
    };
  }
  /**
   * Generates data model and disaptches `auth-settings-changed` custom event.
   *
   * @param {String} type Auth form type.
   * @return {CustomEvent} Dispatched event
   */
  _notifySettingsChange(type) {
    const detail = this._createModel(type);
    const e = new CustomEvent('auth-settings-changed', {
      detail: detail,
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(e);
    return e;
  }
  /**
   * A coniniet method to set a property value and call the settings changed function.
   *
   * Note, this function is to be called from user input only. Calling this function
   * from a property change will cause invalid validation report.
   *
   * @param {String} prop Name of the property to set
   * @param {any} value A value to set.
   */
  _setSettingsInputValue(prop, value) {
    this.__isInputEvent = true;
    this[prop] = value;
    this._settingsChanged();
    this.__isInputEvent = false;
  }

  /**
   * Dispatches `auth-settings-changed` custom event asynchronously or, if
   * `__isInputEvent` flag is set, synchronously.
   */
  _settingsChanged() {
    if (this.__isInputEvent) {
      this.__notifyChanged();
    } else {
      if (this.__settingsDebouncer) {
        clearTimeout(this.__settingsDebouncer);
      }
      this.__settingsDebouncer = setTimeout(() => this.__notifyChanged());
    }
  }

  __notifyChanged() {
    this.__settingsDebouncer = null;
    const e = this._notifySettingsChange(this.type);
    if (this._notifyHeaderChange) {
      this._notifyHeaderChange(e.detail.settings);
    }
  }

  _getEventTarget(e) {
    let target;
    if (e.composedPath) {
      target = e.composedPath()[0];
    } else if (e.path) {
      target = e.path[0];
    } else {
      target = e.target;
    }
    return target;
  }
  /**
   * Restores an item from a session store and assigns it to a local
   * property.
   * @param {String} sessionKey Session storage key
   * @param {String} localKey This component's property
   */
  _restoreSessionProperty(sessionKey, localKey) {
    if (!this[localKey]) {
      const value = sessionStorage.getItem(sessionKey);
      if (value) {
        this[localKey] = value;
      }
    }
  }
  /**
   * Stores a property in a session storage.
   * @param {String} sessionKey A storage key
   * @param {String} value Value to store
   */
  _storeSessionProperty(sessionKey, value) {
    if (!value) {
      return;
    }
    if (typeof value === 'object') {
      value = JSON.stringify(value);
    }
    sessionStorage.setItem(sessionKey, value);
  }
}

var authStyles = css `
anypoint-input,
anypoint-masked-input {
  width: auto;
  display: block;
}

.edit-icon {
  visibility: hidden;
}

[hidden] {
  display: none !important;
}

.adv-toggle {
  margin-top: 8px;
}

.markdown-body,
.docs-container {
  font-size: var(--arc-font-body1-font-size);
  font-weight: var(--arc-font-body1-font-weight);
  line-height: var(--arc-font-body1-line-height);
  color: var(--inline-documentation-color, rgba(0, 0, 0, 0.87));
}

arc-marked {
  background-color: var(--inline-documentation-background-color, #FFF3E0);
  padding: 4px;
}

.markdown-body p:first-child {
  margin-top: 0;
  padding-top: 0;
}

.markdown-body p:last-child {
  margin-bottom: 0;
  padding-bottom: 0;
}

.form-title {
  font-size: 1.25rem;
  margin: 12px 8px;
}

.subtitle {
  font-size: var(--arc-font-subhead-font-size);
  font-weight: var(--arc-font-subhead-font-weight);
  line-height: var(--arc-font-subhead-line-height);
  margin: 12px 8px;
}

anypoint-input,
anypoint-masked-input {
  margin: 20px 8px;
}
`;

class AnypointMaskedInput extends AnypointInput {
  get _visibilityToggleIcon() {
    return this.visible ? 'arc:visibility-off' : 'arc:visibility';
  }

  get _visibilityToggleTitle() {
    return this.visible ?
      'Hide input value' :
      'Show input value';
  }

  get _visibilityToggleLabel() {
    return this.visible ?
      'Activate to hide input value' :
      'Activate to show input value';
  }

  get _inputType() {
    if (this.visible) {
      return this.type || 'text';
    } else {
      return 'password';
    }
  }

  static get properties() {
    return {
      /**
       * When set the input renders the value visible and restores
       * original input type.
       */
      visible: { type: Boolean }
    };
  }
  /**
   * Toggles `visible` property value.
   */
  toggleVisibility() {
    this.visible = !this.visible;
  }

  _suffixTemplate() {
    const {
      disabled,
      _visibilityToggleIcon,
      _visibilityToggleTitle,
      _visibilityToggleLabel
    } = this;
    return html`
    <div class="suffixes">
      <anypoint-icon-button
        @click="${this.toggleVisibility}"
        title="${_visibilityToggleTitle}"
        aria-label="${_visibilityToggleLabel}"
        ?disabled="${disabled}">
        <iron-icon icon="${_visibilityToggleIcon}"></iron-icon>
      </anypoint-icon-button>
      <slot name="suffix"></slot>
    </div>`;
  }
}

window.customElements.define('anypoint-masked-input', AnypointMaskedInput);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The `<auth-method-basic>` element displays a form to provide the Basic
 * auth credentials.
 * It calculates base64 has while typing into username or password field.
 *
 * It accepts `hash` as a property and once set it will atempt to decode it
 * and set username and paswword.
 *
 * ### Example
 *
 * ```html
 * <auth-method-basic hash="dGVzdDp0ZXN0"></auth-method-basic>
 * ```
 *
 * This example will produce a form with prefilled username and passowrd with
 * value "test".
 *
 * @customElement
 * @memberof UiElements
 * @demo demo/basic.html
 * @extends AuthMethodBase
 */
class AuthMethodBasic extends AuthMethodBase {
  static get styles() {
    return [
      authStyles,
      css`
      :host {
        display: block;
      }`
    ];
  }

  render() {
    const {
      username,
      password,
      outlined,
      compatibility,
      readOnly,
      disabled
    } = this;
    return html`
      <iron-form>
        <form autocomplete="on">
          <anypoint-input
            .value="${username}"
            @input="${this._usernameHandler}"
            name="username"
            type="text"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Username is required">
            <label slot="label">User name</label>
          </anypoint-input>
          <anypoint-masked-input
            name="password"
            .value="${password}"
            @input="${this._passwordHandler}"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Password</label>
          </anypoint-masked-input>
        </form>
      </iron-form>`;
  }

  static get properties() {
    return {
      // The password.
      password: { type: String },
      // The username.
      username: { type: String }
    };
  }
  /**
   * @return {String} base64 hash of the uid and passwd. When set it will override
   * current username and password.
   */
  get hash() {
    let { username, password } = this;
    if (!username) {
      username = '';
    }
    if (!password) {
      password = '';
    }
    let hash;
    if (username || password) {
      const enc = `${username}:${password}`;
      hash = btoa(enc);
    } else {
      hash = '';
    }
    return hash;
  }

  get username() {
    return this._username || '';
  }

  set username(value) {
    /* istanbul ignore else */
    if (this._sop('username', value)) {
      this._valueChanged();
      this._notifyChanged('username', value);
    }
  }

  get password() {
    return this._password || '';
  }

  set password(value) {
    /* istanbul ignore else */
    if (this._sop('password', value)) {
      this._valueChanged();
      this._notifyChanged('password', value);
    }
  }

  constructor() {
    super('basic');
    this._onAuthSettings = this._onAuthSettings.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('auth-settings-changed', this._onAuthSettings);
  }

  _detachListeners(node) {
    node.removeEventListener('auth-settings-changed', this._onAuthSettings);
  }

  firstUpdated() {
    this._valueChanged();
  }

  /**
   * Resets state of the form.
   */
  reset() {
    this.username = '';
    this.password = '';
  }
  /**
   * Validates the form.
   *
   * @return {Boolean} Validation result.
   */
  validate() {
    const form = this.shadowRoot.querySelector('iron-form');
    /* istanbul ignore if */
    if (!form) {
      return true;
    }
    return form.validate();
  }
  /**
   * Creates a settings object with user provided data.
   *
   * @return {Object} User provided data
   */
  getSettings() {
    return {
      hash: this.hash,
      password: this.password || '',
      username: this.username || ''
    };
  }
  /**
   * Restores settings from stored value.
   *
   * @param {Object} settings Object returned by `_getSettings()`
   */
  restore(settings) {
    this.password = settings.password;
    this.username = settings.username;
  }
  /**
   * Handler to the `auth-settings-changed` event (fired by all auth panels).
   * If the event was fired by other element with the same method ttype
   * then the form will be updated to incomming values.
   * This helps to sync changes between elements in the same app.
   *
   * @param {Event} e
   */
  _onAuthSettings(e) {
    if (this._getEventTarget(e) === this || e.detail.type !== 'basic') {
      return;
    }
    this.restore(e.detail.settings);
  }
  /**
   * Dispatches `request-header-changed` custom event to inform other
   * elements about authorization value change.
   *
   * @param {Object} settings
   */
  _notifyHeaderChange(settings) {
    const hash = settings && settings.hash || '';
    const value = `Basic ${hash}`;
    this.dispatchEvent(new CustomEvent('request-header-changed', {
      detail: {
        name: 'Authorization',
        value
      },
      bubbles: true,
      composed: true
    }));
  }

  _usernameHandler(e) {
    this._setSettingsInputValue('username', e.target.value);
  }

  _passwordHandler(e) {
    this._setSettingsInputValue('password', e.target.value);
  }

  _valueChanged() {
    if (this.__isInputEvent) {
      return;
    }
    this._settingsChanged();
  }
  /**
   * Fired when error occured when decoding hash.
   * The event is not bubbling.
   *
   * @event error
   * @param {Error} error The error object.
   */
  /**
   * Fired when the any of the auth method settings has changed.
   * This event will be fired quite frequently - each time anything in the text field changed.
   * With one exception. This event will not be fired if the validation of the form didn't passed.
   *
   * @event auth-settings-changed
   * @param {Object} settings Current settings containing hash, password
   * and username.
   * @param {String} type The authorization type - basic
   * @param {Boolean} valid True if the form has been validated.
   */
  /**
   * Fired when the header value has changed.
   *
   * @event request-header-changed
   * @param {String} name Name of the header
   * @param {String} value Value of the header
   */
}
window.customElements.define('auth-method-basic', AuthMethodBasic);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The `<auth-method-digest>` element displays a form for digest authentication.
 * The user have to choose is he want to provide username and password only or
 * all digest parameters to calculate final authorization header.
 *
 * In first case, the listeners and the transport method must perform handshake
 * by it's own. Otherwise authorization header should be set with calculated value.
 *
 * ### Example
 * ```
 * <auth-method-digest username="john" password="doe"></auth-method-digest>
 * ```
 *
 * The `settings` property (of the element or even detail property) for full form
 * has the following structure:
 *
 * ```
 * {
 *  "username": String,
 *  "realm": String,
 *  "nonce": String,
 *  "uri": String,
 *  "response": String,
 *  "opaque": String,
 *  "qop": String - can be empty,
 *  "nc": String,
 *  "cnonce": String
 * }
 * ```
 *
 * ## Response calculation
 * Depending on the algorithm and quality of protection (qop) properties the hasing
 * algorithm may need following data:
 * - request URL
 * - request payload (body)
 * - request HTTP method
 *
 * The element should be provided with this information by setting it's properties.
 * However, the element will listen for `url-value-changed`, `http-method-changed`
 * and `body-value-changed` events on the window object. Once the event is handled
 * it will set up corresponding properties.
 * All this events must have a `value` property set on event's detail object.
 *
 * @customElement
 * @memberof UiElements
 * @demo demo/digest.html
 * @extends AuthMethodBase
 */
class AuthMethodDigest extends AuthMethodBase {
  static get styles() {
    return [
      authStyles,
      css`
      :host {
        display: block;
      }`
    ];
  }

  render() {
    const {
      username,
      password,
      outlined,
      compatibility,
      readOnly,
      disabled,
      fullForm
    } = this;
    return html`
    <iron-form>
      <form autocomplete="on">
        <anypoint-input
          .value="${username}"
          @input="${this._valueHandler}"
          name="username"
          type="text"
          required
          autovalidate
          autocomplete="on"
          .outlined="${outlined}"
          .compatibility="${compatibility}"
          .readOnly="${readOnly}"
          .disabled="${disabled}"
          invalidmessage="Username is required">
          <label slot="label">User name</label>
        </anypoint-input>
        <anypoint-masked-input
          name="password"
          .value="${password}"
          @input="${this._valueHandler}"
          autocomplete="on"
          .outlined="${outlined}"
          .compatibility="${compatibility}"
          .readOnly="${readOnly}"
          .disabled="${disabled}">
          <label slot="label">Password</label>
        </anypoint-masked-input>

        <div class="adv-toggle">
          <anypoint-checkbox
            class="adv-settings-input"
            .checked="${fullForm}"
            @change="${this._advHandler}"
            .disabled="${disabled || readOnly}"
          >Advanced settings</anypoint-checkbox>
        </div>

        ${fullForm ? html`<div class="extended-form">
          <anypoint-input
            .value="${this.realm}"
            @input="${this._valueHandler}"
            name="realm"
            type="text"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Realm is required">
            <label slot="label">Server issued realm</label>
          </anypoint-input>

          <anypoint-input
            .value="${this.nonce}"
            @input="${this._valueHandler}"
            name="nonce"
            type="text"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Nonce is required">
            <label slot="label">Server issued nonce</label>
          </anypoint-input>

          <anypoint-dropdown-menu
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
          >
            <label slot="label">Quality of protection</label>
            <anypoint-listbox
              slot="dropdown-content"
              .selected="${this.qop}"
              @selected-changed="${this._qopHandler}"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${disabled}"
              attrforselected="data-qop">
              <anypoint-item .compatibility="${compatibility}" data-qop="auth">auth</anypoint-item>
              <anypoint-item .compatibility="${compatibility}" data-qop="auth-int">auth-int</anypoint-item>
            </anypoint-listbox>
          </anypoint-dropdown-menu>

          <anypoint-input
            .value="${this.nc}"
            @input="${this._valueHandler}"
            name="nc"
            type="number"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Nonce count is required">
            <label slot="label">Nounce count</label>
          </anypoint-input>

          <anypoint-dropdown-menu
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
          >
            <label slot="label">Hash algorithm</label>
            <anypoint-listbox
              slot="dropdown-content"
              .selected="${this.algorithm}"
              @selected-changed="${this._algorithmHandler}"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${disabled}"
              attrforselected="data-algorithm">
              <anypoint-item .compatibility="${compatibility}" data-algorithm="MD5">MD5</anypoint-item>
              <anypoint-item .compatibility="${compatibility}" data-algorithm="MD5-sess">MD5-sess</anypoint-item>
            </anypoint-listbox>
          </anypoint-dropdown-menu>

          <anypoint-input
            .value="${this.opaque}"
            @input="${this._valueHandler}"
            name="opaque"
            type="text"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Server issued opaque is required">
            <label slot="label">Server issued opaque string</label>
          </anypoint-input>

          <anypoint-input
            .value="${this.cnonce}"
            @input="${this._valueHandler}"
            name="cnonce"
            type="text"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Client nounce is required">
            <label slot="label">Client nounce</label>
          </anypoint-input>
        </div>` : ''}
      </form>
    </iron-form>`;
  }

  static get properties() {
    return {
      // The password.
      password: { type: String },
      // The username.
      username: { type: String },
      // If set then it will display all form fields.
      fullForm: { type: Boolean },
      // Server issued realm.
      realm: { type: String },
      // Server issued nonce.
      nonce: { type: String },
      // The realm value for the digest response.
      algorithm: { type: String },
      /**
       * The quality of protection value for the digest response.
       * Either '', 'auth' or 'auth-int'
       */
      qop: { type: String },
      // Nonce count - increments with each request used with the same nonce
      nc: { type: Number },
      // Client nonce
      cnonce: { type: String },
      // A string of data specified by the server
      opaque: { type: String },
      // Hashed response to server challenge
      response: { type: String },
      // Request HTTP method
      httpMethod: { type: String },
      // Current request URL.
      requestUrl: { type: String },

      _requestUri: { type: String },
      // Current request body.
      requestBody: { type: String }
    };
  }

  get requestUrl() {
    return this._requestUrl;
  }

  set requestUrl(value) {
    const old = this._requestUrl;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._requestUrl = value;
    this._processRequestUrl(value);
  }

  constructor() {
    super('digest');
    this.nc = 1;
    this.algorithm = 'MD5';
    this._onUrlChanged = this._onUrlChanged.bind(this);
    this._onHttpMethodChanged = this._onHttpMethodChanged.bind(this);
    this._onBodyChanged = this._onBodyChanged.bind(this);
    this._onAuthSettings = this._onAuthSettings.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('url-value-changed', this._onUrlChanged);
    node.addEventListener('http-method-changed', this._onHttpMethodChanged);
    node.addEventListener('body-value-changed', this._onBodyChanged);
    node.addEventListener('auth-settings-changed', this._onAuthSettings);
  }

  _detachListeners(node) {
    node.removeEventListener('url-value-changed', this._onUrlChanged);
    node.removeEventListener('http-method-changed', this._onHttpMethodChanged);
    node.removeEventListener('body-value-changed', this._onBodyChanged);
    node.removeEventListener('auth-settings-changed', this._onAuthSettings);
  }

  firstUpdated() {
    this._settingsChanged();
  }
  /**
   * Validates the form.
   *
   * @return {Boolean} Validation result.
   */
  validate() {
    const form = this.shadowRoot.querySelector('iron-form');
    /* istanbul ignore if */
    if (!form) {
      return true;
    }
    return form ? form.validate() : true;
  }
  /**
   * Returns current settings. Object's structure depends on `fullForm`
   * property. If it's `false` then the object will contain username and
   * password. Otherwise it will contain a list of parameters of the
   * Authorization header.
   *
   * @return {Object}
   */
  getSettings() {
    if (!this.fullForm) {
      return {
        password: this.password || '',
        username: this.username || ''
      };
    }
    this.response = this.generateResponse();
    const settings = {};
    settings.username = this.username || '';
    settings.password = this.password || '';
    settings.realm = this.realm;
    settings.nonce = this.nonce;
    settings.uri = this._requestUri;
    settings.response = this.response;
    settings.opaque = this.opaque;
    settings.qop = this.qop;
    settings.nc = ('00000000' + this.nc).slice(-8);
    settings.cnonce = this.cnonce;
    settings.algorithm = this.algorithm;
    return settings;
  }

  /**
   * Restores settings from stored value.
   *
   * @param {Object} settings Object returned by `_getSettings()`
   */
  restore(settings) {
    this.username = settings.username;
    this.password = settings.password;
    this.realm = settings.realm;
    this.nonce = settings.nonce;
    this.opaque = settings.opaque;
    this.qop = settings.qop;
    this.cnonce = settings.cnonce;
    if (settings.uri) {
      this._requestUri = settings.uri;
    }
    if (settings.nc) {
      this.nc = Number(settings.nc.replace(/0+/, ''));
    }
  }

  _processInput() {
    if (this.fullForm) {
      if (!this.nc) {
        this.nc = 1;
        return;
      }
      if (!this.cnonce) {
        this.cnonce = this.generateCnonce();
        return;
      }
    }
  }
  /**
   * Generates client nonce.
   *
   * @return {String} Generated client nonce.
   */
  generateCnonce() {
    const characters = 'abcdef0123456789';
    let token = '';
    for (let i = 0; i < 16; i++) {
      const randNum = Math.round(Math.random() * characters.length);
      token += characters.substr(randNum, 1);
    }
    return token;
  }
  /**
   * Generates the response header based on the parameters provided in the
   * form.
   *
   * See https://en.wikipedia.org/wiki/Digest_access_authentication#Overview
   *
   * @return {String} A response part of the authenticated digest request.
   */
  generateResponse() {
    /* global CryptoJS */
    const HA1 = this._getHA1();
    const HA2 = this._getHA2();
    const ncString = ('00000000' + this.nc).slice(-8);
    let responseStr = HA1 + ':' + this.nonce;
    if (!this.qop) {
      responseStr += ':' + HA2;
    } else {
      responseStr += ':' + ncString + ':' + this.cnonce + ':' + this.qop + ':' + HA2;
    }
    return CryptoJS.MD5(responseStr).toString();
  }
  // Generates HA1 as defined in Digest spec.
  _getHA1() {
    let HA1param = this.username + ':' + this.realm + ':' + this.password;
    let HA1 = CryptoJS.MD5(HA1param).toString();

    if (this.algorithm === 'MD5-sess') {
      HA1param = HA1 + ':' + this.nonce + ':' + this.cnonce;
      HA1 = CryptoJS.MD5(HA1param).toString();
    }
    return HA1;
  }
  // Generates HA2 as defined in Digest spec.
  _getHA2() {
    let HA2param = this.httpMethod + ':' + this._requestUri;
    if (this.qop === 'auth-int') {
      HA2param += ':' + CryptoJS.MD5(this.requestBody).toString();
    }
    return CryptoJS.MD5(HA2param).toString();
  }
  /**
   * Handler to the `url-value-changed` event. When the element handle this
   * event it will update the `requestUrl` property.
   * @param {CustomEvent} e
   */
  _onUrlChanged(e) {
    this.requestUrl = e.detail.value;
  }
  /**
   * Handler to the `http-method-changed` event. When the element handle this
   * event it will update the `httpMethod` property.
   * @param {CustomEvent} e
   */
  _onHttpMethodChanged(e) {
    this.httpMethod = e.detail.value;
    this._processInput();
    this._settingsChanged();
  }
  /**
   * Handler to the `body-value-changed` event. When the element handle this
   * event it will update the `requestBody` property.
   * @param {CustomEvent} e
   */
  _onBodyChanged(e) {
    this.requestBody = e.detail.value;
    this._processInput();
    this._settingsChanged();
  }
  /**
   * Handler to the `auth-settings-changed` event (fired by all auth panels).
   * If the event was fired by other element with the same method ttype
   * then the form will be updated to incomming values.
   * This helps to sync changes between elements in the same app.
   * @param {CustomEvent} e
   */
  _onAuthSettings(e) {
    const target = this._getEventTarget(e);
    if (target === this || e.detail.type !== 'digest') {
      return;
    }
    this.restore(e.detail.settings);
  }

  _advHandler(e) {
    this._processInput();
    this._setSettingsInputValue('fullForm', e.target.checked);
  }

  _qopHandler(e) {
    this._processInput();
    this._setSettingsInputValue('qop', e.detail.value);
  }

  _algorithmHandler(e) {
    this._processInput();
    this._setSettingsInputValue('algorithm', e.detail.value);
  }

  _valueHandler(e) {
    const { name, value } = e.target;
    this._processInput();
    this._setSettingsInputValue(name, value);
  }

  _processRequestUrl(value) {
    if (!value || typeof value !== 'string') {
      this._requestUri = undefined;
      this._processInput();
      this._settingsChanged();
      return;
    }
    try {
      const url = new URL(value);
      value = url.pathname;
    } catch (_) {
      value = value.trum();
    }
    this._requestUri = value;
    this._processInput();
    this._settingsChanged();
  }
  /**
   * Fired when error occured when decoding hash.
   *
   * @event error
   * @param {Error} error The error object.
   */
  /**
   * Fired when the any of the auth method settings has changed.
   * This event will be fired quite frequently - each time anything in the text field changed.
   * With one exception. This event will not be fired if the validation of the form didn't passed.
   *
   * @event auth-settings-changed
   * @param {Object} settings Current settings containing hash, password
   * and username.
   * @param {String} type The authorization type - basic
   * @param {Boolean} valid True if the form has been validated.
   */
}
window.customElements.define('auth-method-digest', AuthMethodDigest);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The `<auth-method-ntlm>` element displays a form to provide the NTLM auth
 * credentials.
 *
 * It only provides data since NTLM authentication and all calculations must
 * be conducted when working on socket.
 *
 * This form requires to provide at least username and password. The domain
 * parameter is not required in NTLM so it may be empty.
 *
 * ### Example
 *
 * ```html
 * <auth-method-ntlm username="john" password="doe" domain="my-nt-domain"></auth-method-ntlm>
 * ```
 *
 * @customElement
 * @memberof UiElements
 * @demo demo/ntlm.html
 * @extends AuthMethodBase
 */
class AuthMethodNtlm extends AuthMethodBase {
  static get styles() {
    return [
      authStyles,
      css`
      :host {
        display: block;
      }`
    ];
  }

  render() {
    const {
      username,
      password,
      domain,
      outlined,
      compatibility,
      readOnly,
      disabled
    } = this;
    return html`
      <iron-form>
        <form autocomplete="on">
          <anypoint-input
            .value="${username}"
            @input="${this._valueHandler}"
            name="username"
            type="text"
            required
            autovalidate
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Username is required">
            <label slot="label">User name</label>
          </anypoint-input>
          <anypoint-masked-input
            name="password"
            .value="${password}"
            @input="${this._valueHandler}"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Password</label>
          </anypoint-masked-input>
          <anypoint-input
            .value="${domain}"
            @input="${this._valueHandler}"
            name="domain"
            type="text"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">NT domain</label>
          </anypoint-input>
        </form>
      </iron-form>`;
  }

  static get properties() {
    return {
      // The domain parameter for the request.
      domain: { type: String },
      // The password.
      password: { type: String },
      // The username.
      username: { type: String }
    };
  }

  get username() {
    return this._username || '';
  }

  set username(value) {
    /* istanbul ignore else */
    if (this._sop('username', value)) {
      this._valueChanged();
    }
  }

  get password() {
    return this._password || '';
  }

  set password(value) {
    /* istanbul ignore else */
    if (this._sop('password', value)) {
      this._valueChanged();
    }
  }

  get domain() {
    return this._domain || '';
  }

  set domain(value) {
    /* istanbul ignore else */
    if (this._sop('domain', value)) {
      this._valueChanged();
    }
  }

  constructor() {
    super('ntlm');
    this._onAuthSettings = this._onAuthSettings.bind(this);
  }

  firstUpdated() {
    this._valueChanged();
  }

  _attachListeners(node) {
    node.addEventListener('auth-settings-changed', this._onAuthSettings);
  }
  _detachListeners(node) {
    node.removeEventListener('auth-settings-changed', this._onAuthSettings);
  }

  /**
   * Validates the form.
   *
   * @return {Boolean} `true` if valid, `false` otherwise.
   */
  validate() {
    const form = this.shadowRoot.querySelector('iron-form');
    /* istanbul ignore if */
    if (!form) {
      return true;
    }
    return form.validate();
  }
  /**
   * Creates a settings object with user provided data.
   *
   * @return {Object} User provided data
   */
  getSettings() {
    return {
      domain: this.domain || '',
      password: this.password || '',
      username: this.username || ''
    };
  }

  /**
   * Restores settings from stored value.
   *
   * @param {Object} settings Object returned by `_getSettings()`
   */
  restore(settings) {
    this.domain = settings.domain;
    this.password = settings.password;
    this.username = settings.username;
  }

  reset() {
    this.domain = '';
    this.password = '';
    this.username = '';
  }
  /**
   * Handler for the `auth-settings-changed` event (fired by all auth panels).
   * If the event was fired by other element with the same method ttype
   * then the form will be updated to incomming values.
   *
   * @param {Event} e
   */
  _onAuthSettings(e) {
    if (this._getEventTarget(e) === this || e.detail.type !== 'ntlm') {
      return;
    }
    this.restore(e.detail.settings);
  }

  _valueHandler(e) {
    const { name, value } = e.target;
    this._setSettingsInputValue(name, value);
  }

  _valueChanged() {
    if (this.__isInputEvent) {
      return;
    }
    this._settingsChanged();
  }
  /**
   * Fired when error occured when decoding hash.
   *
   * @event error
   * @param {Error} error The error object.
   */
  /**
   * Fired when the any of the auth method settings has changed.
   * This event will be fired quite frequently - each time anything in the text field changed.
   * With one exception. This event will not be fired if the validation of the form didn't passed.
   *
   * The `domain` field is not required in the form so check for missing `domain` value if it's
   * required in your application.
   *
   * @event auth-settings-changed
   * @param {Object} settings Current settings containing domain, password
   * and username.
   * @param {String} type The authorization type - ntlm
   * @param {Boolean} valid True if the form has been validated.
   */
}
window.customElements.define('auth-method-ntlm', AuthMethodNtlm);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
`iron-a11y-announcer` is a singleton element that is intended to add a11y
to features that require on-demand announcement from screen readers. In
order to make use of the announcer, it is best to request its availability
in the announcing element.

Example:

    Polymer({

      is: 'x-chatty',

      attached: function() {
        // This will create the singleton element if it has not
        // been created yet:
        Polymer.IronA11yAnnouncer.requestAvailability();
      }
    });

After the `iron-a11y-announcer` has been made available, elements can
make announces by firing bubbling `iron-announce` events.

Example:

    this.fire('iron-announce', {
      text: 'This is an announcement!'
    }, { bubbles: true });

Note: announcements are only audible if you have a screen reader enabled.

@group Iron Elements
@demo demo/index.html
*/
const IronA11yAnnouncer = Polymer({
  _template: html$1`
    <style>
      :host {
        display: inline-block;
        position: fixed;
        clip: rect(0px,0px,0px,0px);
      }
    </style>
    <div aria-live$="[[mode]]">[[_text]]</div>
`,

  is: 'iron-a11y-announcer',

  properties: {

    /**
     * The value of mode is used to set the `aria-live` attribute
     * for the element that will be announced. Valid values are: `off`,
     * `polite` and `assertive`.
     */
    mode: {type: String, value: 'polite'},

    _text: {type: String, value: ''}
  },

  created: function() {
    if (!IronA11yAnnouncer.instance) {
      IronA11yAnnouncer.instance = this;
    }

    document.body.addEventListener(
        'iron-announce', this._onIronAnnounce.bind(this));
  },

  /**
   * Cause a text string to be announced by screen readers.
   *
   * @param {string} text The text that should be announced.
   */
  announce: function(text) {
    this._text = '';
    this.async(function() {
      this._text = text;
    }, 100);
  },

  _onIronAnnounce: function(event) {
    if (event.detail && event.detail.text) {
      this.announce(event.detail.text);
    }
  }
});

IronA11yAnnouncer.instance = null;

IronA11yAnnouncer.requestAvailability = function() {
  if (!IronA11yAnnouncer.instance) {
    IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
  }

  document.body.appendChild(IronA11yAnnouncer.instance);
};

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
`Polymer.IronFitBehavior` fits an element in another element using `max-height`
and `max-width`, and optionally centers it in the window or another element.

The element will only be sized and/or positioned if it has not already been
sized and/or positioned by CSS.

CSS properties            | Action
--------------------------|-------------------------------------------
`position` set            | Element is not centered horizontally or vertically
`top` or `bottom` set     | Element is not vertically centered
`left` or `right` set     | Element is not horizontally centered
`max-height` set          | Element respects `max-height`
`max-width` set           | Element respects `max-width`

`Polymer.IronFitBehavior` can position an element into another element using
`verticalAlign` and `horizontalAlign`. This will override the element's css
position.

    <div class="container">
      <iron-fit-impl vertical-align="top" horizontal-align="auto">
        Positioned into the container
      </iron-fit-impl>
    </div>

Use `noOverlap` to position the element around another element without
overlapping it.

    <div class="container">
      <iron-fit-impl no-overlap vertical-align="auto" horizontal-align="auto">
        Positioned around the container
      </iron-fit-impl>
    </div>

Use `horizontalOffset, verticalOffset` to offset the element from its
`positionTarget`; `Polymer.IronFitBehavior` will collapse these in order to
keep the element within `fitInto` boundaries, while preserving the element's
CSS margin values.

    <div class="container">
      <iron-fit-impl vertical-align="top" vertical-offset="20">
        With vertical offset
      </iron-fit-impl>
    </div>

@demo demo/index.html
@polymerBehavior
*/
const IronFitBehavior = {

  properties: {

    /**
     * The element that will receive a `max-height`/`width`. By default it is
     * the same as `this`, but it can be set to a child element. This is useful,
     * for example, for implementing a scrolling region inside the element.
     * @type {!Element}
     */
    sizingTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * The element to fit `this` into.
     */
    fitInto: {type: Object, value: window},

    /**
     * Will position the element around the positionTarget without overlapping
     * it.
     */
    noOverlap: {type: Boolean},

    /**
     * The element that should be used to position the element. If not set, it
     * will default to the parent node.
     * @type {!Element}
     */
    positionTarget: {type: Element},

    /**
     * The orientation against which to align the element horizontally
     * relative to the `positionTarget`. Possible values are "left", "right",
     * "center", "auto".
     */
    horizontalAlign: {type: String},

    /**
     * The orientation against which to align the element vertically
     * relative to the `positionTarget`. Possible values are "top", "bottom",
     * "middle", "auto".
     */
    verticalAlign: {type: String},

    /**
     * If true, it will use `horizontalAlign` and `verticalAlign` values as
     * preferred alignment and if there's not enough space, it will pick the
     * values which minimize the cropping.
     */
    dynamicAlign: {type: Boolean},

    /**
     * A pixel value that will be added to the position calculated for the
     * given `horizontalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `horizontalAlign`.
     *
     * If `horizontalAlign` is "left" or "center", this offset will increase or
     * decrease the distance to the left side of the screen: a negative offset
     * will move the dropdown to the left; a positive one, to the right.
     *
     * Conversely if `horizontalAlign` is "right", this offset will increase
     * or decrease the distance to the right side of the screen: a negative
     * offset will move the dropdown to the right; a positive one, to the left.
     */
    horizontalOffset: {type: Number, value: 0, notify: true},

    /**
     * A pixel value that will be added to the position calculated for the
     * given `verticalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `verticalAlign`.
     *
     * If `verticalAlign` is "top" or "middle", this offset will increase or
     * decrease the distance to the top side of the screen: a negative offset
     * will move the dropdown upwards; a positive one, downwards.
     *
     * Conversely if `verticalAlign` is "bottom", this offset will increase
     * or decrease the distance to the bottom side of the screen: a negative
     * offset will move the dropdown downwards; a positive one, upwards.
     */
    verticalOffset: {type: Number, value: 0, notify: true},

    /**
     * Set to true to auto-fit on attach.
     */
    autoFitOnAttach: {type: Boolean, value: false},

    /** @type {?Object} */
    _fitInfo: {type: Object}
  },

  get _fitWidth() {
    var fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  },

  get _fitHeight() {
    var fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  },

  get _fitLeft() {
    var fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  },

  get _fitTop() {
    var fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  },

  /**
   * The element that should be used to position the element,
   * if no position target is configured.
   */
  get _defaultPositionTarget() {
    var parent = dom(this).parentNode;

    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }

    return parent;
  },

  /**
   * The horizontal align value, accounting for the RTL/LTR text direction.
   */
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      // In RTL, "left" becomes "right".
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  },

  /**
   * True if the element should be positioned instead of centered.
   * @private
   */
  get __shouldPosition() {
    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;
  },

  attached: function() {
    // Memoize this to avoid expensive calculations & relayouts.
    // Make sure we do it only once
    if (typeof this._isRTL === 'undefined') {
      this._isRTL = window.getComputedStyle(this).direction == 'rtl';
    }
    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      if (window.getComputedStyle(this).display === 'none') {
        setTimeout(function() {
          this.fit();
        }.bind(this));
      } else {
        // NOTE: shadydom applies distribution asynchronously
        // for performance reasons webcomponents/shadydom#120
        // Flush to get correct layout info.
        window.ShadyDOM && ShadyDOM.flush();
        this.fit();
      }
    }
  },

  detached: function() {
    if (this.__deferredFit) {
      clearTimeout(this.__deferredFit);
      this.__deferredFit = null;
    }
  },

  /**
   * Positions and fits the element into the `fitInto` element.
   */
  fit: function() {
    this.position();
    this.constrain();
    this.center();
  },

  /**
   * Memoize information needed to position and size the target element.
   * @suppress {deprecated}
   */
  _discoverInfo: function() {
    if (this._fitInfo) {
      return;
    }
    var target = window.getComputedStyle(this);
    var sizer = window.getComputedStyle(this.sizingTarget);

    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ?
            'top' :
            (target.bottom !== 'auto' ? 'bottom' : null),
        horizontally: target.left !== 'auto' ?
            'left' :
            (target.right !== 'auto' ? 'right' : null)
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  },

  /**
   * Resets the target element's position and size constraints, and clear
   * the memoized data.
   */
  resetFit: function() {
    var info = this._fitInfo || {};
    for (var property in info.sizerInlineStyle) {
      this.sizingTarget.style[property] = info.sizerInlineStyle[property];
    }
    for (var property in info.inlineStyle) {
      this.style[property] = info.inlineStyle[property];
    }

    this._fitInfo = null;
  },

  /**
   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after
   * the element or the `fitInto` element has been resized, or if any of the
   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.
   * It preserves the scroll position of the sizingTarget.
   */
  refit: function() {
    var scrollLeft = this.sizingTarget.scrollLeft;
    var scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  },

  /**
   * Positions the element according to `horizontalAlign, verticalAlign`.
   */
  position: function() {
    if (!this.__shouldPosition) {
      // needs to be centered, and it is done after constrain.
      return;
    }
    this._discoverInfo();

    this.style.position = 'fixed';
    // Need border-box for margin/padding.
    this.sizingTarget.style.boxSizing = 'border-box';
    // Set to 0, 0 in order to discover any offset caused by parent stacking
    // contexts.
    this.style.left = '0px';
    this.style.top = '0px';

    var rect = this.getBoundingClientRect();
    var positionRect = this.__getNormalizedRect(this.positionTarget);
    var fitRect = this.__getNormalizedRect(this.fitInto);

    var margin = this._fitInfo.margin;

    // Consider the margin as part of the size for position calculations.
    var size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };

    var position = this.__getPosition(
        this._localeHorizontalAlign,
        this.verticalAlign,
        size,
        rect,
        positionRect,
        fitRect);

    var left = position.left + margin.left;
    var top = position.top + margin.top;

    // We first limit right/bottom within fitInto respecting the margin,
    // then use those values to limit top/left.
    var right = Math.min(fitRect.right - margin.right, left + rect.width);
    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);

    // Keep left/top within fitInto respecting the margin.
    left = Math.max(
        fitRect.left + margin.left,
        Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(
        fitRect.top + margin.top,
        Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));

    // Use right/bottom to set maxWidth/maxHeight, and respect
    // minWidth/minHeight.
    this.sizingTarget.style.maxWidth =
        Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
    this.sizingTarget.style.maxHeight =
        Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';

    // Remove the offset caused by any stacking context.
    this.style.left = (left - rect.left) + 'px';
    this.style.top = (top - rect.top) + 'px';
  },

  /**
   * Constrains the size of the element to `fitInto` by setting `max-height`
   * and/or `max-width`.
   */
  constrain: function() {
    if (this.__shouldPosition) {
      return;
    }
    this._discoverInfo();

    var info = this._fitInfo;
    // position at (0px, 0px) if not already positioned, so we can measure the
    // natural size.
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }

    // need border-box for margin/padding
    this.sizingTarget.style.boxSizing = 'border-box';
    // constrain the width and height if not already set
    var rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(
          rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(
          rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  },

  /**
   * @protected
   * @deprecated
   */
  _sizeDimension: function(rect, positionedBy, start, end, extent) {
    this.__sizeDimension(rect, positionedBy, start, end, extent);
  },

  /**
   * @private
   */
  __sizeDimension: function(rect, positionedBy, start, end, extent) {
    var info = this._fitInfo;
    var fitRect = this.__getNormalizedRect(this.fitInto);
    var max = extent === 'Width' ? fitRect.width : fitRect.height;
    var flip = (positionedBy === end);
    var offset = flip ? max - rect[end] : rect[start];
    var margin = info.margin[flip ? start : end];
    var offsetExtent = 'offset' + extent;
    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] =
        (max - margin - offset - sizingOffset) + 'px';
  },

  /**
   * Centers horizontally and vertically if not already positioned. This also
   * sets `position:fixed`.
   */
  center: function() {
    if (this.__shouldPosition) {
      return;
    }
    this._discoverInfo();

    var positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      // Already positioned.
      return;
    }
    // Need position:fixed to center
    this.style.position = 'fixed';
    // Take into account the offset caused by parents that create stacking
    // contexts (e.g. with transform: translate3d). Translate to 0,0 and
    // measure the bounding rect.
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    // It will take in consideration margins and transforms
    var rect = this.getBoundingClientRect();
    var fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  },

  __getNormalizedRect: function(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  },

  __getOffscreenArea: function(position, size, fitRect) {
    var verticalCrop = Math.min(0, position.top) +
        Math.min(0, fitRect.bottom - (position.top + size.height));
    var horizontalCrop = Math.min(0, position.left) +
        Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width +
        Math.abs(horizontalCrop) * size.height;
  },


  __getPosition: function(
      hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {
    // All the possible configurations.
    // Ordered as top-left, top-right, bottom-left, bottom-right.
    var positions = [
      {
        verticalAlign: 'top',
        horizontalAlign: 'left',
        top: positionRect.top + this.verticalOffset,
        left: positionRect.left + this.horizontalOffset
      },
      {
        verticalAlign: 'top',
        horizontalAlign: 'right',
        top: positionRect.top + this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset
      },
      {
        verticalAlign: 'bottom',
        horizontalAlign: 'left',
        top: positionRect.bottom - size.height - this.verticalOffset,
        left: positionRect.left + this.horizontalOffset
      },
      {
        verticalAlign: 'bottom',
        horizontalAlign: 'right',
        top: positionRect.bottom - size.height - this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset
      }
    ];

    if (this.noOverlap) {
      // Duplicate.
      for (var i = 0, l = positions.length; i < l; i++) {
        var copy = {};
        for (var key in positions[i]) {
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      // Horizontal overlap only.
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      // Vertical overlap only.
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }

    // Consider auto as null for coding convenience.
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;

    if (!hAlign || hAlign === 'center') {
      positions.push({
        verticalAlign: 'top',
        horizontalAlign: 'center',
        top: positionRect.top + this.verticalOffset +
            (this.noOverlap ? positionRect.height : 0),
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
      positions.push({
        verticalAlign: 'bottom',
        horizontalAlign: 'center',
        top: positionRect.bottom - size.height - this.verticalOffset -
            (this.noOverlap ? positionRect.height : 0),
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
    }

    if (!vAlign || vAlign === 'middle') {
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'left',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.left + this.horizontalOffset +
            (this.noOverlap ? positionRect.width : 0)
      });
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'right',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.right - size.width - this.horizontalOffset -
            (this.noOverlap ? positionRect.width : 0)
      });
    }

    if (vAlign === 'middle' && hAlign === 'center') {
      positions.push({
        verticalAlign: 'middle',
        horizontalAlign: 'center',
        top: positionRect.top - sizeNoMargins.height / 2 +
            positionRect.height / 2 + this.verticalOffset,
        left: positionRect.left - sizeNoMargins.width / 2 +
            positionRect.width / 2 + this.horizontalOffset
      });
    }

    var position;
    for (var i = 0; i < positions.length; i++) {
      var candidate = positions[i];
      var vAlignOk = candidate.verticalAlign === vAlign;
      var hAlignOk = candidate.horizontalAlign === hAlign;

      // If both vAlign and hAlign are defined, return exact match.
      // For dynamicAlign and noOverlap we'll have more than one candidate, so
      // we'll have to check the offscreenArea to make the best choice.
      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {
        position = candidate;
        break;
      }

      // Align is ok if alignment preferences are respected. If no preferences,
      // it is considered ok.
      var alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);

      // Filter out elements that don't match the alignment (if defined).
      // With dynamicAlign, we need to consider all the positions to find the
      // one that minimizes the cropped area.
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }

      candidate.offscreenArea =
          this.__getOffscreenArea(candidate, size, fitRect);
      // If not cropped and respects the align requirements, keep it.
      // This allows to prefer positions overlapping horizontally over the
      // ones overlapping vertically.
      if (candidate.offscreenArea === 0 && alignOk) {
        position = candidate;
        break;
      }
      position = position || candidate;
      var diff = candidate.offscreenArea - position.offscreenArea;
      // Check which crops less. If it crops equally, check if at least one
      // align setting is ok.
      if (diff < 0 || (diff === 0 && (vAlignOk || hAlignOk))) {
        position = candidate;
      }
    }

    return position;
  }

};

/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

var p$3 = Element.prototype;
var matches$2 = p$3.matches || p$3.matchesSelector || p$3.mozMatchesSelector ||
    p$3.msMatchesSelector || p$3.oMatchesSelector || p$3.webkitMatchesSelector;

const IronFocusablesHelper = {

  /**
   * Returns a sorted array of tabbable nodes, including the root node.
   * It searches the tabbable nodes in the light and shadow dom of the chidren,
   * sorting the result by tabindex.
   * @param {!Node} node
   * @return {!Array<!HTMLElement>}
   */
  getTabbableNodes: function(node) {
    var result = [];
    // If there is at least one element with tabindex > 0, we need to sort
    // the final array by tabindex.
    var needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  },

  /**
   * Returns if a element is focusable.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isFocusable: function(element) {
    // From http://stackoverflow.com/a/1600194/4228703:
    // There isn't a definite list, it's up to the browser. The only
    // standard we have is DOM Level 2 HTML
    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the
    // only elements that have a focus() method are HTMLInputElement,
    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This
    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these
    // tests with tabbables in different browsers
    // http://allyjs.io/data-tables/focusable.html

    // Elements that cannot be focused if they have [disabled] attribute.
    if (matches$2.call(element, 'input, select, textarea, button, object')) {
      return matches$2.call(element, ':not([disabled])');
    }
    // Elements that can be focused even if they have [disabled] attribute.
    return matches$2.call(
        element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');
  },

  /**
   * Returns if a element is tabbable. To be tabbable, a element must be
   * focusable, visible, and with a tabindex !== -1.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isTabbable: function(element) {
    return this.isFocusable(element) &&
        matches$2.call(element, ':not([tabindex="-1"])') &&
        this._isVisible(element);
  },

  /**
   * Returns the normalized element tabindex. If not focusable, returns -1.
   * It checks for the attribute "tabindex" instead of the element property
   * `tabIndex` since browsers assign different values to it.
   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
   * @param {!HTMLElement} element
   * @return {!number}
   * @private
   */
  _normalizedTabIndex: function(element) {
    if (this.isFocusable(element)) {
      var tabIndex = element.getAttribute('tabindex') || 0;
      return Number(tabIndex);
    }
    return -1;
  },

  /**
   * Searches for nodes that are tabbable and adds them to the `result` array.
   * Returns if the `result` array needs to be sorted by tabindex.
   * @param {!Node} node The starting point for the search; added to `result`
   * if tabbable.
   * @param {!Array<!HTMLElement>} result
   * @return {boolean}
   * @private
   */
  _collectTabbableNodes: function(node, result) {
    // If not an element or not visible, no need to explore children.
    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
      return false;
    }
    var element = /** @type {!HTMLElement} */ (node);
    var tabIndex = this._normalizedTabIndex(element);
    var needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }

    // In ShadowDOM v1, tab order is affected by the order of distrubution.
    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
    // in ShadowDOM v0 tab order is not affected by the distrubution order,
    // in fact getTabbableNodes(#root) returns [#B, #A].
    //  <div id="root">
    //   <!-- shadow -->
    //     <slot name="a">
    //     <slot name="b">
    //   <!-- /shadow -->
    //   <input id="A" slot="a">
    //   <input id="B" slot="b" tabindex="1">
    //  </div>
    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.
    var children;
    if (element.localName === 'content' || element.localName === 'slot') {
      children = dom(element).getDistributedNodes();
    } else {
      // Use shadow root if possible, will check for distributed nodes.
      children = dom(element.root || element).children;
    }
    for (var i = 0; i < children.length; i++) {
      // Ensure method is always invoked to collect tabbable children.
      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
    }
    return needsSort;
  },

  /**
   * Returns false if the element has `visibility: hidden` or `display: none`
   * @param {!HTMLElement} element
   * @return {boolean}
   * @private
   */
  _isVisible: function(element) {
    // Check inline style first to save a re-flow. If looks good, check also
    // computed style.
    var style = element.style;
    if (style.visibility !== 'hidden' && style.display !== 'none') {
      style = window.getComputedStyle(element);
      return (style.visibility !== 'hidden' && style.display !== 'none');
    }
    return false;
  },

  /**
   * Sorts an array of tabbable elements by tabindex. Returns a new array.
   * @param {!Array<!HTMLElement>} tabbables
   * @return {!Array<!HTMLElement>}
   * @private
   */
  _sortByTabIndex: function(tabbables) {
    // Implement a merge sort as Array.prototype.sort does a non-stable sort
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    var len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    var pivot = Math.ceil(len / 2);
    var left = this._sortByTabIndex(tabbables.slice(0, pivot));
    var right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  },

  /**
   * Merge sort iterator, merges the two arrays into one, sorted by tab index.
   * @param {!Array<!HTMLElement>} left
   * @param {!Array<!HTMLElement>} right
   * @return {!Array<!HTMLElement>}
   * @private
   */
  _mergeSortByTabIndex: function(left, right) {
    var result = [];
    while ((left.length > 0) && (right.length > 0)) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }

    return result.concat(left, right);
  },

  /**
   * Returns if element `a` has lower tab order compared to element `b`
   * (both elements are assumed to be focusable and tabbable).
   * Elements with tabindex = 0 have lower tab order compared to elements
   * with tabindex > 0.
   * If both have same tabindex, it returns false.
   * @param {!HTMLElement} a
   * @param {!HTMLElement} b
   * @return {boolean}
   * @private
   */
  _hasLowerTabOrder: function(a, b) {
    // Normalize tabIndexes
    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
    var ati = Math.max(a.tabIndex, 0);
    var bti = Math.max(b.tabIndex, 0);
    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;
  }
};

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/*
`iron-overlay-backdrop` is a backdrop used by `Polymer.IronOverlayBehavior`. It
should be a singleton.

### Styling

The following custom properties and mixins are available for styling.

Custom property | Description | Default
-------------------------------------------|------------------------|---------
`--iron-overlay-backdrop-background-color` | Backdrop background color | #000
`--iron-overlay-backdrop-opacity`          | Backdrop opacity | 0.6
`--iron-overlay-backdrop`                  | Mixin applied to `iron-overlay-backdrop`.                      | {}
`--iron-overlay-backdrop-opened`           | Mixin applied to `iron-overlay-backdrop` when it is displayed | {}
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--iron-overlay-backdrop-background-color, #000);
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        @apply --iron-overlay-backdrop;
      }

      :host(.opened) {
        opacity: var(--iron-overlay-backdrop-opacity, 0.6);
        pointer-events: auto;
        @apply --iron-overlay-backdrop-opened;
      }
    </style>

    <slot></slot>
`,

  is: 'iron-overlay-backdrop',

  properties: {

    /**
     * Returns true if the backdrop is opened.
     */
    opened: {
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_openedChanged',
    }

  },

  listeners: {
    'transitionend': '_onTransitionend',
  },

  created: function() {
    // Used to cancel previous requestAnimationFrame calls when opened changes.
    this.__openedRaf = null;
  },

  attached: function() {
    this.opened && this._openedChanged(this.opened);
  },

  /**
   * Appends the backdrop to document body if needed.
   */
  prepare: function() {
    if (this.opened && !this.parentNode) {
      dom(document.body).appendChild(this);
    }
  },

  /**
   * Shows the backdrop.
   */
  open: function() {
    this.opened = true;
  },

  /**
   * Hides the backdrop.
   */
  close: function() {
    this.opened = false;
  },

  /**
   * Removes the backdrop from document body if needed.
   */
  complete: function() {
    if (!this.opened && this.parentNode === document.body) {
      dom(this.parentNode).removeChild(this);
    }
  },

  _onTransitionend: function(event) {
    if (event && event.target === this) {
      this.complete();
    }
  },

  /**
   * @param {boolean} opened
   * @private
   */
  _openedChanged: function(opened) {
    if (opened) {
      // Auto-attach.
      this.prepare();
    } else {
      // Animation might be disabled via the mixin or opacity custom property.
      // If it is disabled in other ways, it's up to the user to call complete.
      var cs = window.getComputedStyle(this);
      if (cs.transitionDuration === '0s' || cs.opacity == 0) {
        this.complete();
      }
    }

    if (!this.isAttached) {
      return;
    }

    // Always cancel previous requestAnimationFrame.
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    // Force relayout to ensure proper transitions.
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(function() {
      this.__openedRaf = null;
      this.toggleClass('opened', this.opened);
    }.bind(this));
  }
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @struct
 * @constructor
 * @private
 */
const IronOverlayManagerClass = function() {
  /**
   * Used to keep track of the opened overlays.
   * @private {!Array<!Element>}
   */
  this._overlays = [];

  /**
   * iframes have a default z-index of 100,
   * so this default should be at least that.
   * @private {number}
   */
  this._minimumZ = 101;

  /**
   * Memoized backdrop element.
   * @private {Element|null}
   */
  this._backdropElement = null;

  // Enable document-wide tap recognizer.
  // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
  // of an overlay via event.stopPropagation(). The only way to prevent
  // closing of an overlay should be through its APIs.
  // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
  // Pass no-op function because MSEdge 15 doesn't handle null as 2nd argument
  // https://github.com/Microsoft/ChakraCore/issues/3863
  add(document.documentElement, 'tap', function() {});
  document.addEventListener('tap', this._onCaptureClick.bind(this), true);
  document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
  document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
};

IronOverlayManagerClass.prototype = {

  constructor: IronOverlayManagerClass,

  /**
   * The shared backdrop element.
   * @return {!Element} backdropElement
   */
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('iron-overlay-backdrop');
    }
    return this._backdropElement;
  },

  /**
   * The deepest active element.
   * @return {!Element} activeElement the active element
   */
  get deepActiveElement() {
    var active = document.activeElement;
    // document.activeElement can be null
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
    // In IE 11, it can also be an object when operating in iframes.
    // In these cases, default it to document.body.
    if (!active || active instanceof Element === false) {
      active = document.body;
    }
    while (active.root && dom(active.root).activeElement) {
      active = dom(active.root).activeElement;
    }
    return active;
  },

  /**
   * Brings the overlay at the specified index to the front.
   * @param {number} i
   * @private
   */
  _bringOverlayAtIndexToFront: function(i) {
    var overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    var lastI = this._overlays.length - 1;
    var currentOverlay = this._overlays[lastI];
    // Ensure always-on-top overlay stays on top.
    if (currentOverlay &&
        this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    // If already the top element, return.
    if (i >= lastI) {
      return;
    }
    // Update z-index to be on top.
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }

    // Shift other overlays behind the new on top.
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  },

  /**
   * Adds the overlay and updates its z-index if it's opened, or removes it if
   * it's closed. Also updates the backdrop z-index.
   * @param {!Element} overlay
   */
  addOrRemoveOverlay: function(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  },

  /**
   * Tracks overlays for z-index and focus management.
   * Ensures the last added overlay with always-on-top remains on top.
   * @param {!Element} overlay
   */
  addOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    var insertionIndex = this._overlays.length;
    var currentOverlay = this._overlays[insertionIndex - 1];
    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    var newZ = this._getZ(overlay);

    // Ensure always-on-top overlay stays on top.
    if (currentOverlay &&
        this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      // This bumps the z-index of +2.
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      // Update minimumZ to match previous overlay's z-index.
      var previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }

    // Update z-index and insert overlay.
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);

    this.trackBackdrop();
  },

  /**
   * @param {!Element} overlay
   */
  removeOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);

    this.trackBackdrop();
  },

  /**
   * Returns the current overlay.
   * @return {!Element|undefined}
   */
  currentOverlay: function() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  },

  /**
   * Returns the current overlay z-index.
   * @return {number}
   */
  currentOverlayZ: function() {
    return this._getZ(this.currentOverlay());
  },

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   * @param {number} minimumZ
   */
  ensureMinimumZ: function(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  },

  focusOverlay: function() {
    var current = /** @type {?} */ (this.currentOverlay());
    if (current) {
      current._applyFocus();
    }
  },

  /**
   * Updates the backdrop z-index.
   */
  trackBackdrop: function() {
    var overlay = this._overlayWithBackdrop();
    // Avoid creating the backdrop if there is no overlay with backdrop.
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
    // Property observers are not fired until element is attached
    // in Polymer 2.x, so we ensure element is attached if needed.
    // https://github.com/Polymer/polymer/issues/4526
    this.backdropElement.prepare();
  },

  /**
   * @return {!Array<!Element>}
   */
  getBackdrops: function() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  },

  /**
   * Returns the z-index for the backdrop.
   * @return {number}
   */
  backdropZ: function() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  },

  /**
   * Returns the top opened overlay that has a backdrop.
   * @return {!Element|undefined}
   * @private
   */
  _overlayWithBackdrop: function() {
    for (var i = this._overlays.length - 1; i >= 0; i--) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  },

  /**
   * Calculates the minimum z-index for the overlay.
   * @param {Element=} overlay
   * @private
   */
  _getZ: function(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(
          overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  },

  /**
   * @param {!Element} element
   * @param {number|string} z
   * @private
   */
  _setZ: function(element, z) {
    element.style.zIndex = z;
  },

  /**
   * @param {!Element} overlay
   * @param {number} aboveZ
   * @private
   */
  _applyOverlayZ: function(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  },

  /**
   * Returns the deepest overlay in the path.
   * @param {!Array<!Element>=} path
   * @return {!Element|undefined}
   * @suppress {missingProperties}
   * @private
   */
  _overlayInPath: function(path) {
    path = path || [];
    for (var i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  },

  /**
   * Ensures the click event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureClick: function(event) {
    var i = this._overlays.length - 1;
    if (i === -1)
      return;
    var path = /** @type {!Array<!EventTarget>} */ (dom(event).path);
    var overlay;
    // Check if clicked outside of overlay.
    while ((overlay = /** @type {?} */ (this._overlays[i])) &&
           this._overlayInPath(path) !== overlay) {
      overlay._onCaptureClick(event);
      if (overlay.allowClickThrough) {
        i--;
      } else {
        break;
      }
    }
  },

  /**
   * Ensures the focus event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureFocus: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  },

  /**
   * Ensures TAB and ESC keyboard events are delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureKeyDown: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      if (IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {
        overlay._onCaptureEsc(event);
      } else if (IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
        overlay._onCaptureTab(event);
      }
    }
  },

  /**
   * Returns if the overlay1 should be behind overlay2.
   * @param {!Element} overlay1
   * @param {!Element} overlay2
   * @return {boolean}
   * @suppress {missingProperties}
   * @private
   */
  _shouldBeBehindOverlay: function(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
};

const IronOverlayManager = new IronOverlayManagerClass();

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
/**
 * Used to calculate the scroll direction during touch events.
 * @type {!Object}
 */
var lastTouchPosition$1 = {pageX: 0, pageY: 0};
/**
 * Used to avoid computing event.path and filter scrollable nodes (better perf).
 * @type {?EventTarget}
 */
var lastRootTarget$1 = null;
/**
 * @type {!Array<!Node>}
 */
var lastScrollableNodes$1 = [];
/**
 * @type {!Array<string>}
 */
var scrollEvents$1 = [
  // Modern `wheel` event for mouse wheel scrolling:
  'wheel',
  // Older, non-standard `mousewheel` event for some FF:
  'mousewheel',
  // IE:
  'DOMMouseScroll',
  // Touch enabled devices
  'touchstart',
  'touchmove'
];
// must be defined for modulizer
var _boundScrollHandler$1;
var currentLockingElement$1;

/**
 * Push an element onto the current scroll lock stack. The most recently
 * pushed element and its children will be considered scrollable. All
 * other elements will not be scrollable.
 *
 * Scroll locking is implemented as a stack so that cases such as
 * dropdowns within dropdowns are handled well.
 *
 * @param {!HTMLElement} element The element that should lock scroll.
 */
function pushScrollLock$1(element) {
  // Prevent pushing the same element twice
  if (_lockingElements$1.indexOf(element) >= 0) {
    return;
  }

  if (_lockingElements$1.length === 0) {
    _lockScrollInteractions$1();
  }

  _lockingElements$1.push(element);
  currentLockingElement$1 = _lockingElements$1[_lockingElements$1.length - 1];
}

/**
 * Remove an element from the scroll lock stack. The element being
 * removed does not need to be the most recently pushed element. However,
 * the scroll lock constraints only change when the most recently pushed
 * element is removed.
 *
 * @param {!HTMLElement} element The element to remove from the scroll
 * lock stack.
 */
function removeScrollLock$1(element) {
  var index = _lockingElements$1.indexOf(element);

  if (index === -1) {
    return;
  }

  _lockingElements$1.splice(index, 1);
  currentLockingElement$1 = _lockingElements$1[_lockingElements$1.length - 1];

  if (_lockingElements$1.length === 0) {
    _unlockScrollInteractions$1();
  }
}

const _lockingElements$1 = [];

function _scrollInteractionHandler$1(event) {
  // Avoid canceling an event with cancelable=false, e.g. scrolling is in
  // progress and cannot be interrupted.
  if (event.cancelable && _shouldPreventScrolling$1(event)) {
    event.preventDefault();
  }
  // If event has targetTouches (touch event), update last touch position.
  if (event.targetTouches) {
    var touch = event.targetTouches[0];
    lastTouchPosition$1.pageX = touch.pageX;
    lastTouchPosition$1.pageY = touch.pageY;
  }
}

function _lockScrollInteractions$1() {
  _boundScrollHandler$1 =
      _boundScrollHandler$1 || _scrollInteractionHandler$1.bind(undefined);
  for (var i = 0, l = scrollEvents$1.length; i < l; i++) {
    // NOTE: browsers that don't support objects as third arg will
    // interpret it as boolean, hence useCapture = true in this case.
    document.addEventListener(
        scrollEvents$1[i], _boundScrollHandler$1, {capture: true, passive: false});
  }
}

function _unlockScrollInteractions$1() {
  for (var i = 0, l = scrollEvents$1.length; i < l; i++) {
    // NOTE: browsers that don't support objects as third arg will
    // interpret it as boolean, hence useCapture = true in this case.
    document.removeEventListener(
        scrollEvents$1[i], _boundScrollHandler$1, {capture: true, passive: false});
  }
}

/**
 * Returns true if the event causes scroll outside the current locking
 * element, e.g. pointer/keyboard interactions, or scroll "leaking"
 * outside the locking element when it is already at its scroll boundaries.
 * @param {!Event} event
 * @return {boolean}
 * @private
 */
function _shouldPreventScrolling$1(event) {
  // Update if root target changed. For touch events, ensure we don't
  // update during touchmove.
  var target = dom(event).rootTarget;
  if (event.type !== 'touchmove' && lastRootTarget$1 !== target) {
    lastRootTarget$1 = target;
    lastScrollableNodes$1 = _getScrollableNodes$1(dom(event).path);
  }

  // Prevent event if no scrollable nodes.
  if (!lastScrollableNodes$1.length) {
    return true;
  }
  // Don't prevent touchstart event inside the locking element when it has
  // scrollable nodes.
  if (event.type === 'touchstart') {
    return false;
  }
  // Get deltaX/Y.
  var info = _getScrollInfo$1(event);
  // Prevent if there is no child that can scroll.
  return !_getScrollingNode$1(lastScrollableNodes$1, info.deltaX, info.deltaY);
}

/**
 * Returns an array of scrollable nodes up to the current locking element,
 * which is included too if scrollable.
 * @param {!Array<!Node>} nodes
 * @return {!Array<!Node>} scrollables
 * @private
 */
function _getScrollableNodes$1(nodes) {
  var scrollables = [];
  var lockingIndex = nodes.indexOf(currentLockingElement$1);
  // Loop from root target to locking element (included).
  for (var i = 0; i <= lockingIndex; i++) {
    // Skip non-Element nodes.
    if (nodes[i].nodeType !== Node.ELEMENT_NODE) {
      continue;
    }
    var node = /** @type {!Element} */ (nodes[i]);
    // Check inline style before checking computed style.
    var style = node.style;
    if (style.overflow !== 'scroll' && style.overflow !== 'auto') {
      style = window.getComputedStyle(node);
    }
    if (style.overflow === 'scroll' || style.overflow === 'auto') {
      scrollables.push(node);
    }
  }
  return scrollables;
}

/**
 * Returns the node that is scrolling. If there is no scrolling,
 * returns undefined.
 * @param {!Array<!Node>} nodes
 * @param {number} deltaX Scroll delta on the x-axis
 * @param {number} deltaY Scroll delta on the y-axis
 * @return {!Node|undefined}
 * @private
 */
function _getScrollingNode$1(nodes, deltaX, deltaY) {
  // No scroll.
  if (!deltaX && !deltaY) {
    return;
  }
  // Check only one axis according to where there is more scroll.
  // Prefer vertical to horizontal.
  var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var canScroll = false;
    if (verticalScroll) {
      // delta < 0 is scroll up, delta > 0 is scroll down.
      canScroll = deltaY < 0 ?
          node.scrollTop > 0 :
          node.scrollTop < node.scrollHeight - node.clientHeight;
    } else {
      // delta < 0 is scroll left, delta > 0 is scroll right.
      canScroll = deltaX < 0 ?
          node.scrollLeft > 0 :
          node.scrollLeft < node.scrollWidth - node.clientWidth;
    }
    if (canScroll) {
      return node;
    }
  }
}

/**
 * Returns scroll `deltaX` and `deltaY`.
 * @param {!Event} event The scroll event
 * @return {{deltaX: number, deltaY: number}} Object containing the
 * x-axis scroll delta (positive: scroll right, negative: scroll left,
 * 0: no scroll), and the y-axis scroll delta (positive: scroll down,
 * negative: scroll up, 0: no scroll).
 * @private
 */
function _getScrollInfo$1(event) {
  var info = {deltaX: event.deltaX, deltaY: event.deltaY};
  // Already available.
  if ('deltaX' in event) ;
  // Safari has scroll info in `wheelDeltaX/Y`.
  else if ('wheelDeltaX' in event && 'wheelDeltaY' in event) {
    info.deltaX = -event.wheelDeltaX;
    info.deltaY = -event.wheelDeltaY;
  }
  // IE10 has only vertical scroll info in `wheelDelta`.
  else if ('wheelDelta' in event) {
    info.deltaX = 0;
    info.deltaY = -event.wheelDelta;
  }
  // Firefox has scroll info in `detail` and `axis`.
  else if ('axis' in event) {
    info.deltaX = event.axis === 1 ? event.detail : 0;
    info.deltaY = event.axis === 2 ? event.detail : 0;
  }
  // On mobile devices, calculate scroll direction.
  else if (event.targetTouches) {
    var touch = event.targetTouches[0];
    // Touch moves from right to left => scrolling goes right.
    info.deltaX = lastTouchPosition$1.pageX - touch.pageX;
    // Touch moves from down to up => scrolling goes down.
    info.deltaY = lastTouchPosition$1.pageY - touch.pageY;
  }
  return info;
}

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/** @polymerBehavior */
const IronOverlayBehaviorImpl = {

  properties: {

    /**
     * True if the overlay is currently displayed.
     */
    opened:
        {observer: '_openedChanged', type: Boolean, value: false, notify: true},

    /**
     * True if the overlay was canceled when it was last closed.
     */
    canceled: {
      observer: '_canceledChanged',
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Set to true to display a backdrop behind the overlay. It traps the focus
     * within the light DOM of the overlay.
     */
    withBackdrop: {
      observer: '_withBackdropChanged',
      type: Boolean,
    },

    /**
     * Set to true to disable auto-focusing the overlay or child nodes with
     * the `autofocus` attribute` when the overlay is opened.
     */
    noAutoFocus: {
      type: Boolean,
      value: false,
    },

    /**
     * Set to true to disable canceling the overlay with the ESC key.
     */
    noCancelOnEscKey: {
      type: Boolean,
      value: false,
    },

    /**
     * Set to true to disable canceling the overlay by clicking outside it.
     */
    noCancelOnOutsideClick: {
      type: Boolean,
      value: false,
    },

    /**
     * Contains the reason(s) this overlay was last closed (see
     * `iron-overlay-closed`). `IronOverlayBehavior` provides the `canceled`
     * reason; implementers of the behavior can provide other reasons in
     * addition to `canceled`.
     */
    closingReason: {
      // was a getter before, but needs to be a property so other
      // behaviors can override this.
      type: Object,
    },

    /**
     * Set to true to enable restoring of focus when overlay is closed.
     */
    restoreFocusOnClose: {
      type: Boolean,
      value: false,
    },

    /**
     * Set to true to allow clicks to go through overlays.
     * When the user clicks outside this overlay, the click may
     * close the overlay below.
     */
    allowClickThrough: {
      type: Boolean,
    },

    /**
     * Set to true to keep overlay always on top.
     */
    alwaysOnTop: {
      type: Boolean,
    },

    /**
     * Determines which action to perform when scroll outside an opened overlay
     * happens. Possible values: lock - blocks scrolling from happening, refit -
     * computes the new position on the overlay cancel - causes the overlay to
     * close
     */
    scrollAction: {
      type: String,
    },

    /**
     * Shortcut to access to the overlay manager.
     * @private
     * @type {!IronOverlayManagerClass}
     */
    _manager: {
      type: Object,
      value: IronOverlayManager,
    },

    /**
     * The node being focused.
     * @type {?Node}
     */
    _focusedChild: {
      type: Object,
    }

  },

  listeners: {'iron-resize': '_onIronResize'},

  observers: ['__updateScrollObservers(isAttached, opened, scrollAction)'],

  /**
   * The backdrop element.
   * @return {!Element}
   */
  get backdropElement() {
    return this._manager.backdropElement;
  },

  /**
   * Returns the node to give focus to.
   * @return {!Node}
   */
  get _focusNode() {
    return this._focusedChild || dom(this).querySelector('[autofocus]') || this;
  },

  /**
   * Array of nodes that can receive focus (overlay included), ordered by
   * `tabindex`. This is used to retrieve which is the first and last focusable
   * nodes in order to wrap the focus for overlays `with-backdrop`.
   *
   * If you know what is your content (specifically the first and last focusable
   * children), you can override this method to return only `[firstFocusable,
   * lastFocusable];`
   * @return {!Array<!Node>}
   * @protected
   */
  get _focusableNodes() {
    return IronFocusablesHelper.getTabbableNodes(this);
  },

  /**
   * @return {void}
   */
  ready: function() {
    // Used to skip calls to notifyResize and refit while the overlay is
    // animating.
    this.__isAnimating = false;
    // with-backdrop needs tabindex to be set in order to trap the focus.
    // If it is not set, IronOverlayBehavior will set it, and remove it if
    // with-backdrop = false.
    this.__shouldRemoveTabIndex = false;
    // Used for wrapping the focus on TAB / Shift+TAB.
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    // Used by to keep track of the RAF callbacks.
    this.__rafs = {};
    // Focused node before overlay gets opened. Can be restored on close.
    this.__restoreFocusNode = null;
    // Scroll info to be restored.
    this.__scrollTop = this.__scrollLeft = null;
    this.__onCaptureScroll = this.__onCaptureScroll.bind(this);
    // Root nodes hosting the overlay, used to listen for scroll events on them.
    this.__rootNodes = null;
    this._ensureSetup();
  },

  attached: function() {
    // Call _openedChanged here so that position can be computed correctly.
    if (this.opened) {
      this._openedChanged(this.opened);
    }
    this._observer = dom(this).observeNodes(this._onNodesChange);
  },

  detached: function() {
    dom(this).unobserveNodes(this._observer);
    this._observer = null;
    for (var cb in this.__rafs) {
      if (this.__rafs[cb] !== null) {
        cancelAnimationFrame(this.__rafs[cb]);
      }
    }
    this.__rafs = {};
    this._manager.removeOverlay(this);

    // We got detached while animating, ensure we show/hide the overlay
    // and fire iron-overlay-opened/closed event!
    if (this.__isAnimating) {
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        // Restore the focus if necessary.
        this._applyFocus();
        this._finishRenderClosed();
      }
    }
  },

  /**
   * Toggle the opened state of the overlay.
   */
  toggle: function() {
    this._setCanceled(false);
    this.opened = !this.opened;
  },

  /**
   * Open the overlay.
   */
  open: function() {
    this._setCanceled(false);
    this.opened = true;
  },

  /**
   * Close the overlay.
   */
  close: function() {
    this._setCanceled(false);
    this.opened = false;
  },

  /**
   * Cancels the overlay.
   * @param {Event=} event The original event
   */
  cancel: function(event) {
    var cancelEvent =
        this.fire('iron-overlay-canceled', event, {cancelable: true});
    if (cancelEvent.defaultPrevented) {
      return;
    }

    this._setCanceled(true);
    this.opened = false;
  },

  /**
   * Invalidates the cached tabbable nodes. To be called when any of the
   * focusable content changes (e.g. a button is disabled).
   */
  invalidateTabbables: function() {
    this.__firstFocusableNode = this.__lastFocusableNode = null;
  },

  _ensureSetup: function() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = 'none';
    this.style.display = 'none';
  },

  /**
   * Called when `opened` changes.
   * @param {boolean=} opened
   * @protected
   */
  _openedChanged: function(opened) {
    if (opened) {
      this.removeAttribute('aria-hidden');
    } else {
      this.setAttribute('aria-hidden', 'true');
    }

    // Defer any animation-related code on attached
    // (_openedChanged gets called again on attached).
    if (!this.isAttached) {
      return;
    }

    this.__isAnimating = true;

    // Deraf for non-blocking rendering.
    this.__deraf('__openedChanged', this.__openedChanged);
  },

  _canceledChanged: function() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  },

  _withBackdropChanged: function() {
    // If tabindex is already set, no need to override it.
    if (this.withBackdrop && !this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '-1');
      this.__shouldRemoveTabIndex = true;
    } else if (this.__shouldRemoveTabIndex) {
      this.removeAttribute('tabindex');
      this.__shouldRemoveTabIndex = false;
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  },

  /**
   * tasks which must occur before opening; e.g. making the element visible.
   * @protected
   */
  _prepareRenderOpened: function() {
    // Store focused node.
    this.__restoreFocusNode = this._manager.deepActiveElement;

    // Needed to calculate the size of the overlay so that transitions on its
    // size will have the correct starting points.
    this._preparePositioning();
    this.refit();
    this._finishPositioning();

    // Safari will apply the focus to the autofocus element when displayed
    // for the first time, so we make sure to return the focus where it was.
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
      this.__restoreFocusNode.focus();
    }
  },

  /**
   * Tasks which cause the overlay to actually open; typically play an
   * animation.
   * @protected
   */
  _renderOpened: function() {
    this._finishRenderOpened();
  },

  /**
   * Tasks which cause the overlay to actually close; typically play an
   * animation.
   * @protected
   */
  _renderClosed: function() {
    this._finishRenderClosed();
  },

  /**
   * Tasks to be performed at the end of open action. Will fire
   * `iron-overlay-opened`.
   * @protected
   */
  _finishRenderOpened: function() {
    this.notifyResize();
    this.__isAnimating = false;

    this.fire('iron-overlay-opened');
  },

  /**
   * Tasks to be performed at the end of close action. Will fire
   * `iron-overlay-closed`.
   * @protected
   */
  _finishRenderClosed: function() {
    // Hide the overlay.
    this.style.display = 'none';
    // Reset z-index only at the end of the animation.
    this.style.zIndex = '';
    this.notifyResize();
    this.__isAnimating = false;
    this.fire('iron-overlay-closed', this.closingReason);
  },

  _preparePositioning: function() {
    this.style.transition = this.style.webkitTransition = 'none';
    this.style.transform = this.style.webkitTransform = 'none';
    this.style.display = '';
  },

  _finishPositioning: function() {
    // First, make it invisible & reactivate animations.
    this.style.display = 'none';
    // Force reflow before re-enabling animations so that they don't start.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = '';
    this.style.transform = this.style.webkitTransform = '';
    // Now that animations are enabled, make it visible again
    this.style.display = '';
    // Force reflow, so that following animations are properly started.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
  },

  /**
   * Applies focus according to the opened state.
   * @protected
   */
  _applyFocus: function() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    } else {
      // Restore focus.
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        // If the activeElement is `<body>` or inside the overlay,
        // we are allowed to restore the focus. In all the other
        // cases focus might have been moved elsewhere by another
        // component or by an user interaction (e.g. click on a
        // button outside the overlay).
        var activeElement = this._manager.deepActiveElement;
        if (activeElement === document.body ||
            dom(this).deepContains(activeElement)) {
          this.__restoreFocusNode.focus();
        }
      }
      this.__restoreFocusNode = null;
      this._focusNode.blur();
      this._focusedChild = null;
    }
  },

  /**
   * Cancels (closes) the overlay. Call when click happens outside the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureClick: function(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  },

  /**
   * Keeps track of the focused child. If withBackdrop, traps focus within
   * overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureFocus: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    var path = dom(event).path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild = path[0];
    }
  },

  /**
   * Handles the ESC key event and cancels (closes) the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureEsc: function(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  },

  /**
   * Handles TAB key events to track focus changes.
   * Will wrap focus for overlays withBackdrop.
   * @param {!Event} event
   * @protected
   */
  _onCaptureTab: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    this.__ensureFirstLastFocusables();
    // TAB wraps from last to first focusable.
    // Shift + TAB wraps from first to last focusable.
    var shift = event.shiftKey;
    var nodeToCheck =
        shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    var nodeToSet =
        shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    var shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      // If nodeToCheck is the same as nodeToSet, it means we have an overlay
      // with 0 or 1 focusables; in either case we still need to trap the
      // focus within the overlay.
      shouldWrap = true;
    } else {
      // In dom=shadow, the manager will receive focus changes on the main
      // root but not the ones within other shadow roots, so we can't rely on
      // _focusedChild, but we should check the deepest active element.
      var focusedNode = this._manager.deepActiveElement;
      // If the active element is not the nodeToCheck but the overlay itself,
      // it means the focus is about to go outside the overlay, hence we
      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).
      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);
    }

    if (shouldWrap) {
      // When the overlay contains the last focusable element of the document
      // and it's already focused, pressing TAB would move the focus outside
      // the document (e.g. to the browser search bar). Similarly, when the
      // overlay contains the first focusable element of the document and it's
      // already focused, pressing Shift+TAB would move the focus outside the
      // document (e.g. to the browser search bar).
      // In both cases, we would not receive a focus event, but only a blur.
      // In order to achieve focus wrapping, we prevent this TAB event and
      // force the focus. This will also prevent the focus to temporarily move
      // outside the overlay, which might cause scrolling.
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  },

  /**
   * Refits if the overlay is opened and not animating.
   * @protected
   */
  _onIronResize: function() {
    if (this.opened && !this.__isAnimating) {
      this.__deraf('refit', this.refit);
    }
  },

  /**
   * Will call notifyResize if overlay is opened.
   * Can be overridden in order to avoid multiple observers on the same node.
   * @protected
   */
  _onNodesChange: function() {
    if (this.opened && !this.__isAnimating) {
      // It might have added focusable nodes, so invalidate cached values.
      this.invalidateTabbables();
      this.notifyResize();
    }
  },

  /**
   * Updates the references to the first and last focusable nodes.
   * @private
   */
  __ensureFirstLastFocusables: function() {
    var focusableNodes = this._focusableNodes;
    this.__firstFocusableNode = focusableNodes[0];
    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
  },

  /**
   * Tasks executed when opened changes: prepare for the opening, move the
   * focus, update the manager, render opened/closed.
   * @private
   */
  __openedChanged: function() {
    if (this.opened) {
      // Make overlay visible, then add it to the manager.
      this._prepareRenderOpened();
      this._manager.addOverlay(this);
      // Move the focus to the child node with [autofocus].
      this._applyFocus();

      this._renderOpened();
    } else {
      // Remove overlay, then restore the focus before actually closing.
      this._manager.removeOverlay(this);
      this._applyFocus();

      this._renderClosed();
    }
  },

  /**
   * Debounces the execution of a callback to the next animation frame.
   * @param {!string} jobname
   * @param {!Function} callback Always bound to `this`
   * @private
   */
  __deraf: function(jobname, callback) {
    var rafs = this.__rafs;
    if (rafs[jobname] !== null) {
      cancelAnimationFrame(rafs[jobname]);
    }
    rafs[jobname] = requestAnimationFrame(function nextAnimationFrame() {
      rafs[jobname] = null;
      callback.call(this);
    }.bind(this));
  },

  /**
   * @param {boolean} isAttached
   * @param {boolean} opened
   * @param {string=} scrollAction
   * @private
   */
  __updateScrollObservers: function(isAttached, opened, scrollAction) {
    if (!isAttached || !opened || !this.__isValidScrollAction(scrollAction)) {
      removeScrollLock$1(this);
      this.__removeScrollListeners();
    } else {
      if (scrollAction === 'lock') {
        this.__saveScrollPosition();
        pushScrollLock$1(this);
      }
      this.__addScrollListeners();
    }
  },

  /**
   * @private
   */
  __addScrollListeners: function() {
    if (!this.__rootNodes) {
      this.__rootNodes = [];
      // Listen for scroll events in all shadowRoots hosting this overlay only
      // when in native ShadowDOM.
      if (useShadow) {
        var node = this;
        while (node) {
          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {
            this.__rootNodes.push(node);
          }
          node = node.host || node.assignedSlot || node.parentNode;
        }
      }
      this.__rootNodes.push(document);
    }
    this.__rootNodes.forEach(function(el) {
      el.addEventListener('scroll', this.__onCaptureScroll, {
        capture: true,
        passive: true,
      });
    }, this);
  },

  /**
   * @private
   */
  __removeScrollListeners: function() {
    if (this.__rootNodes) {
      this.__rootNodes.forEach(function(el) {
        el.removeEventListener('scroll', this.__onCaptureScroll, {
          capture: true,
          passive: true,
        });
      }, this);
    }
    if (!this.isAttached) {
      this.__rootNodes = null;
    }
  },

  /**
   * @param {string=} scrollAction
   * @return {boolean}
   * @private
   */
  __isValidScrollAction: function(scrollAction) {
    return scrollAction === 'lock' || scrollAction === 'refit' ||
        scrollAction === 'cancel';
  },

  /**
   * @private
   */
  __onCaptureScroll: function(event) {
    if (this.__isAnimating) {
      return;
    }
    // Check if scroll outside the overlay.
    if (dom(event).path.indexOf(this) >= 0) {
      return;
    }
    switch (this.scrollAction) {
      case 'lock':
        // NOTE: scrolling might happen if a scroll event is not cancellable, or
        // if user pressed keys that cause scrolling (they're not prevented in
        // order not to break a11y features like navigate with arrow keys).
        this.__restoreScrollPosition();
        break;
      case 'refit':
        this.__deraf('refit', this.refit);
        break;
      case 'cancel':
        this.cancel(event);
        break;
    }
  },

  /**
   * Memoizes the scroll position of the outside scrolling element.
   * @private
   */
  __saveScrollPosition: function() {
    if (document.scrollingElement) {
      this.__scrollTop = document.scrollingElement.scrollTop;
      this.__scrollLeft = document.scrollingElement.scrollLeft;
    } else {
      // Since we don't know if is the body or html, get max.
      this.__scrollTop =
          Math.max(document.documentElement.scrollTop, document.body.scrollTop);
      this.__scrollLeft = Math.max(
          document.documentElement.scrollLeft, document.body.scrollLeft);
    }
  },

  /**
   * Resets the scroll position of the outside scrolling element.
   * @private
   */
  __restoreScrollPosition: function() {
    if (document.scrollingElement) {
      document.scrollingElement.scrollTop = this.__scrollTop;
      document.scrollingElement.scrollLeft = this.__scrollLeft;
    } else {
      // Since we don't know if is the body or html, set both.
      document.documentElement.scrollTop = document.body.scrollTop =
          this.__scrollTop;
      document.documentElement.scrollLeft = document.body.scrollLeft =
          this.__scrollLeft;
    }
  },

};

/**
  Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden
  or shown, and displays on top of other content. It includes an optional
  backdrop, and can be used to implement a variety of UI controls including
  dialogs and drop downs. Multiple overlays may be displayed at once.

  See the [demo source
  code](https://github.com/PolymerElements/iron-overlay-behavior/blob/master/demo/simple-overlay.html)
  for an example.

  ### Closing and canceling

  An overlay may be hidden by closing or canceling. The difference between close
  and cancel is user intent. Closing generally implies that the user
  acknowledged the content on the overlay. By default, it will cancel whenever
  the user taps outside it or presses the escape key. This behavior is
  configurable with the `no-cancel-on-esc-key` and the
  `no-cancel-on-outside-click` properties. `close()` should be called explicitly
  by the implementer when the user interacts with a control in the overlay
  element. When the dialog is canceled, the overlay fires an
  'iron-overlay-canceled' event. Call `preventDefault` on this event to prevent
  the overlay from closing.

  ### Positioning

  By default the element is sized and positioned to fit and centered inside the
  window. You can position and size it manually using CSS. See
  `Polymer.IronFitBehavior`.

  ### Backdrop

  Set the `with-backdrop` attribute to display a backdrop behind the overlay.
  The backdrop is appended to `<body>` and is of type `<iron-overlay-backdrop>`.
  See its doc page for styling options.

  In addition, `with-backdrop` will wrap the focus within the content in the
  light DOM. Override the [`_focusableNodes`
  getter](#Polymer.IronOverlayBehavior:property-_focusableNodes) to achieve a
  different behavior.

  ### Limitations

  The element is styled to appear on top of other content by setting its
  `z-index` property. You must ensure no element has a stacking context with a
  higher `z-index` than its parent stacking context. You should place this
  element as a child of `<body>` whenever possible.

  @demo demo/index.html
  @polymerBehavior
 */
const IronOverlayBehavior =
    [IronFitBehavior, IronResizableBehavior, IronOverlayBehaviorImpl];

/**
 * Fired after the overlay opens.
 * @event iron-overlay-opened
 */

/**
 * Fired when the overlay is canceled, but before it is closed.
 * @event iron-overlay-canceled
 * @param {Event} event The closing of the overlay can be prevented
 * by calling `event.preventDefault()`. The `event.detail` is the original event
 * that originated the canceling (e.g. ESC keyboard event or click event outside
 * the overlay).
 */

/**
 * Fired after the overlay closes.
 * @event iron-overlay-closed
 * @param {Event} event The `event.detail` is the `closingReason` property
 * (contains `canceled`, whether the overlay was canceled).
 */

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

// Keeps track of the toast currently opened.
var currentToast = null;

/**
Material design: [Snackbars &
toasts](https://www.google.com/design/spec/components/snackbars-toasts.html)

`paper-toast` provides a subtle notification toast. Only one `paper-toast` will
be visible on screen.

Use `opened` to show the toast:

Example:

    <paper-toast text="Hello world!" opened></paper-toast>

Also `open()` or `show()` can be used to show the toast:

Example:

    <paper-button on-click="openToast">Open Toast</paper-button>
    <paper-toast id="toast" text="Hello world!"></paper-toast>

    ...

    openToast: function() {
      this.$.toast.open();
    }

Set `duration` to 0, a negative number or Infinity to persist the toast on
screen:

Example:

    <paper-toast text="Terms and conditions" opened duration="0">
      <a href="#">Show more</a>
    </paper-toast>


### Styling
The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-toast-background-color` | The paper-toast background-color | `#323232`
`--paper-toast-color` | The paper-toast color | `#f1f1f1`

This element applies the mixin `--paper-font-common-base` but does not import
`paper-styles/typography.html`. In order to apply the `Roboto` font to this
element, make sure you've imported `paper-styles/typography.html`.

@group Paper Elements
@element paper-toast
@demo demo/index.html
@hero hero.svg
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        display: block;
        position: fixed;
        background-color: var(--paper-toast-background-color, #323232);
        color: var(--paper-toast-color, #f1f1f1);
        min-height: 48px;
        min-width: 288px;
        padding: 16px 24px;
        box-sizing: border-box;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
        border-radius: 2px;
        margin: 12px;
        font-size: 14px;
        cursor: default;
        -webkit-transition: -webkit-transform 0.3s, opacity 0.3s;
        transition: transform 0.3s, opacity 0.3s;
        opacity: 0;
        -webkit-transform: translateY(100px);
        transform: translateY(100px);
        @apply --paper-font-common-base;
      }

      :host(.capsule) {
        border-radius: 24px;
      }

      :host(.fit-bottom) {
        width: 100%;
        min-width: 0;
        border-radius: 0;
        margin: 0;
      }

      :host(.paper-toast-open) {
        opacity: 1;
        -webkit-transform: translateY(0px);
        transform: translateY(0px);
      }
    </style>

    <span id="label">{{text}}</span>
    <slot></slot>
`,

  is: 'paper-toast',
  behaviors: [IronOverlayBehavior],

  properties: {
    /**
     * The element to fit `this` into.
     * Overridden from `Polymer.IronFitBehavior`.
     */
    fitInto: {type: Object, value: window, observer: '_onFitIntoChanged'},

    /**
     * The orientation against which to align the dropdown content
     * horizontally relative to `positionTarget`.
     * Overridden from `Polymer.IronFitBehavior`.
     */
    horizontalAlign: {type: String, value: 'left'},

    /**
     * The orientation against which to align the dropdown content
     * vertically relative to `positionTarget`.
     * Overridden from `Polymer.IronFitBehavior`.
     */
    verticalAlign: {type: String, value: 'bottom'},

    /**
     * The duration in milliseconds to show the toast.
     * Set to `0`, a negative number, or `Infinity`, to disable the
     * toast auto-closing.
     */
    duration: {type: Number, value: 3000},

    /**
     * The text to display in the toast.
     */
    text: {type: String, value: ''},

    /**
     * Overridden from `IronOverlayBehavior`.
     * Set to false to enable closing of the toast by clicking outside it.
     */
    noCancelOnOutsideClick: {type: Boolean, value: true},

    /**
     * Overridden from `IronOverlayBehavior`.
     * Set to true to disable auto-focusing the toast or child nodes with
     * the `autofocus` attribute` when the overlay is opened.
     */
    noAutoFocus: {type: Boolean, value: true}
  },

  listeners: {'transitionend': '__onTransitionEnd'},

  /**
   * Read-only. Deprecated. Use `opened` from `IronOverlayBehavior`.
   * @property visible
   * @deprecated
   */
  get visible() {
    Base._warn('`visible` is deprecated, use `opened` instead');
    return this.opened;
  },

  /**
   * Read-only. Can auto-close if duration is a positive finite number.
   * @property _canAutoClose
   */
  get _canAutoClose() {
    return this.duration > 0 && this.duration !== Infinity;
  },

  created: function() {
    this._autoClose = null;
    IronA11yAnnouncer.requestAvailability();
  },

  /**
   * Show the toast. Without arguments, this is the same as `open()` from
   * `IronOverlayBehavior`.
   * @param {(Object|string)=} properties Properties to be set before opening the toast.
   * e.g. `toast.show('hello')` or `toast.show({text: 'hello', duration: 3000})`
   */
  show: function(properties) {
    if (typeof properties == 'string') {
      properties = {text: properties};
    }
    for (var property in properties) {
      if (property.indexOf('_') === 0) {
        Base._warn(
            'The property "' + property + '" is private and was not set.');
      } else if (property in this) {
        this[property] = properties[property];
      } else {
        Base._warn('The property "' + property + '" is not valid.');
      }
    }
    this.open();
  },

  /**
   * Hide the toast. Same as `close()` from `IronOverlayBehavior`.
   */
  hide: function() {
    this.close();
  },

  /**
   * Called on transitions of the toast, indicating a finished animation
   * @private
   */
  __onTransitionEnd: function(e) {
    // there are different transitions that are happening when opening and
    // closing the toast. The last one so far is for `opacity`.
    // This marks the end of the transition, so we check for this to determine
    // if this is the correct event.
    if (e && e.target === this && e.propertyName === 'opacity') {
      if (this.opened) {
        this._finishRenderOpened();
      } else {
        this._finishRenderClosed();
      }
    }
  },

  /**
   * Overridden from `IronOverlayBehavior`.
   * Called when the value of `opened` changes.
   */
  _openedChanged: function() {
    if (this._autoClose !== null) {
      this.cancelAsync(this._autoClose);
      this._autoClose = null;
    }
    if (this.opened) {
      if (currentToast && currentToast !== this) {
        currentToast.close();
      }
      currentToast = this;
      this.fire('iron-announce', {text: this.text});
      if (this._canAutoClose) {
        this._autoClose = this.async(this.close, this.duration);
      }
    } else if (currentToast === this) {
      currentToast = null;
    }
    IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
  },

  /**
   * Overridden from `IronOverlayBehavior`.
   */
  _renderOpened: function() {
    this.classList.add('paper-toast-open');
  },

  /**
   * Overridden from `IronOverlayBehavior`.
   */
  _renderClosed: function() {
    this.classList.remove('paper-toast-open');
  },

  /**
   * @private
   */
  _onFitIntoChanged: function(fitInto) {
    this.positionTarget = fitInto;
  }

  /**
   * Fired when `paper-toast` is opened.
   *
   * @event 'iron-announce'
   * @param {{text: string}} detail Contains text that will be announced.
   */
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const template$2 = html$1`
<custom-style>
  <style is="custom-style">
    html {

      /* Material Design color palette for Google products */

      --google-red-100: #f4c7c3;
      --google-red-300: #e67c73;
      --google-red-500: #db4437;
      --google-red-700: #c53929;

      --google-blue-100: #c6dafc;
      --google-blue-300: #7baaf7;
      --google-blue-500: #4285f4;
      --google-blue-700: #3367d6;

      --google-green-100: #b7e1cd;
      --google-green-300: #57bb8a;
      --google-green-500: #0f9d58;
      --google-green-700: #0b8043;

      --google-yellow-100: #fce8b2;
      --google-yellow-300: #f7cb4d;
      --google-yellow-500: #f4b400;
      --google-yellow-700: #f09300;

      --google-grey-100: #f5f5f5;
      --google-grey-300: #e0e0e0;
      --google-grey-500: #9e9e9e;
      --google-grey-700: #616161;

      /* Material Design color palette from online spec document */

      --paper-red-50: #ffebee;
      --paper-red-100: #ffcdd2;
      --paper-red-200: #ef9a9a;
      --paper-red-300: #e57373;
      --paper-red-400: #ef5350;
      --paper-red-500: #f44336;
      --paper-red-600: #e53935;
      --paper-red-700: #d32f2f;
      --paper-red-800: #c62828;
      --paper-red-900: #b71c1c;
      --paper-red-a100: #ff8a80;
      --paper-red-a200: #ff5252;
      --paper-red-a400: #ff1744;
      --paper-red-a700: #d50000;

      --paper-pink-50: #fce4ec;
      --paper-pink-100: #f8bbd0;
      --paper-pink-200: #f48fb1;
      --paper-pink-300: #f06292;
      --paper-pink-400: #ec407a;
      --paper-pink-500: #e91e63;
      --paper-pink-600: #d81b60;
      --paper-pink-700: #c2185b;
      --paper-pink-800: #ad1457;
      --paper-pink-900: #880e4f;
      --paper-pink-a100: #ff80ab;
      --paper-pink-a200: #ff4081;
      --paper-pink-a400: #f50057;
      --paper-pink-a700: #c51162;

      --paper-purple-50: #f3e5f5;
      --paper-purple-100: #e1bee7;
      --paper-purple-200: #ce93d8;
      --paper-purple-300: #ba68c8;
      --paper-purple-400: #ab47bc;
      --paper-purple-500: #9c27b0;
      --paper-purple-600: #8e24aa;
      --paper-purple-700: #7b1fa2;
      --paper-purple-800: #6a1b9a;
      --paper-purple-900: #4a148c;
      --paper-purple-a100: #ea80fc;
      --paper-purple-a200: #e040fb;
      --paper-purple-a400: #d500f9;
      --paper-purple-a700: #aa00ff;

      --paper-deep-purple-50: #ede7f6;
      --paper-deep-purple-100: #d1c4e9;
      --paper-deep-purple-200: #b39ddb;
      --paper-deep-purple-300: #9575cd;
      --paper-deep-purple-400: #7e57c2;
      --paper-deep-purple-500: #673ab7;
      --paper-deep-purple-600: #5e35b1;
      --paper-deep-purple-700: #512da8;
      --paper-deep-purple-800: #4527a0;
      --paper-deep-purple-900: #311b92;
      --paper-deep-purple-a100: #b388ff;
      --paper-deep-purple-a200: #7c4dff;
      --paper-deep-purple-a400: #651fff;
      --paper-deep-purple-a700: #6200ea;

      --paper-indigo-50: #e8eaf6;
      --paper-indigo-100: #c5cae9;
      --paper-indigo-200: #9fa8da;
      --paper-indigo-300: #7986cb;
      --paper-indigo-400: #5c6bc0;
      --paper-indigo-500: #3f51b5;
      --paper-indigo-600: #3949ab;
      --paper-indigo-700: #303f9f;
      --paper-indigo-800: #283593;
      --paper-indigo-900: #1a237e;
      --paper-indigo-a100: #8c9eff;
      --paper-indigo-a200: #536dfe;
      --paper-indigo-a400: #3d5afe;
      --paper-indigo-a700: #304ffe;

      --paper-blue-50: #e3f2fd;
      --paper-blue-100: #bbdefb;
      --paper-blue-200: #90caf9;
      --paper-blue-300: #64b5f6;
      --paper-blue-400: #42a5f5;
      --paper-blue-500: #2196f3;
      --paper-blue-600: #1e88e5;
      --paper-blue-700: #1976d2;
      --paper-blue-800: #1565c0;
      --paper-blue-900: #0d47a1;
      --paper-blue-a100: #82b1ff;
      --paper-blue-a200: #448aff;
      --paper-blue-a400: #2979ff;
      --paper-blue-a700: #2962ff;

      --paper-light-blue-50: #e1f5fe;
      --paper-light-blue-100: #b3e5fc;
      --paper-light-blue-200: #81d4fa;
      --paper-light-blue-300: #4fc3f7;
      --paper-light-blue-400: #29b6f6;
      --paper-light-blue-500: #03a9f4;
      --paper-light-blue-600: #039be5;
      --paper-light-blue-700: #0288d1;
      --paper-light-blue-800: #0277bd;
      --paper-light-blue-900: #01579b;
      --paper-light-blue-a100: #80d8ff;
      --paper-light-blue-a200: #40c4ff;
      --paper-light-blue-a400: #00b0ff;
      --paper-light-blue-a700: #0091ea;

      --paper-cyan-50: #e0f7fa;
      --paper-cyan-100: #b2ebf2;
      --paper-cyan-200: #80deea;
      --paper-cyan-300: #4dd0e1;
      --paper-cyan-400: #26c6da;
      --paper-cyan-500: #00bcd4;
      --paper-cyan-600: #00acc1;
      --paper-cyan-700: #0097a7;
      --paper-cyan-800: #00838f;
      --paper-cyan-900: #006064;
      --paper-cyan-a100: #84ffff;
      --paper-cyan-a200: #18ffff;
      --paper-cyan-a400: #00e5ff;
      --paper-cyan-a700: #00b8d4;

      --paper-teal-50: #e0f2f1;
      --paper-teal-100: #b2dfdb;
      --paper-teal-200: #80cbc4;
      --paper-teal-300: #4db6ac;
      --paper-teal-400: #26a69a;
      --paper-teal-500: #009688;
      --paper-teal-600: #00897b;
      --paper-teal-700: #00796b;
      --paper-teal-800: #00695c;
      --paper-teal-900: #004d40;
      --paper-teal-a100: #a7ffeb;
      --paper-teal-a200: #64ffda;
      --paper-teal-a400: #1de9b6;
      --paper-teal-a700: #00bfa5;

      --paper-green-50: #e8f5e9;
      --paper-green-100: #c8e6c9;
      --paper-green-200: #a5d6a7;
      --paper-green-300: #81c784;
      --paper-green-400: #66bb6a;
      --paper-green-500: #4caf50;
      --paper-green-600: #43a047;
      --paper-green-700: #388e3c;
      --paper-green-800: #2e7d32;
      --paper-green-900: #1b5e20;
      --paper-green-a100: #b9f6ca;
      --paper-green-a200: #69f0ae;
      --paper-green-a400: #00e676;
      --paper-green-a700: #00c853;

      --paper-light-green-50: #f1f8e9;
      --paper-light-green-100: #dcedc8;
      --paper-light-green-200: #c5e1a5;
      --paper-light-green-300: #aed581;
      --paper-light-green-400: #9ccc65;
      --paper-light-green-500: #8bc34a;
      --paper-light-green-600: #7cb342;
      --paper-light-green-700: #689f38;
      --paper-light-green-800: #558b2f;
      --paper-light-green-900: #33691e;
      --paper-light-green-a100: #ccff90;
      --paper-light-green-a200: #b2ff59;
      --paper-light-green-a400: #76ff03;
      --paper-light-green-a700: #64dd17;

      --paper-lime-50: #f9fbe7;
      --paper-lime-100: #f0f4c3;
      --paper-lime-200: #e6ee9c;
      --paper-lime-300: #dce775;
      --paper-lime-400: #d4e157;
      --paper-lime-500: #cddc39;
      --paper-lime-600: #c0ca33;
      --paper-lime-700: #afb42b;
      --paper-lime-800: #9e9d24;
      --paper-lime-900: #827717;
      --paper-lime-a100: #f4ff81;
      --paper-lime-a200: #eeff41;
      --paper-lime-a400: #c6ff00;
      --paper-lime-a700: #aeea00;

      --paper-yellow-50: #fffde7;
      --paper-yellow-100: #fff9c4;
      --paper-yellow-200: #fff59d;
      --paper-yellow-300: #fff176;
      --paper-yellow-400: #ffee58;
      --paper-yellow-500: #ffeb3b;
      --paper-yellow-600: #fdd835;
      --paper-yellow-700: #fbc02d;
      --paper-yellow-800: #f9a825;
      --paper-yellow-900: #f57f17;
      --paper-yellow-a100: #ffff8d;
      --paper-yellow-a200: #ffff00;
      --paper-yellow-a400: #ffea00;
      --paper-yellow-a700: #ffd600;

      --paper-amber-50: #fff8e1;
      --paper-amber-100: #ffecb3;
      --paper-amber-200: #ffe082;
      --paper-amber-300: #ffd54f;
      --paper-amber-400: #ffca28;
      --paper-amber-500: #ffc107;
      --paper-amber-600: #ffb300;
      --paper-amber-700: #ffa000;
      --paper-amber-800: #ff8f00;
      --paper-amber-900: #ff6f00;
      --paper-amber-a100: #ffe57f;
      --paper-amber-a200: #ffd740;
      --paper-amber-a400: #ffc400;
      --paper-amber-a700: #ffab00;

      --paper-orange-50: #fff3e0;
      --paper-orange-100: #ffe0b2;
      --paper-orange-200: #ffcc80;
      --paper-orange-300: #ffb74d;
      --paper-orange-400: #ffa726;
      --paper-orange-500: #ff9800;
      --paper-orange-600: #fb8c00;
      --paper-orange-700: #f57c00;
      --paper-orange-800: #ef6c00;
      --paper-orange-900: #e65100;
      --paper-orange-a100: #ffd180;
      --paper-orange-a200: #ffab40;
      --paper-orange-a400: #ff9100;
      --paper-orange-a700: #ff6500;

      --paper-deep-orange-50: #fbe9e7;
      --paper-deep-orange-100: #ffccbc;
      --paper-deep-orange-200: #ffab91;
      --paper-deep-orange-300: #ff8a65;
      --paper-deep-orange-400: #ff7043;
      --paper-deep-orange-500: #ff5722;
      --paper-deep-orange-600: #f4511e;
      --paper-deep-orange-700: #e64a19;
      --paper-deep-orange-800: #d84315;
      --paper-deep-orange-900: #bf360c;
      --paper-deep-orange-a100: #ff9e80;
      --paper-deep-orange-a200: #ff6e40;
      --paper-deep-orange-a400: #ff3d00;
      --paper-deep-orange-a700: #dd2c00;

      --paper-brown-50: #efebe9;
      --paper-brown-100: #d7ccc8;
      --paper-brown-200: #bcaaa4;
      --paper-brown-300: #a1887f;
      --paper-brown-400: #8d6e63;
      --paper-brown-500: #795548;
      --paper-brown-600: #6d4c41;
      --paper-brown-700: #5d4037;
      --paper-brown-800: #4e342e;
      --paper-brown-900: #3e2723;

      --paper-grey-50: #fafafa;
      --paper-grey-100: #f5f5f5;
      --paper-grey-200: #eeeeee;
      --paper-grey-300: #e0e0e0;
      --paper-grey-400: #bdbdbd;
      --paper-grey-500: #9e9e9e;
      --paper-grey-600: #757575;
      --paper-grey-700: #616161;
      --paper-grey-800: #424242;
      --paper-grey-900: #212121;

      --paper-blue-grey-50: #eceff1;
      --paper-blue-grey-100: #cfd8dc;
      --paper-blue-grey-200: #b0bec5;
      --paper-blue-grey-300: #90a4ae;
      --paper-blue-grey-400: #78909c;
      --paper-blue-grey-500: #607d8b;
      --paper-blue-grey-600: #546e7a;
      --paper-blue-grey-700: #455a64;
      --paper-blue-grey-800: #37474f;
      --paper-blue-grey-900: #263238;

      /* opacity for dark text on a light background */
      --dark-divider-opacity: 0.12;
      --dark-disabled-opacity: 0.38; /* or hint text or icon */
      --dark-secondary-opacity: 0.54;
      --dark-primary-opacity: 0.87;

      /* opacity for light text on a dark background */
      --light-divider-opacity: 0.12;
      --light-disabled-opacity: 0.3; /* or hint text or icon */
      --light-secondary-opacity: 0.7;
      --light-primary-opacity: 1.0;

    }

  </style>
</custom-style>
`;
template$2.setAttribute('style', 'display: none;');
document.head.appendChild(template$2.content);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const $_documentContainer = document.createElement('template');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-spinner-styles">
  <template>
    <style>
      /*
      /**************************/
      /* STYLES FOR THE SPINNER */
      /**************************/

      /*
       * Constants:
       *      ARCSIZE     = 270 degrees (amount of circle the arc takes up)
       *      ARCTIME     = 1333ms (time it takes to expand and contract arc)
       *      ARCSTARTROT = 216 degrees (how much the start location of the arc
       *                                should rotate each time, 216 gives us a
       *                                5 pointed star shape (it's 360/5 * 3).
       *                                For a 7 pointed star, we might do
       *                                360/7 * 3 = 154.286)
       *      SHRINK_TIME = 400ms
       */

      :host {
        display: inline-block;
        position: relative;
        width: 28px;
        height: 28px;

        /* 360 * ARCTIME / (ARCSTARTROT + (360-ARCSIZE)) */
        --paper-spinner-container-rotation-duration: 1568ms;

        /* ARCTIME */
        --paper-spinner-expand-contract-duration: 1333ms;

        /* 4 * ARCTIME */
        --paper-spinner-full-cycle-duration: 5332ms;

        /* SHRINK_TIME */
        --paper-spinner-cooldown-duration: 400ms;
      }

      #spinnerContainer {
        width: 100%;
        height: 100%;

        /* The spinner does not have any contents that would have to be
         * flipped if the direction changes. Always use ltr so that the
         * style works out correctly in both cases. */
        direction: ltr;
      }

      #spinnerContainer.active {
        -webkit-animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite;
        animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite;
      }

      @-webkit-keyframes container-rotate {
        to { -webkit-transform: rotate(360deg) }
      }

      @keyframes container-rotate {
        to { transform: rotate(360deg) }
      }

      .spinner-layer {
        position: absolute;
        width: 100%;
        height: 100%;
        opacity: 0;
        white-space: nowrap;
        color: var(--paper-spinner-color, var(--google-blue-500));
      }

      .layer-1 {
        color: var(--paper-spinner-layer-1-color, var(--google-blue-500));
      }

      .layer-2 {
        color: var(--paper-spinner-layer-2-color, var(--google-red-500));
      }

      .layer-3 {
        color: var(--paper-spinner-layer-3-color, var(--google-yellow-500));
      }

      .layer-4 {
        color: var(--paper-spinner-layer-4-color, var(--google-green-500));
      }

      /**
       * IMPORTANT NOTE ABOUT CSS ANIMATION PROPERTIES (keanulee):
       *
       * iOS Safari (tested on iOS 8.1) does not handle animation-delay very well - it doesn't
       * guarantee that the animation will start _exactly_ after that value. So we avoid using
       * animation-delay and instead set custom keyframes for each color (as layer-2undant as it
       * seems).
       */
      .active .spinner-layer {
        -webkit-animation-name: fill-unfill-rotate;
        -webkit-animation-duration: var(--paper-spinner-full-cycle-duration);
        -webkit-animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        -webkit-animation-iteration-count: infinite;
        animation-name: fill-unfill-rotate;
        animation-duration: var(--paper-spinner-full-cycle-duration);
        animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        animation-iteration-count: infinite;
        opacity: 1;
      }

      .active .spinner-layer.layer-1 {
        -webkit-animation-name: fill-unfill-rotate, layer-1-fade-in-out;
        animation-name: fill-unfill-rotate, layer-1-fade-in-out;
      }

      .active .spinner-layer.layer-2 {
        -webkit-animation-name: fill-unfill-rotate, layer-2-fade-in-out;
        animation-name: fill-unfill-rotate, layer-2-fade-in-out;
      }

      .active .spinner-layer.layer-3 {
        -webkit-animation-name: fill-unfill-rotate, layer-3-fade-in-out;
        animation-name: fill-unfill-rotate, layer-3-fade-in-out;
      }

      .active .spinner-layer.layer-4 {
        -webkit-animation-name: fill-unfill-rotate, layer-4-fade-in-out;
        animation-name: fill-unfill-rotate, layer-4-fade-in-out;
      }

      @-webkit-keyframes fill-unfill-rotate {
        12.5% { -webkit-transform: rotate(135deg) } /* 0.5 * ARCSIZE */
        25%   { -webkit-transform: rotate(270deg) } /* 1   * ARCSIZE */
        37.5% { -webkit-transform: rotate(405deg) } /* 1.5 * ARCSIZE */
        50%   { -webkit-transform: rotate(540deg) } /* 2   * ARCSIZE */
        62.5% { -webkit-transform: rotate(675deg) } /* 2.5 * ARCSIZE */
        75%   { -webkit-transform: rotate(810deg) } /* 3   * ARCSIZE */
        87.5% { -webkit-transform: rotate(945deg) } /* 3.5 * ARCSIZE */
        to    { -webkit-transform: rotate(1080deg) } /* 4   * ARCSIZE */
      }

      @keyframes fill-unfill-rotate {
        12.5% { transform: rotate(135deg) } /* 0.5 * ARCSIZE */
        25%   { transform: rotate(270deg) } /* 1   * ARCSIZE */
        37.5% { transform: rotate(405deg) } /* 1.5 * ARCSIZE */
        50%   { transform: rotate(540deg) } /* 2   * ARCSIZE */
        62.5% { transform: rotate(675deg) } /* 2.5 * ARCSIZE */
        75%   { transform: rotate(810deg) } /* 3   * ARCSIZE */
        87.5% { transform: rotate(945deg) } /* 3.5 * ARCSIZE */
        to    { transform: rotate(1080deg) } /* 4   * ARCSIZE */
      }

      @-webkit-keyframes layer-1-fade-in-out {
        0% { opacity: 1 }
        25% { opacity: 1 }
        26% { opacity: 0 }
        89% { opacity: 0 }
        90% { opacity: 1 }
        to { opacity: 1 }
      }

      @keyframes layer-1-fade-in-out {
        0% { opacity: 1 }
        25% { opacity: 1 }
        26% { opacity: 0 }
        89% { opacity: 0 }
        90% { opacity: 1 }
        to { opacity: 1 }
      }

      @-webkit-keyframes layer-2-fade-in-out {
        0% { opacity: 0 }
        15% { opacity: 0 }
        25% { opacity: 1 }
        50% { opacity: 1 }
        51% { opacity: 0 }
        to { opacity: 0 }
      }

      @keyframes layer-2-fade-in-out {
        0% { opacity: 0 }
        15% { opacity: 0 }
        25% { opacity: 1 }
        50% { opacity: 1 }
        51% { opacity: 0 }
        to { opacity: 0 }
      }

      @-webkit-keyframes layer-3-fade-in-out {
        0% { opacity: 0 }
        40% { opacity: 0 }
        50% { opacity: 1 }
        75% { opacity: 1 }
        76% { opacity: 0 }
        to { opacity: 0 }
      }

      @keyframes layer-3-fade-in-out {
        0% { opacity: 0 }
        40% { opacity: 0 }
        50% { opacity: 1 }
        75% { opacity: 1 }
        76% { opacity: 0 }
        to { opacity: 0 }
      }

      @-webkit-keyframes layer-4-fade-in-out {
        0% { opacity: 0 }
        65% { opacity: 0 }
        75% { opacity: 1 }
        90% { opacity: 1 }
        to { opacity: 0 }
      }

      @keyframes layer-4-fade-in-out {
        0% { opacity: 0 }
        65% { opacity: 0 }
        75% { opacity: 1 }
        90% { opacity: 1 }
        to { opacity: 0 }
      }

      .circle-clipper {
        display: inline-block;
        position: relative;
        width: 50%;
        height: 100%;
        overflow: hidden;
      }

      /**
       * Patch the gap that appear between the two adjacent div.circle-clipper while the
       * spinner is rotating (appears on Chrome 50, Safari 9.1.1, and Edge).
       */
      .spinner-layer::after {
        content: '';
        left: 45%;
        width: 10%;
        border-top-style: solid;
      }

      .spinner-layer::after,
      .circle-clipper .circle {
        box-sizing: border-box;
        position: absolute;
        top: 0;
        border-width: var(--paper-spinner-stroke-width, 3px);
        border-radius: 50%;
      }

      .circle-clipper .circle {
        bottom: 0;
        width: 200%;
        border-style: solid;
        border-bottom-color: transparent !important;
      }

      .circle-clipper.left .circle {
        left: 0;
        border-right-color: transparent !important;
        -webkit-transform: rotate(129deg);
        transform: rotate(129deg);
      }

      .circle-clipper.right .circle {
        left: -100%;
        border-left-color: transparent !important;
        -webkit-transform: rotate(-129deg);
        transform: rotate(-129deg);
      }

      .active .gap-patch::after,
      .active .circle-clipper .circle {
        -webkit-animation-duration: var(--paper-spinner-expand-contract-duration);
        -webkit-animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        -webkit-animation-iteration-count: infinite;
        animation-duration: var(--paper-spinner-expand-contract-duration);
        animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        animation-iteration-count: infinite;
      }

      .active .circle-clipper.left .circle {
        -webkit-animation-name: left-spin;
        animation-name: left-spin;
      }

      .active .circle-clipper.right .circle {
        -webkit-animation-name: right-spin;
        animation-name: right-spin;
      }

      @-webkit-keyframes left-spin {
        0% { -webkit-transform: rotate(130deg) }
        50% { -webkit-transform: rotate(-5deg) }
        to { -webkit-transform: rotate(130deg) }
      }

      @keyframes left-spin {
        0% { transform: rotate(130deg) }
        50% { transform: rotate(-5deg) }
        to { transform: rotate(130deg) }
      }

      @-webkit-keyframes right-spin {
        0% { -webkit-transform: rotate(-130deg) }
        50% { -webkit-transform: rotate(5deg) }
        to { -webkit-transform: rotate(-130deg) }
      }

      @keyframes right-spin {
        0% { transform: rotate(-130deg) }
        50% { transform: rotate(5deg) }
        to { transform: rotate(-130deg) }
      }

      #spinnerContainer.cooldown {
        -webkit-animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite, fade-out var(--paper-spinner-cooldown-duration) cubic-bezier(0.4, 0.0, 0.2, 1);
        animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite, fade-out var(--paper-spinner-cooldown-duration) cubic-bezier(0.4, 0.0, 0.2, 1);
      }

      @-webkit-keyframes fade-out {
        0% { opacity: 1 }
        to { opacity: 0 }
      }

      @keyframes fade-out {
        0% { opacity: 1 }
        to { opacity: 0 }
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer.content);

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/** @polymerBehavior */
const PaperSpinnerBehavior = {

  properties: {
    /**
     * Displays the spinner.
     */
    active: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      observer: '__activeChanged'
    },

    /**
     * Alternative text content for accessibility support.
     * If alt is present, it will add an aria-label whose content matches alt
     * when active. If alt is not present, it will default to 'loading' as the
     * alt value.
     */
    alt: {type: String, value: 'loading', observer: '__altChanged'},

    __coolingDown: {type: Boolean, value: false}
  },

  __computeContainerClasses: function(active, coolingDown) {
    return [
      active || coolingDown ? 'active' : '',
      coolingDown ? 'cooldown' : ''
    ].join(' ');
  },

  __activeChanged: function(active, old) {
    this.__setAriaHidden(!active);
    this.__coolingDown = !active && old;
  },

  __altChanged: function(alt) {
    // user-provided `aria-label` takes precedence over prototype default
    if (alt === 'loading') {
      this.alt = this.getAttribute('aria-label') || alt;
    } else {
      this.__setAriaHidden(alt === '');
      this.setAttribute('aria-label', alt);
    }
  },

  __setAriaHidden: function(hidden) {
    var attr = 'aria-hidden';
    if (hidden) {
      this.setAttribute(attr, 'true');
    } else {
      this.removeAttribute(attr);
    }
  },

  __reset: function() {
    this.active = false;
    this.__coolingDown = false;
  }
};

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

const template$3 = html$1`
  <style include="paper-spinner-styles"></style>

  <div id="spinnerContainer" class-name="[[__computeContainerClasses(active, __coolingDown)]]" on-animationend="__reset" on-webkit-animation-end="__reset">
    <div class="spinner-layer layer-1">
      <div class="circle-clipper left">
        <div class="circle"></div>
      </div>
      <div class="circle-clipper right">
        <div class="circle"></div>
      </div>
    </div>

    <div class="spinner-layer layer-2">
      <div class="circle-clipper left">
        <div class="circle"></div>
      </div>
      <div class="circle-clipper right">
        <div class="circle"></div>
      </div>
    </div>

    <div class="spinner-layer layer-3">
      <div class="circle-clipper left">
        <div class="circle"></div>
      </div>
      <div class="circle-clipper right">
        <div class="circle"></div>
      </div>
    </div>

    <div class="spinner-layer layer-4">
      <div class="circle-clipper left">
        <div class="circle"></div>
      </div>
      <div class="circle-clipper right">
        <div class="circle"></div>
      </div>
    </div>
  </div>
`;
template$3.setAttribute('strip-whitespace', '');

/**
Material design: [Progress &
activity](https://www.google.com/design/spec/components/progress-activity.html)

Element providing a multiple color material design circular spinner.

    <paper-spinner active></paper-spinner>

The default spinner cycles between four layers of colors; by default they are
blue, red, yellow and green. It can be customized to cycle between four
different colors. Use <paper-spinner-lite> for single color spinners.

### Accessibility

Alt attribute should be set to provide adequate context for accessibility. If
not provided, it defaults to 'loading'. Empty alt can be provided to mark the
element as decorative if alternative content is provided in another form (e.g. a
text block following the spinner).

    <paper-spinner alt="Loading contacts list" active></paper-spinner>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-spinner-layer-1-color` | Color of the first spinner rotation | `--google-blue-500`
`--paper-spinner-layer-2-color` | Color of the second spinner rotation | `--google-red-500`
`--paper-spinner-layer-3-color` | Color of the third spinner rotation | `--google-yellow-500`
`--paper-spinner-layer-4-color` | Color of the fourth spinner rotation | `--google-green-500`
`--paper-spinner-stroke-width` | The width of the spinner stroke | 3px

@group Paper Elements
@element paper-spinner
@hero hero.svg
@demo demo/index.html
*/
Polymer({
  _template: template$3,

  is: 'paper-spinner',

  behaviors: [PaperSpinnerBehavior]
});

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
 * `iron-range-behavior` provides the behavior for something with a minimum to
 * maximum range.
 *
 * @demo demo/index.html
 * @polymerBehavior
 */
const IronRangeBehavior = {

  properties: {

    /**
     * The number that represents the current value.
     */
    value: {type: Number, value: 0, notify: true, reflectToAttribute: true},

    /**
     * The number that indicates the minimum value of the range.
     */
    min: {type: Number, value: 0, notify: true},

    /**
     * The number that indicates the maximum value of the range.
     */
    max: {type: Number, value: 100, notify: true},

    /**
     * Specifies the value granularity of the range's value.
     */
    step: {type: Number, value: 1, notify: true},

    /**
     * Returns the ratio of the value.
     */
    ratio: {type: Number, value: 0, readOnly: true, notify: true},
  },

  observers: ['_update(value, min, max, step)'],

  _calcRatio: function(value) {
    return (this._clampValue(value) - this.min) / (this.max - this.min);
  },

  _clampValue: function(value) {
    return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
  },

  _calcStep: function(value) {
    // polymer/issues/2493
    value = parseFloat(value);

    if (!this.step) {
      return value;
    }

    var numSteps = Math.round((value - this.min) / this.step);
    if (this.step < 1) {
      /**
       * For small values of this.step, if we calculate the step using
       * `Math.round(value / step) * step` we may hit a precision point issue
       * eg. 0.1 * 0.2 =  0.020000000000000004
       * http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
       *
       * as a work around we can divide by the reciprocal of `step`
       */
      return numSteps / (1 / this.step) + this.min;
    } else {
      return numSteps * this.step + this.min;
    }
  },

  _validateValue: function() {
    var v = this._clampValue(this.value);
    this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
    return this.value !== v;
  },

  _update: function() {
    this._validateValue();
    this._setRatio(this._calcRatio(this.value) * 100);
  }

};

/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/

/**
Material design: [Progress &
activity](https://www.google.com/design/spec/components/progress-activity.html)

The progress bars are for situations where the percentage completed can be
determined. They give users a quick sense of how much longer an operation
will take.

Example:

    <paper-progress value="10"></paper-progress>

There is also a secondary progress which is useful for displaying intermediate
progress, such as the buffer level during a streaming playback progress bar.

Example:

    <paper-progress value="10" secondary-progress="30"></paper-progress>

### Styling progress bar:

To change the active progress bar color:

    paper-progress {
       --paper-progress-active-color: #e91e63;
    }

To change the secondary progress bar color:

    paper-progress {
      --paper-progress-secondary-color: #f8bbd0;
    }

To change the progress bar background color:

    paper-progress {
      --paper-progress-container-color: #64ffda;
    }

Add the class `transiting` to a paper-progress to animate the progress bar when
the value changed. You can also customize the transition:

    paper-progress {
      --paper-progress-transition-duration: 0.08s;
      --paper-progress-transition-timing-function: ease;
      --paper-progress-transition-delay: 0s;
    }

To change the duration of the indeterminate cycle:

    paper-progress {
      --paper-progress-indeterminate-cycle-duration: 2s;
    }

The following mixins are available for styling:

Custom property | Description | Default
----------------|-------------|---------
`--paper-progress-container` | Mixin applied to container | `{}`
`--paper-progress-transition-duration` | Duration of the transition | `0.08s`
`--paper-progress-transition-timing-function` | The timing function for the transition | `ease`
`--paper-progress-transition-delay` | delay for the transition | `0s`
`--paper-progress-container-color` | Color of the container | `--google-grey-300`
`--paper-progress-active-color` | The color of the active bar | `--google-green-500`
`--paper-progress-secondary-color` | The color of the secondary bar | `--google-green-100`
`--paper-progress-disabled-active-color` | The color of the active bar if disabled | `--google-grey-500`
`--paper-progress-disabled-secondary-color` | The color of the secondary bar if disabled  | `--google-grey-300`
`--paper-progress-height` | The height of the progress bar | `4px`
`--paper-progress-indeterminate-cycle-duration` | Duration of an indeterminate cycle | `2s`

@group Paper Elements
@element paper-progress
@demo demo/index.html
*/
Polymer({
  _template: html$1`
    <style>
      :host {
        display: block;
        width: 200px;
        position: relative;
        overflow: hidden;
      }

      :host([hidden]), [hidden] {
        display: none !important;
      }

      #progressContainer {
        @apply --paper-progress-container;
        position: relative;
      }

      #progressContainer,
      /* the stripe for the indeterminate animation*/
      .indeterminate::after {
        height: var(--paper-progress-height, 4px);
      }

      #primaryProgress,
      #secondaryProgress,
      .indeterminate::after {
        @apply --layout-fit;
      }

      #progressContainer,
      .indeterminate::after {
        background: var(--paper-progress-container-color, var(--google-grey-300));
      }

      :host(.transiting) #primaryProgress,
      :host(.transiting) #secondaryProgress {
        -webkit-transition-property: -webkit-transform;
        transition-property: transform;

        /* Duration */
        -webkit-transition-duration: var(--paper-progress-transition-duration, 0.08s);
        transition-duration: var(--paper-progress-transition-duration, 0.08s);

        /* Timing function */
        -webkit-transition-timing-function: var(--paper-progress-transition-timing-function, ease);
        transition-timing-function: var(--paper-progress-transition-timing-function, ease);

        /* Delay */
        -webkit-transition-delay: var(--paper-progress-transition-delay, 0s);
        transition-delay: var(--paper-progress-transition-delay, 0s);
      }

      #primaryProgress,
      #secondaryProgress {
        @apply --layout-fit;
        -webkit-transform-origin: left center;
        transform-origin: left center;
        -webkit-transform: scaleX(0);
        transform: scaleX(0);
        will-change: transform;
      }

      #primaryProgress {
        background: var(--paper-progress-active-color, var(--google-green-500));
      }

      #secondaryProgress {
        background: var(--paper-progress-secondary-color, var(--google-green-100));
      }

      :host([disabled]) #primaryProgress {
        background: var(--paper-progress-disabled-active-color, var(--google-grey-500));
      }

      :host([disabled]) #secondaryProgress {
        background: var(--paper-progress-disabled-secondary-color, var(--google-grey-300));
      }

      :host(:not([disabled])) #primaryProgress.indeterminate {
        -webkit-transform-origin: right center;
        transform-origin: right center;
        -webkit-animation: indeterminate-bar var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
        animation: indeterminate-bar var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
      }

      :host(:not([disabled])) #primaryProgress.indeterminate::after {
        content: "";
        -webkit-transform-origin: center center;
        transform-origin: center center;

        -webkit-animation: indeterminate-splitter var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
        animation: indeterminate-splitter var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
      }

      @-webkit-keyframes indeterminate-bar {
        0% {
          -webkit-transform: scaleX(1) translateX(-100%);
        }
        50% {
          -webkit-transform: scaleX(1) translateX(0%);
        }
        75% {
          -webkit-transform: scaleX(1) translateX(0%);
          -webkit-animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          -webkit-transform: scaleX(0) translateX(0%);
        }
      }

      @-webkit-keyframes indeterminate-splitter {
        0% {
          -webkit-transform: scaleX(.75) translateX(-125%);
        }
        30% {
          -webkit-transform: scaleX(.75) translateX(-125%);
          -webkit-animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
        100% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
      }

      @keyframes indeterminate-bar {
        0% {
          transform: scaleX(1) translateX(-100%);
        }
        50% {
          transform: scaleX(1) translateX(0%);
        }
        75% {
          transform: scaleX(1) translateX(0%);
          animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          transform: scaleX(0) translateX(0%);
        }
      }

      @keyframes indeterminate-splitter {
        0% {
          transform: scaleX(.75) translateX(-125%);
        }
        30% {
          transform: scaleX(.75) translateX(-125%);
          animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          transform: scaleX(.75) translateX(125%);
        }
        100% {
          transform: scaleX(.75) translateX(125%);
        }
      }
    </style>

    <div id="progressContainer">
      <div id="secondaryProgress" hidden\$="[[_hideSecondaryProgress(secondaryRatio)]]"></div>
      <div id="primaryProgress"></div>
    </div>
`,

  is: 'paper-progress',
  behaviors: [IronRangeBehavior],

  properties: {
    /**
     * The number that represents the current secondary progress.
     */
    secondaryProgress: {type: Number, value: 0},

    /**
     * The secondary ratio
     */
    secondaryRatio: {type: Number, value: 0, readOnly: true},

    /**
     * Use an indeterminate progress indicator.
     */
    indeterminate:
        {type: Boolean, value: false, observer: '_toggleIndeterminate'},

    /**
     * True if the progress is disabled.
     */
    disabled: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      observer: '_disabledChanged'
    }
  },

  observers:
      ['_progressChanged(secondaryProgress, value, min, max, indeterminate)'],

  hostAttributes: {role: 'progressbar'},

  _toggleIndeterminate: function(indeterminate) {
    // If we use attribute/class binding, the animation sometimes doesn't
    // translate properly on Safari 7.1. So instead, we toggle the class here in
    // the update method.
    this.toggleClass('indeterminate', indeterminate, this.$.primaryProgress);
  },

  _transformProgress: function(progress, ratio) {
    var transform = 'scaleX(' + (ratio / 100) + ')';
    progress.style.transform = progress.style.webkitTransform = transform;
  },

  _mainRatioChanged: function(ratio) {
    this._transformProgress(this.$.primaryProgress, ratio);
  },

  _progressChanged: function(
      secondaryProgress, value, min, max, indeterminate) {
    secondaryProgress = this._clampValue(secondaryProgress);
    value = this._clampValue(value);

    var secondaryRatio = this._calcRatio(secondaryProgress) * 100;
    var mainRatio = this._calcRatio(value) * 100;

    this._setSecondaryRatio(secondaryRatio);
    this._transformProgress(this.$.secondaryProgress, secondaryRatio);
    this._transformProgress(this.$.primaryProgress, mainRatio);

    this.secondaryProgress = secondaryProgress;

    if (indeterminate) {
      this.removeAttribute('aria-valuenow');
    } else {
      this.setAttribute('aria-valuenow', value);
    }
    this.setAttribute('aria-valuemin', min);
    this.setAttribute('aria-valuemax', max);
  },

  _disabledChanged: function(disabled) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
  },

  _hideSecondaryProgress: function(secondaryRatio) {
    return secondaryRatio === 0;
  }
});

/*
Copyright 2019 Pawel Psztyc, The ARC team

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * # `<paper-autocomplete>`
 *
 * @customElement
 * @demo demo/index.html
 */
class AnypointAutocomplete extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    const {
      loader,
      _loading,
      _opened,
      _oldTarget,
      verticalAlign,
      horizontalAlign,
      scrollAction,
      horizontalOffset,
      verticalOffset,
      compatibility,
      noAnimations,
      _suggestions
    } = this;
    let { noink } = this;
    if (noink === undefined) {
      noink = false;
    }
    const _showLoader = !!loader && !!_loading;
    return html`
    <anypoint-dropdown
      .positionTarget="${_oldTarget}"
      .verticalAlign="${verticalAlign}"
      .verticalOffset="${verticalOffset}"
      .horizontalAlign="${horizontalAlign}"
      .horizontalOffset="${horizontalOffset}"
      .scrollAction="${scrollAction}"
      .opened="${_opened}"
      .noAnimations="${noAnimations}"
      noautofocus
      nooverlap
      nocancelonoutsideclick
      @overlay-closed="${this._closeHandler}">
      <anypoint-listbox
        aria-label="Use arrows and enter to select list item. Escape to close the list."
        slot="dropdown-content"
        selectable="anypoint-item"
        useariaselected
        @select="${this._selectionHandler}">
        ${_showLoader ? html`<paper-progress style="width: 100%" indeterminate></paper-progress>` : undefined}
        ${_suggestions.map((item) => html`<anypoint-item ?compatibility="${compatibility}">
          <div>${item.value || item}</div>
          ${compatibility ? undefined : html`<paper-ripple .noink="${noink}"></paper-ripple>`}
        </anypoint-item>`)}
      </anypoint-listbox>
    </anypoint-dropdown>
    `;
  }

  static get properties() {
    return {
      /**
       * A target input field to observe.
       * It accepts an element which is the input with `value` property or
       * an id of an element that is a child of the parent element of this node.
       * @type {HTMLElement|String}
       */
      target: { },
      /**
       * List of suggestions to display.
       * If the array items are strings they will be used for display a suggestions and
       * to insert a value.
       * If the list is an object the each object must contain `value` and `display`
       * properties.
       * The `display` property will be used in the suggestions list and the
       * `value` property will be used to insert the value to the referenced text field.
       *
       * @type {Array<Object>|Array<String>}
       */
      source: { type: Array },
      /**
       * List of suggestion that are rendered.
       */
      _suggestions: { type: Array },
      /**
       * True when user query changed and waiting for `source` property update
       */
      _loading: { type: Boolean },
      /**
       * Set this to true if you use async operation in response for query event.
       * This will display a loader when querying for more suggestions.
       * Do not use it it you do not handle suggestions asynchronously.
       */
      loader: { type: Boolean, reflect: true },
      /**
       * If true it will opend suggestions on input field focus.
       */
      openOnFocus: { type: Boolean },

      _opened: { type: Boolean },
      /**
       * The orientation against which to align the element vertically
       * relative to the text input.
       * Possible values are "top", "bottom", "middle", "auto".
       */
      verticalAlign: { type: String },
      /**
       * A pixel value that will be added to the position calculated for the
       * given `verticalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `verticalAlign`.
       *
       * If `verticalAlign` is "top" or "middle", this offset will increase or
       * decrease the distance to the top side of the screen: a negative offset
       * will move the dropdown upwards; a positive one, downwards.
       *
       * Conversely if `verticalAlign` is "bottom", this offset will increase
       * or decrease the distance to the bottom side of the screen: a negative
       * offset will move the dropdown downwards; a positive one, upwards.
       */
      verticalOffset: { type: Number },
      /**
       * The orientation against which to align the element horizontally
       * relative to the text input. Possible values are "left", "right",
       * "center", "auto".
       */
      horizontalAlign: { type: String },
      /**
       * A pixel value that will be added to the position calculated for the
       * given `horizontalAlign`, in the direction of alignment. You can think
       * of it as increasing or decreasing the distance to the side of the
       * screen given by `horizontalAlign`.
       *
       * If `horizontalAlign` is "left" or "center", this offset will increase or
       * decrease the distance to the left side of the screen: a negative offset
       * will move the dropdown to the left; a positive one, to the right.
       *
       * Conversely if `horizontalAlign` is "right", this offset will increase
       * or decrease the distance to the right side of the screen: a negative
       * offset will move the dropdown to the right; a positive one, to the left.
       */
      horizontalOffset: { type: Number },
      /**
       * Determines which action to perform when scroll outside an opened overlay
       * happens. Possible values: lock - blocks scrolling from happening, refit -
       * computes the new position on the overlay cancel - causes the overlay to
       * close
       */
      scrollAction: { type: String },
      /**
       * Removes animation from the dropdown.
       */
      noAnimations: { type: Boolean },
      /**
       * Removes ripple effect from list items.
       * This effect is always disabled when `compatibility` is set.
       */
      noink: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * When set it won't setup `aria-controls` on target element.
       */
      noTargetControls: { type: Boolean }
    };
  }

  get target() {
    return this._target;
  }

  set target(value) {
    const old = this._target;
    if (old === value) {
      return;
    }
    this._target = value;
    this._targetChanged();
  }

  /**
   * @return {Array<String>|Array<Object>} List of suggestion that are rendered.
   */
  get suggestions() {
    return this._suggestions;
  }
  /**
   * @return {Boolean} True when user query changed and waiting for `source` property update
   */
  get loading() {
    return this._loading;
  }

  get _loading() {
    return this.__loading;
  }

  set _loading(value) {
    const old = this.__loading;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__loading = value;
    this.requestUpdate('_loading', value);
    this.dispatchEvent(new CustomEvent('loading-chanegd', {
      detail: {
        value
      }
    }));
  }

  get source() {
    return this._source;
  }

  set source(value) {
    const old = this._source;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._source = value;
    if (this._opened) {
      this._filterSuggestions();
    }
    if (this._loading) {
      this._loading = false;
    }
  }
  /**
   * @return {Boolean} True if the overlay is currently opened.
   */
  get opened() {
    return this._opened;
  }

  get _opened() {
    return this.__opened;
  }

  set _opened(value) {
    const old = this.__opened;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__opened = value;
    this.requestUpdate('_opened', old);
    this._openedChanged(value);
    this.dispatchEvent(new CustomEvent('opened-changed', {
      detail: {
        value
      }
    }));
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get compatibility() {
    return this._compatibility;
  }

  set compatibility(value) {
    const old = this._compatibility;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._compatibility = value;
    this.requestUpdate('compatibility', old);
  }

  get isAttached() {
    return this._isAttached;
  }

  set isAttached(value) {
    const old = this._isAttached;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._isAttached = value;
    this._targetChanged();
  }

  get _listbox() {
    if (!this.__listbox) {
      this.__listbox = this.querySelector('anypoint-listbox');
    }
    return this.__listbox;
  }

  /**
   * @return {Function} Previously registered handler for `query` event
   */
  get onquery() {
    return this._onquery;
  }
  /**
   * Registers a callback function for `query` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onquery(value) {
    this._registerCallback('query', value);
  }
  /**
   * @return {Function} Previously registered handler for `selected` event
   */
  get onselected() {
    return this._onselected;
  }
  /**
   * Registers a callback function for `selected` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onselected(value) {
    this._registerCallback('selected', value);
  }

  constructor() {
    super();
    this._targetInputHandler = this._targetInputHandler.bind(this);
    this._targetFocusHandler = this._targetFocusHandler.bind(this);
    this._targetKeydown = this._targetKeydown.bind(this);

    this._suggestions = [];
    this._loading = false;
    this.loader = false;
    this.openOnFocus = false;
    this._opened = false;
    this.horizontalAlign = 'center';
    this.verticalAlign = 'top';
    this.scrollAction = 'refit';
    this.horizontalOffset = 0;
    this.verticalOffset = 2;
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this._ensureNodeId(this);
    this.style.position = 'absolute';
    this.isAttached = true;
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.isAttached = false;
  }

  firstUpdated() {
    // Styles are defined here because it does not uses shadow root
    // to comply with accessibility requiremenets.
    // Styles defined in the component's `styles` getter won't be applied
    // to the children.
    const box = this._listbox;
    this._ensureNodeId(box);
    box.style.backgroundColor = 'var(--anypoiont-autocomplete-background-color, #fff)';
    box.style.boxShadow = 'var(--anypoiont-autocomplete-dropdown-shaddow)';
    const id = box.id;
    this.setAttribute('aria-owns', id);
    this.setAttribute('aria-controls', id);
    const target = this._oldTarget;
    if (!target || this.noTargetControls) {
      return;
    }
    target.setAttribute('aria-controls', id);
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }
  /**
   * Handler for target property change.
   */
  _targetChanged() {
    const { target, isAttached } = this;
    if (this._oldTarget) {
      this._oldTarget.removeEventListener('input', this._targetInputHandler);
      this._oldTarget.removeEventListener('focus', this._targetFocusHandler);
      this._oldTarget.removeEventListener('keydown', this._targetKeydown);
      this._oldTarget = null;
    }
    if (!target || !isAttached) {
      return;
    }
    this.notifyResize();
    if (typeof target === 'string') {
      const parent = this.parentElement;
      if (!parent || !parent.querySelector) {
        return;
      }
      const node = parent.querySelector(`#${target}`);
      if (node) {
        this.target = node;
        return;
      }
    } else if (target) {
      target.addEventListener('input', this._targetInputHandler);
      target.addEventListener('focus', this._targetFocusHandler);
      target.addEventListener('keydown', this._targetKeydown);
      this._setupTargetAria(target);
      this._oldTarget = target;
      if (target === document.activeElement) {
        this._targetFocus();
      }
    }
  }
  /**
   * Sets target input width on the listbox before rendering.
   */
  _setComboboxWidth() {
    const target = this._oldTarget;
    const box = this._listbox;
    if (!target || !box || !target.nodeType || target.nodeType !== Node.ELEMENT_NODE) {
      return;
    }
    const rect = target.getBoundingClientRect();
    const width = rect.width;
    if (!width) {
      return;
    }
    box.style.width = `${width}px`;
  }
  /**
   * Generates an id on passed element.
   * @param {HTMLElement} target An element to set id on to
   */
  _ensureNodeId(target) {
    if (target.id) {
      return;
    }
    const id = Math.floor((Math.random() * 100000) + 1);
    target.id = `paperAutocompleteInput${id}`;
  }
  /**
   * Setups relavent aria attributes in the target input.
   * @param {HTMLElement} target An element to set attribute on to
   */
  _setupTargetAria(target) {
    this._ensureNodeId(this);
    target.setAttribute('aria-autocomplete', 'list');
    target.setAttribute('autocomplete', 'off');
    target.setAttribute('aria-haspopup', 'true');
    // parent node of the input also should have aria attributes
    const parent = target.parentElement;
    if (!parent) {
      return;
    }
    parent.setAttribute('role', 'combobox');
    parent.setAttribute('aria-expanded', 'false');
    parent.setAttribute('aria-owns', this.id);
    parent.setAttribute('aria-haspopup', 'listbox');
    if (!parent.hasAttribute('aria-label') && !parent.hasAttribute('aria-labelledby')) {
      parent.setAttribute('aria-label', 'Text input with list suggestions');
    }
  }
  /**
   * Sets `aria-expanded` on input's parent element.
   * @param {Boolean} opened
   */
  _openedChanged(opened) {
    const target = this._oldTarget;
    const parent = target && target.parentElement;
    if (!parent) {
      return;
    }
    parent.setAttribute('aria-expanded', String(opened));
  }
  /**
   * Renders suggestions on target's `input` event
   * @param {Event} e
   */
  _targetInputHandler(e) {
    if (e.detail) {
      // This event is dispatched by the autocomplete
      return;
    }
    this.renderSuggestions();
  }
  /**
   * Renders suggestions on target input focus if `openOnFocus` is set.
   */
  _targetFocusHandler() {
    if (!this.openOnFocus || this.opened || this.__autocompleteFocus || this.__ignoreNextFocus) {
      return;
    }
    this.__autocompleteFocus = true;
    setTimeout(() => {
      this.__autocompleteFocus = false;
      this.renderSuggestions();
    });
  }
  /**
   * Renders suggestions for current input and opens the overlay if
   * there are suggestions to show.
   */
  renderSuggestions() {
    if (!this.isAttached) {
      return;
    }
    let { value } = this._oldTarget;
    if (value === undefined || value === null) {
      value = '';
    }
    if (typeof value !== 'string') {
      value = String(value);
    }
    if (this._previousQuery && value.indexOf(this._previousQuery) === 0) {
      this._previousQuery = value;
      this._filterSuggestions();
      return;
    }
    this._listbox.selected = -1;
    this._disaptchQuery(value);
    this._previousQuery = value;
    this._filterSuggestions();
    if (this.loader) {
      this._loading = true;
      if (!this._opened) {
        this._setComboboxWidth();
        this._opened = true;
      }
    }
  }
  /**
   * Disaptches query event and returns it.
   * @param {String} value Current input value.
   * @return {CustomEvent}
   */
  _disaptchQuery(value) {
    const e = new CustomEvent('query', {
      detail: {
        value
      }
    });
    this.dispatchEvent(e);
    return e;
  }
  /**
   * Filter `source` array for current value.
   */
  _filterSuggestions() {
    if (!this._oldTarget || this._previousQuery === undefined) {
      return;
    }
    this._suggestions = [];
    const source = this.source;
    if (!source) {
      return;
    }
    const query = this._previousQuery ? this._previousQuery.toLowerCase() : '';
    const filtered = this._listSuggestions(source, query);
    if (filtered.length === 0) {
      this._opened = false;
      return;
    }
    filtered.sort(function(a, b) {
      const valueA = (typeof a === 'string') ? a : String(a.value);
      const valueB = (typeof b === 'string') ? b : String(b.value);
      const lowerA = valueA.toLowerCase();
      const lowerB = valueB.toLowerCase();
      const aIndex = lowerA.indexOf(query);
      const bIndex = lowerB.indexOf(query);
      if (aIndex === bIndex) {
        return valueA.localeCompare(valueB);
      }
      if (aIndex === 0 && bIndex !== 0) {
        return -1;
      }
      if (bIndex === 0 && aIndex !== 0) {
        return 1;
      }
      if (valueA > valueB) {
        return 1;
      }
      if (valueA < valueB) {
        return -1;
      }
      return valueA.localeCompare(valueB);
    });
    this._suggestions = filtered;
    this.notifyResize();
    setTimeout(() => {
      if (!this.opened) {
        this._setComboboxWidth();
        this._opened = true;
      }
    });
  }

  _listSuggestions(source, query) {
    if (!query && this.openOnFocus) {
      return source;
    }
    const filter = function(item) {
      const value = (typeof item === 'string') ? item : item.value;
      return String(value).toLowerCase().indexOf(query) !== -1;
    };
    const filtered = query ? source.filter(filter) : source;
    return filtered;
  }

  _closeHandler() {
    if (this._opened) {
      this._opened = false;
    }
    if (!this.__ignoreCloseRefocus) {
      this._refocusTarget();
    }
  }

  notifyResize() {
    const node = this.querySelector('anypoint-dropdown');
    if (node) {
      node.notifyResize();
    }
  }

  _selectionHandler(e) {
    const { selected } = e.target;
    if (selected === -1 || selected === null || selected === undefined) {
      return;
    }
    this._selectSuggestion(selected);
  }
  /**
   * Inserts selected suggestion into the text box and closes the suggestions.
   * @param {Number} selected Index of suggestion to use.
   */
  _selectSuggestion(selected) {
    let value = this._suggestions[selected];
    if (!value) {
      return;
    }
    const suggestionValue = value;
    if (typeof value !== 'string' && typeof value.value !== 'undefined') {
      value = value.value;
    }
    value = String(value);
    this.target.value = value;
    this.target.dispatchEvent(new CustomEvent('input', {
      detail: {
        autocomplete: this
      }
    }));
    this._opened = false;
    this._inform(suggestionValue);
  }

  _refocusTarget() {
    this.__ignoreNextFocus = true;
    this.target.blur();
    this.target.focus();
    setTimeout(() => {
      this.__ignoreNextFocus = false;
    });
  }

  /**
   * Handler for the keydown event.
   * @param {KeyboardEvent} e
   */
  _targetKeydown(e) {
    if (e.key === 'ArrowDown') {
      this._onDownKey();
      e.preventDefault();
      e.stopPropagation();
    } else if (e.key === 'ArrowUp') {
      this._onUpKey();
      e.preventDefault();
      e.stopPropagation();
    } else if (e.key === 'Enter') {
      this._onEnterKey();
    } else if (e.key === 'Tab') {
      this._onTabDown();
    } else if (e.key === 'Escape') {
      this._onEscKey();
    }
  }
  /**
   * If the dropdown is opened then it focuses on the first element on the list.
   * If closed it opens the suggestions and focuses on the first element on
   * the list.
   */
  _onDownKey() {
    if (!this._opened) {
      this.renderSuggestions();
      setTimeout(() => {
        if (this._opened) {
          this._listbox.focus();
        }
      });
    } else {
      this._listbox.focus();
    }
  }
  /**
   * If the dropdown is opened then it focuses on the last element on the list.
   * If closed it opens the suggestions and focuses on the last element on
   * the list.
   */
  _onUpKey() {
    if (!this._opened) {
      this.renderSuggestions();
      setTimeout(() => {
        if (this._opened) {
          this._listbox._focusPrevious();
        }
      });
    } else {
      this._listbox.focus();
      this._listbox._focusPrevious();
    }
  }
  /**
   * Closes the dropdown.
   */
  _onEscKey() {
    this._opened = false;
  }
  /**
   * Accetps first suggestion from the dropdown when opened.
   */
  _onEnterKey() {
    if (!this._opened) {
      return;
    }
    this._selectSuggestion(0);
  }
  /**
   * The element refocuses on the input when suggestions closes.
   * Also, the lisbox element is focusable so with tab it can be next target.
   * Finally, the dropdown has close animation that takes some time to finish
   * so it will try to refocus after the animation finish.
   * This function sets flags in debouncer to prohibit this.
   */
  _onTabDown() {
    if (this._opened) {
      this._listbox.tabIndex = -1;
      this.__ignoreNextFocus = true;
      this.__ignoreCloseRefocus = true;
      this._opened = false;
      setTimeout(() => {
        this._listbox.tabIndex = 0;
        this.__ignoreNextFocus = false;
        this.__ignoreCloseRefocus = false;
      }, 300);
    }
  }
  /**
  * Dispatches `selected` event with new value.
  *
  * @param {String|Object} value Selected value.
  */
 _inform(value) {
   const ev = new CustomEvent('selected', {
     detail: {
       value
     },
     cancelable: true
   });
   this.dispatchEvent(ev);
 }
}
/**
 * Fired when user entered some text into the input.
 * It is a time to query external datastore for suggestions and update "source" property.
 * Source should be updated event if the backend result with empty values and should set
 * the list to empty array.
 *
 * Nore that setting up source in response to this event after the user has closed
 * the dropdown it will have no effect at the moment.
 *
 * @event query
 * @param {String} value An entered phrase in text field.
 */
/**
 * Fired when the item was selected by the user.
 * At the time of receiving this event new value is already set in target input field.
 *
 * @event selected
 * @param {String} value Selected value
 */
window.customElements.define('anypoint-autocomplete', AnypointAutocomplete);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
A selector for OAuth 2.0 scope. Provides the UI to enter a scope for OAuth 2.0 settings.

#### Example

```html
<oauth2-scope-selector></oauth2-scope-selector>
```

`allowed-scopes` attribute allows to provide a list of predefined scopes
supported by the endpoint. When the list is set, autocomplete is enabled.
Autocomplete is supported by `anypoint-autocomplete` element.

Setting `prevent-custom-scopes` dissallows adding a scope that is not defined
in the `allowed-scopes` array. This can only work with `allowed-scopes` set

#### Example

```html
<oauth2-scope-selector prevent-custom-scopes allowed-scopes='["email", "profile"]'></oauth2-scope-selector>
```

And in JavaScript

```javascript
var selector = document.querySelector('oauth2-scope-selector');
selector.allowedScopes = ['profile', 'email'];
```

## Adding scope documentation

`allowedScopes` property can be an list of object to present scope description
after it is selected. Object in the array has to contain `label` and `description` properties.
`label` is scope value.

### Example

```javascript
const scopes = [
  {
    'label': 'user',
    'description': 'Grants read/write access to profile info only. Note that this scope includes user:email and user:follow.'
  },
  {'label': 'user:email', 'description': 'Grants read access to a user\'s email addresses.'},
  {'label': 'user:follow', 'description': 'Grants access to follow or unfollow other users.'}
];
const selector = document.querySelector('oauth2-scope-selector');
selector.allowedScopes = scopes;
```

See demo page for example implementation.

## Use with forms

The element can be used in a form by using `iron-form` custom element.
It's value is reported to the form as any other form input. `name` attribute
must be set in order to process the value.

```html
<iron-form id="form">
  <form>
    <oauth2-scope-selector name="scope" required></oauth2-scope-selector>
  </form>
</iron-form>
<script>
const form = document.getElementById('form');
const values = form.serializeForm();
console.log(values); // {"scope": []}
</script>
```

@customElement
@demo demo/index.html
@memberof UiElements
@appliesMixin ValidatableMixin
@appliesMixin ControlStateMixin
*/
class OAuth2ScopeSelector extends ControlStateMixin(ValidatableMixin(LitElement)) {
  static get styles() {
    return css `
    :host {
     display: block;
     outline: none;
     box-sizing: border-box;

     font-size: var(--arc-font-body1-font-size);
     font-weight: var(--arc-font-body1-font-weight);
     line-height: var(--arc-font-body1-line-height);
   }

   anypoint-autocomplete {
     top: 52px;
   }

   .input-container {
     position: relative;
   }

   .add-button,
   .delete-icon {
     margin-left: 12px;
   }

   .form-label {
     margin: 12px 8px;
   }

   .scope-input {
     width: auto;
   }

   .scopes-list {
    list-style: none;
    margin: 12px 8px;
    padding: 0;
   }

   .scope-item {
    display: flex;
    flex-direction: row;
    align-items: center;
   }

   .scope-display {
     overflow: hidden;
     font-size: 16px;
   }

   .scope-item[two-line] {
     margin-bottom: 12px;
   }

   .scope-item[two-line] .scope-display {
     font-weight: 400;
   }

   .scope-item-label {
     text-overflow: ellipsis;
     overflow: hidden;
     white-space: nowrap;
   }

   .scope-display div[secondary] {
     font-size: 14px;
     font-weight: 400;
     line-height: 20px;
     color: var(--oauth2-scope-selector-item-description-color, #737373);
   }`;
  }

  _scopesListTemplate() {
    const value = this.value;
    if (!value || !value.length) {
      return;
    }
    const {
      readOnly,
      disabled,
      _allowedIsObject
    } = this;
    return value.map((item, index) => html`
    <li class="scope-item" ?two-line="${_allowedIsObject}">
      <div class="scope-display">
        <div class="scope-item-label">${item}</div>
        <div secondary="">${this._computeItemDescription(item, _allowedIsObject)}</div>
      </div>
      <anypoint-icon-button
        class="delete-icon"
        data-index="${index}"
        data-action="remove-scope"
        @click="${this._removeScope}"
        ?disabled="${readOnly || disabled}"
        aria-label="Press to remove this scope from the list"
        title="Remove scope">
        <iron-icon icon="arc:remove-circle-outline"></iron-icon>
      </anypoint-icon-button>
    </li>`);
  }

  render() {
    const {
      name,
      invalid,
      currentValue,
      readOnly,
      compatibility,
      outlined,
      disabled,
      _autocompleteScopes,
      _inputTarget,
      _invalidMessage
    } = this;
    return html `
    <div class="container">
      <label class="form-label">Scopes</label>

      <div class="input-container">
        <anypoint-input
          name="${name}"
          ?invalid="${invalid}"
          class="scope-input"
          .value="${currentValue}"
          ?readOnly="${readOnly}"
          ?disabled="${disabled}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          title="Enter authorization scopes for this API endpoint"
          .invalidMessage="${_invalidMessage}"
          @value-changed="${this._currentValueHandler}"
          @keydown="${this._keyDown}">
          <label slot="label">Scope value</label>
          <anypoint-icon-button
            class="add-button"
            data-action="add-scope"
            slot="suffix"
            @click="${this._appendScope}"
            ?disabled="${readOnly || disabled}"
            aria-label="Press to add current scope to the list"
            title="Add scope">
            <iron-icon icon="arc:add-circle-outline"></iron-icon>
          </anypoint-icon-button>
        </anypoint-input>

        ${_autocompleteScopes && _autocompleteScopes.length ?
          html`<anypoint-autocomplete
          .target="${_inputTarget}"
          .source="${_autocompleteScopes}"
          @selected="${this._suggestionSelected}"
        ></anypoint-autocomplete>` : ''}
      </div>

      <ul class="scopes-list">
        ${this._scopesListTemplate()}
      </ul>
    </div>
    <paper-toast missing-scope text="Enter scope value to add a scope."></paper-toast>
    <paper-toast dissalowed text="You can't enter this scope. Use one of the provided scopes."></paper-toast>
`;
  }

  static get properties() {
    return {
      /**
       * List of scopes entered by the user. It can be used it pre-select scopes
       * by providing an array with scope values.
       */
      value: { type: Array },
      /**
       * Form input name
       */
      name: { type: String },
      /**
       * Current value entered by the user. This is not a scope and it is not
       * yet in the scopes list. User has to accept the scope before it become
       * available in the scopes list.
       */
      currentValue: { type: String },
      // Target for `anypoint-autocomplete`
      _inputTarget: { type: Object },
      /**
       * List of available scopes.
       * It can be either list of string or list of object. If this is the
       * list of object then this expects to each object contain a `label`
       * and `description` keys.
       *
       * ### Example
       * ```
       * {
       *   'label': 'user',
       *   'description': 'Grants read/write access to profile info only. '
       * }
       * ```
       * When the description is provided it will be displayed below the name
       * of the scope.
       */
      allowedScopes: { type: Array },
      // If true then scopes that are in the `allowedScopes` list will be
      // allowed to be add.
      preventCustomScopes: { type: Boolean },
      // Computed value, true if the `allowedScopes` is a list of objects
      _allowedIsObject: { type: Boolean },
      /**
       * Set to true to auto-validate the input value when it changes.
       */
      autoValidate: { type: Boolean },
      /**
       * List of scopes to be set as autocomplete source.
       */
      _autocompleteScopes: { type: Array },
      /**
       * Returns true if the value is invalid.
       *
       * If `autoValidate` is true, the `invalid` attribute is managed automatically,
       * which can clobber attempts to manage it manually.
       */
      invalid: { type: Boolean, reflect: true },
      /**
       * Set to true to mark the input as required.
       */
      required: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set the editor is in disabled mode.
       */
      disabled: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get _invalidMessage() {
    let message;
    if (this.allowedScopes) {
      message = 'Entered value is not allowed';
    } else if (this.required) {
      message = 'Scope value is required';
    }
    return message;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._value = value;
    this.requestUpdate('value', old);
    this._handleAutoValidate(this.autoValidate, value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get allowedScopes() {
    return this._allowedScopes;
  }

  set allowedScopes(value) {
    const old = this._allowedScopes;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._allowedScopes = value;
    this._allowedIsObject = this._computeAllowedIsObject(value);
    this._autocompleteScopes = this._normalizeScopes(value);
  }

  get invalid() {
    return this._invalid;
  }

  set invalid(value) {
    const old = this._invalid;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._invalid = value;
    this.requestUpdate('invalid', old);
    this._invalidChanged(value);
    this.dispatchEvent(new CustomEvent('invalid-changed', {
      detail: {
        value
      }
    }));
  }

  constructor() {
    super();

    this.value = [];
  }

  firstUpdated() {
    this._inputTarget = this.shadowRoot.querySelector('.scope-input');
  }

  _invalidChanged(invalid) {
    this.setAttribute('aria-invalid', invalid);
  }

  // Add currently entered scope value to the scopes list.
  _appendScope() {
    const value = this.currentValue;
    if (!value) {
      this.shadowRoot.querySelector('paper-toast[missing-scope]').opened = true;
      return;
    }
    this.currentValue = '';
    this.append(value);
  }
  // Remove scope button click handler
  _removeScope(e) {
    const index = Number(e.currentTarget.dataset.index);
    if (index !== index || !this.value) {
      return;
    }
    this.value.splice(index, 1);
    this.value = [...this.value];
  }
  /**
   * Handler for the `anypoint-autocomplete` selected event.
   *
   * @param {Event} e
   */
  _suggestionSelected(e) {
    e.preventDefault();

    const scope = e.detail.value;
    this.append(scope);
    setTimeout(() => {
      this.currentValue = '';
    });
  }
  /**
   * Adds a scope to the list. The same as pushing item to the `scopes`
   * array but it will check for duplicates first.
   *
   * @param {String} scope Scope value to append
   */
  append(scope) {
    const scopeValue = typeof scope === 'string' ? scope : scope.value;
    if (!scopeValue) {
      return;
    }
    const all = this.value || [];
    let index = all.indexOf(scopeValue);
    if (index !== -1) {
      return;
    }
    const as = this.allowedScopes;
    if (as && as.length) {
      index = this._findAllowedScopeIndex(scopeValue);
      if (index === -1 && this.preventCustomScopes) {
        this.shadowRoot.querySelector('paper-toast[dissalowed]').opened = true;
        return;
      }
    }
    all.push(scopeValue);
    this.value = [...all];
  }
  /**
   * Finds an index if the `scope` in the `allowedScopes` list.
   *
   * @param {String} scope A scope value (label) to find.
   * @return {Number} An index of scope or `-1` if not found.
   */
  _findAllowedScopeIndex(scope) {
    let index = -1;
    const scopes = this.allowedScopes;
    if (!scopes || !scopes.length || !scope) {
      return index;
    }
    if (this._allowedIsObject) {
      index = scopes.findIndex((item) => item.label === scope);
    } else {
      index = this.allowedScopes.indexOf(scope);
    }
    return index;
  }
  // A handler for the input's key down event. Handles ENTER press.
  _keyDown(e) {
    if (e.key !== 'Enter') {
      return;
    }
    const ac = this.shadowRoot.querySelector('anypoint-autocomplete');
    if (ac && ac.opened) {
      return;
    }
    this._appendScope();
    this.currentValue = '';
  }
  /**
   * Normalizes scopes to use it with autocomplete element.
   *
   * @param {Array} scopes List of autocomplete values. Can be list of
   * strings or objects
   * @return {Array} Normalized scopes list for autocomplete.
   */
  _normalizeScopes(scopes) {
    if (!scopes || !scopes.length) {
      return undefined;
    }
    return scopes.map((item) => {
      if (typeof item === 'string') {
        return item;
      }
      return {
        'display': item.label,
        'value': item.label,
      };
    });
  }
  /**
   * Compute function for the _allowedIsObject. Check first item of the
   * `allowedScopes` array if it is an object (return `true`) or
   * string (return `false`);
   * @param {Array<String>|Array<Object>} allowedScopes
   * @return {Boolean}
   */
  _computeAllowedIsObject(allowedScopes) {
    if (!allowedScopes || !allowedScopes.length) {
      return false;
    }
    const first = allowedScopes[0];
    return typeof first !== 'string';
  }
  /**
   * Returns a description for the selected scope.
   *
   * @param {String} scope Scope name
   * @param {Boolean} allowedIsObject True if allowed scopes is an object.
   * @return {String} Description of the scope or `` (empty string) if the
   * item do not exists.
   */
  _computeItemDescription(scope, allowedIsObject) {
    if (!allowedIsObject) {
      return;
    }
    const index = this._findAllowedScopeIndex(scope);
    if (index === -1) {
      return '';
    }
    return this.allowedScopes[index].description;
  }
  /**
   * Returns false if the element is required and does not have a selection,
   * and true otherwise.
   *
   * @return {boolean} true if `required` is false, or if `required` is true
   * and the element has a valid selection.
   */
  _getValidity() {
    const {
      value,
      disabled,
      required,
      allowedScopes
    } = this;
    const hasValue = !!(value && value.length);
    const valid = disabled || !required || (required && hasValue);
    if (!valid || !hasValue || !allowedScopes) {
      return valid;
    }
    for (let i = 0, len = value.length; i < len; i++) {
      const scope = value[i];
      const index = this._findAllowedScopeIndex(scope);
      if (index === -1) {
        return false;
      }
    }
    return true;
  }

  _handleAutoValidate(autoValidate) {
    if (autoValidate) {
      this.invalid = !this._getValidity();
    }
  }

  _currentValueHandler(e) {
    this.currentValue = e.detail.value;
  }
}
window.customElements.define('oauth2-scope-selector', OAuth2ScopeSelector);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The `<auth-method-oauth2>` element displays a form to provide the OAuth 2.0 settings.
 *
 * ### Example
 *
 * ```html
 * <auth-method-oauth2></auth-method-oauth2>
 * ```
 *
 * This element uses `oauth2-scope-selector` so the `allowedScopes`, `preventCustomScopes` and
 * `scopes` properties will be set on this element. See documentation of `oauth2-scope-selector`
 * for more description.

 * ### Forcing the user to select scope from the list
 *
 * ```html
 * <auth-method-oauth2 prevent-custom-scopes></auth-method-oauth2>
 * ```
 *
 * ```javascript
 * var form = document.querySelector('auth-method-oauth2');
 * form.allowedScopes = ['profile', 'email'];
 * ```
 *
 * ## Authorizing the user
 * The element sends the `oauth2-token-requested` with the OAuth settings provided with the form.
 * Any element / app can handle this event and perform authorization.
 * *
 * When the authorization is performed the app / other element should set back `accessToken` property
 * of this element or send the `oauth2-token-response` with token response value so the change will
 * can reflected in the UI.
 * ARC provides the `oauth2-authorization` element that can handle this events.
 *
 * ### Example
 *
 * ```html
 * <auth-method-oauth2></auth-method-oauth2>
 * <oauth2-authorization></oauth2-authorization>
 * ```
 *
 * The `oauth2-authorization` can be set anywhere in the DOM up from this element siblings to the
 * body. See demo for example usage.
 *
 ## Redirect URL
 * Most OAuth 2 providers requires setting the redirect URL with the request. This can't be changed
 * by the user and redirect URL can be only set in the provider's settings panel. The element
 * accepts the `redirectUri` property which will be displayed to the user that (s)he has to set up
 * this callback URL in the OAuth provider settings. It can be any URL where token / code will be
 * handled properly and the value returned to the `oauth2-authorization` element.
 * See `oauth2-authorization` documentation for more information.
 *
 * If you going to use `oauth2-authorization` popup then the redirect URL value must be set to:
 * `/bower_components/oauth-authorization/oauth-popup.html`. Mind missing `2` in `oauth-authorization`.
 * This popup is a common popup for auth methods.
 *
 * ### OAuth 2.0 extensibility
 *
 * As per [RFC6749, section 8](https://tools.ietf.org/html/rfc6749#section-8) OAuth 2.0
 * protocol can be extended by custom `grant_type`, custom query parameters and custom headers.
 *
 * This is not yet supported in RAML. However, working together with RAML spec creators,
 * an official RAML annotation to extend OAuth 2.0 settings has been created.
 * The annotation source can be found in the [RAML organization repository]
 * (https://github.com/raml-org/raml-annotations/blob/master/annotations/security-schemes/oauth-2-custom-settings.raml).
 *
 * When the annotation is applied to the `ramlSettings` property, this element renders
 * additional form inputs to support custom schemes.
 *
 * This produces additional property in the token authorization request: `customData`.
 * The object contains user input from custom properties.
 * *
 * #### `customData` model
 *
 * ```json
 * customData: {
 *  auth: {
 *    parameters: Array|undefined
 *  },
 *  token: {
 *    parameters: Array|undefined,
 *    headers: Array|undefined,
 *    body: Array|undefined
 *  }
 * }
 * ```
 * `auth` contains properties to be applied to the authorization request.
 * Only query parameetrs are (and can be) supported.
 *
 * `token` property contains properties to be applied when making token request.
 * It can include `parameters` as a query parameters, `headers` as a list
 * of headers to apply, and `body` as a list of properties to send with
 * body.
 *
 * Note: `body` content type is always `application/x-www-form-urlencoded`.
 * `customData.token.body` parameters must not be url encoded. Processors
 * handing token request should handle values encoding.
 *
 * #### Annotation example
 *
 * ```yaml
 *  annotationTypes:
 *    customSettings: !include oauth-2-custom-settings.raml
 *  securitySchemes:
 *    oauth2:
 *      type: OAuth 2.0
 *      describedBy:
 *        headers:
 *          Authorization:
 *            example: "Bearer token"
 *      settings:
 *        (customSettings):
 *          authorizationSettings:
 *            queryParameters:
 *              resource:
 *                type: string
 *                required: true
 *                description: |
 *                  A resource ID that defines a domain of authorization.
 *          accessTokenSettings:
 *            body:
 *              resource:
 *                type: string
 *                required: true
 *                description: |
 *                  A resource ID that defines a domain of authorization.
 *        accessTokenUri: https://auth.domain.com/authorize
 *        authorizationUri: https://auth.domain.com/token
 *        authorizationGrants: [code]
 *     scopes: profile
 * ```
 *
 * ## clientId and clientSecret
 *
 * In RAML there's no way to set an example or demo clientId/secret for the
 * tools like API console. This component supports reading data from
 * Polymer's `iron-meta` component. Meta components creeated with
 * `oauth2-client-id` and `oauth2-client-secret` will be used to prepopulate
 * the form if the form doesn't contain this properties already.
 *
 * Note, values changed by the user are persistent per browser session
 * (until browser is closed). Refresing the page will restore user input
 * instead the one defined in `iron-meta` elements.
 *
 * ### Example
 *
 * ```html
 * <iron-meta key="oauth2-client-id" value="abcd"></iron-meta>
 * <iron-meta key="oauth2-client-secret" value="efgh"></iron-meta>
 * ```
 *
 * @customElement
 * @memberof UiElements
 * @appliesMixin AmfHelperMixin
 * @demo demo/oauth2.html
 * @demo demo/oauth2-amf.html Using AMF data model
 * @extends AuthMethodBase
 */
class AuthMethodOauth2 extends AmfHelperMixin(AuthMethodBase) {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      authStyles,
      css`:host {
        display: block;
        font-size: var(--arc-font-body1-font-size);
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
      }

      .form {
        flex: 1;
      }

      oauth2-scope-selector {
        margin: 24px 0;
        outline: none;
      }

      .grant-dropdown {
        width: auto;
        min-width: 320px;
      }

      .authorize-actions {
        display: flex;
        flex-direction: row;
        flex: 1;
        align-items: center;
      }

      .authorize-actions > anypoint-button {
        margin: 0;
      }

      .authorize-actions > anypoint-spinner {
        margin-left: 12px;
      }

      .token-info,
      .redirect-info {
        margin: 12px 8px;
        color: var(--auth-method-oauth2-redirect-info-color, rgba(0, 0, 0, 0.74));
      }

      .code {
        font-family: var(--arc-font-code-family);
        flex: 1;
        outline: none;
        cursor: text;
      }

      .token-label {
        font-weight: 500;
        font-size: 16px;
        margin: 12px 8px;
      }

      .current-token {
        margin-top: 12px;
      }

      .redirect-section,
      oauth2-scope-selector {
        box-sizing: border-box;
      }

      *[hiddable] {
        display: none;
      }

      *[data-grant="authorization_code"] *[data-visible~="authorization_code"],
      *[data-grant="client_credentials"] *[data-visible~="client_credentials"],
      *[data-grant="implicit"] *[data-visible~="implicit"],
      *[data-grant="password"] *[data-visible~="password"] {
        display: block;
      }

      form[is-custom-grant] *[data-visible] {
        display: block !important;
      }

      .field-value {
        display: flex;
        flex-direction: row;
        flex: 1;
        align-items: center;
      }

      api-property-form-item {
        flex: 1;
      }

      .error-toast {
        background-color: var(--warning-primary-color, #FF7043);
        color: var(--warning-contrast-color, #fff);
      }

      api-property-form-item[is-array] {
        margin-top: 8px;
      }

      .read-only-param-field {
         background-color: rgba(0, 0, 0, 0.12);
         display: block;
         white-space: pre-wrap;
         word-wrap: break-word;
         word-break: break-all;
         display: flex;
         flex-direction: row;
       }

       .read-only-param-field.padding {
         padding: 12px;
       }`
    ];
  }

  static get properties() {
    return {
      // Seleted authorization grand type.
      grantType: { type: String },
      /**
       * Computed value, true if the grant type is a cutom definition.
       */
      isCustomGrant: { type: Boolean },
      // The client ID for the auth token.
      clientId: { type: String },
      // The client secret. It to be used when selected server flow.
      clientSecret: { type: String },
      // The authorization URL to initialize the OAuth flow.
      authorizationUri: { type: String },
      // The access token URL to exchange code for token. It is used in server flow.
      accessTokenUri: { type: String },
      // The password. To be used with the password flow.
      password: { type: String },
      // The password. To be used with the password flow.
      username: { type: String },
      /**
       * A callback URL to be used with this element.
       * User can't change the callback URL and it will inform the user to setup OAuth to use
       * this value.
       *
       * This is relevant when selected flow is the browser flow.
       */
      redirectUri: { type: String },
      /**
       * List of user selected scopes.
       * It can be pre-populated with list of scopes (array of strings).
       */
      scopes: { type: Array },
      /**
       * List of pre-defined scopes to choose from. It will be passed to the `oauth2-scope-selector`
       * element.
       */
      allowedScopes: { type: Array },
      /**
       * If true then the `oauth2-scope-selector` will disallow to add a scope that is not
       * in the `allowedScopes` list. Has no effect if the `allowedScopes` is not set.
       */
      preventCustomScopes: { type: Boolean },
      // True when currently authorizing the user.
      _authorizing: { type: Boolean },
      /**
       * When the user authorized the app it should be set to the token value.
       * This element do not perform authorization. Other elements must intercept
       * `oauth2-token-requested` and perform the authorization.
       */
      accessToken: { type: String },
      /**
       * Received from the response token value.
       * By default it is "bearer" as the only one defined in OAuth 2.0
       * spec.
       * If the token response contains `tokenType` property this value is
       * updated.
       */
      tokenType: { type: String },
      /**
       * AMF json/ld mode describing security scheme.
       */
      amfSettings: { type: Object },

      // Currently available grant types.
      grantTypes: { type: Array },
      /**
       * The element automatically hides following fileds it the element has been initialized
       * with values for this fields (without user interaction):
       *
       * - autorization url
       * - token url
       * - scopes
       *
       * If all this values are set then the element sets `isAdvanced` attribute and sets
       * `advancedOpened` to false
       *
       * Setting this property will prevent this behavior.
       */
      noAuto: { type: Boolean },
      /**
       * If set it renders autorization url, token url and scopes as advanced options
       * which are then invisible by default. User can oen setting using the UI.
       */
      isAdvanced: { type: Boolean },
      /**
       * If true then the advanced options are opened.
       */
      advancedOpened: { type: Boolean },
      /**
       * If set, the grant typr selector will be hidden from the UI.
       */
      noGrantType: { type: Boolean },
      /**
       * List of query parameters to apply to authorization request.
       * This is allowed by the OAuth 2.0 spec as an extension of the
       * protocol.
       * This value is computed if the `ramlSettings` contains annotations
       * and one of it is `customSettings`.
       * See https://github.com/raml-org/raml-annotations for definition.
       */
      _authQueryParameters: { type: Array },
      /**
       * List of query parameters to apply to token request.
       * This is allowed by the OAuth 2.0 spec as an extension of the
       * protocol.
       * This value is computed if the `ramlSettings` contains annotations
       * and one of it is `customSettings`.
       * See https://github.com/raml-org/raml-annotations for definition.
       */
      _tokenQueryParameters: { type: Array },
      /**
       * List of headers to apply to token request.
       * This is allowed by the OAuth 2.0 spec as an extension of the
       * protocol.
       * This value is computed if the `ramlSettings` contains annotations
       * and one of it is `customSettings`.
       * See https://github.com/raml-org/raml-annotations for definition.
       */
      _tokenHeaders: { type: Array },
      /**
       * List of body parameters to apply to token request.
       * This is allowed by the OAuth 2.0 spec as an extension of the
       * protocol.
       * This value is computed if the `ramlSettings` contains annotations
       * and one of it is `customSettings`.
       * See https://github.com/raml-org/raml-annotations for definition.
       */
      _tokenBody: { type: Array },
      /**
       * Default delivery method of access token. Reported with
       * settings change event as `deliveryMethod`.
       *
       * This value is added to event's `settings` property.
       *
       * When setting AMF model, this value may change, if AMF description
       * forces different than default placement of the token.
       */
      oauthDeliveryMethod: { type: String },
      /**
       * Default parameter name that carries access token. Reported with
       * the settings change event as `deliveryName`.
       *
       * This value is added to event's `settings` property.
       *
       * When setting AMF model, this value may change, if AMF description
       * forces different than default parameter name for the token.
       */
      oauthDeliveryName: { type: String },
      /**
       * Renders slightly different view that is optymized for mobile
       * or narrow area on desktop.
       */
      narrow: { type: Boolean, reflect: true }
    };
  }

  get grantType() {
    return this._grantType || '';
  }

  set grantType(value) {
    if (this._sop('grantType', value)) {
      this.isCustomGrant = this._computeIsCustomGrant(value);
      if (value === 'password') {
        this.advancedOpened = true;
        this.isAdvanced = false;
      } else if (!this.isAdvanced) {
        this._autoHide();
      }
    }
  }

  get grantTypes() {
    return this._grantTypes;
  }

  set grantTypes(value) {
    /* istanbul ignore else */
    if (this._sop('grantTypes', value)) {
      if (value && value.length === 1) {
        this.noGrantType = true;
      } else {
        this.noGrantType = false;
      }
    }
  }

  get accessToken() {
    return this._accessToken;
  }

  set accessToken(value) {
    /* istanbul ignore else */
    if (this._sop('accessToken', value)) {
      this._storeSessionProperty(this.storeKeys.token, value);
    }
  }

  get tokenType() {
    return this._tokenType;
  }

  set tokenType(value) {
    /* istanbul ignore else */
    if (this._sop('tokenType', value)) {
      this._storeSessionProperty(this.storeKeys.tokenType, value);
    }
  }

  get amfSettings() {
    return this._amfSettings;
  }

  set amfSettings(value) {
    /* istanbul ignore else */
    if (this._sop('amfSettings', value)) {
      this._amfSettingsChanged();
    }
  }

  get _queryModelOpts() {
    return {
      valueDelimiter: '=',
      decodeValues: true
    };
  }

  get _headersModelOpts() {
    return {
      valueDelimiter: ':'
    };
  }

  /**
   * List of OAuth 2.0 grants.
   * This list can be extended by custom grants
   * @return {Array<Object>} List of objects with `type` and `label`
   * properties.
   */
  get _oauth2GrantTypes() {
    return [{
      type: 'implicit',
      label: 'Access token (browser flow)'
    }, {
      type: 'authorization_code',
      label: 'Authorization code (server flow)'
    }, {
      type: 'client_credentials',
      label: 'Client credentials'
    }, {
      type: 'password',
      label: 'Password'
    }];
  }

  constructor() {
    super('oauth2');
    this._oauth2ErrorHandler = this._oauth2ErrorHandler.bind(this);
    this._tokenSuccessHandler = this._tokenSuccessHandler.bind(this);
    this._headerChangedHandler = this._headerChangedHandler.bind(this);

    this.oauthDeliveryName = 'authorization';
    this.oauthDeliveryMethod = 'header';
    this.grantTypes = this._oauth2GrantTypes;
  }

  firstUpdated() {
    this._isInitialized = true;
    if (this.amfSettings) {
      this._amfSettingsChanged();
    }
    this._autoHide();
    this._autoRestore();
    if (!this._tokenType) {
      this._tokenType = 'Bearer';
    }
  }

  updated() {
    this._settingsChanged();
  }

  _attachListeners(node) {
    window.addEventListener('oauth2-error', this._oauth2ErrorHandler);
    window.addEventListener('oauth2-token-response', this._tokenSuccessHandler);
    node.addEventListener('request-header-changed', this._headerChangedHandler);
  }

  _detachListeners(node) {
    window.removeEventListener('oauth2-error', this._oauth2ErrorHandler);
    window.removeEventListener('oauth2-token-response', this._tokenSuccessHandler);
    node.removeEventListener('request-header-changed', this._headerChangedHandler);
  }
  /**
   * Overrides `AmfHelperMixin.__amfChanged`
   */
  __amfChanged() {
    this._amfSettingsChanged();
  }
  /**
   * This function hides all non-crucial fields that has been pre-filled when element has been
   * initialize (values not provided by the user). Hidden fields will be available under
   * "advanced" options.
   *
   * To prevent this behavior set `no-auto` attribute on this element.
   */
  _autoHide() {
    if (this.noAuto) {
      this.advancedOpened = true;
      return;
    }
    if (this.grantType === 'password') {
      this.advancedOpened = true;
    } else if (this.authorizationUri && this.accessTokenUri && !!(this.scopes && this.scopes.length)) {
      this.isAdvanced = true;
      this.advancedOpened = false;
    } else {
      this.advancedOpened = true;
    }
  }

  get storeKeys() {
    return {
      clientId: 'auth.methods.latest.client_id',
      clientSecret: 'auth.methods.latest.client_secret',
      authorizationUri: 'auth.methods.latest.auth_uri',
      accessTokenUri: 'auth.methods.latest.token_uri',
      username: 'auth.methods.latest.username',
      password: 'auth.methods.latest.password',
      token: 'auth.methods.latest.auth_token',
      tokenType: 'auth.methods.latest.tokenType'
    };
  }
  /**
   * Automatically restores value from session store if any exists.
   * It does not override values already set.
   */
  _autoRestore() {
    const keys = this.storeKeys;
    this._restoreSessionProperty(keys.clientId, 'clientId');
    this._restoreSessionProperty(keys.token, 'accessToken');
    this._restoreSessionProperty(keys.tokenType, 'tokenType');
    this._restoreSessionProperty(keys.authorizationUri, 'authorizationUri');
    this._restoreSessionProperty(keys.accessTokenUri, 'accessTokenUri');
    this._restoreSessionProperty(keys.clientSecret, 'clientSecret');
    this._restoreSessionProperty(keys.username, 'username');
    this._restoreSessionProperty(keys.password, 'password');
    if (!this.clientId) {
      this._restoreMetaClientId();
    }
    if (!this.clientSecret) {
      this._restoreMetaClientSecret();
    }
  }
  /**
   * Sets `clientId` property from `iron-meta` if created.
   * The key for the meta is `oauth2-client-id`
   */
  _restoreMetaClientId() {
    const meta = document.createElement('iron-meta').byKey('oauth2-client-id');
    if (!meta) {
      return;
    }
    this.clientId = meta;
  }
  /**
   * Sets `clientSecret` property from `iron-meta` if created.
   * The key for the meta is `oauth2-client-secret`
   */
  _restoreMetaClientSecret() {
    const meta = document.createElement('iron-meta').byKey('oauth2-client-secret');
    if (!meta) {
      return;
    }
    this.clientSecret = meta;
  }
  /**
   * Validates the form.
   *
   * @return {Boolean} `true` if valid, `false` otherwise.
   */
  validate() {
    const form = this.shadowRoot.querySelector('iron-form');
    /* istanbul ignore if */
    if (!form) {
      return true;
    }
    return form.validate();
  }

  // Checks if the HTML element should be visible in the UI for given properties.
  _isFieldDisabled(...args) {
    const isCustom = args.splice(0, 1)[0];
    if (isCustom) {
      return false;
    }
    const grantType = args.splice(0, 1)[0];
    return args.indexOf(grantType) === -1;
  }
  /**
   * Dispatches the `oauth2-token-requested` event.
   * The event is handled by `oauth-authorization` component.
   *
   * If your application has own OAuth2 token exchange system then
   * handle the event and authorize the user.
   *
   * @return {Boolean} True if event was sent. Can be false if event is not
   * handled or when the form is invalid.
   */
  authorize() {
    const validationResult = this.validate();
    if (!validationResult) {
      this._errorToast('Authorization form is not valid.');
      return false;
    }
    const detail = this.getSettings();
    this._lastState = this.generateState();
    detail.state = this._lastState;
    this._authorizing = true;
    const e = new CustomEvent('oauth2-token-requested', {
      detail: detail,
      bubbles: true,
      composed: true,
      cancelable: true
    });
    this.dispatchEvent(e);
    this._analyticsEvent('auth-method-oauth2', 'usage-authorize', 'requested');
    if (!e.defaultPrevented) {
      this._errorToast('The application did not handled token request correctly.');
      this._authorizing = false;
      return false;
    }
    return true;
  }
  /**
   * Displays an error message in error toast
   * @param {String} message Message to display.
   */
  _errorToast(message) {
    const toast = this.shadowRoot.querySelector('paper-toast.error-toast');
    toast.text = message;
    toast.opened = true;
  }

  /**
   * Generates `state` parameter for the OAuth2 call.
   *
   * @return {String} Generated state string.
   */
  generateState() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    for (let i = 0; i < 6; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }

  /**
   * Returns current configuration of the OAuth2.
   *
   * @return {Object} Current OAuth2 configuration.
   */
  getSettings() {
    const detail = {
      type: this.grantType,
      clientId: this.clientId,
      accessToken: this.accessToken || '',
      tokenType: this.tokenType,
      scopes: this.scopes,
      customData: {
        auth: {},
        token: {}
      },
      deliveryMethod: this.oauthDeliveryMethod,
      deliveryName: this.oauthDeliveryName
    };
    switch (this.grantType) {
      case 'implicit':
        // The browser flow.
        detail.authorizationUri = this.authorizationUri;
        detail.redirectUri = this.redirectUri;
        this._computeAuthCustomData(detail);
        delete detail.customData.token;
        break;
      case 'authorization_code':
        // The server flow.
        detail.authorizationUri = this.authorizationUri;
        detail.clientSecret = this.clientSecret;
        detail.accessTokenUri = this.accessTokenUri;
        detail.redirectUri = this.redirectUri;
        this._computeAuthCustomData(detail);
        this._computeTokenCustomData(detail);
        break;
      case 'client_credentials':
        // The server flow.
        detail.accessTokenUri = this.accessTokenUri;
        this._computeTokenCustomData(detail);
        delete detail.customData.auth;
        break;
      case 'password':
        // The server flow.
        detail.username = this.username;
        detail.password = this.password;
        detail.accessTokenUri = this.accessTokenUri;
        this._computeTokenCustomData(detail);
        delete detail.customData.auth;
        break;
      default:
        // Custom grant type.
        detail.authorizationUri = this.authorizationUri;
        detail.clientSecret = this.clientSecret;
        detail.accessTokenUri = this.accessTokenUri;
        detail.redirectUri = this.redirectUri;
        detail.username = this.username;
        detail.password = this.password;
        this._computeAuthCustomData(detail);
        this._computeTokenCustomData(detail);
        break;
    }
    return detail;
  }
  /**
   * Adds `customData` property values that can be applied to the
   * authorization request.
   *
   * @param {Object} detail Token request detail object. The object is passed
   * by reference so no need for return value
   */
  _computeAuthCustomData(detail) {
    const params = this._authQueryParameters;
    if (params) {
      detail.customData.auth.parameters =
      this._computeCustomParameters(params);
    }
  }
  /**
   * Adds `customData` property values that can be applied to the
   * token request.
   *
   * @param {Object} detail Token request detail object. The object is passed
   * by reference so no need for return value
   */
  _computeTokenCustomData(detail) {
    const {
      _tokenQueryParameters,
      _tokenHeaders,
      _tokenBody
    } = this;
    if (_tokenQueryParameters) {
      detail.customData.token.parameters =
        this._computeCustomParameters(_tokenQueryParameters);
    }
    if (_tokenHeaders) {
      detail.customData.token.headers =
        this._computeCustomParameters(_tokenHeaders);
    }
    if (_tokenBody) {
      detail.customData.token.body =
        this._computeCustomParameters(_tokenBody);
    }
  }
  /**
   * Computes list of parameter values from current model.
   *
   * This function ignores empty values if they are not required.
   * Required property are always included, even if the value is not set.
   *
   * @param {Array} params Model for form inputs.
   * @return {Array|undefined} Array of objects with `name` and `value`
   * properties or undefined if `params` is empty or no values are available.
   */
  _computeCustomParameters(params) {
    if (!params || !params.length) {
      return;
    }
    const result = [];
    params.forEach((item) => {
      const value = item.value;
      if (!item.required) {
        const type = typeof value;
        if (type === 'number') {
          if (!value && value !== 0) {
            return;
          }
        } else if (type === 'string') {
          if (!value) {
            return;
          }
        } else if (value instanceof Array) {
          if (!value[0]) {
            return;
          }
        } else if (type === 'undefined') {
          return;
        }
      }
      result.push({
        name: item.name,
        value: item.value || ''
      });
    });
    if (result.length === 0) {
      return;
    }
    return result;
  }
  /**
   * Restores settings from stored value.
   *
   * @param {Object} settings Object returned by `getSettings()`
   */
  restore(settings) {
    this.grantType = settings.type;
    this.clientId = settings.clientId;
    this.accessToken = settings.accessToken;
    this.scopes = settings.scopes;
    switch (this.grantType) {
      case 'implicit':
        this.authorizationUri = settings.authorizationUri;
        break;
      case 'authorization_code':
        this.authorizationUri = settings.authorizationUri;
        this.clientSecret = settings.clientSecret;
        this.accessTokenUri = settings.accessTokenUri;
        break;
      case 'client_credentials':
        // The server flow.
        this.clientSecret = settings.clientSecret;
        this.accessTokenUri = settings.accessTokenUri;
        break;
      case 'password':
        // The server flow.
        this.username = settings.username;
        this.password = settings.password;
        this.accessTokenUri = settings.accessTokenUri;
        break;
      default:
        this.authorizationUri = settings.authorizationUri;
        this.clientSecret = settings.clientSecret;
        this.accessTokenUri = settings.accessTokenUri;
        this.username = settings.username;
        this.password = settings.password;
    }
  }
  /**
   * Handler for `oauth2-error` custom event.
   * Informs the user about the error in the flow if the state property
   * is the one used with the request.
   *
   * @param {CustomEvent} e
   */
  _oauth2ErrorHandler(e) {
    const info = e.detail;
    // API console may not support state check (may not return it back)
    if (typeof info.state !== 'undefined') {
      if (info.state !== this._lastState) {
        return;
      }
    }
    this._authorizing = false;
    this._lastState = undefined;
    this._errorToast(info.message);
    this._analyticsEvent('auth-method-oauth2', 'usage-authorize', 'failure');
  }
  /**
   * Handler for the token response from the authorization component.
   *
   * @param {CustomEvent} e
   */
  _tokenSuccessHandler(e) {
    const info = e.detail;
    // API console may not support state check (mey not return it back)
    if (typeof info.state !== 'undefined') {
      if (info.state !== this._lastState) {
        return;
      }
    }
    this._authorizing = false;
    this._lastState = undefined;
    if (info.accessToken && info.accessToken !== this.accessToken) {
      if (info.tokenType && info.tokenType !== this.tokenType) {
        this.tokenType = info.tokenType;
      } else if (!info.tokenType && this.tokenType !== 'Bearer') {
        this.tokenType = 'Bearer';
      }
      this.accessToken = info.accessToken;
      this.dispatchEvent(new CustomEvent('oauth2-token-ready', {
        detail: {
          token: info.accessToken,
          tokenType: this.tokenType
        },
        bubbles: true,
        composed: true
      }));
    }
    this._analyticsEvent('auth-method-oauth2', 'usage-authorize', 'success');
  }
  /**
   * Handler to set up data from the AMF model.
   */
  _amfSettingsChanged() {
    if (!this._isInitialized) {
      return;
    }
    const model = this.amfSettings;
    const prefix = this.ns.raml.vocabularies.security;
    if (!this._hasType(model, prefix + 'ParametrizedSecurityScheme')) {
      this._setupOAuthDeliveryMethod();
      this._updateGrantTypes();
      return;
    }
    const shKey = this._getAmfKey(prefix + 'scheme');
    let scheme = model[shKey];
    let type;
    if (scheme) {
      if (scheme instanceof Array) {
        scheme = scheme[0];
      }
      type = this._getValue(scheme, prefix + 'type');
    }
    const isOauth2 = type === 'OAuth 2.0';
    if (!isOauth2) {
      this._setupOAuthDeliveryMethod();
      this._updateGrantTypes();
      return;
    }
    this._setupOAuthDeliveryMethod(scheme);
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.security + 'settings');
    let settings = scheme[sKey];
    if (settings instanceof Array) {
      settings = settings[0];
    }
    this.__cancelChangeEvent = true;
    this._preFillAmfData(settings);
    this.__cancelChangeEvent = false;
    this._autoHide();
  }

  _setupOAuthDeliveryMethod(model) {
    const info = this._getOauth2DeliveryMethod(model);
    if (this.oauthDeliveryMethod !== info.method) {
      this.oauthDeliveryMethod = info.method;
    }
    if (this.oauthDeliveryName !== info.name) {
      this.oauthDeliveryName = info.name;
    }
  }
  /**
   * Determines placemenet of OAuth authorization token location.
   * It can be either query parameter or header. This function
   * reads API spec to get this information or provides default if
   * not specifies.
   *
   * @param {Object} info Security AMF model
   * @return {Object}
   */
  _getOauth2DeliveryMethod(info) {
    const result = {
      method: 'header',
      name: 'authorization'
    };
    if (!info) {
      return result;
    }
    const http = this.ns.raml.vocabularies.http;
    const hKey = this._getAmfKey(http + 'header');
    const pKey = this._getAmfKey(http + 'parameter');
    const nKey = this._getAmfKey(this.ns.schema.schemaName);
    let header = info[hKey];
    if (header instanceof Array) {
      header = header[0];
    }
    if (header) {
      const headerName = this._getValue(header, nKey);
      if (headerName) {
        result.name = headerName;
        return result;
      }
    }
    let parameter = info[pKey];
    if (parameter instanceof Array) {
      parameter = parameter[0];
    }
    if (parameter) {
      const paramName = this._getValue(parameter, nKey);
      if (paramName) {
        result.name = paramName;
        result.method = 'query';
        return result;
      }
    }
    return result;
  }
  /**
   * Reads API security definition and applies in to the view as predefined
   * values.
   *
   * @param {Object} model AMF model describing settings of the security
   * scheme
   */
  _preFillAmfData(model) {
    if (!model) {
      return;
    }
    const sec = this.ns.raml.vocabularies.security;
    if (!this._hasType(model, sec + 'OAuth2Settings')) {
      return;
    }
    this.authorizationUri = this._getValue(model, sec + 'authorizationUri') || '';
    this.accessTokenUri = this._getValue(model, sec + 'accessTokenUri') || '';
    this.scopes = this._redSecurityScopes(model[this._getAmfKey(sec + 'scope')]);
    const apiGrants = this._getValueArray(model, sec + 'authorizationGrant');
    const annotationKey = this._amfCustomSettingsKey(model);
    const annotation = annotationKey ? model[annotationKey] : undefined;
    const grants = this._applyAnnotationGranst(apiGrants, annotation);
    if (grants && grants instanceof Array && grants.length) {
      const index = grants.indexOf('code');
      if (index !== -1) {
        grants[index] = 'authorization_code';
      }
      this._updateGrantTypes(grants);
    } else {
      this._updateGrantTypes();
    }
    this._setupAnotationParameters(annotation);
  }
  /**
   * Extracts scopes list from the security definition
   * @param {Array} model
   * @return {Array<String>|undefined}
   */
  _redSecurityScopes(model) {
    model = this._ensureArray(model);
    if (!model) {
      return;
    }
    const result = [];
    for (let i = 0, len = model.length; i < len; i++) {
      const value = this._getValue(model[i], this.ns.raml.vocabularies.security + 'name');
      if (!value) {
        continue;
      }
      result.push(value);
    }
    return result;
  }
  /**
   * Finds a key for Custom settings
   * @param {Object} model Security scheme settings object.
   * @return {String|undefined}
   */
  _amfCustomSettingsKey(model) {
    const keys = Object.keys(model);
    const data = this.ns.raml.vocabularies.data;
    const settingsKeys = [
      this._getAmfKey(data + 'authorizationSettings'),
      this._getAmfKey(data + 'authorizationGrants'),
      this._getAmfKey(data + 'accessTokenSettings')
    ];
    for (let i = 0; i < keys.length; i++) {
      const node = model[keys[i]];
      if (node[settingsKeys[0]] || node[settingsKeys[1]] || node[settingsKeys[2]]) {
        return keys[i];
      }
    }
  }
  /**
   * Applies `authorizationGrants` from OAuth2 settings annotation.
   *
   * @param {Array} gransts OAuth spec grants available for the endpoint
   * @param {?Object} annotation Read annotation.
   * @return {Array} List of granst to apply.
   */
  _applyAnnotationGranst(gransts, annotation) {
    if (!annotation) {
      return gransts;
    }
    if (!gransts) {
      gransts = [];
    }
    const d = this.ns.raml.vocabularies.data;
    let model = annotation[this._getAmfKey(d + 'authorizationGrants')];
    model = this._ensureArray(model);
    if (!model || !model.length) {
      return gransts;
    }
    const list = model[0][this._getAmfKey(this.ns.w3.name + '1999/02/22-rdf-syntax-ns#member')];
    const addedGrants = [];
    list.forEach((item) => {
      const v = this._getValue(item, d + 'value');
      if (!v) {
        return;
      }
      addedGrants.push(v);
    });
    if (!addedGrants.length) {
      return gransts;
    }
    const ignoreKey = d + 'ignoreDefaultGrants';
    if (typeof annotation[ignoreKey] !== 'undefined') {
      gransts = [];
    }
    gransts = gransts.concat(addedGrants);
    return gransts;
  }
  /**
   * Sets up annotation supported variables to apply form view for:
   * - authorization query parameters
   * - authorization headers
   * - token query parameters
   * - token headers
   * - token body
   *
   * @param {Object} annotation Annotation applied to the OAuth settings
   */
  _setupAnotationParameters(annotation) {
    /* istanbul ignore if */
    if (this._authQueryParameters) {
      this._authQueryParameters = undefined;
    }
    /* istanbul ignore if */
    if (this._tokenQueryParameters) {
      this._tokenQueryParameters = undefined;
    }
    /* istanbul ignore if */
    if (this._tokenHeaders) {
      this._tokenHeaders = undefined;
    }
    /* istanbul ignore if */
    if (this._tokenBody) {
      this._tokenBody = undefined;
    }
    /* istanbul ignore if */
    if (!annotation) {
      return;
    }
    const d = this.ns.raml.vocabularies.data;
    const qpKey = this._getAmfKey(d + 'queryParameters');
    let authSettings = annotation[this._getAmfKey(d + 'authorizationSettings')];
    let tokenSettings = annotation[this._getAmfKey(d + 'accessTokenSettings')];
    if (authSettings) {
      if (authSettings instanceof Array) {
        authSettings = authSettings[0];
      }
      const qp = authSettings[qpKey];
      if (qp) {
        this._setupAuthRequestQueryParameters(qp);
      }
    }
    if (tokenSettings) {
      if (tokenSettings instanceof Array) {
        tokenSettings = tokenSettings[0];
      }
      const qp = tokenSettings[qpKey];
      const headers = tokenSettings[this._getAmfKey(d + 'headers')];
      const body = tokenSettings[this._getAmfKey(d + 'body')];
      if (qp) {
        this._setupTokenRequestQueryParameters(qp);
      }
      if (headers) {
        this._setupTokenRequestHeaders(headers);
      }
      if (body) {
        this._setupTokenRequestBody(body);
      }
    }
  }
  /**
   * Sets up query parameters to be used with authorization request.
   *
   * @param {Array} params List of parameters from the annotation.
   */
  _setupAuthRequestQueryParameters(params) {
    const model = this._createViewModel(params, this._queryModelOpts);
    /* istanbul ignore if */
    if (!model) {
      return;
    }
    this._authQueryParameters = model;
  }
  /**
   * Sets up query parameters to be used with token request.
   *
   * @param {Array} params List of parameters from the annotation.
   */
  _setupTokenRequestQueryParameters(params) {
    const model = this._createViewModel(params, this._queryModelOpts);
    /* istanbul ignore if */
    if (!model) {
      return;
    }
    this._tokenQueryParameters = model;
  }
  /**
   * Sets up headers to be used with token request.
   *
   * @param {Array} params List of parameters from the annotation.
   */
  _setupTokenRequestHeaders(params) {
    const model = this._createViewModel(params, this._headersModelOpts);
    /* istanbul ignore if */
    if (!model) {
      return;
    }
    this._tokenHeaders = model;
  }
  /**
   * Sets up body parameters to be used with token request.
   *
   * @param {Array} params List of parameters from the annotation.
   */
  _setupTokenRequestBody(params) {
    const model = this._createViewModel(params, this._queryModelOpts);
    /* istanbul ignore if */
    if (!model) {
      return;
    }
    this._tokenBody = model;
  }
  /**
   * Creats a form view model for type items.
   *
   * @param {Array|object} param Property or list of properties to process.
   * @param {Object} modelOptions
   * @return {Array|undefined} Form view model or undefined if not set.
   */
  _createViewModel(param, modelOptions) {
    /* istanbul ignore if */
    if (!param) {
      return;
    }
    if (param instanceof Array) {
      param = param[0];
    }
    const factory = document.createElement('api-view-model-transformer');
    factory.amf = this.amf;
    return factory.modelForRawObject(param, modelOptions);
  }
  /**
   * Computes value of `isCustomGrant` property when `grantType` changes.
   *
   * @param {String} grantType Selected grant type.
   * @return {Boolean} `true` if the `grantType` is none of the ones defined
   * by the OAuth 2.0 spec.
   */
  _computeIsCustomGrant(grantType) {
    return ['implicit', 'authorization_code', 'client_credentials', 'password']
        .indexOf(grantType) === -1;
  }
  /**
   * Updates list of OAuth grant types supported by current endpoint.
   * The information should be available in RAML file.
   *
   * @param {Array<String>?} supportedTypes List of supported types. If empty
   * or not set then all available types will be displayed.
   */
  _updateGrantTypes(supportedTypes) {
    const available = this._computeGrantList(supportedTypes);
    this.grantTypes = available;
    // check if current selection is still available
    const current = this.grantType;
    const hasCurrent = current ?
      available.some((item) => item.type === current) : false;
    if (!hasCurrent) {
      this.grantType = available[0].type;
    } else if (available.length === 1) {
      this.grantType = available[0].type;
    }
  }
  /**
   * Computes list of grant types to render in the form.
   *
   * @param {?Array<String>} allowed List of types allowed by the
   * component configuration or API spec applied to this element. If empty
   * or not set then all OAuth 2.0 default types are returned.
   * @return {Array<Object>}
   */
  _computeGrantList(allowed) {
    let defaults = this._oauth2GrantTypes;
    if (!allowed || !allowed.length) {
      return defaults;
    }
    allowed = Array.from(allowed);
    for (let i = defaults.length - 1; i >= 0; i--) {
      const index = allowed.indexOf(defaults[i].type);
      if (index === -1) {
        defaults.splice(i, 1);
      } else {
        allowed.splice(index, 1);
      }
    }
    if (allowed.length) {
      allowed = allowed.map(function(item) {
        return {
          label: item,
          type: item
        };
      });
      defaults = defaults.concat(allowed);
    }
    return defaults;
  }
  /**
   * Handler for the `request-header-changed` custom event.
   * If the panel is opened the it checks if current header updates
   * authorization.
   *
   * @param {Event} e
   */
  _headerChangedHandler(e) {
    /* istanbul ignore if */
    if (e.defaultPrevented || this._getEventTarget(e) === this) {
      return;
    }
    let name = e.detail.name;
    /* istanbul ignore if */
    if (!name) {
      return;
    }
    name = name.toLowerCase();
    if (name !== 'authorization') {
      return;
    }
    let value = e.detail.value;
    if (!value) {
      if (this.accessToken) {
        this.accessToken = '';
      }
      return;
    }
    const lowerValue = value.toLowerCase();
    const lowerType = (this.tokenType || 'bearer').toLowerCase();
    if (lowerValue.indexOf(lowerType) !== 0) {
      if (this.accessToken) {
        this.accessToken = '';
      }
      return;
    }
    value = value.substr(lowerType.length + 1).trim();
    this.accessToken = value;
  }

  _modelForCustomType(type) {
    let model;
    if (type === 'auth-query') {
      model = this._authQueryParameters;
    } else if (type === 'token-query') {
      model = this._tokenQueryParameters;
    } else if (type === 'token-headers') {
      model = this._tokenHeaders;
    } else {
      model = this._tokenBody;
    }
    return model;
  }
  /**
   * Toggles documentartion for custom property.
   *
   * @param {CustomEvent} e
   */
  _toggleDocumentation(e) {
    const index = Number(e.currentTarget.dataset.index);
    const type = e.currentTarget.dataset.type;
    if (index !== index || !type) {
      return;
    }
    const model = this._modelForCustomType(type);
    model[index].docsOpened = !model[index].docsOpened;
    this.requestUpdate();
  }
  /**
   * Dispatches analytics event.
   *
   * @param {String} category Event category
   * @param {String} action Event action
   * @param {String} label Event label
   */
  _analyticsEvent(category, action, label) {
    const e = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: category,
        action: action,
        label: label
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(e);
  }
  /**
   * A handler for `focus` event on a label that contains text and
   * should be coppied to clipboard when user is interacting with it.
   *
   * @param {ClickEvent} e
   */
  _clickCopyAction(e) {
    const node = e.target;
    const elm = this.shadowRoot.querySelector('clipboard-copy');
    elm.content = node.innerText;
    if (elm.copy()) {
      this.shadowRoot.querySelector('#clipboardToast').opened = true;
    }
    setTimeout(() => {
      if (document.body.createTextRange) {
        const range = document.body.createTextRange();
        range.moveToElementText(node);
        range.select();
      } else if (window.getSelection) {
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNode(node);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    });
  }

  _advHandler(e) {
    this._setSettingsInputValue('advancedOpened', e.target.checked);
  }

  _selectionHandler(e) {
    const { value } = e.detail;
    const { name } = e.target.parentElement;
    this._setSettingsInputValue(name, value);
  }

  _valueHandler(e) {
    const { name, value } = e.target;
    this._setSettingsInputValue(name, value);
    const persistent = e.target.dataset.persistent;
    if (persistent === 'true') {
      this._storeSessionProperty(this.storeKeys[name], value);
    }
  }

  _customValueChanged(e) {
    const index = Number(e.target.dataset.index);
    const type = e.target.dataset.type;
    /* istanbul ignore if */
    if (index !== index || !type) {
      return;
    }
    const value = e.target.value;
    const model = this._modelForCustomType(type);
    model[index].value = value;
    this._settingsChanged();
  }

  _scopesChanged(e) {
    this.scopes = e.detail.value;
  }

  _getGrantTypeTemplate() {
    const {
      grantType,
      outlined,
      compatibility,
      readOnly,
      disabled,
      noGrantType
    } = this;
    const items = this.grantTypes || [];
    return html`
    <anypoint-dropdown-menu
      name="grantType"
      required
      autovalidate
      class="grant-dropdown"
      ?hidden="${noGrantType}"
      .outlined="${outlined}"
      .compatibility="${compatibility}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
    >
      <label slot="label">Grant type</label>
      <anypoint-listbox
        slot="dropdown-content"
        .selected="${grantType}"
        @selected-changed="${this._selectionHandler}"
        data-name="grantType"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled="${disabled}"
        attrforselected="data-value">
        ${items.map((item) =>
    html`<anypoint-item .compatibility="${compatibility}" data-value="${item.type}">${item.label}</anypoint-item>`)}
      </anypoint-listbox>
    </anypoint-dropdown-menu>`;
  }

  _getCustomPropertiesTemplate() {
    const { _authQueryParameters, _tokenQueryParameters, _tokenHeaders, _tokenBody } = this;
    return html`
    ${_authQueryParameters && _authQueryParameters.length ?
      html`<div class="subtitle">Authorization request query parameters</div>
      ${this._templateForCustomArray(_authQueryParameters, 'auth-query')}` : ''}
    ${_tokenQueryParameters && _tokenQueryParameters.length ?
      html`<div class="subtitle">Token request query parameters</div>
      ${this._templateForCustomArray(_tokenQueryParameters, 'token-query')}` : ''}
    ${_tokenHeaders && _tokenHeaders.length ?
      html`<div class="subtitle">Token request headers</div>
      ${this._templateForCustomArray(_tokenHeaders, 'token-headers')}` : ''}
    ${_tokenBody && _tokenBody.length ?
      html`<div class="subtitle">Token request body</div>
      ${this._templateForCustomArray(_tokenBody, 'token-body')}` : ''}
    `;
  }

  _templateForCustomArray(items, type) {
    const {
      outlined,
      compatibility,
      readOnly,
      disabled,
      noDocs
    } = this;
    return items.map((item, index) => html`<div class="custom-data-field">
      <div class="field-value">
        <api-property-form-item
          .model="${item}"
          .value="${item.value}"
          name="${item.name}"
          ?readonly="${readOnly}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          ?disabled="${disabled}"
          data-type="${type}"
          data-index="${index}"
          @value-changed="${this._customValueChanged}"></api-property-form-item>
          ${item.hasDescription && !noDocs ? html`<anypoint-icon-button
            class="hint-icon"
            title="Toggle description"
            aria-label="Press to toggle description"
            data-type="${type}"
            data-index="${index}"
            @click="${this._toggleDocumentation}">
            <iron-icon icon="arc:help"></iron-icon>
          </anypoint-icon-button>` : undefined}
      </div>
      ${item.hasDescription && !noDocs && item.docsOpened ? html`<div class="docs-container">
        <arc-marked .markdown="${item.description}">
          <div slot="markdown-html" class="markdown-body"></div>
        </arc-marked>
      </div>` : ''}
    </div>`);
  }

  _getRedirectTemplate() {
    const {
      redirectUri
    } = this;
    return html`<div class="subtitle">Redirect URI</div>
    <section>
      <div class="redirect-section">
        <p class="redirect-info">Set this redirect URI in OAuth 2.0 provider settings.</p>
        <p class="read-only-param-field padding">
          <span class="code" @click="${this._clickCopyAction}">${redirectUri}</span>
        </p>
      </div>
    </section>`;
  }

  _getAdvancedTemplate(customGrantRequired) {
    const {
      outlined,
      compatibility,
      readOnly,
      disabled,
      isAdvanced,
      advancedOpened,
      grantType,
      isCustomGrant,
      authorizationUri,
      accessTokenUri,
      username,
      password,
      allowedScopes,
      preventCustomScopes,
      scopes
    } = this;
    const authUriDisabled = disabled ||
      this._isFieldDisabled(isCustomGrant, grantType, 'implicit', 'authorization_code');
    const atUriDisabled = disabled ||
      this._isFieldDisabled(isCustomGrant, grantType, 'client_credentials', 'authorization_code', 'password');
    const passwdDisabled = disabled ||
      this._isFieldDisabled(isCustomGrant, grantType, 'password');
    return html`
    ${isAdvanced ? html`<div class="adv-toggle">
      <div class="adv-toggle">
        <anypoint-checkbox
          class="adv-settings-input"
          .checked="${advancedOpened}"
          @change="${this._advHandler}"
          .disabled="${readOnly}"
        >Advanced settings</anypoint-checkbox>
      </div>
    </div>` : ''}

    <div class="advanced-section" ?hidden="${!advancedOpened}">
      <anypoint-input
        ?required="${customGrantRequired}"
        autovalidate
        name="authorizationUri"
        .value="${authorizationUri}"
        @input="${this._valueHandler}"
        type="url"
        autocomplete="on"
        hiddable
        data-persistent="true"
        data-visible="implicit authorization_code"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled="${authUriDisabled}"
        title="The authorization URL to initialize the OAuth flow. Check your provider's documentation"
        invalidmessage="Authorization URI is required for this grant type">
        <label slot="label">Authorization URI</label>
      </anypoint-input>

      <anypoint-input
        ?required="${customGrantRequired}"
        autovalidate
        name="accessTokenUri"
        .value="${accessTokenUri}"
        @input="${this._valueHandler}"
        type="url"
        autocomplete="on"
        hiddable
        data-persistent="true"
        data-visible="client_credentials authorization_code password"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled="${atUriDisabled}"
        title="The access token URL is used by server implementations to exchange code for access token"
        invalidmessage="Token URI is required for this grant type">
        <label slot="label">Access token URI</label>
      </anypoint-input>

      <anypoint-masked-input
        ?required="${customGrantRequired}"
        autovalidate
        name="username"
        .value="${username}"
        @input="${this._valueHandler}"
        autocomplete="on"
        hiddable
        data-persistent="true"
        data-visible="password"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled="${passwdDisabled}"
        title="The user name required for this OAuth authentication"
        invalidmessage="Username is required for this grant type">
        <label slot="label">Username</label>
      </anypoint-masked-input>

      <anypoint-masked-input
        ?required="${customGrantRequired}"
        autovalidate
        name="password"
        .value="${password}"
        @input="${this._valueHandler}"
        autocomplete="on"
        hiddable
        data-persistent="true"
        data-visible="password"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled="${passwdDisabled}"
        title="The password required for this OAuth authentication"
        invalidmessage="Password is required for this grant type">
        <label slot="label">Password</label>
      </anypoint-masked-input>

      <div>
        <oauth2-scope-selector
          .allowedScopes="${allowedScopes}"
          .preventCustomScopes="${preventCustomScopes}"
          .value="${scopes}"
          .readOnly="${readOnly}"
          .disabled="${disabled}"
          .outlined="${outlined}"
          .compatibility="${compatibility}"
          name="scopes"
          @value-changed="${this._scopesChanged}"></oauth2-scope-selector>
      </div>
    </div>
    `;
  }

  render() {
    const {
      outlined,
      compatibility,
      readOnly,
      disabled,
      grantType,
      isCustomGrant,
      clientId,
      clientSecret,
      accessToken,
      _authorizing
    } = this;

    const customGrantRequired = !isCustomGrant;
    const clientIdRequired = ['client_credentials', 'password'].indexOf(grantType) !== -1 ? false : customGrantRequired;
    const secretDisabled = disabled ||
      this._isFieldDisabled(isCustomGrant, grantType, 'client_credentials', 'authorization_code');
    const hasAccessToken = !!accessToken;
    return html`
    <iron-form data-grant="${grantType}">
      <form autocomplete="on" ?is-custom-grant="${isCustomGrant}">
          ${this._getGrantTypeTemplate()}
          <section>
            <anypoint-masked-input
              ?required="${clientIdRequired}"
              autovalidate
              name="clientId"
              .value="${clientId}"
              @input="${this._valueHandler}"
              autocomplete="on"
              data-persistent="true"
              hiddable
              data-visible="implicit authorization_code"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${disabled}"
              title="The client ID registered in your OAuth provider"
              invalidmessage="Client ID is required for this grant type">
              <label slot="label">Client id</label>
            </anypoint-masked-input>

            <anypoint-masked-input
              ?required="${clientIdRequired}"
              autovalidate
              name="clientSecret"
              .value="${clientSecret}"
              @input="${this._valueHandler}"
              autocomplete="on"
              hiddable
              data-persistent="true"
              data-visible="authorization_code"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${secretDisabled}"
              title="The client secret is a generated by your provider unique string for your app"
              invalidmessage="Client secret is required for this grant type">
              <label slot="label">Client secret</label>
            </anypoint-masked-input>
            ${this._getCustomPropertiesTemplate()}
            ${this._getAdvancedTemplate(customGrantRequired)}
          </section>
          ${this._getRedirectTemplate()}
      </form>
    </iron-form>

    ${hasAccessToken ?
      html`<div class="current-token">
        <label class="token-label">Current token</label>
        <p class="read-only-param-field padding">
          <span class="code" @click="${this._clickCopyAction}">${accessToken}</span>
        </p>
        <div class="authorize-actions">
          <anypoint-button
            ?disabled="${_authorizing}"
            class="auth-button"
            emphasis="medium"
            data-type="refresh-token"
            @click="${this.authorize}">Refresh access token</anypoint-button>
          <paper-spinner .active="${_authorizing}"></paper-spinner>
        </div>
      </div>` :
    html`<div class="authorize-actions">
      <anypoint-button
        ?disabled="${_authorizing}"
        class="auth-button"
        emphasis="medium"
        data-type="get-token"
        @click="${this.authorize}">Request access token</anypoint-button>
      <paper-spinner .active="${_authorizing}"></paper-spinner>
    </div>`}

    <paper-toast text="" duration="5000"></paper-toast>
    <paper-toast class="error-toast" text="" duration="5000"></paper-toast>
    <paper-toast text="Value copied to clipboard" id="clipboardToast" duration="2000"></paper-toast>
    <clipboard-copy></clipboard-copy>`;
  }
  /**
   * Fired when user requested to perform an authorization.
   * The details object vary depends on the `grantType` property.
   * However this event always fire two properties set on the `detail` object: `type` and
   * `clientId`.
   *
   * @event oauth2-token-requested
   * @param {String} type The type of grant option selected by the user. `implicit` is
   * the browser flow where token ir requested. `authorization_code` or server flow is where
   * client asks for the authorization code and exchange it later for the auth token using
   * client secret. Other options are `password` and `client_credentials`.
   * @param {String} clientId Every type requires `clientId`.
   * @param {String} authorizationUri Token authorization URL. Used in `implicit` and
   * `authorization_code` types. In both cases means the initial endpoint to request for token
   * or the authorization code.
   * @param {Array<String>} scopes A list of scopes seleted by the user. Used in `implicit`
   * and `authorization_code` types.
   * @param {String} redirectUri A redirect URL of the client after authorization (or error).
   * This must be set in the provider's OAuth settings. Callback URL must communicate with
   * the app to pass the information back to the application. User can't change the `redirectUri`
   * but the app shouldn't rely on this value since in browser environment it is possible to
   * temper with variables. The `redirectUri` must be set to this element by owner app (which
   * must know this value). A `redirectUri` is set for `implicit` and `authorization_code`
   * types.
   * @param {String} clientSecret The client secret that user can get from the OAuth provider
   * settings console. User in `authorization_code` and `client_credentials` types.
   * @param {String} accessTokenUri An URL to exchange code for the access token. Used by
   * `authorization_code`, `client_credentials` and `password` types.
   * @param {String} username Used with `password` type.
   * @param {String} password Used with `password` type.
   * @param {Object} customData Custom query parameters, headers and body applied
   * to the authorization or token request. See this element description for details.
   * @param {String} deliveryMethod Access token location in the request.
   * It can be either `header` or `query`. Defaults to header.
   * @param {String} deliveryName Name of the parmater to use to transport
   * the token. By default it is `authorization` for header value.
   */
  /**
   * Fired when the any of the auth method settings has changed.
   * This event will be fired quite frequently - each time anything in the text field changed.
   * With one exception. This event will not be fired if the validation of the form didn't passed.
   *
   * This event will set current settings as a detail object which are the same as for the
   * `oauth2-token-requested` event. Additionally it will contain a `accessToken` property. This
   * valye can be `undefined` if token hasn't been requested yet by the user.
   * Clients should support a situaltion when the user do not request the token before requesting
   * the resource and perform authorization.
   *
   * @event auth-settings-changed
   * @param {Object} settings See the `oauth2-token-requested` for detailed
   * description
   * @param {String} type The authentication type selected by the user.
   * @param {Boolean} valid True if the form has been validated.
   */
  /**
   * Fired when the request token has been obtained and it's ready to serve.
   * Because only one auth panel can be displayed ad a time it can be assumed
   * that if new token has been obtained then it is current authorization
   * method.
   *
   * @event oauth2-token-ready
   * @param {String} token The OAuth 2.0 token
   * @param {String} tokenType Token type reported by the server.
   */
}
window.customElements.define('auth-method-oauth2', AuthMethodOauth2);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The `<auth-method-oauth1>` element displays a form to provide the OAuth 1a settings.
 *
 * ### Example
 *
 * ```html
 * <auth-method-oauth1 consumer-key="xyz"></auth-method-oauth1>
 * ```
 *
 * ### Required form fields
 *
 * - Consumer key
 * - Timestamp
 * - Nonce
 * - Signature method
 *
 * ## Authorizing the user
 *
 * This element displays form for user input only. To perform authorization and
 * later to sign the request, add `oauth-authorization/oauth1-authorization.html`
 * to the DOM. This element sends `oauth1-token-requested` that is handled by
 * autorization element.
 *
 * Note that the OAuth1 authorization wasn't designed for browser. Most existing
 * OAuth1 implementation disallow browsers to perform the authorization by
 * not allowing POST requests to authorization server. Therefore receiving token
 * may not be possible without using browser extensions to alter HTTP request to
 * enable CORS.
 * If the server disallow obtaining authorization token and secret from clients
 * then the application should listen for `oauth1-token-requested` custom event
 * and perform authorization on the server side.
 *
 * When application is performing authorization instead of `oauth1-authorization`
 * element then the application should dispatch `oauth1-token-response` custom event
 * with `oauth_token` and `oauth_token_secret` properties set on detail object.
 * This element handles the response to reset UI state and to updates other elements
 * status that works with authorization.
 *
 * ## Signing the request
 *
 * See description for `oauth-authorization/oauth1-authorization.html` element.
 *
 * @customElement
 * @memberof UiElements
 * @appliesMixin ApiElements.AmfHelperMixin
 * @demo demo/oauth1.html
 * @extends AuthMethodBase
 */
class AuthMethodOauth1 extends AmfHelperMixin(AuthMethodBase) {
  static get styles() {
    return [
      authStyles,
      css`
      :host {
        display: block;
      }

      .form {
        max-width: 700px;
      }

      .grant-dropdown {
        width: 320px;
      }

      .authorize-actions {
        margin-top: 12px;
      }`
    ];
  }

  render() {
    const {
      authTokenMethod,
      authParamsLocation,
      consumerKey,
      consumerSecret,
      token,
      tokenSecret,
      requestTokenUri,
      accessTokenUri,
      authorizationUri,
      redirectUri,
      timestamp,
      nonce,
      realm,
      signatureMethod,
      signatureMethods,
      _authorizing,
      outlined,
      compatibility,
      readOnly,
      disabled
    } = this;
    const hasSignatureMethods = !!(signatureMethods && signatureMethods.length);
    return html`
    <div class="form">
      <iron-form>
        <form autocomplete="on">
          <anypoint-dropdown-menu
            name="authTokenMethod"
            required
            autovalidate
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
          >
            <label slot="label">Authorization token method</label>
            <anypoint-listbox
              slot="dropdown-content"
              .selected="${authTokenMethod}"
              @selected-changed="${this._selectionHandler}"
              data-name="authTokenMethod"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${disabled}"
              attrforselected="data-value">
              <anypoint-item .compatibility="${compatibility}" data-value="GET">GET</anypoint-item>
              <anypoint-item .compatibility="${compatibility}" data-value="POST">POST</anypoint-item>
            </anypoint-listbox>
          </anypoint-dropdown-menu>

          <anypoint-dropdown-menu
            required
            autovalidate
            name="authParamsLocation"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
          >
            <label slot="label">Oauth parameters location</label>
            <anypoint-listbox
              slot="dropdown-content"
              .selected="${authParamsLocation}"
              @selected-changed="${this._selectionHandler}"
              data-name="authParamsLocation"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${disabled}"
              attrforselected="data-value">
              <anypoint-item .compatibility="${compatibility}" data-value="querystring">Query string</anypoint-item>
              <anypoint-item .compatibility="${compatibility}"
                data-value="authorization">Authorization header</anypoint-item>
            </anypoint-listbox>
          </anypoint-dropdown-menu>

          <anypoint-masked-input
            required
            autovalidate
            name="consumerKey"
            .value="${consumerKey}"
            @input="${this._valueHandler}"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Consumer key is required">
            <label slot="label">Consumer key</label>
          </anypoint-masked-input>

          <anypoint-masked-input
            name="consumerSecret"
            .value="${consumerSecret}"
            @input="${this._valueHandler}"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Consumer secret</label>
          </anypoint-masked-input>

          <anypoint-masked-input
            name="token"
            .value="${token}"
            @input="${this._valueHandler}"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Token</label>
          </anypoint-masked-input>

          <anypoint-masked-input
            name="tokenSecret"
            .value="${tokenSecret}"
            @input="${this._valueHandler}"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Token secret</label>
          </anypoint-masked-input>

          <anypoint-input
            name="requestTokenUri"
            .value="${requestTokenUri}"
            @input="${this._valueHandler}"
            type="text"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Request token URL</label>
          </anypoint-input>

          <anypoint-input
            name="accessTokenUri"
            .value="${accessTokenUri}"
            @input="${this._valueHandler}"
            type="url"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Token Authorization URL</label>
          </anypoint-input>

          <anypoint-input
            name="authorizationUri"
            .value="${authorizationUri}"
            @input="${this._valueHandler}"
            type="url"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">User authorization dialog URL</label>
          </anypoint-input>

          <anypoint-input
            name="redirectUri"
            .value="${redirectUri}"
            @input="${this._valueHandler}"
            type="url"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Redirect URL</label>
          </anypoint-input>

          <anypoint-input
            required
            autovalidate
            name="timestamp"
            .value="${timestamp}"
            @input="${this._valueHandler}"
            type="number"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Timestamp is required">
            <label slot="label">Timestamp</label>
            <anypoint-icon-button
              slot="suffix"
              title="Regenerate timestamp"
              aria-label="Press to regenerate timestamp"
              @click="${this._genTimestamp}">
              <iron-icon alt="Regenerate input icon" icon="arc:help"></iron-icon>
            </anypoint-icon-button>
          </anypoint-input>

          <anypoint-input
            required
            autovalidate
            name="nonce"
            .value="${nonce}"
            @input="${this._valueHandler}"
            type="text"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            invalidmessage="Nonce is required">
            <label slot="label">Nonce</label>
            <anypoint-icon-button
              slot="suffix"
              title="Regenerate nonce"
              aria-label="Press to regenerate nonce"
              @click="${this._genNonce}">
              <iron-icon alt="Regenerate input icon" icon="arc:help"></iron-icon>
            </anypoint-icon-button>
          </anypoint-input>

          <anypoint-input
            name="realm"
            .value="${realm}"
            @input="${this._valueHandler}"
            type="text"
            autocomplete="on"
            .outlined="${outlined}"
            .compatibility="${compatibility}"
            .readOnly="${readOnly}"
            .disabled="${disabled}">
            <label slot="label">Realm</label>
          </anypoint-input>

          ${hasSignatureMethods ?
            html`<anypoint-dropdown-menu
              required
              autovalidate
              name="signatureMethod"
              .outlined="${outlined}"
              .compatibility="${compatibility}"
              .readOnly="${readOnly}"
              .disabled="${disabled}"
            >
              <label slot="label">Signature method</label>
              <anypoint-listbox
                slot="dropdown-content"
                .selected="${signatureMethod}"
                @selected-changed="${this._selectionHandler}"
                data-name="signatureMethod"
                .outlined="${outlined}"
                .compatibility="${compatibility}"
                .readOnly="${readOnly}"
                .disabled="${disabled}"
                attrforselected="data-value">
                ${signatureMethods.map((item) =>
              html`<anypoint-item .compatibility="${compatibility}" data-value="${item}">${item}</anypoint-item>`)}
              </anypoint-listbox>
            </anypoint-dropdown-menu>` :
            ''}

          <div class="authorize-actions">
            <anypoint-button
              ?disabled="${_authorizing}"
              class="auth-button"
              @click="${this.authorize}">Authorize</anypoint-button>
            <paper-spinner .active="${_authorizing}"></paper-spinner>
          </div>
        </form>
      </iron-form>
    </div>
    <paper-toast text="" duration="5000"></paper-toast>`;
  }

  static get properties() {
    return {
      // Client ID aka consumer key
      consumerKey: { type: String },
      // The client secret aka consumer secret
      consumerSecret: { type: String },
      // Oauth 1 token (from the oauth console)
      token: { type: String },
      // Oauth 1 token secret (from the oauth console)
      tokenSecret: { type: String },
      // Timestamp
      timestamp: { type: Number },
      // The nonce generated for this request
      nonce: { type: String },
      // Optional realm
      realm: { type: String },
      /**
       * Signature method. Enum {`HMAC-SHA256`, `HMAC-SHA1`, `PLAINTEXT`}
       */
      signatureMethod: { type: String },

      // True when currently authorizing the user.
      _authorizing: { type: Boolean },
      /**
       * Authorization callback URI
       */
      redirectUri: { type: String },
      /**
       * OAuth1 endpoint to obtain request token to request user authorization.
       */
      requestTokenUri: { type: String },
      /**
       * Endpoint to authorize the token.
       */
      accessTokenUri: { type: String },
      /**
       * HTTP method to obtain authorization header.
       * Spec recommends POST
       */
      authTokenMethod: { type: String },
      /**
       * A location of the OAuth 1 authorization parameters.
       * It can be either in the URL as a query string (`querystring` value)
       * or in the authorization header (`authorization`) value.
       */
      authParamsLocation: { type: String },
      /**
       * An URI to authentication endpoint where the user should be redirected
       * to auththorize the app.
       */
      authorizationUri: { type: String },
      /**
       * RAML `securedBy` obejct definition.
       * If set, it will prefill the settings in the auth panel.
       */
      amfSettings: { type: Object },
      /**
       * List of currently support signature methods.
       * This can be updated when `amfSettings` property is set.
       */
      signatureMethods: { type: Array }
    };
  }
  /**
   * Returns default list of signature methods for OAuth1
   */
  get defaultSignatureMethods() {
    return ['HMAC-SHA1', 'RSA-SHA1', 'PLAINTEXT'];
  }

  get amfSettings() {
    return this._amfSettings;
  }

  set amfSettings(value) {
    /* istanbul ignore else */
    if (this._sop('amfSettings', value)) {
      this._amfSettingsChanged();
    }
  }

  constructor() {
    super('oauth1');
    this._oauth1ErrorHandler = this._oauth1ErrorHandler.bind(this);
    this._tokenResponseHandler = this._tokenResponseHandler.bind(this);

    this.signatureMethod = 'HMAC-SHA1';
    this.authTokenMethod = 'POST';
    this.authParamsLocation = 'authorization';
    this._genTimestamp();
    this._genNonce();
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.signatureMethods) {
      this.signatureMethods = this.defaultSignatureMethods;
    }
  }

  _attachListeners() {
    window.addEventListener('oauth1-error', this._oauth1ErrorHandler);
    window.addEventListener('oauth1-token-response', this._tokenResponseHandler);
  }

  _detachListeners() {
    window.removeEventListener('oauth1-error', this._onAuthSettings);
    window.removeEventListener('oauth1-token-response', this._tokenResponseHandler);
  }

  updated() {
    this._settingsChanged();
  }
  /**
   * Overrides `AmfHelperMixin.__amfChanged`
   */
  __amfChanged() {
    this._amfSettingsChanged();
  }
  /**
   * Validates the form.
   *
   * @return {Boolean} `true` if valid, `false` otherwise.
   */
  validate() {
    const form = this.shadowRoot.querySelector('iron-form');
    /* istanbul ignore if */
    if (!form) {
      return true;
    }
    return form.validate();
  }

  _createModel(type) {
    let validationResult = this.validate();
    const settings = this.getSettings();
    if (validationResult) {
      if (!settings || !settings.token || !settings.tokenSecret) {
        validationResult = false;
      }
    }
    return {
      settings,
      type,
      valid: validationResult
    };
  }

  getSettings() {
    return {
      consumerKey: this.consumerKey,
      consumerSecret: this.consumerSecret,
      token: this.token,
      tokenSecret: this.tokenSecret,
      timestamp: this.timestamp,
      nonce: this.nonce,
      realm: this.realm,
      signatureMethod: this.signatureMethod,
      requestTokenUri: this.requestTokenUri,
      accessTokenUri: this.accessTokenUri,
      redirectUri: this.redirectUri,
      authTokenMethod: this.authTokenMethod,
      authParamsLocation: this.authParamsLocation,
      authorizationUri: this.authorizationUri,
      type: 'oauth1'
    };
  }

  /**
   * Restores settings from stored value.
   *
   * @param {Object} settings Object returned by `_getSettings()`
   */
  restore(settings) {
    this.consumerKey = settings.consumerKey;
    this.consumerSecret = settings.consumerSecret;
    this.token = settings.token;
    this.tokenSecret = settings.tokenSecret;
    this.timestamp = settings.timestamp;
    this.nonce = settings.nonce;
    this.realm = settings.realm;
    this.signatureMethod = settings.signatureMethod;
    this.requestTokenUri = settings.requestTokenUri;
    this.accessTokenUri = settings.accessTokenUri;
    this.redirectUri = settings.redirectUri;
    this.authTokenMethod = settings.authTokenMethod;
    this.authParamsLocation = settings.authParamsLocation;
    this.authorizationUri = settings.authorizationUri;
  }
  /**
   * Sends the `oauth2-token-requested` event.
   * @return {Boolean} True if event was sent. Can be false if event is not
   * handled or when the form is invalid.
   */
  authorize() {
    this._authorizing = true;
    const detail = {};
    if (this.consumerKey) {
      detail.consumerKey = this.consumerKey;
    }
    if (this.consumerSecret) {
      detail.consumerSecret = this.consumerSecret;
    }
    if (this.token) {
      detail.token = this.token;
    }
    if (this.tokenSecret) {
      detail.tokenSecret = this.tokenSecret;
    }
    /* istanbul ignore else */
    if (this.timestamp) {
      detail.timestamp = this.timestamp;
    }
    /* istanbul ignore else */
    if (this.nonce) {
      detail.nonce = this.nonce;
    }
    if (this.realm) {
      detail.realm = this.realm;
    }
    /* istanbul ignore else */
    if (this.signatureMethod) {
      detail.signatureMethod = this.signatureMethod;
    }
    if (this.requestTokenUri) {
      detail.requestTokenUri = this.requestTokenUri;
    }
    if (this.accessTokenUri) {
      detail.accessTokenUri = this.accessTokenUri;
    }
    if (this.redirectUri) {
      detail.redirectUri = this.redirectUri;
    }
    /* istanbul ignore else */
    if (this.authParamsLocation) {
      detail.authParamsLocation = this.authParamsLocation;
    }
    /* istanbul ignore else */
    if (this.authTokenMethod) {
      detail.authTokenMethod = this.authTokenMethod;
    }
    if (this.authorizationUri) {
      detail.authorizationUri = this.authorizationUri;
    }
    detail.type = 'oauth1';
    this.dispatchEvent(new CustomEvent('oauth1-token-requested', {
      detail,
      bubbles: true,
      composed: true,
      camcelable: true
    }));
    return true;
  }
  /**
   * Handles OAuth1 authorization errors.
   *
   * @param {CustomEvent} e
   */
  _oauth1ErrorHandler(e) {
    this._authorizing = false;
    const toast = this.shadowRoot.querySelector('paper-toast');
    toast.text = e.detail.message;
    toast.opened = true;
  }

  /**
   * Handler for the `oauth1-token-response` custom event.
   * Sets `token` and `tokenSecret` properties from the event.
   *
   * @param {CustomEvent} e
   */
  _tokenResponseHandler(e) {
    this._authorizing = false;
    this.token = e.detail.oauth_token;
    this.tokenSecret = e.detail.oauth_token_secret;
  }
  // Sets timestamp in seconds
  _genTimestamp() {
    const t = Math.floor(Date.now() / 1000);
    this.timestamp = t;
  }
  /**
   * Sets autogenerated nocne
   * @param {?Number} length Optional, size of generated string. Default to 32.
   */
  _genNonce() {
    const result = [];
    const chrs = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const chrsLength = chrs.length;
    const length = 32;
    for (let i = 0; i < length; i++) {
      result[result.length] = (chrs[Math.floor(Math.random() * chrsLength)]);
    }
    this.nonce = result.join('');
  }
  /**
   * Called when the AMF object change
   */
  _amfSettingsChanged() {
    const model = this.amfSettings;
    if (!model) {
      this.signatureMethods = this.defaultSignatureMethods;
      return;
    }
    const prefix = this.ns.raml.vocabularies.security;
    const shKey = this._getAmfKey(prefix + 'scheme');
    let scheme = model[shKey];
    let type;
    if (scheme) {
      if (scheme instanceof Array) {
        scheme = scheme[0];
      }
      type = this._getValue(scheme, prefix + 'type');
    }
    if (type !== 'OAuth 1.0') {
      this.signatureMethods = this.defaultSignatureMethods;
      return;
    }
    const sKey = this._getAmfKey(this.ns.raml.vocabularies.security + 'settings');
    let settings = scheme[sKey];
    if (settings instanceof Array) {
      settings = settings[0];
    }
    if (!settings) {
      this.signatureMethods = this.defaultSignatureMethods;
      return;
    }
    this.requestTokenUri = this._getValue(settings, prefix + 'requestTokenUri');
    this.authorizationUri = this._getValue(settings, prefix + 'authorizationUri');
    this.accessTokenUri = this._getValue(settings, prefix + 'tokenCredentialsUri');
    const signaturtes = this._getValueArray(settings, prefix + 'signature');
    if (!signaturtes || !signaturtes.length) {
      this.signatureMethods = this.defaultSignatureMethods;
    } else {
      this.signatureMethods = signaturtes;
    }
  }

  _selectionHandler(e) {
    const { value } = e.detail;
    const { name } = e.target.parentElement;
    this._setSettingsInputValue(name, value);
  }

  _valueHandler(e) {
    const { name, value } = e.target;
    this._setSettingsInputValue(name, value);
  }
  /**
   * Fired when user requested to perform an authorization.
   * The details object vary depends on the `grantType` property.
   * However this event always fire two properties set on the `detail` object: `type` and
   * `clientId`.
   *
   * @event oauth1-token-requested
   * @param {String} consumerKey The consumer key. May be undefined if not provided.
   * @param {String} consumerSecret May be undefined if not provided.
   * @param {String} token May be undefined if not provided.
   * @param {String} tokenSecret May be undefined if not provided.
   * @param {String} timestamp May be undefined if not provided.
   * @param {String} nonce May be undefined if not provided.
   * @param {String} realm May be undefined if not provided.
   * @param {String} signatureMethod May be undefined if not provided.
   * @param {String} type Always `oauth1`
   */
  /**
   * Fired when the any of the auth method settings has changed.
   * This event will be fired quite frequently - each time anything in the text field changed.
   * With one exception. This event will not be fired if the validation of the form didn't passed.
   *
   * @event auth-settings-changed
   * @param {Object} settings Current settings. See the
   * `oauth1-token-requested` for detailed description.
   * @param {String} type The authorization type - oauth1
   */
}
window.customElements.define('auth-method-oauth1', AuthMethodOauth1);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The `<auth-method-custom>` element displays a form to provide the
 * authorization details for RAML's custom security scheme.
 *
 * The element, alike other auth methods, dispatches `auth-settings-changed`
 * custom event. However, it also sends `request-header-changed` and
 * `query-parameters-changed` custom event to directly manipulate values
 * in corresponding UI element. This events are supported with all API components
 * that handles headers or query parameters.
 *
 * This element is rendered empty if `amfSettings` property is not set.
 * Parent element or application should check if model contains the scheme.
 *
 * ### Example
 *
 * ```html
 * <auth-method-custom securityscheme="{...}"></auth-method-custom>
 * ```
 *
 * @customElement
 * @memberof UiElements
 * @appliesMixin AmfHelperMixin
 * @demo demo/custom.html
 * @extends AuthMethodBase
 */
class AuthMethodCustom extends AmfHelperMixin(AuthMethodBase) {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      authStyles,
      css`
      :host {
        display: block;
      }

      .field-value {
        display: flex;
        flex-direction: row;
        flex: 1;
        align-items: center;
      }

      api-property-form-item {
        flex: 1;
      }

      .subtitle {
        display: flex;
        flex-direction: row;
        align-items: center;
      }`
    ];
  }

  render() {
    const {
      _schemeName,
      _schemeDescription,
      _hasSchemeDescription,
      outlined,
      compatibility,
      documentationOpened
    } = this;
    return html`
      <section>
        ${_schemeName ? html`<div class="scheme-header">
          <div class="subtitle">
            <span>Scheme: ${_schemeName}</span>
            ${_hasSchemeDescription ? html`<anypoint-icon-button
              class="hint-icon"
              title="Toggle description"
              aria-label="Press to toggle schema description"
              ?outlined="${outlined}"
              ?compatibility="${compatibility}"
              @click="${this.toggleSchemeDocumentation}">
              <iron-icon icon="arc:help"></iron-icon>
            </anypoint-icon-button>` : ''}
          </div>
          ${_hasSchemeDescription && documentationOpened ? html`<div class="docs-container">
            <arc-marked .markdown="${_schemeDescription}" main-docs>
              <div slot="markdown-html" class="markdown-body"></div>
            </arc-marked>
          </div>` : ''}
        </div>` : ''}

        <iron-form>
          <form autocomplete="on">
            ${this._getHeadersTemplate()}
            ${this._getQueryTemplate()}
          </form>
        </iron-form>
      </section>`;
  }

  static get properties() {
    return {
      /**
       * AMF security scheme model.
       */
      amfSettings: { type: Object },
      /**
       * Computed list of headers to render in the form.
       */
      _headers: { type: Array },
      /**
       * Computed list of query parameters to render.
       */
      _queryParameters: { type: Array },
      /**
       * Name of the security scheme
       */
      _schemeName: { type: String },
      /**
       * Security scheme description
       */
      _schemeDescription: { type: String },
      /**
       * True to opend scheme descripyion, if available.
       */
      documentationOpened: { type: Boolean }
    };
  }

  get _hasSchemeDescription() {
    if (this.noDocs) {
      return false;
    }
    return !!this._schemeDescription;
  }

  get amfSettings() {
    return this._amfSettings;
  }

  set amfSettings(value) {
    /* istanbul ignore else */
    if (this._sop('amfSettings', value)) {
      this._schemeChanged();
    }
  }

  get _transformer() {
    if (!this.__transformer) {
      this.__transformer = document.createElement('api-view-model-transformer');
    }
    return this.__transformer;
  }

  constructor() {
    super('x-custom');
    this._headerChangedHandler = this._headerChangedHandler.bind(this);
    this._parameterChangedHandler = this._parameterChangedHandler.bind(this);
  }

  disconnectedCallback() {
    /* istanbul ignore else */
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.__transformer = null;
  }

  firstUpdated() {
    this._settingsChanged();
  }

  _attachListeners(node) {
    node.addEventListener('request-header-changed', this._headerChangedHandler);
    node.addEventListener('query-parameter-changed', this._parameterChangedHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('request-header-changed', this._headerChangedHandler);
    node.removeEventListener('query-parameter-changed', this._parameterChangedHandler);
  }
  /**
   * Overrides `AmfHelperMixin.__amfChanged`
   */
  __amfChanged() {
    this._schemeChanged();
  }

  _getHeadersTemplate() {
    return this._formListTemplate(this._headers, 'header');
  }

  _getQueryTemplate() {
    return this._formListTemplate(this._queryParameters, 'query');
  }

  _formListTemplate(items, type) {
    if (!items || !items.length) {
      return '';
    }
    const {
      outlined,
      compatibility,
      readOnly,
      disabled,
      noDocs
    } = this;
    return html`<section>
    ${items.map((item, index) =>
    this._formItemTemplate(item, index, outlined, compatibility, readOnly, disabled, noDocs, type))}
    </section>`;
  }

  _formItemTemplate(item, index, outlined, compatibility, readOnly, disabled, noDocs, type) {
    return html`<div class="field-value">
      <api-property-form-item
        .model="${item}"
        .value="${item.value}"
        name="${item.name}"
        ?readonly="${readOnly}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        ?disabled="${disabled}"
        data-type="${type}"
        data-index="${index}"
        @value-changed="${this._inputValueChanged}"></api-property-form-item>
        ${item.hasDescription && !noDocs ? html`<anypoint-icon-button
          class="hint-icon"
          title="Toggle description"
          aria-label="Press to toggle description"
          data-type="${type}"
          data-index="${index}"
          @click="${this._toggleDocumentation}">
          <iron-icon icon="arc:help"></iron-icon>
        </anypoint-icon-button>` : undefined}
    </div>
    ${item.hasDescription && !noDocs && item.docsOpened ? html`<div class="docs-container">
      <arc-marked .markdown="${item.description}">
        <div slot="markdown-html" class="markdown-body"></div>
      </arc-marked>
    </div>` : ''}`;
  }

  /**
   * Validates the form.
   *
   * @return {Boolean} `true` if valid, `false` otherwise.
   */
  validate() {
    const form = this.shadowRoot.querySelector('iron-form');
    /* istanbul ignore if */
    if (!form) {
      return true;
    }
    return form.validate();
  }

  _schemeChanged() {
    if (this.__schemeChangeDebouncer) {
      return;
    }
    this.__schemeChangeDebouncer = true;
    setTimeout(() => {
      this.__schemeChangeDebouncer = false;
      this.__schemeChanged(this.amfSettings);
    });
  }

  __schemeChanged() {
    const model = this.amfSettings;
    const prefix = this.ns.raml.vocabularies.security;
    this._headers = undefined;
    this._queryParameters = undefined;
    if (!this._hasType(model, this.ns.raml.vocabularies.security + 'ParametrizedSecurityScheme')) {
      return;
    }
    const shKey = this._getAmfKey(prefix + 'scheme');
    let scheme = model[shKey];
    let type;
    if (scheme) {
      if (scheme instanceof Array) {
        scheme = scheme[0];
      }
      type = this._getValue(scheme, prefix + 'type');
    }
    if (!type || type.indexOf('x-') !== 0) {
      return;
    }
    const hKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'header');
    this._createViewModel('header', this._ensureArray(scheme[hKey]));
    const params = this._readParamsProperties(scheme);
    this._createViewModel('parameter', params);
    this._schemeName = this._getValue(model, prefix + 'name');
    this._schemeDescription = this._getValue(scheme, this.ns.schema.desc);
    this._settingsChanged();
  }

  _readParamsProperties(scheme) {
    const pKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'parameter');
    let result = this._ensureArray(scheme[pKey]);
    if (result) {
      return result;
    }
    const qKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'queryString');
    result = this._ensureArray(scheme[qKey]);
    if (result) {
      result = result[0];
    }
    return result;
  }
  /**
   * Generates view model using the tranformer.
   *
   * @param {String} type Param type. Either `header` or `parameter`.
   * @param {Array} model
   */
  _createViewModel(type, model) {
    if (!model) {
      return;
    }
    const factory = this._transformer;
    factory.amf = this.amf;
    const data = factory.computeViewModel(model);
    if (!data) {
      return;
    }
    if (type === 'header') {
      this._headers = data;
      this._notifyModelChanged(type, data);
    } else if (type === 'parameter') {
      this._queryParameters = data;
      this._notifyModelChanged(type, data);
    }
  }
  /**
   * Returns current configuration of the OAuth2.
   *
   * @return {Object} Current OAuth2 configuration.
   */
  getSettings() {
    const form = this.shadowRoot.querySelector('iron-form');
    if (!form) {
      return {};
    }
    return form.serializeForm();
  }
  /**
   * Toggles documentartion for custom property.
   *
   * @param {CustomEvent} e
   */
  _toggleDocumentation(e) {
    const index = Number(e.currentTarget.dataset.index);
    const type = e.currentTarget.dataset.type;
    if (index !== index || !type) {
      return;
    }
    const model = type === 'query' ? this._queryParameters : this._headers;
    model[index].docsOpened = !model[index].docsOpened;
    this.requestUpdate();
  }
  /**
   * Toggles docs opened state
   */
  toggleSchemeDocumentation() {
    this.documentationOpened = !this.documentationOpened;
  }
  /**
   * Handler for the `request-header-changed` event.
   * It updates value for a single header if this header is already on the list.
   * @param {CustomEvent} e
   */
  _headerChangedHandler(e) {
    this._updateEventValue(e, this._headers);
  }
  /**
   * Handler for the `query-parameter-changed` event.
   * It updates value for a single parameter if this parameter is already on the list.
   * @param {CustomEvent} e
   */
  _parameterChangedHandler(e) {
    this._updateEventValue(e, this._queryParameters);
  }
  /**
   * Update array value for given type (`headers` or `queryParameters`) for given event.
   * @param {CustomEvent} e
   * @param {Array} model Model to use to update the value.
   */
  _updateEventValue(e, model) {
    if (!model || !model.length) {
      return;
    }
    const target = this._getEventTarget(e);
    if (target === this || e.defaultPrevented) {
      return;
    }
    const name = e.detail.name;
    if (!name || typeof name !== 'string') {
      return;
    }
    for (let i = 0, len = model.length; i < len; i++) {
      const pName = model[i].name;
      if (!pName) {
        continue;
      }
      if (pName === name) {
        model[i].value = e.detail.value;
        this.requestUpdate();
        this._settingsChanged();
        return;
      }
    }
  }
  /**
   * Handler for the `value-changed` event disaptched by input element.
   * Dispatches 'request-header-changed' or 'query-parameter-changed'
   * event. Other components can update their state when the value change.
   *
   * @param {CustomEvent} e
   */
  _inputValueChanged(e) {
    const index = Number(e.target.dataset.index);
    const type = e.target.dataset.type;
    if (index !== index || !type) {
      return;
    }
    const model = type === 'query' ? this._queryParameters : this._headers;
    const { name } = model[index];
    const { value } = e.detail;
    model[index].value = value;
    this.__isInputEvent = true;
    this._settingsChanged();
    this.__isInputEvent = false;
    this._dispatchParamChanged(type, name, value);
  }
  /**
   * Dispatches header/query parameter changed event - depending on the type.
   * @param {String} type `header` or `query`
   * @param {String} name name of the property
   * @param {String} value changed value
   */
  _dispatchParamChanged(type, name, value) {
    const eventType = type === 'header' ? 'request-header-changed' : 'query-parameter-changed';
    this.dispatchEvent(new CustomEvent(eventType, {
      detail: {
        name,
        value
      },
      bubbles: true,
      composed: true
    }));
  }
  /**
   * Calls `_dispatchParamChanged()` on each item to notify other editors about
   * value change.
   * @param {String} type Changed type.
   * @param {String} data View model
   */
  _notifyModelChanged(type, data) {
    if (!data || !data.length) {
      return;
    }
    data.forEach((item) => this._dispatchParamChanged(type, item.name, item.value));
  }
  /**
   * Fired when the any of the auth method settings has changed.
   * This event will be fired quite frequently - each time anything in the text field changed.
   * With one exception. This event will not be fired if the validation of the form didn't passed.
   *
   * @event auth-settings-changed
   * @param {Object} settings Current settings containing hash, password
   * and username.
   * @param {String} type The authorization type - x-custom
   * @param {Boolean} valid True if the form has been validated.
   * @param {String} name Name of the custom method to differeciante them if many.
   */
  /**
   * Fired when the header value has changed.
   *
   * @event request-header-changed
   * @param {String} name Name of the header
   * @param {String} value Value of the header
   */
  /**
   * Fired when the header value has changed.
   *
   * @event query-parameter-changed
   * @param {String} name Name of the parameter
   * @param {String} value Value of the parameter
   */
}
window.customElements.define('auth-method-custom', AuthMethodCustom);

/**
@license
Copyright 2019 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * Authorization panel used in the request panel to get user authorization information.
 *
 * @customElement
 * @memberof UiElements
 * @appliesMixin EventsTargetMixin
 * @appliesMixin AuthorizationPanelAmfOverlay
 * @demo demo/basic.html Basic element
 * @demo demo/meta-data.html IronMeta defined methods
 * @demo demo/amf.html RAML or OAS data from AMF model
 * @demo demo/amf-meta.html RAML or OAS data from AMF model and IronMeta
 */
class AuthorizationPanel extends AuthorizationPanelAmfOverlay(EventsTargetMixin(LitElement)) {
  static get styles() {
    return css`
    :host {
      display: block;
    }

    .auth-container {
      position: relative;
    }

    .no-method-info,
    .no-support-info {
      font-style: var(--no-info-message-font-style, italic);
      font-size: var(--no-info-message-font-size, 16px);
      color: var(--no-info-message-color, rgba(0, 0, 0, 0.74));
      margin: 12px 8px;
    }

    [hidden] {
      display: none;
    }

    .auth-title-single {
      font-size: 1.28rem;
      margin: 12px 8px;
      font-weight: 200;
    }`;
  }

  static get properties() {
    return {
      /**
       * Selected authorization type. It is one of the types supported by
       * `advanced-rest-client/auth-methods` component.
       *
       * This corresponds to the index of `authMethods` array.
       */
      selected: { type: Number },
      /**
       * List of currently rendered authorization methods.
       * This value changes when `securedBy` changes to reflect number of
       * authorization methods supported by current endpoint.
       */
      authMethods: { type: Array },
      /**
       * Current settings of selected auth type.
       *
       * Can be `undefined` if the user hasn't filled all required fields in the
       * form.
       */
      settings: { type: Object },
      /**
       * The OAuth2 redirect URL to be set in the OAuth2 form pane.
       */
      redirectUri: { type: Boolean },
      /**
       * If true the panels won't render inline documentation if
       * the information is available.
       */
      noDocs: { type: Boolean },
      // Current HTTP method. Passed to digest method.
      httpMethod: { type: String },
      // Current request URL. Passed to digest method.
      requestUrl: { type: String },
      // Current request body. Passed to digest method.
      requestBody: { type: String },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean, reflect: true },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
      /**
       * If set it renders a narrow layout
       */
      narrow: { type: Boolean, reflect: true },
    };
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    /* istanbul ignore if */
    if (old === value) {
      return false;
    }
    this._selected = value;
    this.requestUpdate('selected', old);
    this._selectedChanged(value, old);
    this.validate();
  }

  get settings() {
    return this._settings;
  }

  set settings(value) {
    if (this._sop('settings', value)) {
      this.validate();
      this.dispatchEvent(new CustomEvent('settings-changed', {
        detail: {
          value
        }
      }));
    }
  }
  /**
   * List of authorization methods supported by this element.
   * Each item has `id` and `name` property. The `id` is internal ID for
   * authorization methods. Can be any of: `none`, `basic`, `ntlm`, `digest`,
   * `oauth1` and `oauth2`. The `name` property is a lable for the method
   * used in UI.
   * @return {Array<Object>}
   */
  get supportedMethods() {
    return [{
      'type': 'none',
      'name': 'No authorization'
    }, {
      'type': 'Basic Authentication',
      'name': 'Basic authentication'
    }, {
      'type': 'ntlm',
      'name': 'NTLM'
    }, {
      'type': 'Digest Authentication',
      'name': 'Digest authentication'
    }, {
      'type': 'OAuth 2.0',
      'name': 'OAuth 2.0'
    }, {
      'type': 'OAuth 1.0',
      'name': 'OAuth 1.0'
    }];
  }
  /**
   * @return {HTMLElement} Currently rendered authorization panel.
   */
  get currentPanel() {
    const selector = '.auth-panel > *';
    return this.shadowRoot.querySelector(selector);
  }

  constructor() {
    super();
    this.selected = 0;
    this._authSettingsHandler = this._authSettingsHandler.bind(this);
    this._onAuthSettingsChanged = this._onAuthSettingsChanged.bind(this);
  }

  _attachListeners() {
    if (!this.authMethods) {
      this.authMethods = this._listAuthMethods();
    }
    this.addEventListener('auth-settings-changed', this._authSettingsHandler);
    this.addEventListener('authorization-settings-changed', this._onAuthSettingsChanged);
  }

  _detachListeners() {
    this.removeEventListener('auth-settings-changed', this._authSettingsHandler);
    this.removeEventListener('authorization-settings-changed', this._onAuthSettingsChanged);
  }

  /**
   * Clears the state of the panel.
   */
  clear() {
    this.selected = undefined;
    this.settings = {};
    this._authRequired = false;
    this.invalid = false;
  }

  /**
   * Replaces active panel with new one and dipatches
   * `authorization-type-changed` event.
   *
   * If the event is canceled it restores previous value in the selector.
   *
   * @param {Number} selected
   * @param {Number} oldValue
   */
  _selectedChanged(selected, oldValue) {
    this._ensureAuthHeaderRemoved(oldValue);
    this._notifySettings();
  }
  /**
   * Ensures that the authorization header is removed if previously
   * selected (and now deselected) type is one of using Authorization
   * header.
   * @param {Number} oldSelected Previously selected auth method
   */
  _ensureAuthHeaderRemoved(oldSelected) {
    const methods = this.authMethods;
    if (oldSelected === undefined || !methods) {
      return;
    }
    const oldMethod = methods[oldSelected];
    const type = oldMethod && this._panelTypeToRamType(oldMethod.type);
    if (type && ['Basic Authentication', 'OAuth 1.0', 'OAuth 2.0']
      .indexOf(type) !== -1) {
      this._clearAuthHeader();
    }
  }
  /**
   * Dispatches `request-header-deleted` custom event to inform listeners
   * that `authorization` header should not be used.
   */
  _clearAuthHeader() {
    this.fire('request-header-deleted', {
      name: 'authorization'
    }, {
      cancelable: true
    });
  }
  /**
   * Lists available authorization methods.
   * By default it returns list from `supportedMethods` property which is the
   * list of all supported methods by this element.
   * If `iron-meta` element with key `auth-methods` is set then it will use
   * this information to compute list of auth methods.
   * See element description for more information.
   *
   * @return {Array<Object>} See `supportedMethods` property for data model.
   */
  _listAuthMethods() {
    const meta = this._listMetaAuthMethods();
    if (meta) {
      return meta;
    }
    return this.supportedMethods;
  }
  /**
   * Creates a listing of methods from `iron-meta` definition.
   *
   * @return {Array|undefined} List of methods defined in `iron-meta`
   * or undefined if not set.
   */
  _listMetaAuthMethods() {
    let meta = document.createElement('iron-meta').byKey('auth-methods');
    if (!meta) {
      return;
    }
    if (typeof meta === 'string') {
      try {
        meta = JSON.parse(meta);
      } catch (e) {
        return;
      }
    }
    if (!(meta instanceof Array)) {
      return;
    }
    const result = [];
    meta.forEach((key) => {
      let name;
      switch (key) {
        case null:
          name = 'No authorization';
          key = 'none';
          break;
        case 'ntlm':
          name = 'NTLM';
          break;
        case 'basic':
          name = 'Basic Authentication';
          key = name;
          break;
        case 'digest':
          name = 'Digest Authentication';
          key = name;
          break;
        case 'oauth1':
          name = 'OAuth 1.0';
          key = name;
          break;
        case 'oauth2':
          name = 'OAuth 2.0';
          key = name;
          break;
      }
      if (name) {
        result.push({
          type: key,
          name
        });
      }
    });
    return result;
  }
  /**
   * Handler for `auth-settings-changed` custom event.
   * Sets up `settings` property from the event.
   *
   * @param {CustomEvent} e
   */
  _authSettingsHandler(e) {
    e.stopPropagation();
    e.stopImmediatePropagation();
    if (this.readOnly || this.disabled) {
      return;
    }
    this.settings = e.detail;
    this._processPanelSettings(e.detail);
    this._notifySettings();
  }
  /**
   * Restores settings to a panel including selection and data.
   *
   * @param {Object} settings The same settings object as dispatched in
   * `detail` object from this element.
   */
  restore(settings) {
    if (!settings) {
      if (this.selected || this.selected === 0) {
        this.selected = undefined;
      }
      return;
    }
    const methods = this.authMethods;
    if (!methods) {
      return;
    }
    const index = methods.findIndex((item) =>
      this._panelTypeToRamType(item.type) === this._panelTypeToRamType(settings.type));
    if (index === -1) {
      return;
    }
    if (this.selected !== index) {
      this.selected = index;
    }
    this.settings = settings;
    // selection might have changes so the panel was not ready
    setTimeout(() => {
      const panel = this.currentPanel;
      if (panel) {
        // Can be no-auth panel
        panel.restore(settings.settings);
      }
    });
  }
  /**
   * Notifies settings change if currently selected method is the same as
   * `settings.type`.
   */
  _notifySettings() {
    if (this.readOnly || this.disabled) {
      return;
    }
    const { selected } = this;
    const config = this.authMethods && this.authMethods[selected];
    const isBlank = ['none', 'Pass Through'].indexOf(config && config.type) !== -1;
    if (isBlank) {
      this.settings = {};
    }
    const { settings } = this;
    let valid = false;
    let type;
    if (config) {
      type = config.type;
      if (isBlank) {
        valid = true;
      } else if (settings) {
        valid = settings.valid || false;
      } else if (this.authVaid) {
        valid = true;
      }
    } else {
      type = 'none';
      if (!this._authRequired) {
        valid = true;
      }
    }
    this.fire('authorization-settings-changed', {
      settings: settings ? settings.settings : {},
      valid,
      type
    });
  }
  /**
   * Rstores authorization settings if event is external.
   *
   * @param {CustomEvent} e
   */
  _onAuthSettingsChanged(e) {
    if (this.readOnly || e.composedPath()[0] === this) {
      return;
    }
    this.restore(e.detail);
  }
  /**
   * Processes incomming settings and acts if any action needed to authorize
   * the use has to be performed.
   *
   * @param {Object} settings Current settings.
   */
  _processPanelSettings(settings) {
    switch (settings.type) {
      case 'oauth2': this._handleOauth2Settings(settings); break;
      case 'digest': this._handleDigestSettings(settings); break;
    }
  }
  /**
   * Handles the case when OAuth2 settings changed.
   *
   * @param {Object} settings Oauth2 auth settings object
   */
  _handleOauth2Settings(settings) {
    settings = settings || {};

    const authSettings = settings.settings || {};
    const token = authSettings.accessToken;
    if (!token) {
      settings.valid = false;
      this.settings = settings;
      return;
    }
    let type;
    let value;
    if (authSettings.deliveryMethod === 'header') {
      type = 'request-header-changed';
      value = authSettings.tokenType + ' ' + token;
    } else {
      type = 'query-parameter-changed';
      value = token;
    }
    this.fire(type, {
      name: authSettings.deliveryName,
      value: value
    }, {
      cancelable: true
    });
  }
  /**
   * Handles the case when digest auth method settings changed.
   *
   * @param {Object} settings Digest auth method settings object
   * It can be either username and password (that will be passed to
   * transport method) then this function do nothing or list of Authorization
   * header parameters.
   */
  _handleDigestSettings(settings) {
    if (!settings.valid) {
      this.fire('request-header-changed', {
        name: 'authorization',
        value: ''
      });
      return;
    }
    settings = settings.settings;
    if (!settings) {
      return;
    }
    const data = settings.settings;
    if (!data || !(data.username && data.password)) {
      return;
    }
    let value = 'Digest ';
    Object.keys(data).forEach((name) => {
      value += name + '="' + data[name] + '", ';
    });
    value = value.substr(0, value.length - 2);
    this.fire('request-header-changed', {
      name: 'authorization',
      value: value
    }, {
      cancelable: true
    });
  }

  fire(type, detail, options) {
    const defaults = {
      bubbles: true,
      composed: true,
      cancelable: false
    };
    if (!options) {
      options = defaults;
    } else {
      options = Object.assign(defaults, options);
    }
    options.detail = detail;
    const e = new CustomEvent(type, options);
    this.dispatchEvent(e);
    return e;
  }
  /**
   * If selected authorization type is `oauth1` or `oauth2` it calls
   * `authorize()` function of selected panel.
   * If other method is selected it does nothing.
   *
   * @return {Boolean} True if the panel received intent to authorize and
   * `false` otherwise
   */
  forceTokenAuthorization() {
    const selected = this.authMethods && this.authMethods[this.selected];
    if (!selected) {
      return false;
    }
    if (['OAuth 2.0', 'OAuth 1.0'].indexOf(selected.type) === -1) {
      return false;
    }
    const panel = this.currentPanel;
    if (!panel) {
      return true;
    }
    return panel.authorize();
  }
  /**
   * Dispatches analytics event.
   *
   * @param {String} category Event category
   * @param {String} action Event action
   * @param {String} label Event label
   */
  _analyticsEvent(category, action, label) {
    this.fire('send-analytics', {
      type: 'event',
      category: category,
      action: action,
      label: label
    });
  }

  _selectionHandler(e) {
    const { value } = e.detail;
    const { name } = e.target.parentElement;
    this[name] = value;
  }

  _selectorTemplate() {
    const {
      outlined,
      legacy,
      readOnly,
      disabled,
      selected
    } = this;
    const items = this.authMethods || [];
    const isSingle = items.length === 1;
    return html`
    ${isSingle ? html`<div role="heading" aria-level="3" class="auth-title-single">${items[0].name}</div>` : ''}
    <anypoint-dropdown-menu
      ?hidden="${isSingle}"
      name="selected"
      .outlined="${outlined}"
      .legacy="${legacy}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
    >
      <label slot="label">Authorization method</label>
      <anypoint-listbox
        slot="dropdown-content"
        .selected="${selected}"
        @selected-changed="${this._selectionHandler}"
        .outlined="${outlined}"
        .legacy="${legacy}"
        .readOnly="${readOnly}"
        .disabled="${disabled}">
        ${items.map((item) => html`<anypoint-item .legacy="${legacy}">${item.name}</anypoint-item>`)}
      </anypoint-listbox>
    </anypoint-dropdown-menu>`;
  }

  _panelTemplate() {
    const { selected, authMethods } = this;
    if (selected === -1 || selected === undefined || !authMethods || !authMethods.length) {
      return;
    }
    const item = authMethods[selected];
    switch (item.type) {
      case 'none': return '';
      case 'Basic Authentication': return this._basicTemplate();
      case 'Digest Authentication': return this._digestTemplate();
      case 'ntlm': return this._ntlmTemplate();
      case 'Pass Through': return this._passThroughTemplate();
      case 'OAuth 2.0': return this._oauth2Template(item.type, item.name);
      case 'OAuth 1.0': return this._oauth1Template(item.type, item.name);
      default: return this._customTemplate(item.type, item.name);
    }
  }

  _basicTemplate() {
    const {
      eventsTarget,
      readOnly,
      disabled,
      legacy,
      outlined
    } = this;

    return html`<auth-method-basic
      .eventsTarget="${eventsTarget}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?outlined="${outlined}"
      ?legacy="${legacy}"
    ></auth-method-basic>`;
  }

  _digestTemplate() {
    const {
      eventsTarget,
      readOnly,
      disabled,
      legacy,
      outlined,
      narrow,
      requestUrl,
      httpMethod,
      requestBody
    } = this;

    return html`<auth-method-digest
      .eventsTarget="${eventsTarget}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?narrow="${narrow}"
      ?outlined="${outlined}"
      ?legacy="${legacy}"
      .requestUrl="${requestUrl}"
      .httpMethod="${httpMethod}"
      .requestBody="${requestBody}"
    ></auth-method-digest>`;
  }

  _ntlmTemplate() {
    const {
      eventsTarget,
      readOnly,
      disabled,
      legacy,
      outlined
    } = this;

    return html`<auth-method-ntlm
      .eventsTarget="${eventsTarget}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?outlined="${outlined}"
      ?legacy="${legacy}"
    ></auth-method-ntlm>`;
  }

  _oauth2Template(type, name) {
    const {
      eventsTarget,
      readOnly,
      disabled,
      legacy,
      outlined,
      noDocs,
      redirectUri,
      amf
    } = this;

    const amfSettings = this._computeAmfSettings(type, name);

    return html`<auth-method-oauth2
      .eventsTarget="${eventsTarget}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?outlined="${outlined}"
      ?legacy="${legacy}"
      .noDocs="${noDocs}"
      .redirectUri="${redirectUri}"
      .amf="${amf}"
      .amfSettings="${amfSettings}"
    ></auth-method-oauth2>`;
  }

  _oauth1Template(type, name) {
    const {
      eventsTarget,
      readOnly,
      disabled,
      legacy,
      outlined,
      noDocs,
      redirectUri,
      amf
    } = this;

    const amfSettings = this._computeAmfSettings(type, name);

    return html`<auth-method-oauth1
      .eventsTarget="${eventsTarget}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?outlined="${outlined}"
      ?legacy="${legacy}"
      .noDocs="${noDocs}"
      .redirectUri="${redirectUri}"
      .amf="${amf}"
      .amfSettings="${amfSettings}"
    ></auth-method-oauth1>`;
  }

  _customTemplate(type, name) {
    const amfSettings = this._computeAmfSettings(type, name);
    if (!amfSettings) {
      return html`<p class="no-support-info">This method is not yet supported.</p>`;
    }
    const {
      eventsTarget,
      readOnly,
      disabled,
      legacy,
      outlined,
      noDocs,
      redirectUri,
      amf
    } = this;

    return html`<auth-method-custom
      .eventsTarget="${eventsTarget}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      ?outlined="${outlined}"
      ?legacy="${legacy}"
      .noDocs="${noDocs}"
      .redirectUri="${redirectUri}"
      .amf="${amf}"
      .amfSettings="${amfSettings}"
    ></auth-method-custom>`;
  }

  _passThroughTemplate() {
    return html`<p class="no-support-info">This method is not yet supported.</p>`;
  }

  render() {
    const { authMethods } = this;
    return html`
    <div class="auth-container">
      ${authMethods && authMethods.length ?
        html`
        ${this._selectorTemplate()}
        <section class="auth-panel">
        ${this._panelTemplate()}
        </section>` :
        html`<p class="no-method-info">Authorization method for current endpoint is not supported.</p>`}
    </div>`;
  }
  /**
   * Fired when auth settings change.
   *
   * It will be fired when any of types is currently selected and
   * any value of any property has changed.
   *
   * @event authorization-settings-changed
   * @param {?Object} settings Current auth settings. It depends on enabled `type`.
   * It might be undefined if the user unselected a method (if possible). This
   * means that there's no selection at the moment.
   * @param {?String} type Enabled auth type. For example `basic`, `ntlm` or `oauth2`.
   * It may be `undefined` if the user deselected current method and none is selected.
   * @param {Boolean} valid Flag determining if current settings are valid.
   * This property depends on `null` security scheme when scheme is unselected
   * (`settings` and `type` are `undefined`). If `null` security is set then
   * it is valid when methos is unselected. `false` otherise.
   */
  /**
   * Fired when the authorization type changed.
   * Note that the `settings` property may not be updated at the moment of of
   * firing the event.
   *
   * This event is cancelable. If handler cancels the event the operation
   * is stopped and selection is set to previous value.
   *
   * @event authorization-type-changed
   * @param {String} type Current auth type
   */
  /**
   * Fired when the request header changed and all listeners should update
   * header value.
   *
   * @event request-header-changed
   * @param {String} name Name of the header that has changed
   * @param {String} value Header new value
   */
  /**
   * Fired when the query param changed and all listeners should update
   * parameters / URL value.
   *
   * @event query-parameter-changed
   * @param {String} name Name of the header that has changed
   * @param {String} value Header new value
   */
}
window.customElements.define('authorization-panel', AuthorizationPanel);

/**
@license
Copyright 2018 The Advanced REST client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
Request / response headers and status codes definitions database used in Adavanced REST Client and API Console.
@customElement
@demo demo/index.html
*/
class ArcDefinitions extends HTMLElement {
  static get _dataTemplate() {
    /* eslint-disable max-len */
    const data = `
    {
     "requests":[
      {"key":"Accept","desc":"Content-Types that are acceptable.","example":"Accept: text/plain","autocomplete":["application/json","application/xml","text/plain","application/xml,application/xhtml+xml,text/html;q=0.9, text/plain;q=0.8,image/png,*/*;q=0.5","text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8","text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8","image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg, application/x-ms-xbap, application/x-shockwave-flash, application/msword, */*","text/html, application/xhtml+xml, image/jxr, */*","text/html, application/xml;q=0.9, application/xhtml+xml, image/png, image/webp, image/jpeg, image/gif, image/x-xbitmap, */*;q=0.1","*/*","image/webp,image/*,*/*;q=0.8", "image/png,image/svg+xml,image/*;q=0.8, */*;q=0.5","audio/webm, audio/ogg, audio/wav, audio/*;q=0.9, application/ogg;q=0.7, video/*;q=0.6;*/*;q=0.5","audio/webm,audio/ogg,audio/wav,audio/*;q=0.9,application/ogg;q=0.7,video/*;q=0.6,*/*;q=0.5", "application/javascript, */*;q=0.8","text/css,*/*;q=0.1"]},
      {"key":"Accept-Charset","desc":"Character sets that are acceptable","example":"Accept-Charset: utf-8", "autocomplete": ["utf-8"]},
      {"key":"Accept-Encoding","desc":"Acceptable encodings","example":"Accept-Encoding: &lt;compress | gzip | deflate | identity&gt;","autocomplete":["compress","gzip","deflate"]},
      {"key":"Accept-Language","desc":"Acceptable languages for response","example":"Accept-Language: en-US","autocomplete":["en-US","en-GB, en;q=0.5","hin","jpn","zh-CN","es","ru"]},
      {"key":"Authorization","desc":"Authentication credentials for HTTP authentication","example":"Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="},
      {"key":"Cache-Control","desc":"Used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain","example":"Cache-Control: no-cache","autocomplete":["no-cache","no-store","max-age=3600","max-stale","min-fresh=3600","no-transform","only-if-cached"]},
      {"key":"Connection","desc":"What type of connection the user-agent would prefer","example":"Connection: close","autocomplete": ["keep-alive","close"]},
      {"key":"Cookie","desc":"an HTTP cookie previously sent by the server with Set-Cookie","example":"Cookie: $Version=1; Skin=new;","autocomplete":["name=value","name=value; name2=value2; name3=value3"]},
      {"key":"Content-Length","desc":"The length of the request body in octets (8-bit bytes)","example":"Content-Length: 348"},
      {"key":"Content-Type","desc":"The mime type of the body of the request (used with POST and PUT requests)","example":"Content-Type: application/x-www-form-urlencoded","autocomplete":["application/json","application/xml","application/atom+xml","multipart/form-data","multipart/alternative","multipart/mixed","application/x-www-form-urlencoded","application/base64","application/octet-stream","text/plain","text/css","text/html","application/javascript"]},
      {"key":"Date","desc":"The date and time that the message was sent","example":"Date: Tue, 15 Nov 1994 08:12:31 GMT"},
      {"key":"Expect","desc":"Indicates that particular server behaviors are required by the client","example":"Expect: 100-continue","autocomplete":["100-continue"]},
      {"key":"From","desc":"The email address of the user making the request","example":"From: user@example.com","autocomplete":["webmaster@example.org"]},
      {"key":"Host","desc":"The domain name of the server (for virtual hosting), mandatory since HTTP/1.1","example":"Host: en.wikipedia.org","autocomplete":["advancedrestclient.com"]},
      {"key":"If-Match","desc":"Only perform the action if the client supplied entity matches the same entity on the server. This is mainly for methods like PUT to only update a resource if it has not been modified since the user last updated it.","example":"If-Match: \\"737060cd8c284d8af7ad3082f209582d\\"","autocomplete":["\\"737060cd8c284d8af7ad3082f209582d\\""]},
      {"key":"If-Modified-Since","desc":"Allows a 304 Not Modified to be returned if content is unchanged","example":"If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT"},
      {"key":"If-None-Match","desc":"Allows a 304 Not Modified to be returned if content is unchanged, see HTTP ETag","example":"If-None-Match: \\"737060cd8c284d8af7ad3082f209582d\\"","autocomplete":["\\"737060cd8c284d8af7ad3082f209582d\\""]},
      {"key":"If-Range","desc":"If the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity","example":"If-Range: \\"737060cd8c284d8af7ad3082f209582d\\"","autocomplete":["\\"737060cd8c284d8af7ad3082f209582d\\""]},
      {"key":"If-Unmodified-Since","desc":"Only send the response if the entity has not been modified since a specific time.","example":"If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT"},
      {"key":"Max-Forwards","desc":"Limit the number of times the message can be forwarded through proxies or gateways.","example":"Max-Forwards: 10"},
      {"key":"Pragma","desc":"Implementation-specific headers that may have various effects anywhere along the request-response chain","example":"Pragma: no-cache","autocomplete":["no-cache"]},
      {"key":"Proxy-Authorization","desc":"Authorization credentials for connecting to a proxy.","example":"Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="},
      {"key":"Range","desc":"Request only part of an entity. Bytes are numbered from 0.","example":"Range: bytes=500-999","autocomplete":["bytes=0-999","bytes=200-1000, 2000-6576","bytes=200-1000, 2000-6576, 19000-"]},
      {"key":"Referer","desc":"This is the address of the previous web page from which a link to the currently requested page was followed.","example":"Referer: http://en.wikipedia.org/wiki/Main_Page","autocomplete":["https://advancedrestclient.com/"]},
      {"key":"TE","desc":"The transfer encodings the user agent is willing to accept: the same values as for the response header Transfer-Encoding can be used, plus the \\"trailers\\" value (related to the \\"chunked\\" transfer method) to notify the server it accepts to receive additional headers (the trailers) after the last, zero-sized, chunk.","example":"TE: trailers, deflate","autocomplete":["compress","deflate","gzip","trailers","gzip, deflate;q=0.5"]},
      {"key":"Upgrade","desc":"Ask the server to upgrade to another protocol","example":"Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11","autocomplete":["h2c","websocket","TLS/1.0","TLS/1.0, HTTP/1.1"]},
      {"key":"User-Agent","desc":"The user agent string of the user agent","example":"User-Agent: Mozilla/5.0 (Linux; X11)","autocomplete":["Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0","Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:42.0) Gecko/20100101 Firefox/42.0","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 OPR/38.0.2220.41","Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1","Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)","Googlebot/2.1 (+http://www.google.com/bot.html)"]},
      {"key":"Via","desc":"Informs the server of proxies through which the request was sent.","example":"Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)","autocomplete":["1.1 vegur","HTTP/1.1 GWA","1.0 fred, 1.1 p.example.net"]},
      {"key":"Warning","desc":"A general warning about possible problems with the entity body.","example":"Warning: 199 Miscellaneous warning","autocomplete":["110 anderson/1.3.37 \\"Response is stale\\"","112 - \\"cache down\\" \\"Wed, 21 Oct 2015 07:28:00 GMT\\""]}
     ],
     "responses": [
      {"key":"Accept-Ranges","desc":"What partial content range types this server supports","example":"Accept-Ranges: bytes"},
      {"key":"Age","desc":"The age the object has been in a proxy cache in seconds","example":"Age: 12"},
      {"key":"Allow","desc":"Valid actions for a specified resource. To be used for a 405 Method not allowed","example":"Allow: GET, HEAD"},
      {"key":"Cache-Control","desc":"Tells all caching mechanisms from server to client whether they may cache this object","example":"Cache-Control: max-age"},
      {"key":"Content-Encoding","desc":"The type of encoding used on the data","example":"Content-Encoding: gzip"},
      {"key":"Content-Language","desc":"The language the content is in","example":"Content-Language: da"},
      {"key":"Content-Length","desc":"The length of the response body in octets (8-bit bytes)","example":"Content-Length: 348"},
      {"key":"Content-Location","desc":"An alternate location for the returned data","example":"Content-Location: /index.htm"},
      {"key":"Content-Disposition","desc":"An opportunity to raise a \\"File Download\\" dialogue box for a known MIME type","example":"Content-Disposition: attachment; filename=fname.ext"},
      {"key":"Content-MD5","desc":"A Base64-encoded binary MD5 sum of the content of the response","example":"Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ=="},
      {"key":"Content-Range","desc":"Where in a full body message this partial message belongs","example":"Content-Range: bytes 21010-47021/47022"},
      {"key":"Content-Type","desc":"The mime type of this content","example":"Content-Type: text/html; charset=utf-8"},
      {"key":"Date","desc":"The date and time that the message was sent","example":"Date: Tue, 15 Nov 1994 08:12:31 GMT"},
      {"key":"ETag","desc":"An identifier for a specific version of a resource, often a Message Digest, see ETag","example":"ETag: \\"737060cd8c284d8af7ad3082f209582d\\""},
      {"key":"Expires","desc":"Gives the date/time after which the response is considered stale","example":"Expires: Thu, 01 Dec 1994 16:00:00 GMT"},
      {"key":"Last-Modified","desc":"The last modified date for the requested object, in RFC 2822 format","example":"Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT"},
      {"key":"Link","desc":"Used to express a typed relationship with another resource, where the relation type is defined by RFC 5988","example":"Link: &lt;/feed&gt;; rel=\\"alternate\\""},
      {"key":"Location","desc":"Used in redirection, or when a new resource has been created.","example":"Location: http://www.w3.org/pub/WWW/People.html"},
      {"key":"P3P","desc":"This header is supposed to set P3P policy, in the form of P3P:CP=\\"your_compact_policy\\". However, P3P did not take off[2], most browsers have never fully implemented it, a lot of websites set this header with fake policy text, that was enough to fool browsers the existence of P3P policy and grant permissions for third party cookies.","example":"P3P: CP=\\"This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&answer=151657 for more info.\\""},
      {"key":"Pragma","desc":"Implementation-specific headers that may have various effects anywhere along the request-response chain.","example":"Pragma: no-cache"},
      {"key":"Proxy-Authenticate","desc":"Request authentication to access the proxy.","example":"Proxy-Authenticate: Basic"},
      {"key":"Refresh","desc":"Used in redirection, or when a new resource has been created. This refresh redirects after 5 seconds.(This is a proprietary/non-standard header extension introduced by Netscape and supported by most web browsers.)","example":"Refresh: 5; url=http://www.w3.org/pub/WWW/People.html"},
      {"key":"Retry-After","desc":"If an entity is temporarily unavailable, this instructs the client to try again after a specified period of time.","example":"Retry-After: 120"},
      {"key":"Server","desc":"A name for the server","example":"Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)"},
      {"key":"Set-Cookie","desc":"an HTTP cookie","example":"Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1"},
      {"key":"Trailer","desc":"The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding.","example":"Trailer: Max-Forwards"},
      {"key":"Transfer-Encoding","desc":"The form of encoding used to safely transfer the entity to the user. Currently defined methods are: chunked, compress, deflate, gzip, identity.","example":"Transfer-Encoding: chunked"},
      {"key":"Vary","desc":"Tells downstream proxies how to match future request headers to decide whether the cached response can be used rather than requesting a fresh one from the origin server.","example":"Vary: *"},
      {"key":"Via","desc":"Informs the client of proxies through which the response was sent.","example":"Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)"},
      {"key":"Warning","desc":"A general warning about possible problems with the entity body.","example":"Warning: 199 Miscellaneous warning"},
      {"key":"WWW-Authenticate","desc":"Indicates the authentication scheme that should be used to access the requested entity.","example":"WWW-Authenticate: Basic"}
     ],
     "codes":[
      {"key":100, "label":"Continue","desc":"This means that the server has received the request headers, and that the client should proceed to send the request body (in the case of a request for which a body needs to be sent; for example, a POST request). If the request body is large, sending it to a server when a request has already been rejected based upon inappropriate headers is inefficient. To have a server check if the request could be accepted based on the request's headers alone, a client must send Expect: 100-continue as a header in its initial request and check if a 100 Continue status code is received in response before continuing (or receive 417 Expectation Failed and not continue)."},
      {"key":101, "label":"Switching Protocols","desc":"This means the requester has asked the server to switch protocols and the server is acknowledging that it will do so"},
      {"key":102, "label":"Processing","desc":"As a WebDAV request may contain many sub-requests involving file operations, it may take a long time to complete the request. This code indicates that the server has received and is processing the request, but no response is available yet. This prevents the client from timing out and assuming the request was lost."},
      {"key":200, "label":"OK","desc":"Standard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request the response will contain an entity describing or containing the result of the action."},
      {"key":201, "label":"Created","desc":"The request has been fulfilled and resulted in a new resource being created."},
      {"key":202, "label":"Accepted","desc":"The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place."},
      {"key":203, "label":"Non-Authoritative Information (since HTTP/1.1)","desc":"The server successfully processed the request, but is returning information that may be from another source."},
      {"key":204, "label":"No Content","desc":"The server successfully processed the request, but is not returning any content."},
      {"key":205, "label":"Reset Content","desc":"The server successfully processed the request, but is not returning any content. Unlike a 204 response, this response requires that the requester reset the document view."},
      {"key":206, "label":"Partial Content","desc":"The server is delivering only part of the resource due to a range header sent by the client. The range header is used by tools like wget to enable resuming of interrupted downloads, or split a download into multiple simultaneous streams."},
      {"key":207, "label":"Multi-Status (WebDAV) (RFC 4918)","desc":"The message body that follows is an XML message and can contain a number of separate response codes, depending on how many sub-requests were made."},
      {"key":300, "label":"Multiple Choices","desc":"Indicates multiple options for the resource that the client may follow. It, for instance, could be used to present different format options for video, list files with different extensions, or word sense disambiguation."},
      {"key":301, "label":"Moved Permanently","desc":"This and all future requests should be directed to the given URI."},
      {"key":302, "label":"Found","desc":"This is an example of industrial practice contradicting the standard. HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect (the original describing phrase was \\"Moved Temporarily\\"), but popular browsers implemented 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307 to distinguish between the two behaviours. However, the majority of Web applications and frameworks still use the 302 status code as if it were the 303."},
      {"key":303, "label":"See Other (since HTTP/1.1)","desc":"The response to the request can be found under another URI using a GET method. When received in response to a PUT, it should be assumed that the server has received the data and the redirect should be issued with a separate GET message."},
      {"key":304, "label":"Not Modified","desc":"Indicates the resource has not been modified since last requested. Typically, the HTTP client provides a header like the If-Modified-Since header to provide a time against which to compare. Using this saves bandwidth and reprocessing on both the server and client, as only the header data must be sent and received in comparison to the entirety of the page being re-processed by the server, then sent again using more bandwidth of the server and client."},
      {"key":305, "label":"Use Proxy (since HTTP/1.1)","desc":"Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons."},
      {"key":306, "label":"Switch Proxy","desc":"No longer used."},
      {"key":307, "label":"Temporary Redirect (since HTTP/1.1)","desc":"In this occasion, the request should be repeated with another URI, but future requests can still use the original URI. In contrast to 303, the request method should not be changed when reissuing the original request. For instance, a POST request must be repeated using another POST request."},
      {"key":400, "label":"Bad Request","desc":"The request cannot be fulfilled due to bad syntax."},
      {"key":401, "label":"Unauthorized","desc":"Similar to 403 Forbidden, but specifically for use when authentication is possible but has failed or not yet been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource. See Basic access authentication and Digest access authentication."},
      {"key":402, "label":"Payment Required","desc":"Reserved for future use. The original intention was that this code might be used as part of some form of digital cash or micropayment scheme, but that has not happened, and this code is not usually used. As an example of its use, however, Apple's MobileMe service generates a 402 error (\\"httpStatusCode:402\\" in the Mac OS X Console log) if the MobileMe account is delinquent."},
      {"key":403, "label":"Forbidden","desc":"The request was a legal request, but the server is refusing to respond to it. Unlike a 401 Unauthorized response, authenticating will make no difference."},
      {"key":404, "label":"Not Found","desc":"The requested resource could not be found but may be available again in the future. Subsequent requests by the client are permissible."},
      {"key":405, "label":"Method Not Allowed","desc":"A request was made of a resource using a request method not supported by that resource; for example, using GET on a form which requires data to be presented via POST, or using PUT on a read-only resource."},
      {"key":406, "label":"Not Acceptable","desc":"The requested resource is only capable of generating content not acceptable according to the Accept headers sent in the request."},
      {"key":407, "label":"Proxy Authentication Required","desc":"This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with the proxy."},
      {"key":408, "label":"Request Timeout","desc":"The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."},
      {"key":409, "label":"Conflict","desc":"Indicates that the request could not be processed because of conflict in the request, such as an edit conflict."},
      {"key":410, "label":"Gone","desc":"Indicates that the resource requested is no longer available and will not be available again.[2] This should be used when a resource has been intentionally removed and the resource should be purged. Upon receiving a 410 status code, the client should not request the resource again in the future."},
      {"key":411, "label":"Length Required","desc":"The request did not specify the length of its content, which is required by the requested resource."},
      {"key":412, "label":"Precondition Failed","desc":"The server does not meet one of the preconditions that the requester put on the request."},
      {"key":413, "label":"Request Entity Too Large","desc":"The request is larger than the server is willing or able to process."},
      {"key":414, "label":"Request-URI Too Long","desc":"The URI provided was too long for the server to process."},
      {"key":415, "label":"Unsupported Media Type","desc":"The request entity has a media type which the server or resource does not support.[2] For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format."},
      {"key":416, "label":"Requested Range Not Satisfiable","desc":"The client has asked for a portion of the file, but the server cannot supply that portion. For example, if the client asked for a part of the file that lies beyond the end of the file."},
      {"key":417, "label":"Expectation Failed","desc":"The server cannot meet the requirements of the Expect request-header field."},
      {"key":418, "label":"I'm a teapot","desc":"This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol, and is not expected to be implemented by actual HTTP servers."},
      {"key":422, "label":"Unprocessable Entity (WebDAV) (RFC 4918)","desc":"The request was well-formed but was unable to be followed due to semantic errors."},
      {"key":423, "label":"Locked (WebDAV) (RFC 4918)","desc":"The resource that is being accessed is locked."},
      {"key":424, "label":"Failed Dependency (WebDAV) (RFC 4918)","desc":"The request failed due to failure of a previous request (e.g. a PROPPATCH)."},
      {"key":425, "label":"Unordered Collection (RFC 3648)","desc":"Defined in drafts of \\"WebDAV Advanced Collections Protocol\\", but not present in \\"Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol\\""},
      {"key":426, "label":"Upgrade Required (RFC 2817)","desc":"The client should switch to a different protocol such as TLS/1.0."},
      {"key":444, "label":"No Response","desc":"An Nginx HTTP server extension. The server returns no information to the client and closes the connection (useful as a deterrent for malware)."},
      {"key":449, "label":"Retry With","desc":"A Microsoft extension. The request should be retried after performing the appropriate action."},
      {"key":450, "label":"Blocked by Windows Parental Controls","desc":"A Microsoft extension. This error is given when Windows Parental Controls are turned on and are blocking access to the given webpage."},
      {"key":499, "label":"Client Closed Request","desc":"An Nginx HTTP server extension. This code is introduced to log the case when the connection is closed by client while HTTP server is processing its request, making server unable to send the HTTP header back."},
      {"key":500, "label":"Internal Server Error","desc":"A generic error message, given when no more specific message is suitable."},
      {"key":501, "label":"Not Implemented","desc":"The server either does not recognise the request method, or it lacks the ability to fulfill the request."},
      {"key":502, "label":"Bad Gateway","desc":"The server was acting as a gateway or proxy and received an invalid response from the upstream server."},
      {"key":503, "label":"Service Unavailable","desc":"The server is currently unavailable (because it is overloaded or down for maintenance). Generally, this is a temporary state."},
      {"key":504, "label":"Gateway Timeout","desc":"The server was acting as a gateway or proxy and did not receive a timely response from the upstream server."},
      {"key":505, "label":"HTTP Version Not Supported","desc":"The server does not support the HTTP protocol version used in the request"},
      {"key":506, "label":"Variant Also Negotiates","desc":"Transparent content negotiation for the request results in a circular reference."},
      {"key":507, "label":"Insufficient Storage (WebDAV) (RFC 4918)","desc":"The 507 status code means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request."},
      {"key":509, "label":"Bandwidth Limit Exceeded (Apache bw/limited extension)","desc":"This status code, while used by many servers, is not specified in any RFCs."},
      {"key":510, "label":"Not Extended (RFC 2774)","desc":"Further extensions to the request are required for the server to fulfill it."}
     ]
    }`;
    const tpl = document.createElement('template');
    tpl.innerHTML = data;
    return tpl;
  }
  /**
   * A list of request headers.
   *
   * Each object contains a `key`, `desc` and `example` property. `key` is a header name,
   * `desc` is a description of the header and `example` is an example of usage.
   *
   * ### Example
   * ```
   * [{
   *  "key": "Accept",
   *  "desc": "Content-Types that are acceptable.",
   *  "example": "Accept: text/plain"
   * }],
   * ```
   *
   * Note, this property won't notify parent component when this property is set
   * so 2-way data binding won't work with this property.
   *
   * @type {Array<Object>}
   */
  get requestHeaders() {
    this._setDefinitions();
    return this._requestHeaders;
  }
  /**
   * A list of response headers.
   *
   * Each object contains a `key`, `desc` and `example` property. `key` is a header name,
   * `desc` is a description of the header and `example` is an example of usage.
   *
   * ### Example
   * ```
   * [{
   *  "key": "Age",
   *  "desc": "The age the object has been in a proxy cache in seconds",
   *  "example": "Age: 12"
   * }],
   * ```
   *
   * Note, this property won't notify parent component when this property is set
   * so 2-way data binding won't work with this property.
   *
   * @type {Array<Object>}
   */
  get responseHeaders() {
    this._setDefinitions();
    return this._responseHeaders;
  }
  /**
   * A list of status codes definitions.
   *
   * Each object contains a `key`, `label` and `desc` property. `key` is a status code (as
   * a number), `label` is a status code message and `desc` is description for the status
   * code.
   *
   * ### Example
   * ```
   * [{
   *  "key": 306,
   *  "label": "Switch Proxy",
   *  "desc": "No longer used."
   * }]
   *
   * Note, this property won't notify parent component when this property is set
   * so 2-way data binding won't work with this property.
   *
   * @type {Array<Object>}
   */
  get statusCodes() {
    this._setDefinitions();
    return this._statusCodes;
  }
  /**
   * @constructor
   */
  constructor() {
    super();
    this._queryHeadersHandler = this._queryHeadersHandler.bind(this);
    this._queryCodesHandler = this._queryCodesHandler.bind(this);
  }

  connectedCallback() {
    window.addEventListener('query-headers', this._queryHeadersHandler);
    window.addEventListener('query-status-codes', this._queryCodesHandler);
    if (!this.hasAttribute('aria-hidden')) {
      this.setAttribute('aria-hidden', 'true');
    }
  }

  disconnectedCallback() {
    window.removeEventListener('query-headers', this._queryHeadersHandler);
    window.removeEventListener('query-status-codes', this._queryCodesHandler);
  }
  /**
   * Translates tempolate data into a corresponding values structure.
   */
  _setDefinitions() {
    if (this._definitionsReady) {
      return;
    }
    this._definitionsReady = true;
    const tpl = ArcDefinitions._dataTemplate;
    const defs = JSON.parse(tpl.content.textContent);
    this._requestHeaders = defs.requests;
    this._responseHeaders = defs.responses;
    this._statusCodes = defs.codes;
  }

  /**
   * Queries for request headers that containins a `query`. If query is
   * not set (value is falsy) then it returns all headers definitions array.
   *
   * @param {String} name A header name to look for. It will match a header
   * where the header name contains the `name` param.
   * @return {Array<Object>} Array of the request headers matched `name` in
   * the header's `key` field.
   */
  queryRequestHeaders(name) {
    return this.queryHeaders(name, 'request');
  }

  /**
   * Queries for response headers that containins a `query`. If query is
   * not set (value is falsy) then it returns all headers definitions array.
   *
   * @param {String} name A header name to look for. It will match a header where the header
   * name contains the `name` param.
   * @return {Array<Object>} Array of the response headers matched `name`
   * in the header's `key` field.
   */
  queryResponseHeaders(name) {
    return this.queryHeaders(name, 'response');
  }

  /**
   * Queries for headers containin a `query`. If query is not set
   * (value is falsy) then it returns all headers definitions array.
   *
   * @param {String} query A query to search for in the `key` field of the
   * headers array.
   * @param {String} type If this equals `request` then it will look in the
   * request headers array. Is the response headers list otherwise.
   * @return {Array<Object>} Array of the headers of selected `type`
   * matched a `query` in a header's `key` field.
   */
  queryHeaders(query, type) {
    const headers = type === 'request' ? this.requestHeaders : this.responseHeaders;
    if (!query) {
      return headers;
    }
    query = query.trim().toLowerCase();
    return headers.filter(function(item) {
      return item.key.toLowerCase().indexOf(query) !== -1;
    });
  }

  /**
   * Convinient function to look for a status code in the array.
   *
   * @param {Number} code The status code to look for.
   * @return {Object|Array<Object>|null} Status code definition or null if not found.
   */
  getStatusCode(code) {
    const codes = this.statusCodes;
    if (!code) {
      return codes;
    }
    code = Number(code);
    if (code !== code) {
      return null;
    }
    const res = codes.filter((item) => item.key === code);
    if (!res.length) {
      return null;
    }
    return res[0];
  }
  /**
   * A handler for the status headers query event
   *
   * @param {CustomEvent} e
   */
  _queryHeadersHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    this._stopEvent(e);
    const type = e.detail.type;
    if (!type) {
      e.detail.headers = [];
      return;
    }
    e.detail.headers = this.queryHeaders(e.detail.query, type);
  }
  /**
   * A handler for the status code query event
   *
   * @param {CustomEvent} e
   */
  _queryCodesHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    this._stopEvent(e);
    e.detail.statusCode = this.getStatusCode(e.detail.code);
  }

  _stopEvent(e) {
    e.stopImmediatePropagation();
    e.preventDefault();
  }
}
window.customElements.define('arc-definitions', ArcDefinitions);

/**
 * Headers form item.
 *
 * Provides UI to enter headers data and autocomplete function for both header
 * names and values.
 *
 * @customElement
 * @demo demo/index.html
 * @polymerBehavior IronValidatableBehavior
 * @memberOf ApiComponents
 */
class ApiHeadersFormItem extends ValidatableMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      css`
      :host {
        display: block;
      }

      .form-row {
        display: flex;
        flex-direction: row;
        align-items: center;
        flex: 1;
      }

      .value-field,
      .name-field {
        position: relative;
      }

      .name-field,
      .value-field {
        display: flex;
        flex-direction: row;
        flex: 1;
        align-items: center;
      }

      .param-name,
      api-property-form-item {
        flex: 1;
      }

      api-property-form-item[isarray] {
        margin-top: 8px;
      }

      .param-name {
        margin-right: 12px;
      }

      :host([narrow]) .form-row {
        display: block;
      }

      :host([narrow]) .param-name {
        margin-right: 0;
      }

      [hidden] {
        display: none !important;
      }

      :host([isarray]) .value-field {
        align-items: start;
      }

      :host([isarray]) anypoint-icon-button {
        margin-top: 8px;
      }

      anypoint-icon-button {
        /* margin-top: var(--api-headers-editore-hint-icon-margin-top, 16px); */
      }

      :host([narrow]) anypoint-icon-button {
        /* margin-top: var(--api-headers-editore-hint-icon-margin-top-narrow, 16px); */
      }

      .custom-wrapper {
        display: flex;
        flex-direction: row;
        align-items: center;
      }
      `
    ];
  }

  _customTemplate() {
    const {
      name,
      value,
      readOnly,
      compatibility,
      outlined,
      noDocs,
      _nameInput,
      _nameSuggestions
    } = this;
    const model = this.model || { schema: {} };
    const renderNameSuggestions = this._renderAutocomplete(_nameInput, _nameSuggestions);
    return html`<div class="custom-wrapper">
      <div class="form-row custom-field">
        <div class="name-field">
          <anypoint-input
            .value="${name || ''}"
            class="param-name"
            type="text"
            pattern="\\S*"
            ?readOnly="${readOnly}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"
            required
            invalidmessage="Header name is not valid"
            @value-changed="${this._nameValueHandler}"
            @focus="${this._headerNameFocus}"
            @input="${this._headerNameHandler}">
            <label slot="label">Header name</label>
          </anypoint-input>
          ${renderNameSuggestions ? html`
            <anypoint-autocomplete
              class="name-suggestions"
              .target="${_nameInput}"
              .source="${_nameSuggestions}"
              ?compatibility="${compatibility}"
              @selected="${this._onHeaderNameSelected}"
              @opened-changed="${this._nameSuggestOpenHandler}"></anypoint-autocomplete>` : undefined}
        </div>
        <div class="value-field">
          <api-property-form-item
            name="${name}"
            data-type="custom"
            .model="${model}"
            .value="${value || ''}"
            ?readonly="${readOnly}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"
            @value-changed="${this._valueChangeHandler}"></api-property-form-item>
        </div>
      </div>
      <div class="actions">
        ${!noDocs && model.hasDescription ? html`<anypoint-icon-button
          class="hint-icon"
          title="Show documentation"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          @click="${this.toggleDocs}">
          <iron-icon icon="arc:help"></iron-icon>
        </anypoint-icon-button>` : undefined}
        <slot name="suffix"></slot>
      </div>
    </div>`;
  }

  _modelTemplate() {
    const {
      name,
      value,
      readOnly,
      required,
      compatibility,
      outlined,
      noDocs
    } = this;
    const model = this.model || { schema: {} };
    return html`<div class="value-field api-field">
      <api-property-form-item
        .model="${model}"
        name="${name}"
        .value="${value}"
        data-type="typed"
        ?required="${required}"
        ?readonly="${readOnly}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        @value-changed="${this._valueChangeHandler}"></api-property-form-item>
        ${model.hasDescription && !noDocs ? html`<anypoint-icon-button
          class="hint-icon"
          title="Show documentation"
          @click="${this.toggleDocs}">
          <iron-icon icon="arc:help"></iron-icon>
        </anypoint-icon-button>` : undefined}
      <slot name="suffix"></slot>
    </div>`;
  }

  render() {
    const {
      isCustom,
      docsOpened,
      compatibility,
      noDocs,
      _valueInput,
      _valueSuggestions
    } = this;
    const model = this.model || { schema: {} };
    const hasAutocomplete = this._renderAutocomplete(_valueInput, _valueSuggestions);
    return html`
    ${isCustom ? this._customTemplate() : this._modelTemplate()}

    ${!noDocs && docsOpened && model.description ? html`<arc-marked .markdown="${model.description}">
      <div slot="markdown-html" class="markdown-body"></div>
    </arc-marked>` : undefined}

    ${hasAutocomplete ? html`<anypoint-autocomplete
      class="value-autocomplete"
      openonfocus
      ?compatibility="${compatibility}"
      @selected="${this._valueSelectedHandler}"
      verticaloffset="-10"
      .positionTarget="${_valueInput}"
      .target="${_valueInput}"
      .source="${_valueSuggestions}"></anypoint-autocomplete>` : undefined}
    `;
  }

  static get properties() {
    return {
      /**
       * View model for the headers.
       */
      model: { type: Object },
      /**
       * The name of this element.
       */
      name: { type: String },
      /**
       * The value of this element.
       */
      value: { type: String },
      /**
       * If set it renders a narrow layout
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * True to render documentation (if set in model)
       */
      docsOpened: { type: Boolean },
      /**
       * Set if the header is not specified in the RAML type (is a custom
       * header).
       */
      isCustom: { type: Boolean },
      /**
       * If set it is render the item control as an array item (adds more
       * spacing to the element)
       */
      isArray: { type: Boolean, reflect: true },
      /**
       * List of value suggestion for current header. The list is updated
       * automatically when header name changes
       */
      _valueSuggestions: { type: Array },
      _nameSuggestions: { type: Array },
      // Reference to header value input.
      _valueInput: { type: Object },
      // Reference to the name input field
      _nameInput: { type: Object },
      // True when this model is required
      required: { type: Boolean },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       * Note, Set is separately for `api-view-model-transformer`
       * component as this only affects "custom" items.
       */
      noDocs: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    const old = this._name;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._name = value;
    this.requestUpdate('name', old);
    this._nameChanged(value);
    this.dispatchEvent(new CustomEvent('name-changed', {
      detail: {
        value
      }
    }));
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._value = value;
    this.requestUpdate('value', old);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  constructor() {
    super();
    this.value = '';
  }
  /**
   * Toggles documentation (if available)
   */
  toggleDocs() {
    this.docsOpened = !this.docsOpened;
  }

  /**
   * Handler for header name field focus. It sets `_nameInput` property and
   * requests for header names suggestions to render the autocomplete.
   * @param {CustomEvent} e
   */
  _headerNameFocus(e) {
    if (this.readOnly || this._nameInput) {
      return;
    }
    this._nameInput = e.currentTarget || e.target;
    this._setNameSuggestions(this._nameInput.value);
  }
  /**
   * A handler called when the user selects a suggestion.
   * @param {CustomEvent} e
   */
  _onHeaderNameSelected(e) {
    const { value } = e.detail;
    this.name = value.value || value;
  }
  /**
   * Handler for autocomplete element. Query the datastore for suggestions.
   *
   * @param {Event} e Autocomplete event
   */
  _headerNameHandler(e) {
    const value = e.detail ? e.detail.value : e.target.value;
    this._setNameSuggestions(value);
  }
  /**
   * Queries and sets suggestions for name.
   * @param {String} query The header name to query for.
   */
  _setNameSuggestions(query) {
    const suggestions = this._queryHeaderNameSuggestions(query);
    if (!suggestions || !suggestions.length) {
      this._nameSuggestions = undefined;
      this._nameSuggestionsOpened = false;
      return;
    }
    this._nameSuggestions = suggestions.map((item) => {
      return {
        value: item.key,
        display: item.key
      };
    });
  }
  /**
   * Dispatches `query-headers` custom event to retreive from the application
   * headers definition.
   *
   * `api-headers-form` element contains `arc-definitions` element that
   * listens for this event.
   *
   * @param {String} q Header name to query for
   * @return {Array} Headers definition or empty array
   */
  _queryHeaderNameSuggestions(q) {
    const ev = new CustomEvent('query-headers', {
      detail: {
        type: 'request',
        query: q
      },
      cancelable: true,
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
    return ev.detail.headers;
  }

  _getValidity() {
    let selector = 'api-property-form-item[data-type="';
    selector += this.isCustom ? 'custom' : 'typed';
    selector += '"]';
    const input = this.shadowRoot.querySelector(selector);
    return input.validate();
  }
  /**
   * Updates value suggestions for custom values.
   *
   * @param {String} name Header name
   */
  _nameChanged(name) {
    if (!name) {
      this._valueSuggestions = undefined;
      return;
    }
    if (this.__valueQueryHeaders) {
      clearTimeout(this.__valueQueryHeaders);
    }
    this.__valueQueryHeaders = setTimeout(() => {
      this.__valueQueryHeaders = null;
      const info = this._queryHeaderNameSuggestions(this.name);
      this._updateValueAutocomplete(info);
      if (!this.noDocs) {
        this._updateHeaderDocs(info);
      }
    });
  }
  /**
   * Updates header value autocomplete if header definition contains
   * the `autocomplete` entry. It only sets the autocomplete value when
   * only one header has been found for current input.
   *
   * @param {Array<Object>} headers List of received headers from headers query
   */
  _updateValueAutocomplete(headers) {
    if (!headers || !headers.length) {
      if (this._valueSuggestions) {
        this._valueSuggestions = undefined;
      }
      return;
    }
    let header;
    for (let i = 0, len = headers.length; i < len; i++) {
      if (headers[i].key.toLowerCase() === this.name.toLowerCase()) {
        header = headers[i];
        break;
      }
    }
    if (header) {
      this._valueSuggestions = header.autocomplete;
      if (!this._valueInput) {
        this._valueInput = this.shadowRoot.querySelector('api-property-form-item');
      }
    } else {
      this._valueSuggestions = undefined;
    }
  }
  /**
   * Updates header description if the header doesn't contain a description
   * already.
   *
   * @param {Object} info
   */
  _updateHeaderDocs(info) {
    if (this._nameSuggestionsOpened || this.noDocs) {
      return;
    }
    const model = this.model;
    if (!model) {
      return;
    }
    if (!info || info.length !== 1) {
      if (model.hasDescription && model.__ownDescription) {
        this.model.description = undefined;
        this.model.hasDescription = false;
        this.model.__ownDescription = false;
        this.model = Object.assign({}, this.model);
      }
      return;
    }
    if (model.hasDescription) {
      return;
    }

    this.model.description = info[0].desc;
    this.model.hasDescription = true;
    this.model.__ownDescription = true;
    this.model = Object.assign({}, this.model);
  }
  /**
   * Tests whether autocomplete element should be rendered.
   * @param {?Element} input Target element for autocomplete
   * @param {?Array} suggestions List of suggestions.
   * @return {Boolean} True when has the input and some suggestions.
   */
  _renderAutocomplete(input, suggestions) {
    return !!(input && suggestions && suggestions.length);
  }
  /**
   * Handler for name field value change. Sets new name on this element.
   * @param {CustomEvent} e
   */
  _nameValueHandler(e) {
    this.name = e.detail.value;
  }
  /**
   * Handler for name autocomplete opened changed event.
   * It sets opened flag so the element won't request for value suggestions while
   * autocomplete is opened.
   * @param {CustomEvent} e
   */
  _nameSuggestOpenHandler(e) {
    this._nameSuggestionsOpened = e.detail.value;
  }
  /**
   * Handler for value change from the value input
   * @param {CustomEvent} e
   */
  _valueChangeHandler(e) {
    this.value = e.detail.value;
  }
  /**
   * Handler for value autocomplete selection event.
   * Validates the input as after the autocomplete updates the value programatically
   * it won't trigger validation.
   */
  _valueSelectedHandler() {
    setTimeout(() => {
      this.validate();
    });
  }
  /**
   * If it is custom header then it focuses on the name ionput.
   * Otherwise it focuses on API form item.
   */
  focus() {
    let node;
    if (this.isCustom) {
      node = this.shadowRoot.querySelector('.name-field anypoint-input');
    } else {
      node = this.shadowRoot.querySelector('api-property-form-item');
    }
    if (node) {
      node.focus();
    }
  }
}

window.customElements.define('api-headers-form-item', ApiHeadersFormItem);

/**
 * HTTP headers form build from AMF json/ld model.
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin ApiFormMixin
 * @appliesMixin ValidatableMixin
 * @memberOf ApiComponents
 */
class ApiHeadersForm extends ValidatableMixin(ApiFormMixin(LitElement)) {
  static get styles() {
    return [
      formStyles,
      css`:host {
        display: block;
      }

      api-headers-form-item {
        flex: 1;
      }

      .enable-checkbox {
        margin-right: 8px;
      }

      [hidden] {
        display: none !important;
      }

      .empty-info {
        color: var(--empty-info-color, rgba(0, 0, 0, 0.74));
        font-size: var(--empty-info-font-size, 16px);
      }`
    ];
  }

  render() {
    const {
      renderEmptyMessage,
      renderOptionalCheckbox,
      allowDisableParams,
      readOnly,
      hasOptional,
      narrow,
      noDocs,
      allowCustom,
      compatibility,
      outlined,
      optionalOpened
    } = this;
    const model = this.model || [];
    return html`<arc-definitions></arc-definitions>

    ${renderEmptyMessage ? html`<p class="empty-info">Headers are not defined for this endpoint</p>` : undefined}

    <iron-form>
      <form enctype="application/json">
        ${renderOptionalCheckbox ? html`<div class="optional-checkbox">
          <anypoint-checkbox
            class="toggle-checkbox"
            .checked="${optionalOpened}"
            @checked-changed="${this._optionalHanlder}"
            title="Shows or hides optional parameters">Show optional headers</anypoint-checkbox>
        </div>` : undefined}
        ${model.map((item, index) => html`
        <div class="form-item" ?data-optional="${this.computeIsOptional(hasOptional, item)}">
          ${allowDisableParams ? html`
          <anypoint-checkbox
            class="enable-checkbox"
            ?checked="${item.schema.enabled}"
            data-index="${index}"
            @checked-changed="${this._enableCheckedHandler}"
            title="Enable or disable this header"
            ?disabled="${readOnly}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}"></anypoint-checkbox>` : undefined}
          <api-headers-form-item
            data-index="${index}"
            .name="${item.name}"
            @name-changed="${this._nameChangeHandler}"
            .value="${item.value}"
            @value-changed="${this._valueChangeHandler}"
            .model="${item}"
            ?required="${item.required}"
            .readOnly="${readOnly}"
            .isCustom="${item.schema.isCustom}"
            .isArray="${item.schema.isArray}"
            ?narrow="${narrow}"
            .noDocs="${noDocs}"
            ?outlined="${outlined}"
            ?compatibility="${compatibility}">
            <anypoint-icon-button
              title="Remove this header"
              aria-label="Press to remove header ${name}"
              class="action-icon delete-icon"
              data-index="${index}"
              @click="${this._removeCustom}"
              slot="suffix"
              ?disabled="${readOnly}"
              ?outlined="${outlined}"
              ?compatibility="${compatibility}">
              <iron-icon icon="arc:remove-circle-outline"></iron-icon>
            </anypoint-icon-button>
          </api-headers-form-item>
        </div>`)}
      </form>
    </iron-form>

    ${allowCustom ? html`<div class="add-action">
      <anypoint-button
        class="action-button"
        @tap="${this.add}"
        title="Add new header"
        aria-label="Press to create a new header"
        ?disabled="${readOnly}">
        <iron-icon
          class="action-icon"
          icon="arc:add-circle-outline"
          alt="Add header icon"></iron-icon>
        Add header
      </anypoint-button>
    </div>` : undefined}
`;
  }

  static get properties() {
    return {
      /**
       * Current value of the headers. Changing the value will update the list
       * of the headers.
       */
      value: { type: String },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       * Note, Set is separately for `api-view-model-transformer`
       * component as this only affects "custom" items.
       */
      noDocs: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * Automatically validates the input on value change.
       */
      autoValidate: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._value = value;
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get model() {
    return this._model;
  }

  set model(value) {
    const old = this._model;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    super.model = value;
    this.requestUpdate('model', old);
    this._modelChanged(value, this.readOnly);
    // The model change is not propagated outside the element as it keeps a copy
    // of the model.
    // This causes issues when dealing with custom headers and parent template regenerates
    // the view as new items won't be propagated. Parent elements
    // should ovserve this event and update the model if needed.
    this.dispatchEvent(new CustomEvent('model-changed', {
      detail: {
        value
      }
    }));
  }

  get readOnly() {
    return this._readOnly;
  }

  set readOnly(value) {
    const old = this._readOnly;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._readOnly = value;
    this.requestUpdate('readOnly', old);
    this._modelChanged(this.model, value);
  }
  /**
   * @return {Function} Previously registered handler for `value-changed` event
   */
  get onvalue() {
    return this['_onvalue-changed'];
  }
  /**
   * Registers a callback function for `value-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onvalue(value) {
    this._registerCallback('value-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `model-changed` event
   */
  get onmodel() {
    return this['_onmodel-changed'];
  }
  /**
   * Registers a callback function for `model-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onmodel(value) {
    this._registerCallback('model-changed', value);
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }

  firstUpdated() {
    this.__firstUpdatedReady = this;
    this._autoDescribeModel(this.model);
  }
  /**
   * Appends an empty header to the list.
   */
  add() {
    if (!this.allowCustom) {
      return;
    }
    this.addCustom('header');
    setTimeout(() => this.focusLast());
  }
  /**
   * Focuses on last form item.
   */
  focusLast() {
    const node = this.shadowRoot.querySelector('.form-item:last-child api-headers-form-item');
    if (!node) {
      return;
    }
    node.focus();
  }

  _modelChanged(model, readOnly) {
    if (readOnly || !model) {
      return;
    }
    if (this.invalid) {
      this.invalid = false;
    }
    this._updateValue(this.autoValidate);
    if (this.__firstUpdatedReady) {
      this._autoDescribeModel(model);
    }
  }
  /**
   * Updates value of the element when model change.
   * @param {Boolean} validate When true then it performs validation after setting
   * the value.
   */
  _updateValue(validate) {
    if (this.__updatingModelValue || this.readOnly) {
      return;
    }
    this.__updatingModelValue = true;
    setTimeout(() => {
      this.__updateValue(validate);
      this.__updatingModelValue = false;
    });
  }
  /**
   * Creates a header value for current model.
   * @param {Boolean} validate When true then it performs validation after setting
   * the value.
   */
  __updateValue(validate) {
    const h = this.model;
    if (!h || !h.length) {
      this.value = '';
      if (this.invalid) {
        this.invalid = false;
      }
      return;
    }
    let value = '';
    for (let i = 0, len = h.length; i < len; i++) {
      const item = h[i];
      if (item.schema && item.schema.enabled === false) {
        continue;
      }
      const n = item.name || '';
      let v = item.value || '';
      if (!n && !v) {
        continue;
      }
      if (v instanceof Array) {
        v = v.join(',');
      }
      if (!v && !item.required) {
        continue;
      }
      if (value[0]) {
        value += '\n';
      }
      value += n + ': ' + v;
    }
    this.value = value;
    if (validate) {
      this.validate();
    }
  }
  /**
   * Adds documentation for headers that doesn't have it already.
   *
   * @param {Array} model View model
   */
  _autoDescribeModel(model) {
    if (this.noDocs || !model) {
      return;
    }
    model.forEach((item, index) => this._fillModelDescription(item, index));
  }
  /**
   * Queries for header information and updates header info if needed.
   *
   * @param {Object} item View model item
   * @param {Number} index Position of the item in `model` array
   */
  _fillModelDescription(item, index) {
    if (item.hasDescription || item.isCustom) {
      return;
    }
    const type = this._queryHeaderData(item.name);
    if (!type) {
      return;
    }
    const model = this.model;
    model[index].description = type.desc;
    model[index].hasDescription = true;
    model[index].schema.examples = [type.example];
    this.model = [...model];
  }
  /**
   * Queries for a header definition.
   *
   * @param {String} name header name to query
   * @return {Object|undefined} Header definition or undefined.
   */
  _queryHeaderData(name) {
    const node = this.shadowRoot.querySelector('arc-definitions');
    if (!node) {
      return;
    }
    const suggestions = node.queryHeaders(name, 'request');
    if (!suggestions) {
      return;
    }
    name = name.toLowerCase();
    return suggestions.find((i) => i.key.toLowerCase() === name);
  }

  _getValidity() {
    const form = this.shadowRoot && this.shadowRoot.querySelector('iron-form');
    return form ? form.validate() : true;
  }

  _enableCheckedHandler(e) {
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    this.model[index].schema.enabled = e.target.checked;
    // this.model = [...this.model];
    this._updateValue(this.autoValidate);
  }

  _nameChangeHandler(e) {
    if (!this.allowCustom) {
      return;
    }
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    const item = this.model[index];
    if (!item.schema.isCustom) {
      return;
    }
    this.model[index].name = e.detail.value;
    // this.model = [...this.model];
    this._updateValue(this.autoValidate);
  }

  _valueChangeHandler(e) {
    const index = Number(e.target.dataset.index);
    if (index !== index) {
      return;
    }
    this.model[index].value = e.detail.value;
    // this.model = [...this.model];
    this._updateValue(this.autoValidate);
  }

  _optionalHanlder(e) {
    this.optionalOpened = e.detail.value;
  }
}

window.customElements.define('api-headers-form', ApiHeadersForm);

/**
Styles definitions for Code Mirror element.

Custom property | Description | Default
----------------|-------------|----------
`--arc-code-mirror-width` | Width of the editor area | `300px`
`--code-mirror-direction` | Direction property of the editor | `ltr`
`--arc-code-mirror-background-color` | Background color of the editor. | `white`
`--arc-code-mirror-line-padding` | Padding applied to editor area | `4px 0`
`--arc-code-mirror-pre-padding` | Padding of each line in the editor | `0 4px`
`--code-mirror-gutters-border-right-color` | Border right color of the gutters | `#ddd`
`--code-mirror-gutters-background-color` | Background of the gutters | `#f7f7f7`
`--code-mirror-line-number-color` | Color of the line number | `#999`
`--code-mirror-cursor-color` | Color of the cursor in the editor area | `black`
`--code-mirror-secondary-cursor-color` | Color of secondary cursor in the editor area | `silver`
`--code-mirror-header-color` | | `inherit`
`--code-mirror-quote-color` | | `#090`
`--code-mirror-negative-color` | | `#d44`
`--code-mirror-positive-color` | | `#292`
`--code-mirror-invalidchar-color` | | `#f00`
`--code-mirror-keyword-color` | | `#5A5CAD`
`--code-mirror-atom-color` | | `#3b548c`
`--code-mirror-def-color` | | `inherit`
`--code-mirror-number-color` | | `#164`
`--code-mirror-variable-color` | | `black`
`--code-mirror-variable2-color` | | `black`
`--code-mirror-variable3-color` | | `black`
`--code-mirror-property-color` | | `inherit`
`--code-mirror-operator-color` | | `inherit`
`--code-mirror-punctuation-color` | | `inherit`
`--code-mirror-comment-color` | | `#0080FF`
`--code-mirror-string-color` | | `#3b548c`
`--code-mirror-string-2-color` | | `#f50`
`--code-mirror-meta-color` | | `#9e9e9e`
`--code-mirror-qualifier-color` | | `grey`
`--code-mirror-builtin-color` | | `#7EA656`
`--code-mirror-bracket-color` | | `#cc7`
`--code-mirror-tag-color` | | `#3F7F7F`
`--code-mirror-attribute-color` | | `#7F007F`
`--code-mirror-error-color` | | `#f00`
`--code-mirror-active-line-background-color` | | `#e8f2ff`
`--code-mirror-active-match-bracked-color` | | `black`
`--code-mirror-active-match-bracked-background-color` | | `yellow`
`--code-mirror-matches-background-color` | | `rgba(255, 150, 0, .3)`
`--code-mirror-selected-background-color` | | `#d9d9d9`
`--code-mirror-focused-selected-background-color` | | `#d7d4f0`
`--code-mirror-selection-background-color` | | #d7d4f0
*/

var cmStyles = css`.CodeMirror {
  /* Set height, width, borders, and global font properties here */
  font-family: monospace;
  color: var(--code-mirror-color, black);
  background-color: var(--code-mirror-background-color, white);
  direction: var(--code-mirror-direction, ltr);
}

.CodeMirror-lines {
  padding: var(--code-mirror-line-padding, 4px 0);
}

.CodeMirror pre.CodeMirror-line {
  color: var(--code-mirror-punctuation-color, inherit);
}

.CodeMirror pre {
  padding: var(--code-mirror-pre-padding, 0 4px);
}

.CodeMirror-scrollbar-filler,
.CodeMirror-gutter-filler {
  background-color: var(--code-mirror-background-color, white);
}
/* GUTTER */
.CodeMirror-gutters {
  border-right: 1px solid var(--code-mirror-gutters-border-right-color, #ddd);
  background-color: var(--code-mirror-gutters-background-color, #f7f7f7);
  white-space: nowrap;
}

.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: var(--code-mirror-line-number-color, #999);
  white-space: nowrap;
}

.CodeMirror-guttermarker {
  color: var(--code-mirror-guttermarker-color, black);
}

.CodeMirror-guttermarker-subtle {
  color: var(--code-mirror-guttermarker-subtle-color, #999);
}
/* CURSOR */
.CodeMirror div.CodeMirror-cursor {
  border-left: 1px solid var(--code-mirror-cursor-color, black);
}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid var(--code-mirror-secondary-cursor-color, silver);
}

.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0 !important;
  background: var(--code-mirror-cursor-color, #7e7);
}

.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1;
}

.cm-fat-cursor-mark {
  background-color: var(--code-mirror-fat-cursor-mark-color, rgba(20, 255, 20, 0.5));
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
}

.cm-animate-fat-cursor {
  width: auto;
  border: 0;
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
  background-color: var(--code-mirror-animate-fat-cursor-color, #7e7);
}

@-moz-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

@-webkit-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

@keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

.cm-tab {
  display: inline-block;
  text-decoration: inherit;
}

.CodeMirror-ruler {
  border-left: 1px solid var(--code-mirror-ruler-border-color, #ccc);
  top: 0;
  bottom: 0;
  position: absolute;
}

/* DEFAULT THEME */
.cm-header {
  font-weight: bold;
  color: var(--code-mirror-header-color, inherit);
}

.cm-quote {
  color: var(--code-mirror-quote-color, #090);
}

.cm-negative {
  color: var(--code-mirror-negative-color, #d44);
}

.cm-positive {
  color: var(--code-mirror-positive-color, #292);
}

.cm-em {
  font-style: italic;
}

.cm-link {
  text-decoration: underline;
}

.cm-strikethrough {
  text-decoration: line-through;
}

.cm-invalidchar {
  color: var(--code-mirror-invalidchar-color, #f00);
}

.cm-keyword {
  line-height: 1em;
  font-weight: bold;
  color: var(--code-mirror-keyword-color, #5A5CAD);
}

.cm-atom {
  color: var(--code-mirror-atom-color, #3b548c);
}

.cm-number {
  color: var(--code-mirror-number-color, #164);
}

.cm-def {
  text-decoration: underline;
  color: var(--code-mirror-def-color, inherit);
}

.cm-variable {
  color: var(--code-mirror-variable-color, black);
}

.cm-variable-2 {
  color: var(--code-mirror-variable2-color, black);
}

.cm-variable-3 {
  color: var(--code-mirror-variable3-color, black);
}

.cm-punctuation {
  color: var(--code-mirror-punctuation-color, inherit);
}

.cm-property {
  color: var(--code-mirror-property-color, inherit);
}

.cm-operator {
  color: var(--code-mirror-operator-color, inherit);
}

.cm-comment {
  color: var(--code-mirror-comment-color, #0080FF);
  font-style: italic;
}

.cm-string {
  color: var(--code-mirror-string-color, #3b548c);
}

.cm-string-2 {
  color: var(--code-mirror-string-color, #f50);
}

.cm-meta {
  color: var(--code-mirror-meta-color, #9e9e9e);
}

.cm-qualifier {
  color: var(--code-mirror-qualifier-color, grey);
}

.cm-builtin {
  color: var(--code-mirror-builtin-color, #7EA656);
}

.cm-bracket {
  color: var(--code-mirror-bracket-color, #cc7);
}

.cm-tag {
  color: var(--code-mirror-tag-color, #3F7F7F);
}

.cm-attribute {
  color: var(--code-mirror-attribute-color, #7F007F);
}

.cm-error {
  color: var(--code-mirror-error-color, #f00);
}

.CodeMirror-composing {
  border-bottom: 2px solid;
}

/* Default styles for common addons */
.CodeMirror-activeline-background {
  background: var(--code-mirror-active-line-background-color, #e8f2ff);
}

div.CodeMirror span.CodeMirror-matchingbracket {
  outline: 1px solid grey;
  color: var(--code-mirror-active-match-bracked-color, black);
  background: var(--code-mirror-active-match-bracked-background-color, yellow);
}

div.CodeMirror span.CodeMirror-nonmatchingbracket {
  color: #f22;
}

.CodeMirror-matchingtag {
  background: var(--code-mirror-matches-background-color, rgba(255, 150, 0, .3));
}

/* Linter */
.CodeMirror-lint-mark-error,
.CodeMirror-lint-mark-warning {
  background-position: left bottom;
  background-repeat: repeat-x;
}

.CodeMirror-lint-mark-error {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==");
}

.CodeMirror-lint-mark-warning {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
}

/* STOP */
/* The rest of this file contains styles related to the mechanics of the editor. You probably shouldn't touch them. */

.CodeMirror {
  position: relative;
  overflow: hidden;
  height: inherit;
}

.CodeMirror-scroll {
  overflow: scroll !important;
  /* Things will break if this is overridden */
  /* 30px is the magic margin used to hide the element's real scrollbars */
  /* See overflow: hidden in .CodeMirror */
  margin-bottom: -30px;
  margin-right: -30px;
  padding-bottom: 30px;
  height: 100%;
  outline: none;
  /* Prevent dragging from highlighting the element */
  position: relative;
}

.CodeMirror-sizer {
  position: relative;
  border-right: 30px solid transparent;
}
/* The fake, visible scrollbars. Used to force redraw during scrolling
before actuall scrolling happens, thus preventing shaking and
flickering artifacts. */

.CodeMirror-vscrollbar,
.CodeMirror-hscrollbar,
.CodeMirror-scrollbar-filler,
.CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none;
}

.CodeMirror-vscrollbar {
  right: 0;
  top: 0;
  overflow-x: hidden;
  overflow-y: scroll;
}

.CodeMirror-hscrollbar {
  bottom: 0;
  left: 0;
  overflow-y: hidden;
  overflow-x: scroll;
}

.CodeMirror-scrollbar-filler {
  right: 0;
  bottom: 0;
}

.CodeMirror-gutter-filler {
  left: 0;
  bottom: 0;
}

.CodeMirror-gutters {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 3;
}

.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  margin-bottom: -30px;
}

.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  height: 100%;
}

.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4;
}

.CodeMirror-gutter-wrapper {
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

.CodeMirror-lines {
  cursor: text;
  min-height: 1px;
}

.CodeMirror pre {
  -moz-border-radius: 0;
  -webkit-border-radius: 0;
  border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
}

.CodeMirror-wrap pre {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal;
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  z-index: 0;
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  overflow: auto;
}

.CodeMirror-widget {}

.CodeMirror-code {
  outline: none;
}
/* Force content-box sizing for the elements where we expect it */

.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.CodeMirror-measure pre {
  position: static;
}

.CodeMirror div.CodeMirror-cursor {
  position: absolute;
  border-right: none;
  width: 0;
}

div.CodeMirror-cursors {
  visibility: hidden;
  position: relative;
  z-index: 3;
}

.CodeMirror-focused div.CodeMirror-cursors {
  visibility: visible;
}

.CodeMirror-selected {
  background: var(--code-mirror-selected-background-color, #d9d9d9);
}

.CodeMirror-focused .CodeMirror-selected {
  background: var(--code-mirror-focused-selected-background-color, #d7d4f0);
}

.CodeMirror-crosshair {
  cursor: crosshair;
}

.CodeMirror ::selection {
  background: var(--code-mirror-selection-background-color, #d7d4f0);
}

.CodeMirror ::-moz-selection {
  background: var(--code-mirror-selection-background-color, #d7d4f0);
}

.cm-searching {
  background: #ffa;
  background: rgba(255, 255, 0, .4);
}

/* Used to force a border model for a node */

.cm-force-border {
  padding-right: .1px;
}

@media print {
  /* Hide the cursor when printing */
  .CodeMirror div.CodeMirror-cursors {
    visibility: hidden;
  }
}
/* See issue #2901 */

.cm-tab-wrap-hack:after {
  content: '';
}

/* Help users use markselection to safely style text background */
span.CodeMirror-selectedtext {
  background: none;
}
/* Hints added to the element */
.hints ::slotted(.CodeMirror-hints) {
  position: absolute;
  z-index: 10;
  background: white;
  overflow: hidden;
  overflow-y: auto;
  max-height: 20em;
  margin-left: 20px;
}`;

/**
@license
Copyright 2018 Pawel Psztyc, The ARC team

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.

Adapted from https://github.com/PETComputacaoUFPR/code-mirror and
https://github.com/PolymerLabs/code-mirror
The MIT License (MIT)

Copyright (c) 2015 PET Computao UFPR

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Copyright (c) 2012 The Polymer Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
  * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* global CodeMirror */
/**
 * Code mirror web component
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 * @appliesMixin ValidatableMixin
 */
class CodeMirrorElement extends ValidatableMixin(LitElement) {
  static get styles() {
    return [
      cmStyles,
      css`:host {
        display: block;
        position: relative;
        height: var(--code-mirror-height, 300px);
      }

      .wrapper {
        height: inherit;
      }

      .content {
        display: none;
      }

      .invalid-message {
        display: none;
      }

      :host([invalid]) .invalid-message {
        display: block;
        color: var(--code-mirror-invalid-label-color, #F44336)
      }

      :host([invalid]) .wrapper {
        border: 1px var(--code-mirror-invalid-border-color, #F44336) solid;
      }
      `
    ];
  }

  render() {
    return html`
    <div class="wrapper"></div>
    <div class="invalid-message">
      <slot name="invalid"></slot>
    </div>
    <div class="content" role="alert">
      <slot></slot>
    </div>
    <div class="hints">
      <slot name="hints"></slot>
    </div>`;
  }

  static get properties() {
    return {
      /**
       * Editor's value.
       * If set at initialization time any content inside this element will be replaced by this
       * value.
       *
       * @type {String}
       */
      value: { type: String },
      /**
       * True when a value is required.
       */
      required: { type: Boolean },
      /**
       * The mode to use. When not given, this will default to the first mode that was loaded.
       * It may be a string, which either simply names the mode or is a MIME type associated with
       * the mode.
       * Alternatively, it may be an object containing configuration options for the mode, with
       * a name property that names the mode. For example
       * <code>{name: "javascript", json: true}</code>
       *
       * @type {String}
       */
      mode: { type: String },
      /**
       * Explicitly set the line separator for the editor. By default (value null), the document
       * will be split on CRLFs as well as lone CRs and LFs, and a single LF will be used as line
       * separator in all output.
       *
       * @type {String}
       */
      lineSeparator: { type: String },
      /**
       * Renders line number when set.
       * @type {Object}
       */
      lineNumbers: { type: Boolean },
      /**
       * The width of a tab character.
       * Defaults to 2.
       *
       * @type {Number}
       */
      tabSize: { type: Number },
      /**
       * Whether to use the context-sensitive indentation that the mode provides (or just indent
       * the same as the line before).
       *
       * @type {Boolean}
       */
      smartIndent: { type: Boolean },
      /**
       * Configures the key map to use. The default is "default", which is the only key map
       * defined in codemirror.js itself.
       *
       * @type {String}
       */
      keyMap: { type: String },
      /**
       * Whether CodeMirror should scroll or wrap for long lines. Defaults to false (scroll).
       *
       * @type {Boolean}
       */
      lineWrapping: { type: Boolean },
      /**
       * This disables editing of the editor content by the user. If the special value "nocursor"
       * is given (instead of simply true), focusing of the editor is also disallowed.
       *
       * @type {Boolean}
       */
      readonly: { type: Boolean },
      /**
       * Whether the cursor should be drawn when a selection is active.
       *
       * @type {Boolean}
       */
      showCursorWhenSelecting: { type: Boolean },
      /**
       * When enabled, which is the default, doing copy or cut when there is no selection will
       * copy or cut the whole lines that have cursors on them.
       *
       * @type {Boolean}
       */
      lineWiseCopyCut: { type: Boolean },
      /**
       * The maximum number of undo levels that the editor stores. Note that this includes
       * selection change events. Defaults to 200.
       *
       * @type {Boolean}
       */
      undoDepth: { type: Number },
      /**
       * The period of inactivity (in milliseconds) that will cause a new history event to be
       * started when typing or deleting. Defaults to 1250.
       *
       * @type {Number}
       */
      historyEventDelay: { type: Number },
      /**
       * Can be used to make CodeMirror focus itself on initialization. Defaults to off.
       *
       * @type {Boolean}
       */
      autofocus: { type: Boolean },
      /**
       * An option for CodeMirror's gutters.
       * For example `['CodeMirror-lint-markers']`
       */
      gutters: { type: Array },
      /**
       * Lint option. It should be a linter object used to lint the
       * value.
       *
       * This option works when `../codemirror/addon/lint.lint.js` is
       * imcluded into the document.
       */
      lint: { type: Object },
      /**
       * A reference to the CodeMirror instance.
       *
       * @type {Object}
       */
      _editor: { type: Object }
    };
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    if (old === value) {
      return;
    }
    this._value = value;
    this._valueChanged(value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get mode() {
    return this._mode;
  }

  set mode(value) {
    const old = this._mode;
    if (old === value) {
      return;
    }
    this._mode = value;
    this._modeChanged(value);
  }

  get lineSeparator() {
    return this._lineSeparator;
  }

  set lineSeparator(value) {
    this.__setProperty('lineSeparator', value);
  }

  get lineNumbers() {
    return this._lineNumbers;
  }

  set lineNumbers(value) {
    this.__setProperty('lineNumbers', value);
  }

  get tabSize() {
    return this._tabSize;
  }

  set tabSize(value) {
    this.__setProperty('tabSize', value);
  }

  get smartIndent() {
    return this._smartIndent;
  }

  set smartIndent(value) {
    this.__setProperty('smartIndent', value);
  }

  get keyMap() {
    return this._keyMap;
  }

  set keyMap(value) {
    this.__setProperty('keyMap', value);
  }

  get lineWrapping() {
    return this._lineWrapping;
  }

  set lineWrapping(value) {
    this.__setProperty('lineWrapping', value);
  }

  get readonly() {
    return this._readOnly;
  }

  set readonly(value) {
    this.__setProperty('readOnly', value);
  }

  get showCursorWhenSelecting() {
    return this._showCursorWhenSelecting;
  }

  set showCursorWhenSelecting(value) {
    this.__setProperty('showCursorWhenSelecting', value);
  }

  get lineWiseCopyCut() {
    return this._lineWiseCopyCut;
  }

  set lineWiseCopyCut(value) {
    this.__setProperty('lineWiseCopyCut', value);
  }

  get undoDepth() {
    return this._undoDepth;
  }

  set undoDepth(value) {
    this.__setProperty('undoDepth', value);
  }

  get historyEventDelay() {
    return this._historyEventDelay;
  }

  set historyEventDelay(value) {
    this.__setProperty('historyEventDelay', value);
  }

  get autofocus() {
    return this._autofocus;
  }

  set autofocus(value) {
    this.__setProperty('autofocus', value);
  }

  get gutters() {
    return this._gutters;
  }

  set gutters(value) {
    this.__setProperty('gutters', value);
  }

  get lint() {
    return this._lint;
  }

  set lint(value) {
    this.__setProperty('lint', value);
  }

  get editor() {
    return this._editor;
  }

  __setProperty(prop, value) {
    const key = `_${prop}`;
    if (this[key] === value) {
      return;
    }
    this[key] = value;
    this.setOption(prop, value);
  }

  /**
   * @constructor
   */
  constructor() {
    super();
    this._onChangeHandler = this._onChangeHandler.bind(this);
    this._onBeforeChangeHnalder = this._onBeforeChangeHnalder.bind(this);

    this._pendingOptions = [];
    this.mode = {
      name: 'javascript',
      json: true
    };
  }

  firstUpdated() {
    if (!this.value) {
      this.value = this._unindent(this._getContentValue() || '');
    }
    this._initializeEditor();
  }

  _initializeEditor() {
    try {
      const wrapper = this.shadowRoot.querySelector('.wrapper');
      const editor = CodeMirror(wrapper, {
        value: this.value,
        mode: this.mode
      });
      this._editor = editor;
      setTimeout(() => this._setPendingOptions());
      editor.getInputField().setAttribute('aria-label', 'Input field');
      editor.setOption('extraKeys', {
        Tab: () => {
          this.blur();
        }
      });
      this._connectEditor();
    } catch (e) {
    }
  }

  _getContentValue() {
    const slot = this.shadowRoot.querySelector('.content slot');
    const nodes = slot.assignedNodes();
    for (let i = 0; i < nodes.length; i++) {
      const value = nodes[i].textContent;
      if (value.trim()) {
        return value;
      }
    }
  }

  _unindent(text) {
    if (!text) {
      return text;
    }
    const lines = text.replace(/\t/g, '  ').split('\n');
    const indent = lines.reduce(function(prev, line) {
      if (/^\s*$/.test(line)) {
        return prev;  // Completely ignore blank lines.
      }
      const lineIndent = line.match(/^(\s*)/)[0].length;
      if (prev === null) {
        return lineIndent;
      }
      return lineIndent < prev ? lineIndent : prev;
    }, null);

    return lines.map((l) => l.substr(indent)).join('\n');
  }

  /**
   * Sets options to an editor that has been set before the editor was created
   */
  _setPendingOptions() {
    if (!this._pendingOptions) {
      return;
    }
    this._pendingOptions.forEach((item) => {
      this.setOption(item.option, item.value);
      if (item.post) {
        try {
          item.post();
        } catch (e) {
        }
      }
    });
    this._pendingOptions = undefined;
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this._connectEditor();
  }

  _connectEditor() {
    if (!this.editor) {
      return;
    }
    this.editor.on('change', this._onChangeHandler);
    this.editor.on('beforeChange', this._onBeforeChangeHnalder);
    this.editor.refresh();
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    if (!this.editor) {
      return;
    }
    this.editor.off('change', this._onChangeHandler);
    this.editor.off('beforeChange', this._onBeforeChangeHnalder);
  }
  /**
   * Refreshes the sate of the editor.
   */
  refresh() {
    if (!this.editor) {
      return;
    }
    this.editor.refresh();
  }
  /**
   * Focus cursor on an editor.
   */
  focus() {
    if (!this.editor) {
      return;
    }
    this.editor.focus();
  }
  /**
   * Set option on an editor.
   *
   * @param {String} option An option name to setOption
   * @param {Any} value A value to be set.
   */
  setOption(option, value) {
    if (!this.editor) {
      this._pendingOptions.push({
        option: option,
        value: value
      });
      return;
    }
    this.editor.setOption(option, value);
  }
  /**
   * Set an editor value when `value` property changed.
   * @param {String} value
   */
  _valueChanged(value) {
    if (!this.editor) {
      return;
    }
    if (value === undefined || value === null) {
      this.editor.setValue('');
    } else if (value !== this.editor.getValue()) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      this.editor.setValue(value);
    }
  }
  /**
   * Auto-called when mode has changed
   * @param {String} val
   */
  _modeChanged(val) {
    if (!val || (val.indexOf && val.indexOf('application/json') === 0)) {
      this.mode = {
        name: 'javascript',
        json: true
      };
      return;
    }
    let mode;
    let spec;
    let info;
    const m = /.+\.([^.]+)$/.exec(val);
    if (m) {
      info = CodeMirror.findModeByExtension(m[1]);
      if (info) {
        mode = info.mode;
        spec = info.mime;
      }
    } else if (/\//.test(val)) {
      info = CodeMirror.findModeByMIME(val);
      if (info) {
        mode = info.mode;
        spec = val;
      }
    } else {
      mode = spec = val;
    }
    if (!this.editor) {
      this._pendingOptions.push({
        option: 'mode',
        value: mode,
        post: function() {
          CodeMirror.autoLoadMode(this.editor, mode);
        }.bind(this)
      });
      return;
    }
    if (!mode) {
      this.setOption('mode', null);
      return;
    }
    this.setOption('mode', spec);
    CodeMirror.autoLoadMode(this.editor, mode);
  }

  _onChangeHandler() {
    this.value = this.editor.getValue();
  }

  _onBeforeChangeHnalder(instance, changeObj) {
    const ev = new CustomEvent('before-change', {
      detail: {
        change: changeObj
      }
    });
    this.dispatchEvent(ev);
    if (ev.detail.change.canceled) {
      this.value = this.editor.getValue();
    }
  }

  _getValidity() {
    if (this.required && !this.value) {
      return false;
    }
    return true;
  }
  /**
   * Fired before a change is applied, and its handler may choose to modify or
   * cancel the change.
   *
   * @event before-change
   * @param {Object} change It has `from`, `to`, and `text` properties,
   * as with the CodeMirror's `change` event.
   *
   * It has a `cancel()` method, which can be called to cancel the change, and,
   * if the change isn't coming from an undo or redo event, an `update(from, to, text)` method,
   * which may be used to modify the change.
   */
}
window.customElements.define('code-mirror', CodeMirrorElement);

/**
 * `code-mirror-hint-container`
 * UI element for hint display.
 *
 * @customElement
 * @demo demo/index.html
 */
class CodeMirrorHintContainer extends LitElement {
  static get styles() {
    return css`
    :host {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    }
    `;
  }

  render() {
    return html`
    <div class="container">
      <slot></slot>
    </div>`;
  }
}
window.customElements.define('code-mirror-hint-container', CodeMirrorHintContainer);

const accept = [
  '*/*',
  'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'application/xml,application/xhtml+xml,text/html;q=0.9, text/plain;q=0.8,image/png,*/*;q=0.5',
  'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg, ' +
  'application/x-ms-xbap, application/x-shockwave-flash, application/msword, */*',
  'text/html, application/xml;q=0.9, application/xhtml+xml, image/png, image/webp, image/jpeg,' +
  ' image/gif, image/x-xbitmap, */*;q=0.1',
  'image/png,image/*;q=0.8,*/*;q=0.5',
  'audio/webm, audio/ogg, audio/wav, audio/*;q=0.9, application/ogg;q=0.7, video/*;q=0.6; ' +
  '*/*;q=0.5',
  'video/webm, video/ogg, video/*;q=0.9, application/ogg=0.7, audio/*;q=0.6; */*;q=0.5',
  'application/javascript, */*;q=0.8',
  'text/css,*/*;q=0.1',
  'text/html, application/xml;q=0.9, application/xhtml+xml, image/png, image/webp, image/jpeg' +
  ', image/gif, image/x-xbitmap, */*;q=0.1'
];
const contentTypes = [
  'application/json',
  'application/xml',
  'application/atom+xml',
  'multipart-form-data',
  'application/x-www-form-urlencoded',
  'application/base64',
  'application/octet-stream',
  'text/plain',
  'text/css',
  'text/html',
  'application/javascript'
];
const authorizationHeaders = ['Basic {base64 of user:password}', 'Bearer {OAuth2 bearer}'];
const authorizationParams = {
  'base64 of user:password': {
    type: String,
    call: 'authorizationBasic'
  },
  'OAuth2 bearer': {
    type: String,
    call: 'authorizationGoogleOauth2'
  }
};

var headersSuggestions = [{
  key: 'Accept',
  values: accept
}, {
  key: 'Accept-Charset',
  values: [
    'UTF-8',
    'UTF-16',
    'ISO-8859-1',
    'ISO-8859-1,utf-8;q=0.7,*;q=0.7'
  ]
}, {
  key: 'Accept-Encoding',
  values: [
    'compress',
    'gzip',
    'deflate',
    'identity',
    'br',
    '*',
    'gzip, deflate, sdch'
  ]
}, {
  key: 'Accept-Language',
  values: [
    'en-US',
    'cad',
    'en-gb;q=0.8, en;q=0.7'
  ]
}, {
  key: 'Authorization',
  values: authorizationHeaders,
  params: authorizationParams
}, {
  key: 'Access-Control-Request-Method',
  values: ['GET', 'POST', 'PUT', 'DELETE']
}, {
  key: 'Access-Control-Request-Headers',
  values: ['{list-of-headers}'],
  params: {
    'list-of-headers': {
      type: String
    }
  }
}, {
  key: 'Cache-Control',
  values: [
    'no-cache',
    'no-store',
    'max-age={seconds}',
    'max-stale={seconds}',
    'min-fresh={seconds}',
    'no-transform',
    'only-if-cached'
  ],
  params: {
    seconds: {
      type: Number
    }
  }
}, {
  key: 'Connection',
  values: ['close', 'keep-alive']
}, {
  key: 'Content-MD5',
  values: ['{md5-of-message}'],
  params: {
    'length-in-bytes': {
      type: String
    }
  }
}, {
  key: 'Content-Length',
  values: ['{length-in-bytes}'],
  params: {
    'length-in-bytes': {
      type: Number
    }
  }
}, {
  key: 'Content-Type',
  values: contentTypes
  /* ,
   params: {
     '*': {
       type: String,
       call: 'contentType'
     }
   }*/
}, {
  key: 'Cookie',
  values: [
    '{cookie name}={cookie value}',
    '{cookie name}={cookie value}; expires={insert GMT date here}; domain={domain.com}; ' +
    'path=/; secure'
  ],
  params: {
    '*': {
      type: String,
      call: 'cookie'
    }
  }
}, {
  key: 'Date',
  values: [
    '{insert GMT date here}'
  ]
}, {
  key: 'DNT',
  values: [0, 1]
}, {
  key: 'Expect',
  values: [
    '200-OK',
    '100-continue'
  ]
}, {
  key: 'From',
  values: ['user@domain.com']
}, {
  key: 'Front-End-Https',
  values: ['on', 'off']
}, {
  key: 'Host',
  values: [
    'www.domain.com',
    'www.domain.com:80'
  ]
}, {
  key: 'If-Match',
  values: ['{insert entity tag}']
}, {
  key: 'If-Modified-Since',
  values: ['{insert GMT date here}']
}, {
  key: 'If-None-Match',
  values: ['{insert entity tag}']
}, {
  key: 'If-Range',
  values: ['{insert entity tag}', '{insert GMT date here}']
}, {
  key: 'If-Unmodified-Since',
  values: ['{insert GMT date here}']
}, {
  key: 'Max-Forwards',
  values: ['{number of forwards}'],
  params: {
    'number of forwards': {
      type: Number
    }
  }
}, {
  key: 'Origin',
  values: []
}, {
  key: 'Pragma',
  values: ['no-cache']
}, {
  key: 'Proxy-Authorization',
  values: authorizationHeaders,
  params: authorizationParams
}, {
  key: 'Proxy-Connection',
  values: ['close', 'keep-alive']
}, {
  key: 'Range',
  values: [
    'bytes={from bytes}-{to bytes}',
    'bytes=-{final bytes}'
  ]
}, {
  key: 'Referer',
  values: ['{http://www.domain.com/}']
}, {
  key: 'TE',
  values: [
    '{header name}',
    'trailers, deflate;q=0.5'
  ]
}, {
  key: 'Upgrade',
  values: ['HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11']
}, {
  key: 'User-Agent',
  values: [
    navigator.userAgent,
    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20120101 Firefox/33.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10; rv:33.0) Gecko/20100101 Firefox/33.0',
    'Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko)' +
    ' Version/7.0.3 Safari/7046A194A',
    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; WOW64; Trident/4.0; SLCC1)',
    'Mozilla/5.0 (MSIE 10.0; Windows NT 6.1; Trident/5.0)',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gec' +
    'ko) Version/6.0 Mobile/10A5376e Safari/8536.25',
    'Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) ' +
    'Version/6.0 Mobile/10A5376e Safari/8536.25',
    'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, ' +
    'like Gecko) Chrome/34.0.1847.114 Mobile Safari/537.36',
    'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM;' +
    ' Touch; NOKIA; Lumia 920)'
  ]
}, {
  key: 'Via',
  values: []
}, {
  key: 'Warning',
  values: [
    '{code} {agent} {message} {date}'
  ],
  properties: {
    code: {
      type: Number
    },
    agent: {
      type: String
    },
    message: {
      type: String
    },
    date: {
      type: Date
    }
  }
}, {
  key: 'X-ATT-DeviceId',
  values: []
}, {
  key: 'X-Forwarded-For',
  values: []
}, {
  key: 'X-Forwarded-Proto',
  values: ['http', 'https']
}, {
  key: 'X-Requested-With',
  values: ['XMLHttpRequest']
}, {
  key: 'X-Wap-Profile',
  values: []
}];

/* global CodeMirror */

function getToken(editor, cur) {
  return editor.getTokenAt(cur);
}
/**
 * Get all keywords (headers names).
 * @param {Array} suggestions List of possible headers
 * @return {Array} Array of founded header names.
 */
function getKeywords(suggestions) {
  const keywords = [];
  const clb = function(header, cm, data, completion) {
    cm.replaceRange(completion.text + ': ', data.from, data.to);
    CodeMirror.signal(cm, 'header-key-selected', completion.text);
  };
  for (let i = 0; i < suggestions.length; i++) {
    keywords.push({
      text: suggestions[i].key,
      hint: clb.bind(null, suggestions[i])
    });
  }
  return keywords;
}

function getHeaderValuesFor(suggestions, key) {
  const keywords = [];
  const clb = function(header, cm, data, completion) {
    cm.replaceRange(completion.text, data.from, data.to);
    CodeMirror.signal(cm, 'header-value-selected', completion.text);

    if (header.params && header.params['*'] && header.params['*'].call) {
      const fromChar = Math.min(data.from.ch, data.to.ch);
      const charTo = fromChar + completion.text.length;
      const line = data.from.line;
      cm.setSelection({
        line: line,
        ch: fromChar
      }, {
        line: line,
        ch: charTo
      });
      CodeMirror.signal(cm, 'header-value-support', {
        type: header.params['*'],
        key: header.key,
        value: completion.text
      });
    } else {
      const match = completion.text.match(/\{(.*?)\}/);
      if (match) {
        if (header.params && (match[1] in header.params)) {
          let fromChar = Math.min(data.from.ch, data.to.ch);
          const line = data.from.line;
          fromChar += completion.text.indexOf('{');
          const charTo = fromChar + match[1].length + 2;
          cm.setSelection({
            line: line,
            ch: fromChar
          }, {
            line: line,
            ch: charTo
          });
          CodeMirror.signal(cm, 'header-value-support', {
            type: header.params[match[1]],
            key: header.key,
            value: completion.text
          });
        }
      }
    }
  };

  for (let i = 0; i < suggestions.length; i++) {
    if (suggestions[i].key.toLowerCase() === key) {
      const valuesLenght = suggestions[i].values && suggestions[i].values.length || 0;
      for (let j = 0; j < valuesLenght; j++) {
        const item = suggestions[i].values[j];
        const completion = {
          text: item,
          hint: clb.bind(null, suggestions[i])
        };
        keywords.push(completion);
      }
      break;
    }
  }
  return keywords;
}

function cleanResults(text, keywords) {
  const results = [];
  let i = 0;
  for (i = 0; i < keywords.length; i++) {
    if (keywords[i].text) {
      if (keywords[i].text.toLowerCase()
          .substring(0, text.length) === text) {
        results.push(keywords[i]);
      }
    } else {
      if (keywords[i].toLowerCase()
          .substring(0, text.length) === text) {
        results.push(keywords[i]);
      }
    }
  }
  return results;
}

function getHints(editor) {
  const cur = editor.getCursor();
  const token = getToken(editor, cur);
  let tokenString = (token.string) ? '' : token.string.trim();
  let keywords = [];
  let i = 0;
  const fromCur = {
    line: cur.line,
    ch: cur.ch + 2
  };
  const toCur = {
    line: cur.line,
    ch: cur.ch
  };
  let flagClean = true;
  const last = editor.getRange({
    line: cur.line,
    ch: cur.ch - 1
  }, cur);
  const last2 = editor.getRange({
    line: cur.line,
    ch: cur.ch - 2
  }, cur);

  let key;
  if ((last === ':' || last2 === ': ') || (last === ',' || last2 === ', ')) {
    key = editor.getRange({
      line: cur.line,
      ch: 0
    }, cur);
    if (!key) {
      key = '';
    }
    key = key.substr(0, key.indexOf(':'))
        .trim()
        .toLowerCase();
    keywords = getHeaderValuesFor(headersSuggestions, key);
  } else if (editor.getRange({
    line: cur.line,
    ch: 0
  }, cur)
      .trim() !== '') {
    const prev = editor.getRange({
      line: cur.line,
      ch: 0
    }, cur)
        .trim();
    const index = prev.indexOf(':');
    if (index !== -1) {
      // looking for the key
      key = prev.substr(0, prev.indexOf(':'))
          .trim()
          .toLowerCase();
      // looking for the value
      tokenString = prev.substr(prev.indexOf(':') + 1)
          .trim()
          .toLowerCase();
      keywords = getHeaderValuesFor(headersSuggestions, key);
    } else {
      // looking for header name starting with...
      tokenString = prev.toLowerCase();
      keywords = getKeywords(headersSuggestions);
    }
    fromCur.ch = token.start;
  } else {
    for (i = 0; i < headersSuggestions.length; i++) {
      keywords = getKeywords(headersSuggestions);
    }
  }

  if (flagClean === true && tokenString.trim() === '') {
    flagClean = false;
  }

  if (flagClean) {
    keywords = cleanResults(tokenString, keywords);
  }
  /*
   * from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,
   to: replaceToken ? Pos(cur.line, token.end) : cur
   */
  return {
    list: keywords,
    from: fromCur,
    to: toCur
  };
}

/* global CodeMirror */
CodeMirror.registerHelper('hint', 'http-headers', getHints);

/**
 * An addon for CodeMirror 5.x to support syntax highlighting for HTTP headers.
 *
 * @return {Object}.
 */
function addon() {
  function failRest(stream, state) {
    stream.skipToEnd();
    state.cur = failRest;
    return 'error';
  }

  function header(stream) {
    if (stream.sol() && !stream.eat(/[ \t]/)) {
      if (stream.match(/^.*?:/)) {
        return 'atom';
      } else {
        stream.skipToEnd();
        return 'error';
      }
    } else {
      stream.skipToEnd();
      return 'string';
    }
  }

  return {
    token: function(stream, state) {
      const cur = state.cur;
      if (!cur || cur !== header && stream.eatSpace()) {
        return null;
      }
      return cur(stream, state);
    },

    blankLine: function(state) {
      state.cur = failRest;
    },

    startState: function() {
      return {
        cur: header
      };
    }
  };
}

/* global CodeMirror */

CodeMirror.defineMode('http-headers', addon);
CodeMirror.defineMIME('message/http-headers', 'http-headers');

/* global CodeMirror */

const HINT_ELEMENT_CLASS = 'CodeMirror-hint';
const ACTIVE_HINT_ELEMENT_CLASS = 'selected';

const defaultOptions = {
  hint: CodeMirror.hint.auto,
  completeSingle: true,
  alignWithWord: true,
  closeCharacters: /[\s()\\[\\]{};:>,]/,
  closeOnUnfocus: true,
  completeOnSingleClick: false,
  container: null,
  customKeys: null,
  extraKeys: null
};

function Completion(cm, options) {
  this.cm = cm;
  this.options = this.buildOptions(options);
  this.widget = null;
  this.debounce = 0;
  this.tick = 0;
  this.startPos = this.cm.getCursor();
  this.startLen = this.cm.getLine(this.startPos.line).length;

  const self = this;
  cm.on('cursorActivity', this.activityFunc = function() {
    self.cursorActivity();
  });
}
function getText(completion) {
  if (typeof completion === 'string') {
    return completion;
  } else {
    return completion.text;
  }
}
function buildKeyMap(completion, handle) {
  const baseMap = {
    Up: function() {
      handle.moveFocus(-1);
    },
    Down: function() {
      handle.moveFocus(1);
    },
    PageUp: function() {
      handle.moveFocus(-handle.menuSize() + 1, true);
    },
    PageDown: function() {
      handle.moveFocus(handle.menuSize() - 1, true);
    },
    Home: function() {
      handle.setFocus(0);
    },
    End: function() {
      handle.setFocus(handle.length - 1);
    },
    Enter: handle.pick,
    Tab: handle.pick,
    Esc: handle.close
  };
  const custom = completion.options.customKeys;
  const ourMap = custom ? {} : baseMap;

  function addBinding(key, val) {
    let bound;
    if (typeof val !== 'string') {
      bound = function(cm) {
        return val(cm, handle);
      };
      // This mechanism is deprecated
    } else if (baseMap.hasOwnProperty(val)) {
      bound = baseMap[val];
    } else {
      bound = val;
    }
    ourMap[key] = bound;
  }
  if (custom) {
    Object.keys(custom).forEach((key) => {
      addBinding(key, custom[key]);
    });
  }
  const extra = completion.options.extraKeys;
  if (extra) {
    Object.keys(extra).forEach((key) => {
      addBinding(key, extra[key]);
    });
  }
  return ourMap;
}

function getHintElement(hintsElement, el) {
  while (el && el !== hintsElement) {
    if (el.nodeName.toUpperCase() === 'ANYPOINT-ITEM' && el.parentNode === hintsElement) {
      return el;
    }
    el = el.parentNode;
  }
}
function Widget(completion, data) {
  this.completion = completion;
  this.data = data;
  this.picked = false;
  const widget = this;
  const cm = completion.cm;

  const hints = this.hints = document.createElement('code-mirror-hint-container');
  hints.slot = 'hints';
  hints.className = 'CodeMirror-hints';
  this.selectedHint = data.selectedHint || 0;
  const container = document.createElement('anypoint-listbox');
  container.selected = 0;
  hints.appendChild(container);

  const completions = data.list;
  for (let i = 0; i < completions.length; ++i) {
    const elt = container.appendChild(document.createElement('anypoint-item'));
    const cur = completions[i];
    let className = HINT_ELEMENT_CLASS + (i !== this.selectedHint ? '' : ' ' +
      ACTIVE_HINT_ELEMENT_CLASS);
    if (cur.className !== null) {
      className = cur.className ? cur.className + ' ' + className : className;
    }
    elt.className = className;
    if (cur.render) {
      cur.render(elt, data, cur);
    } else {
      elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
    }
    elt.hintId = i;
  }
  if (hints.children[0].children[0].nodeName === 'DIV') {
    this._indexOffset = 1;
  } else {
    this._indexOffset = 0;
  }
  let pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null, 'local');
  let left = pos.left;
  let top = pos.bottom;
  let below = true;
  hints.style.left = left + 'px';
  hints.style.top = top + 'px';
  // If we're at the edge of the screen, then we want the menu to appear on the left of the
  // cursor.
  const winW = window.innerWidth || Math.max(document.body.offsetWidth,
      document.documentElement.offsetWidth);
  const winH = window.innerHeight || Math.max(document.body.offsetHeight,
      document.documentElement.offsetHeight);
  (completion.options.container || document.body).appendChild(hints);
  let box = hints.getBoundingClientRect();
  const overlapY = box.bottom - winH;
  if (overlapY > 0) {
    const height = box.bottom - box.top;
    const curTop = pos.top - (pos.bottom - box.top);
    if (curTop - height > 0) { // Fits above cursor
      hints.style.top = (top = pos.top - height) + 'px';
      below = false;
    } else if (height > winH) {
      hints.style.height = (winH - 5) + 'px';
      hints.style.top = (top = pos.bottom - box.top) + 'px';
      const cursor = cm.getCursor();
      if (data.from.ch !== cursor.ch) {
        pos = cm.cursorCoords(cursor);
        hints.style.left = (left = pos.left) + 'px';
        box = hints.getBoundingClientRect();
      }
    }
  }
  let overlapX = box.right - winW;
  if (overlapX > 0) {
    if (box.right - box.left > winW) {
      hints.style.width = (winW - 5) + 'px';
      overlapX -= (box.right - box.left) - winW;
    }
    hints.style.left = (left = pos.left - overlapX) + 'px';
  }

  cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
    moveFocus: function(n, avoidWrap) {
      widget.changeActive(widget.selectedHint + n, avoidWrap);
    },
    setFocus: function(n) {
      widget.changeActive(n);
    },
    menuSize: function() {
      return widget.screenAmount();
    },
    length: completions.length,
    close: function() {
      completion.close();
    },
    pick: function() {
      widget.pick();
    },
    data: data
  }));

  if (completion.options.closeOnUnfocus) {
    let closingOnBlur;
    cm.on('blur', this.onBlur = function() {
      closingOnBlur = setTimeout(function() {
        completion.close();
      }, 100);
    });
    cm.on('focus', this.onFocus = function() {
      clearTimeout(closingOnBlur);
    });
  }

  const startScroll = cm.getScrollInfo();
  cm.on('scroll', this.onScroll = function() {
    const curScroll = cm.getScrollInfo();
    const editor = cm.getWrapperElement().getBoundingClientRect();
    const newTop = top + startScroll.top - curScroll.top;
    let point = newTop -
      (window.pageYOffset || (document.documentElement || document.body).scrollTop);
    if (!below) {
      point += hints.offsetHeight;
    }
    if (point <= editor.top || point >= editor.bottom) {
      return completion.close();
    }
    hints.style.top = newTop + 'px';
    hints.style.left = (left + startScroll.left - curScroll.left) + 'px';
  });

  CodeMirror.on(container, 'click', function(e) {
    const t = getHintElement(hints.children[0], e.target || e.srcElement);
    if (t && t.hintId !== undefined) {
      widget.changeActive(t.hintId);
      widget.pick();
    }
  });

  CodeMirror.on(hints, 'mousedown', function() {
    setTimeout(function() {
      cm.focus();
    }, 20);
  });

  CodeMirror.signal(data, 'select', completions[0], hints.children[0].firstChild);
  return true;
}

Widget.prototype = {
  close: function() {
    if (this.completion.widget !== this) {
      return;
    }
    this.completion.widget = null;
    this.hints.parentNode.removeChild(this.hints);
    this.completion.cm.removeKeyMap(this.keyMap);

    const cm = this.completion.cm;
    if (this.completion.options.closeOnUnfocus) {
      cm.off('blur', this.onBlur);
      cm.off('focus', this.onFocus);
    }
    cm.off('scroll', this.onScroll);
  },

  disable: function() {
    this.completion.cm.removeKeyMap(this.keyMap);
    const widget = this;
    this.keyMap = {
      Enter: function() {
        widget.picked = true;
      }
    };
    this.completion.cm.addKeyMap(this.keyMap);
  },

  pick: function() {
    this.completion.pick(this.data, this.selectedHint);
  },

  changeActive: function(i, avoidWrap) {
    // i += this._indexOffset;
    if (i >= this.data.list.length) {
      i = avoidWrap ? this.data.list.length - 1 : 0;
    } else if (i < 0) {
      i = avoidWrap ? 0 : this.data.list.length - 1;
    }
    if (this.selectedHint === i) {
      return;
    }
    let selectedHint = this.selectedHint + this._indexOffset;
    let node = this.hints.children[0].children[selectedHint];
    node.classList.remove(ACTIVE_HINT_ELEMENT_CLASS);
    selectedHint = i + this._indexOffset;
    this.selectedHint = i;
    node = this.hints.children[0].children[selectedHint];
    node.classList.add(ACTIVE_HINT_ELEMENT_CLASS);
    if (node.offsetTop < this.hints.scrollTop) {
      this.hints.scrollTop = node.offsetTop - 3;
    } else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop +
      this.hints.clientHeight) {
      this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
    }
    CodeMirror.signal(this.data, 'select', this.data.list[selectedHint], node);
  },

  screenAmount: function() {
    return Math.floor(this.hints.clientHeight /
      this.hints.children[0].children[0].offsetHeight) || 1;
  }
};
// This is the old interface, kept around for now to stay
// backwards-compatible.
CodeMirror.showHint = function(cm, getHints, options) {
  if (!getHints) {
    return cm.showHint(options);
  }
  if (options && options.async) {
    getHints.async = true;
  }
  const newOpts = {
    hint: getHints
  };
  if (options) {
    Object.keys(options).forEach((prop) => {
      newOpts[prop] = options[prop];
    });
  }
  return cm.showHint(newOpts);
};


function ShowHintFn(options) {
  // We want a single cursor position.
  if (this.listSelections().length > 1 || this.somethingSelected()) {
    return;
  }

  if (this.state.completionActive) {
    this.state.completionActive.close();
  }
  const completion = this.state.completionActive = new Completion(this, options);
  if (!completion.options.hint) {
    return;
  }

  CodeMirror.signal(this, 'startCompletion', this);
  completion.update(true);
}

CodeMirror.defineExtension('showHint', ShowHintFn);

const raf = window.requestAnimationFrame || function(fn) {
  return setTimeout(fn, 1000 / 60);
};
const caf = window.cancelAnimationFrame || clearTimeout;

Completion.prototype = {
  close: function() {
    if (!this.active()) {
      return;
    }
    this.cm.state.completionActive = null;
    this.tick = null;
    this.cm.off('cursorActivity', this.activityFunc);

    if (this.widget && this.data) {
      CodeMirror.signal(this.data, 'close');
    }
    if (this.widget) {
      this.widget.close();
    }
    CodeMirror.signal(this.cm, 'endCompletion', this.cm);
  },

  active: function() {
    return this.cm.state.completionActive === this;
  },

  pick: function(data, i) {
    const completion = data.list[i];
    if (completion.hint) {
      completion.hint(this.cm, data, completion);
    } else {
      this.cm.replaceRange(getText(completion), completion.from || data.from,
          completion.to || data.to, 'complete');
    }
    CodeMirror.signal(data, 'pick', completion);
    this.close();
  },

  cursorActivity: function() {
    if (this.debounce) {
      caf(this.debounce);
      this.debounce = 0;
    }

    const pos = this.cm.getCursor();
    const line = this.cm.getLine(pos.line);
    if (pos.line !== this.startPos.line ||
      line.length - pos.ch !== this.startLen - this.startPos.ch ||
      pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
      (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
      this.close();
    } else {
      const self = this;
      this.debounce = raf(function() {
        self.update();
      });
      if (this.widget) {
        this.widget.disable();
      }
    }
  },

  update: function(first) {
    if (this.tick === null) {
      return;
    }
    if (this.data) {
      CodeMirror.signal(this.data, 'update');
    }
    if (!this.options.hint.async) {
      this.finishUpdate(this.options.hint(this.cm, this.options), first);
    } else {
      const myTick = ++this.tick;
      const self = this;
      this.options.hint(this.cm, function(data) {
        if (self.tick === myTick) {
          self.finishUpdate(data, first);
        }
      }, this.options);
    }
  },

  finishUpdate: function(data, first) {
    this.data = data;

    const picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
    if (this.widget) {
      this.widget.close();
    }
    if (data && data.list.length) {
      if (picked && data.list.length === 1) {
        this.pick(data, 0);
      } else {
        this.widget = new Widget(this, data);
        CodeMirror.signal(data, 'shown');
      }
    }
  },

  buildOptions: function(options) {
    const editor = this.cm.options.hintOptions;
    const out = {};
    Object.keys(defaultOptions).forEach((prop) => {
      out[prop] = defaultOptions[prop];
    });
    if (editor) {
      for (const prop in editor) {
        if (editor[prop] !== undefined) {
          out[prop] = editor[prop];
        }
      }
    }
    if (options) {
      for (const prop in options) {
        if (options[prop] !== undefined) {
          out[prop] = options[prop];
        }
      }
    }
    return out;
  }
};

CodeMirror.registerHelper('hint', 'auto', function(cm, options) {
  const helpers = cm.getHelpers(cm.getCursor(), 'hint');
  let words;
  if (helpers.length) {
    for (let i = 0; i < helpers.length; i++) {
      const cur = helpers[i](cm, options);
      if (cur && cur.list.length) {
        return cur;
      }
    }
  } else if ((words = cm.getHelper(cm.getCursor(), 'hintWords'))) {
    if (words) {
      return CodeMirror.hint.fromList(cm, {
        words: words
      });
    }
  } else if (CodeMirror.hint.anyword) {
    return CodeMirror.hint.anyword(cm, options);
  }
});

CodeMirror.registerHelper('hint', 'fromList', function(cm, options) {
  const cur = cm.getCursor();
  const token = cm.getTokenAt(cur);
  const found = [];
  for (let i = 0; i < options.words.length; i++) {
    const word = options.words[i];
    if (word.slice(0, token.string.length) === token.string) {
      found.push(word);
    }
  }

  if (found.length) {
    return {
      list: found,
      from: CodeMirror.Pos(cur.line, token.start),
      to: CodeMirror.Pos(cur.line, token.end)
    };
  }
});

CodeMirror.commands.autocomplete = CodeMirror.showHint;

CodeMirror.defineOption('hintOptions', null);

const contentTypeRe = /^[\t\r]*content-type[\t\r]*:[\t\r]*([^\n]*)$/gim;
/**
 * `api-headers-editor`
 * An element to render headers edior based on AMF data model.
 *
 * By default it renders headers form. The user has an option to switch to
 * source editing mode. `code-mirror` element is used in the later case.
 *
 * ## AMF data model
 *
 * This element renders pre-configured form of headers based on
 * [AMF's](https://github.com/mulesoft/amf) json/ld data model.
 * From the model select `http://raml.org/vocabularies/http#header`
 * node which contains list of headers defined for current object
 * (it can be method, trait, security scheme etc).
 * The model is resolved to internal data model by `api-view-model-transformer`
 * element.
 *
 * If the element is used without AMF model `allowCustom` property must be
 * set or otherwise user won't be able to add new header to the editor.
 *
 * ### Example
 *
 * ```html
 * <api-headers-editor id="editor" allow-disable-params></api-headers-editor>
 * <script>
 * let data = await getamf();
 * editor.amf = data;
 * data = data[0]['http://raml.org/vocabularies/document#encodes'][0];
 * data = data['http://raml.org/vocabularies/http#endpoint'][0];
 * data = data['http://www.w3.org/ns/hydra/core#supportedOperation'][0];
 * data = data['http://www.w3.org/ns/hydra/core#expects'][0];
 * data = data['http://raml.org/vocabularies/http#header'];
 * (first endpoint, first method, headers array)
 * editor.amfHeaders = data;
 * editor.addEventListener('value-changed', (e) => console.log(e.detail.value));
 * < /script>
 * ```
 *
 * ### Example without AMF
 *
 * ```html
 * <api-headers-editor id="editor" allow-disable-params allow-custom></api-headers-editor>
 * <script>
 * editor.addEventListener('value-changed', (e) => console.log(e.detail.value));
 * < /script>
 * ```
 *
 * ## Setting value when model is set
 *
 * Model values has priority over value set on the editor.
 * If `amf` is set and value has been altered programatically there
 * are two possible outcomes:
 *
 * 1) If `allowDisableParams` is set, model values are automatically
 * disabled if model item is not in the value
 * 2) If `allowDisableParams` is not set, model values are always
 * added to generated values. Or rather new value is added to the existing
 * model as custom values.
 *
 * @customElement
 * @memberof ApiElements
 * @demo demo/simple.html Simple headers editor
 * @demo demo/raml.html With AMF model
 * @appliesMixin ArcBehaviors.HeadersParserBehavior
 * @appliesMixin ApiFormMixin
 * @appliesMixin ValidatableMixin
 * @appliesMixin AmfHelperMixin
 */
class ApiHeadersEditor extends
    ValidatableMixin(ApiFormMixin(EventsTargetMixin(
      HeadersParserMixin(AmfHelperMixin(LitElement))))) {

  static get styles() {
    return [
      formStyles,
      css`
      :host {
        display: block;
        position: relative;
      }`
    ];
  }

  render() {
    const {
      aware,
      amf,
      amfHeaders,
      viewModel,
      narrow,
      noDocs,
      sourceMode,
      allowCustom,
      allowDisableParams,
      allowHideOptional,
      readOnly,
      outlined,
      legacy,
      value,
      noSourceEditor
    } = this;
    return html`
    ${aware ? html`<raml-aware @api-changed="${this._apiHandler}" .scope="${aware}"></raml-aware>` : undefined}
    <api-view-model-transformer
      @view-model-changed="${this._viewModelHandler}"
      .amf="${amf}"
      .shape="${amfHeaders}"
      .eventsTarget="${this}"
      ?nodocs="${noDocs}"
    ></api-view-model-transformer>

    <div class="content">
      <div class="editor-actions">
        <anypoint-button
          part="content-action-button, code-content-action-button"
          class="action-button"
          data-action="copy"
          @click="${this._copyToClipboard}"
          aria-label="Press to copy headers to clipboard"
          title="Copy example to clipboard">Copy</anypoint-button>
        ${noSourceEditor ? undefined : html`<anypoint-button
          aria-label="Press to toggle source edit mode"
          title="Toggle source edit mode"
          part="content-action-button, code-content-action-button"
          class="action-button"
          data-action="source"
          toggles
          .active="${sourceMode}"
          @active-changed="${this._sourceModeHandler}">Source view</anypoint-button>`}
        <slot name="content-actions"></slot>
      </div>
      <div id="editor">
        ${(!sourceMode || noSourceEditor) ?
          html`<api-headers-form
            .model="${viewModel}"
            ?narrow="${narrow}"
            ?allowcustom="${allowCustom}"
            ?allowdisableparams="${allowDisableParams}"
            ?allowhideoptional="${allowHideOptional}"
            data-headers-panel
            ?nodocs="${noDocs}"
            ?readonly="${readOnly}"
            ?outlined="${outlined}"
            ?legacy="${legacy}"
            @value-changed="${this._editorValueChanged}"
            @invalid-changed="${this._formEditorInvalidHandler}"
            @model-changed="${this._formEditorModelHandler}"
            ></api-headers-form>` :
          html`<code-mirror
            mode="http-headers"
            data-headers-panel
            ?readonly="${readOnly}"
            @value-changed="${this._editorValueChanged}"></code-mirror>`}
      </div>
    </div>
    <clipboard-copy .content="${value}"></clipboard-copy>
    `;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * List of headers defined in AMF model to render.
       */
      amfHeaders: { type: Array },
      /**
       * Headers value.
       */
      value: { type: String },
      /**
       * Generated view model from the headers from `amf` model.
       * This is automatically set when `amf` is set.
       */
      viewModel: { type: Array },
      /**
       * Value of a Content-Type header.
       * When this value change then editor update the value for the content type. However,
       * to change a single header value, please, use `request-headers-changed` event with `name`
       * and `value` properties set on the detail object.
       *
       * @type {Stirng}
       */
      contentType: { type: String },
      // When set to true then the source edit mode is enabled
      sourceMode: { type: Boolean },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       * Note, Set is separately for `api-view-model-transformer`
       * component as this only affects "custom" items.
       */
      noDocs: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * Automatically validates headers agains AMF model when value change.
       * Note, it only works with form editor.
       */
      autoValidate: { type: Boolean },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set only form editor is available.
       *
       * Note, because of dependency, you still have to import CodeMirror
       * or at lease provide a mock function for registering addons.
       *
       * See @advanced-rest-client/code-mirror-hint for used functions.
       */
      noSourceEditor: { type: Boolean }
    };
  }
  /**
   * Reference to currently rendered headers editor.
   * @return {HTMLElement}
   */
  get currentPanel() {
    if (!this.shadowRoot) {
      return null;
    }
    const panel = this.shadowRoot.querySelector('code-mirror');
    if (panel) {
      return panel;
    }
    return this.shadowRoot.querySelector('api-headers-form');
  }

  get _cmExtraKeys() {
    return {
      'Ctrl-Space': this._cmKeysHandler
    };
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._value = value;
    this.requestUpdate('value', old);
    this._valueChanged(value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get contentType() {
    return this._contentType;
  }

  set contentType(value) {
    const old = this._contentType;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._contentType = value;
    this.requestUpdate('contentType', old);
    this._onContentTypeChanged(value);
  }

  get viewModel() {
    return this._viewModel;
  }

  set viewModel(value) {
    const old = this._viewModel;
    /* istanbul ignore if  */
    if (old === value) {
      return;
    }
    this._viewModel = value;
    this.requestUpdate('viewModel', old);
  }
  /**
   * @return {Function} Previously registered handler for `value-changed` event
   */
  get onvalue() {
    return this['_onvalue-changed'];
  }
  /**
   * Registers a callback function for `value-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onvalue(value) {
    this._registerCallback('value-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `content-type-changed-changed` event
   */
  get oncontenttype() {
    return this['_oncontent-type-changed'];
  }
  /**
   * Registers a callback function for `content-type-changed-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set oncontenttype(value) {
    this._registerCallback('content-type-changed', value);
  }
  /**
   * @constructor
   */
  constructor() {
    super();
    this._cmKeysHandler = this._cmKeysHandler.bind(this);
    this._headersChangedHandler = this._headersChangedHandler.bind(this);
    this._headerChangedHandler = this._headerChangedHandler.bind(this);
    this._contentTypeChangedHandler = this._contentTypeChangedHandler.bind(this);
    this._headerDeletedHandler = this._headerDeletedHandler.bind(this);

    this.sourceMode = false;
  }

  _attachListeners(node) {
    node.addEventListener('request-headers-changed', this._headersChangedHandler);
    node.addEventListener('request-header-changed', this._headerChangedHandler);
    node.addEventListener('content-type-changed', this._contentTypeChangedHandler);
    node.addEventListener('request-header-deleted', this._headerDeletedHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('request-headers-changed', this._headersChangedHandler);
    node.removeEventListener('request-header-changed', this._headerChangedHandler);
    node.removeEventListener('content-type-changed', this._contentTypeChangedHandler);
    node.removeEventListener('request-header-deleted', this._headerDeletedHandler);
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }
  /**
   * Handler for `sourceMode` change.
   *
   * Opens desired editr.
   *
   * @param {Boolean} isSource
   */
  _sourceModeChanged(isSource) {
    if (this.noSourceEditor) {
      return;
    }
    if (isSource) {
      setTimeout(() => {
        const panel = this.currentPanel;
        panel.setOption('extraKeys', this._cmExtraKeys);
        panel.value = this.modelToValue(this.viewModel);
      }, 50);
    } else {
      this._modelFromValue();
    }

    const ev = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: 'Usage',
        action: 'Click',
        label: 'Toggle source mode ' + String(isSource),
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }

  /**
   * Updates the value when current editor's value change.
   *
   * @param {CustomEvent} e
   */
  _editorValueChanged(e) {
    const value = e.detail.value;
    if (value !== this.value) {
      this._innerEditorValueChanged = true;
      this.value = value;
      this._innerEditorValueChanged = false;
    }
  }
  /**
   * Creates a headers string from a model.
   *
   * @param {?Array} model Optional, model to process. If not set it uses
   * `this.viewModel`
   * @return {String} Generated headers
   */
  modelToValue(model) {
    if (!model) {
      model = this.viewModel;
    }
    if (!model || !model.length) {
      return '';
    }
    const data = [];
    const disbleAllowed = this.allowDisableParams;
    model.forEach((item) => {
      if (!item || (disbleAllowed && item.schema && item.schema.enabled === false)) {
        return;
      }
      data.push({
        name: item.name,
        value: item.value
      });
    });
    return this.headersToString(data);
  }
  /**
   * Code mirror's ctrl+space key handler.
   * Opens headers fill support.
   *
   * @param {Object} cm Code mirror instance.
   */
  _cmKeysHandler(cm) {
    /* global CodeMirror */
    CodeMirror.showHint(cm, CodeMirror.hint['http-headers'], {
      container: this.currentPanel
    });
  }
  /**
   * Called when switching from source view to form view.
   * Updates view model with values defined in text editor.
   *
   * Only headers existing in `value` are going to be present in the model.
   * Otherwise headers will be disabled.
   *
   * It does nothing if `value` or `viewModel` is not defined.
   *
   * @param {?String} value
   */
  _modelFromValue(value) {
    value = value || this.value;
    if (value === undefined) {
      if (!this.model) {
        return;
      } else {
        value = '';
      }
    }
    let model = this.viewModel;
    if (!model) {
      model = [];
      this.viewModel = model;
    }
    const parsedValue = this.filterHeaders(this.headersToJSON(String(value)));
    const tmp = {};
    const appendCustom = [];
    const disbleAllowed = this.allowDisableParams;
    // updates model value
    for (let i = 0, len = parsedValue.length; i < len; i++) {
      const item = parsedValue[i];
      const index = this._findModelIndex(model, item.name);
      if (index === -1) {
        appendCustom.push(this.createCustom(item));
      } else {
        tmp[item.name] = true;
        if (model[index].value !== item.value) {
          if (model[index].schema.isArray) {
            model[index].value = item.value.split(',');
          } else {
            model[index].value = item.value;
          }
        }
        if (!model[index].schema.enabled) {
          model[index].schema.enabled = true;
        }
      }
    }
    // Disables / removes not existing values.
    for (let i = model.length - 1; i >= 0; i--) {
      if (model[i].name in tmp) {
        continue;
      }
      if (model[i].schema.isCustom) {
        model.splice(i, 1);
      } else if (disbleAllowed) {
        model[i].schema.enabled = false;
      } else {
        if (model[i].schema.isArray) {
          model[i].value = [];
        } else {
          model[i].value = '';
        }
      }
    }
    if (!model.length) {
      this.viewModel = appendCustom;
    } else {
      model = [...model, ...appendCustom];
      this.viewModel = model;
    }
  }
  /**
   * Finds item position in model by name.
   *
   * @param {Array} model Model items
   * @param {String} name Header name to search for
   * @return {Number} Items position or `-1` if not found.
   */
  _findModelIndex(model, name) {
    for (let i = 0, len = model.length; i < len; i++) {
      if (model[i].name === name) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Creates a custom header model item.
   *
   * @param {Object} defaults Default data
   * @return {Object} View model item
   */
  createCustom(defaults) {
    const data = Object.assign({}, defaults);
    if (!data.schema) {
      data.schema = {};
    }
    data.schema.isCustom = true;
    if (!data.schema.type) {
      data.schema.type = 'string';
    }
    if (!data.schema.enabled) {
      data.schema.enabled = true;
    }
    if (!data.schema.inputLabel) {
      data.schema.inputLabel = 'Header value';
    }
    const node = this.shadowRoot.querySelector('api-view-model-transformer');
    if (node) {
      node.buildProperty(data);
    }
    return data;
  }

  /**
   * Handler tor the `request-headers-changed` event.
   * Updates the editor value to the value of the event detail object.
   * @param {CustomEvent} e
   */
  _headersChangedHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    const value = e.detail.value;
    this._setValues(value);
  }
  /**
   * Handler for the `request-header-changed` event.
   * It updates value for a single header.
   * @param {CustomEvent} e
   */
  _headerChangedHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    const name = e.detail.name;
    if (!name) {
      return;
    }
    const value = e.detail.value;
    const arr = this.headersToJSON(this.value);
    let updated = false;
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i].name.toLowerCase() === name.toLowerCase()) {
        arr[i].value = value;
        updated = true;
        break;
      }
    }
    if (!updated) {
      arr.push({
        name: name,
        value: value
      });
    }
    const headers = this.headersToString(arr);
    this._setValues(headers);
  }
  /**
   * Handler for `content-type-changed` event.
   * Uppdates it's value if from external source.
   *
   * @param {CustomEvent} e
   */
  _contentTypeChangedHandler(e) {
    if (e.composedPath()[0] === this || e.defaultPrevented) {
      return;
    }
    this.__cancelContentTypeNotification = true;
    this.contentType = e.detail.value;
    this.__cancelContentTypeNotification = false;
  }
  /**
   * Handler for `request-header-deleted` custom event.
   * Deletes header from the editor.
   * @param {CustomEvent} e
   */
  _headerDeletedHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    const name = e.detail.name;
    if (!name) {
      return;
    }
    const arr = this.headersToJSON(this.value);
    let updated = false;
    for (let i = arr.length - 1; i >= 0; i--) {
      if (arr[i].name.toLowerCase() === name.toLowerCase()) {
        arr.splice(i, 1);
        updated = true;
        break;
      }
    }
    if (!updated) {
      return;
    }
    const headers = this.headersToString(arr);
    this._setValues(headers);
  }
  /**
   * Detects and sets content type value from changed headers value.
   *
   * @param {String} value Headers new value.
   */
  _detectContentType(value) {
    if (!value) {
      value = '';
    }
    contentTypeRe.lastIndex = 0;
    const matches = contentTypeRe.exec(value);
    let ctValue;
    if (!matches) {
      ctValue = '';
    } else {
      ctValue = matches[1];
    }
    if (!ctValue) {
      if (this.contentType) {
        this.contentType = undefined;
      }
    } else {
      ctValue = ctValue.trim();
      if (this.contentType !== ctValue) {
        this.contentType = ctValue;
      }
    }
  }
  /**
   * Called by CodeMirror editor.
   * When something change n the headers list, detect content type header.
   * @param {String} value
   */
  _valueChanged(value) {
    if (this.autoValidate) {
      this.validate();
    }
    this._detectContentType(value);
    if (this._cacncelChangeEvent) {
      if (!this._innerEditorValueChanged) {
        this._modelFromValue(value);
      }
      return;
    }
    if (this._innerEditorValueChanged) {
      if (this.readOnly) {
        return;
      }
      this.dispatchEvent(new CustomEvent('request-headers-changed', {
        detail: {
          value: value
        },
        cancelable: true,
        bubbles: true,
        composed: true
      }));
    } else {
      this._modelFromValue(value);
    }
  }

  _onContentTypeChanged(currentCt) {
    if (this.readOnly) {
      return;
    }
    if (!currentCt) {
      this._notifyContentType('');
      return;
    }
    const arr = this.headersToJSON(this.value);
    let updated = false;
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i].name.toLowerCase() !== 'content-type') {
        continue;
      }
      updated = true;
      if (arr[i].value !== currentCt) {
        arr[i].value = currentCt;
      }
      break;
    }
    if (!updated) {
      arr.push({
        name: 'Content-Type',
        value: currentCt
      });
    }
    const headers = this.headersToString(arr);
    if (!this._innerEditorValueChanged) {
      this._setValues(headers);
      this._modelFromValue(headers);
    }
    this._notifyContentType(currentCt);
  }

  _notifyContentType(type) {
    if (this.__cancelContentTypeNotification) {
      return;
    }
    const ev = new CustomEvent('content-type-changed', {
      detail: {
        value: type
      },
      cancelable: false,
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }
  /**
   * Updates `value` when new value is computed by the editor.
   *
   * @param {String} value A value to set.
   */
  _setValues(value) {
    this._cacncelChangeEvent = true;
    this.value = value;
    this._cacncelChangeEvent = false;
    if (!this._innerEditorValueChanged && this.sourceMode) {
      const panel = this.currentPanel;
      if (panel) {
        panel.value = value;
      }
    }
  }
  /**
   * Coppies current response text value to clipboard.
   * @param {Event} e
   */
  _copyToClipboard(e) {
    const button = e.target;
    const copy = this.shadowRoot.querySelector('clipboard-copy');
    if (copy.copy()) {
      button.innerText = 'Done';
    } else {
      button.innerText = 'Error';
    }
    button.disabled = true;
    if ('part' in button) {
      button.part.add('content-action-button-disabled');
      button.part.add('code-content-action-button-disabled');
    }
    setTimeout(() => this._resetCopyButtonState(button), 1000);
    const ev = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: 'Usage',
        action: 'Click',
        label: 'Headers editor clipboard copy',
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }

  _resetCopyButtonState(button) {
    button.innerText = 'Copy';
    button.disabled = false;
    if ('part' in button) {
      button.part.remove('content-action-button-disabled');
      button.part.remove('code-content-action-button-disabled');
    }
  }

  // Overidden from Polymer.IronValidatableBehavior. Will set the `invalid`
  // attribute automatically, which should be used for styling.
  _getValidity() {
    if (this.sourceMode || !this.shadowRoot) {
      return true;
    }
    const form = this.shadowRoot.querySelector('api-headers-form');
    return form ? form.validate() : true;
  }
  /**
   * Refreshes the CodeMirror editor when in `sourceMode`.
   */
  refresh() {
    if (!this.sourceMode) {
      return;
    }
    const panel = this.currentPanel;
    panel.refresh();
  }

  _apiHandler(e) {
    this.amf = e.detail.value;
  }

  async _viewModelHandler(e) {
    const { value } = e.detail;
    if (value) {
      await this.updateComplete;
      this.viewModel = value;
    }
  }

  _sourceModeHandler(e) {
    if (this.noSourceEditor) {
      return;
    }
    const { value } = e.detail;
    this.sourceMode = value;
    this._sourceModeChanged(value);
  }

  _formEditorInvalidHandler(e) {
    this.invalid = e.detail.value;
  }

  _formEditorModelHandler(e) {
    if (e.detail.value !== this.viewModel) {
      this.viewModel = e.detail.value;
    }
  }
}

window.customElements.define('api-headers-editor', ApiHeadersEditor);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
const AMP_RE = new RegExp(/&/g);
const GT_RE = new RegExp(/>/g);
const LT_RE = new RegExp(/</g);
const SQUOT_RE = new RegExp(/'/g);
const QUOT_RE = new RegExp(/"/g);
/**
 * A behavior to be implemented to elements that needs to parse
 * request / response body.
 * It contains functions to encode / decode form data and to escape HTML.
 *
 * @polymer
 * @mixinFunction
 * @memberof ArcBehaviors
 */
const PayloadParserMixin = dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class PayloadParserMixin extends base {
    /**
     * Regexp to search for the `&` character
     * @type {RegExp}
     */
    get AMP_RE() {
      return AMP_RE;
    }
    /**
     * Regexp to search for the `>` character
     * @type {RegExp}
     */
    get GT_RE() {
      return GT_RE;
    }
    /**
     * Regexp to search for the `<` character
     * @type {RegExp}
     */
    get LT_RE() {
      return LT_RE;
    }
    /**
     * Regexp to search for the `'` character
     * @type {RegExp}
     */
    get SQUOT_RE() {
      return SQUOT_RE;
    }
    /**
     * Regexp to search for the `"` character
     * @type {RegExp}
     */
    get QUOT_RE() {
      return QUOT_RE;
    }
    /**
     * Escape HTML to save HTML text.
     *
     * @param {String} html A HTML string to be escaped.
     * @return {String}
     */
    htmlEscape(html) {
      if (html.indexOf('&') !== -1) {
        html = html.replace(this.AMP_RE, '&amp;');
      }
      if (html.indexOf('<') !== -1) {
        html = html.replace(this.LT_RE, '&lt;');
      }
      if (html.indexOf('>') !== -1) {
        html = html.replace(this.GT_RE, '&gt;');
      }
      if (html.indexOf('"') !== -1) {
        html = html.replace(this.QUOT_RE, '&quot;');
      }
      if (html.indexOf('\'') !== -1) {
        html = html.replace(this.SQUOT_RE, '&apos;');
      }
      return html;
    }
    /**
     * Parse input array to string x-www-form-urlencoded.
     *
     * Note that this function doesn't encodes the name and value. Use
     * `this.formArrayToString(this.encodeUrlEncoded(arr))`
     * to create a encoded string from the array.
     *
     * @param {Array<Object>} arr Input array. Each element must contain an
     * object with `name` and `value` keys.
     * @return {String} A parsed string of `name`=`value` pairs of the input objects.
     */
    formArrayToString(arr) {
      if (!arr || !(arr instanceof Array)) {
        return [];
      }
      const result = [];
      arr.forEach((item) => {
        const data = this._modelItemToFormDataString(item);
        if (data) {
          result[result.length] = data;
        }
      });
      return result.join('&');
    }
    /**
     * Creates a form data string for a single item.
     * @param {Object} model The model with `name` and `value` properties.
     * @return {String} Generated value string for x-www-form-urlencoded form.
     */
    _modelItemToFormDataString(model) {
      if (model.schema && model.schema.enabled === false) {
        return;
      }
      const name = this._paramValue(model.name);
      let value = model.value;
      if (value && value instanceof Array) {
        return value.map((item) => name + '=' + this._paramValue(item))
            .join('&');
      }
      value = this._paramValue(value);
      if (!name && !value) {
        return;
      }
      if (!value && model.required === false) {
        return;
      }
      return name + '=' + value;
    }
    /**
     * Parse input string to array of x-www-form-urlencoded form parameters.
     *
     * This function will not url-decode names and values. Please, use
     * `this.decodeUrlEncoded(this.stringToArray(str))` to create an array
     * of decoded parameters.
     *
     * @param {String} input A string of HTTP x-www-form-urlencoded parameters
     * @return {Array<Object>} An array of params with `name` and `value` keys.
     */
    stringToArray(input) {
      if (typeof input !== 'string' || !input.trim()) {
        return [];
      }
      // Chrome inspector has FormData output in format: `param-name`:`param-value`
      // When copying from inspector the ':' must be replaced with '='
      const htmlInputCheck = /^([^\\=]{1,})=(.*)$/m;
      if (!htmlInputCheck.test(input)) {
        // replace chome inspector data.
        input = input.replace(/^([^\\:]{1,}):(.*)$/gm, '$1=$2&').replace(/\n/gm, '');
        input = input.substr(0, input.length - 1);
      }

      return this._createParamsArray(input);
    }
    /**
     * Converts a string to an array with objects containing name and value keys
     * @param {String} input An input string
     * @return {Array.<Object>} An array of params with `name` and `value` keys.
     */
    _createParamsArray(input) {
      let result = [];
      if (!input) {
        return result;
      }
      let state = 0; // 0 - reading name, 1 - reading value
      let i = 0;
      let _tmpName = '';
      let _tmpValue = '';
      const cond = true;
      while (cond) {
        const ch = input[i++];
        if (ch === undefined) {
          if (_tmpValue || _tmpName) {
            result = this._appendArrayResult(result, _tmpName, _tmpValue);
          }
          break;
        }
        if (ch === '=') {
          if (state !== 1) {
            state = 1;
            continue;
          }
        }
        if (ch === '&') {
          state = 0;
          result = this._appendArrayResult(result, _tmpName, _tmpValue);
          _tmpName = '';
          _tmpValue = '';
          continue;
        }
        if (state === 0) {
          _tmpName += ch;
        } else if (state === 1) {
          _tmpValue += ch;
        }
      }
      return result;
    }
    /**
     * Appends form data parameter to an array.
     * If the parameter already exists in the array it creates an array for
     * the value onstead of appending the same parameter.
     *
     * @param {Array} array An array to append the parameter
     * @param {String} name Name of the form data parameter
     * @param {String} value Value of the form data parameter
     * @return {Array} Updated array
     */
    _appendArrayResult(array, name, value) {
      for (let i = 0, len = array.length; i < len; i++) {
        if (array[i].name === name) {
          if (array[i].value instanceof Array) {
            array[i].value.push(value);
          } else {
            array[i].value = [array[i].value, value];
          }
          return array;
        }
      }
      array.push({
        name: name,
        value: value
      });
      return array;
    }
    /**
     * Encode payload to x-www-form-urlencoded string.
     *
     * @param {Array<object>|String} input An input data.
     * @return {Array<object>|String}
     */
    encodeUrlEncoded(input) {
      if (!input || !input.length) {
        return input;
      }
      const isArray = input instanceof Array;
      if (!isArray) {
        input = this.stringToArray(input);
      }
      input.forEach((obj) => {
        obj.name = this.encodeQueryString(obj.name);
        obj.value = this._encodeValue(obj.value);
      });
      if (isArray) {
        return input;
      }
      return this.formArrayToString(input);
    }
    /**
     * URL encodes a value.
     *
     * @param {String|Array<String>} value Value to encode. Either string or
     * array of strings.
     * @return {String|Array<String>} Encoded value. The same type as the input.
     */
    _encodeValue(value) {
      if (value instanceof Array) {
        for (let i = 0, len = value.length; i < len; i++) {
          value[i] = this.encodeQueryString(value[i]);
        }
        return value;
      }
      return this.encodeQueryString(value);
    }
    /**
     * Decode x-www-form-urlencoded data.
     *
     * @param {Array<object>|String} input An input data.
     * @return {Array<object>|String}
     */
    decodeUrlEncoded(input) {
      if (!input || !input.length) {
        return input;
      }
      const isArray = input instanceof Array;
      if (!isArray) {
        input = this.stringToArray(input);
      }
      input.forEach((obj) => {
        obj.name = this.decodeQueryString(obj.name);
        obj.value = this._decodeValue(obj.value);
      });
      if (isArray) {
        return input;
      }
      return this.formArrayToString(input);
    }
    /**
     * URL decodes a value.
     *
     * @param {String|Array<String>} value Value to decode. Either string or
     * array of strings.
     * @return {String|Array<String>} Decoded value. The same type as the input.
     */
    _decodeValue(value) {
      if (value instanceof Array) {
        for (let i = 0, len = value.length; i < len; i++) {
          value[i] = this.decodeQueryString(value[i]);
        }
        return value;
      }
      return this.decodeQueryString(value);
    }
    /**
     * Parse input string as a payload param key or value.
     *
     * @param {String} input An input to parse.
     * @return {String}
     */
    _paramValue(input) {
      if (!input) {
        return String();
      }
      input = String(input);
      input = input.trim();
      return input;
    }
    /**
     * Parse a line of key=value http params into an object with `name` and `value` keys.
     *
     * @param {String} input A input line of x-www-form-urlencoded text tike `param=value`
     * @return {Object} A parsed object with `name` and `value` keys.
     * @deprecated It's old parser. Use `_createParamsArray` instead.
     */
    _paramLineToFormObject(input) {
      if (!input) {
        return;
      }
      const _tmp = input.split('=');
      const name = _tmp[0].trim();
      if (!name && _tmp.length === 1) {
        return;
      }
      let value;
      if (_tmp.length === 1) {
        value = '';
      } else {
        value = _tmp[1].trim();
      }
      return {
        name: name,
        value: value
      };
    }
    /**
     * Returns a string where all characters that are not valid for a URL
     * component have been escaped. The escaping of a character is done by
     * converting it into its UTF-8 encoding and then encoding each of the
     * resulting bytes as a %xx hexadecimal escape sequence.
     *
     * Note: this method will convert any space character into its escape
     * short form, '+' rather than %20. It should therefore only be used for
     * query-string parts.
     *
     * The following character sets are **not** escaped by this method:
     * - ASCII digits or letters
     * - ASCII punctuation characters: ```- _ . ! ~ * ' ( )</pre>```
     *
     * Notice that this method <em>does</em> encode the URL component delimiter
     * characters:<blockquote>
     *
     * ```
     * ; / ? : & = + $ , #
     * ```
     *
     * @param {String} str A string containing invalid URL characters
     * @return {String} a string with all invalid URL characters escaped
     */
    encodeQueryString(str) {
      if (!str) {
        return str;
      }
      const regexp = /%20/g;
      return encodeURIComponent(str).replace(regexp, '+');
    }
    /**
     * Returns a string where all URL component escape sequences have been
     * converted back to their original character representations.
     *
     * Note: this method will convert the space character escape short form, '+',
     * into a space. It should therefore only be used for query-string parts.
     *
     * @param {String} str string containing encoded URL component sequences
     * @return {String} string with no encoded URL component encoded sequences
     */
    decodeQueryString(str) {
      if (!str) {
        return str;
      }
      const regexp = /\+/g;
      return decodeURIComponent(str.replace(regexp, '%20'));
    }
  }
  return PayloadParserMixin;
});

/**
@license
Copyright 2019 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

/**
 * An element that renders form controls for the editor.
 *
 * @customElement
 * @demo demo/simple.html Simple usage
 * @demo demo/raml.html With AMF model from RAML file
 * @memberof UiElements
 */
class FormDataEditorItem extends LitElement {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      css`:host {
        display: block;
        outline: none;
      }

      .custom-inputs,
      .value-field {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      .narrow .custom-inputs {
        display: block;
      }

      .value-field,
      .param-name,
      .custom-inputs,
      api-property-form-item {
        flex: 1;
      }

      api-property-form-item[isarray] {
        margin-top: 8px;
      }

      .narrow .param-name {
        margin-right: 0;
      }

      [hidden] {
        display: none !important;
      }`
    ];
  }

  _customTemplate() {
    const {
      name,
      value,
      readOnly,
      disabled,
      compatibility,
      outlined
    } = this;
    return html`<div class="custom-inputs">
      <anypoint-input
        name="custom-name"
        .value="${name}"
        @value-changed="${this._nameChangeHandler}"
        class="param-name"
        type="text"
        required
        autovalidate
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled=${disabled}>
        <label slot="label">Parameter name</label>
      </anypoint-input>

      <anypoint-input
        .name="${name}"
        .value="${value}"
        @value-changed="${this._valueChangeHandler}"
        class="param-value"
        type="text"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled=${disabled}>
        <label slot="label">Parameter value</label>
      </anypoint-input>
    </div>

    <anypoint-icon-button
      title="Remove this parameter"
      aria-label="Press to remove parameter ${name}"
      class="action-icon delete-icon"
      @click="${this._remove}"
      slot="suffix"
      ?disabled="${readOnly || disabled}"
      ?outlined="${outlined}"
      ?compatibility="${compatibility}">
      <iron-icon icon="arc:remove-circle-outline"></iron-icon>
    </anypoint-icon-button>`;
  }

  _modelTemplate(model, hasDocs, noDocs) {
    const {
      name,
      value,
      readOnly,
      disabled,
      compatibility,
      outlined,
      narrow,
      required
    } = this;
    return html`<div class="value-field">
      <api-property-form-item
        data-type="typed"
        name="${name}"
        .value="${value}"
        @value-changed="${this._valueChangeHandler}"
        .model="${model}"
        ?required="${required}"
        .readOnly="${readOnly}"
        .disabled=${disabled}
        ?narrow="${narrow}"
        .noDocs="${noDocs}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        ></api-property-form-item>
      ${hasDocs ? html`<anypoint-icon-button
        class="hint-icon"
        title="Toggle documentation"
        aria-label="Press to toggle documentation for this property"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        ?disabled="${disabled}"
        @click="${this._toggleItemDocs}">
        <iron-icon icon="arc:help"></iron-icon>
      </anypoint-icon-button>` : undefined}
    </div>`;
  }

  render() {
    const {
      narrow,
      isCustom,
      docsOpened,
      noDocs,
      model
    } = this;
    const hasDocs = this._computeHasDocumentation(noDocs, model);
    const renderDocs = !noDocs && hasDocs && !!docsOpened;

    return html`
    <div class="form-item${narrow ? ' narrow' : ''}">
      ${isCustom ? this._customTemplate() : this._modelTemplate(model, hasDocs, noDocs)}
    </div>
    ${renderDocs ? html`<div class="docs">
      <arc-marked .markdown="${this._computeDocumentation(model)}">
        <div slot="markdown-html" class="markdown-body"></div>
      </arc-marked>
    </div>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * The name of this element.
       */
      name: { type: String },
      /**
       * The value of this element.
       */
      value: { type: String },
      /**
       * A model item
       */
      model: { type: Object },
      /**
       * If set it renders a narrow layout
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * True to render documentation (if set in model)
       */
      docsOpened: { type: Boolean },
      /**
       * Set if the header is not specified in the RAML type (is a custom
       * header).
       */
      isCustom: { type: Boolean },
      /**
       * If set it is render the item control as an array item (adds more
       * spacing to the element)
       */
      isArray: { type: Boolean, reflect: true },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
      /**
       * When set a model generated item is maked as required.
       */
      required: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  constructor() {
    super();
    this.focus = this.focus.bind(this);
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('focus', this.focus);
    this.setAttribute('tabindex', '0');
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('focus', this.focus);
  }
  /**
   * Focuses on name input (custom value) or the value input (model value).
   */
  focus() {
    let node;
    if (this.isCustom) {
      node = this.shadowRoot.querySelector('.param-name');
      if (node) {
        node = node.inputElement;
      }
    } else {
      node = this.shadowRoot.querySelector('api-property-form-item');
    }
    if (node) {
      node.focus();
    }
  }

  /**
   * Dispatches `remove` custom event that does not bubbles to inform the editor
   * to delete this parameter.
   */
  _remove() {
    this.dispatchEvent(new CustomEvent('remove'));
  }
  /**
   * Computes documentation as a markdown to be placed in the `marked-element`
   * @param {Object} item View model
   * @return {String}
   */
  _computeDocumentation(item) {
    let docs = '';
    if (item.description) {
      docs += item.description;
    }
    if (!item.schema) {
      return docs;
    }
    const schema = item.schema;
    if (docs) {
      docs += '\n\n\n';
    }
    if (schema.pattern) {
      docs += '- Pattern: `' + schema.pattern + '`\n';
    }
    if (schema.examples && schema.examples.length) {
      schema.examples.forEach((item) => {
        if (!item.value) {
          return;
        }
        docs += '- Example';
        if (item.hasName) {
          docs += ' ' + item.name;
        }
        docs += ': `' + item.value + '`\n';
      });
    }
    return docs;
  }
  /**
   * Computes if model item has documentation to display.
   * @param {Boolean} noDocs If set it always cancels docs
   * @param {Object} item Model item
   * @return {Boolean} True if documentation can be rendered.
   */
  _computeHasDocumentation(noDocs, item) {
    if (noDocs || !item) {
      return false;
    }
    if (item.hasDescription) {
      return true;
    }
    if (!item.schema) {
      return false;
    }
    const schema = item.schema;
    if (schema.pattern) {
      return true;
    }
    if (schema.examples && schema.examples.length && schema.examples[0].value) {
      return true;
    }
    return false;
  }

  _valueChangeHandler(e) {
    const { value } = e.detail;
    this.value = value;
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  _nameChangeHandler(e) {
    const { value } = e.detail;
    this.name = value;
    this.dispatchEvent(new CustomEvent('name-changed', {
      detail: {
        value
      }
    }));
  }

  _toggleItemDocs() {
    this.docsOpened = !this.docsOpened;
  }
}
window.customElements.define('form-data-editor-item', FormDataEditorItem);

/**
@license
Copyright 2019 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element to edit form data (x-www-form-urlencoded).
 * @customElement
 * @demo demo/index.html
 * @appliesMixin ValidatableMixin
 * @appliesMixin ApiFormMixin
 * @appliesMixin PayloadParserBehavior
 * @memberof UiElements
 */
class FormDataEditor extends PayloadParserMixin(ValidatableMixin(ApiFormMixin(LitElement))) {
  static get styles() {
    return [
      formStyles,
      css`:host {
        display: block;
      }

      .form-item-row {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      form-data-editor-item {
        flex: 1;
      }

      .option-pane {
        margin: 8px 0;
        display: flex;
        flex-direction: row;
        align-items: center;
      }
      `
    ];
  }

  _formRowTemplate(item, index) {
    const {
      allowHideOptional,
      optionalOpened,
      allowDisableParams,
      readOnly,
      disabled,
      compatibility,
      outlined,
      narrow,
      noDocs,
      hasOptional
    } = this;
    const rowClass = this._computeItemClass(item, narrow, allowHideOptional, optionalOpened, allowDisableParams);
    const isOptional = this.computeIsOptional(hasOptional, item);
    return html`<div
      class="${rowClass}"
      ?data-optional="${isOptional}">

      ${allowDisableParams ? html`
      <anypoint-checkbox
        class="enable-checkbox"
        ?checked="${item.schema.enabled}"
        data-index="${index}"
        ?data-array="${item.schema.isArray}"
        @checked-changed="${this._enableCheckedHandler}"
        title="Enable or disable this parameter"
        aria-label="Toggle to enable or disable this parameter"
        ?disabled="${readOnly || disabled}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"></anypoint-checkbox>` : undefined}

      <form-data-editor-item
        data-index="${index}"
        .narrow="${narrow}"
        .name="${item.name}"
        .value="${item.value}"
        .model="${item}"
        .noDocs="${noDocs}"
        .required="${item.required}"
        .disabled="${disabled}"
        .readOnly="${readOnly}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}"
        .isCustom="${item.schema.isCustom}"
        .isArray="${item.schema.isArray}"
        @remove="${this._removeCustom}"
        @value-changed="${this._valueChangeHanlder}"
        @name-changed="${this._nameChangeHanlder}"></form-data-editor-item>
    </div>`;
  }

  render() {
    const {
      renderOptionalCheckbox,
      optionalOpened,
      allowCustom,
      readOnly,
      disabled
    } = this;
    let { model } = this;
    if (!model) {
      model = [];
    }
    const encButtonsEmphasis = allowCustom ? 'low' : 'medium';
    return html`
    <div class="option-pane">
      ${allowCustom ? html`<div class="add-action">
        <anypoint-button
          class="action-button"
          emphasis="medium"
          @click="${this.add}"
          title="Add new parameter"
          aria-label="Press to create a new parameter"
          ?disabled="${readOnly || disabled}">
          <iron-icon
            class="action-icon"
            icon="arc:add-circle-outline"
            alt="Add parameter icon"></iron-icon>
          Add parameter
        </anypoint-button>
      </div>` : undefined}

      <anypoint-button
        title="Encodes payload to x-www-form-urlencoded data"
        aria-label="Press to encode form values"
        emphasis="${encButtonsEmphasis}"
        @click="${this._encodePaylod}"
        ?disabled="${readOnly || disabled}">
        Encode payload
      </anypoint-button>

      <anypoint-button
        title="Decodes payload to human readable form"
        aria-label="Press to decode form values"
        emphasis="${encButtonsEmphasis}"
        @click="${this._decodePaylod}"
        ?disabled="${readOnly || disabled}">
        Decode payload
      </anypoint-button>

      <slot name="content-action"></slot>
    </div>

    ${renderOptionalCheckbox ? html`<div class="optional-checkbox">
      <anypoint-checkbox
        class="toggle-checkbox"
        .checked="${optionalOpened}"
        @checked-changed="${this._optionalHanlder}"
        title="Toggles optional parameters">
        Show optional parameters
      </anypoint-checkbox>
    </div>` : undefined}

    <iron-form>
      <form enctype="application/json">
        ${model.map((item, index) => this._formRowTemplate(item, index))}
      </form>
    </iron-form>

    ${model.length === 0 && !allowCustom ?
      html`<p>This endpoint does not declare body properties</p>` : ''}

    ${model.length !== 0 && allowCustom ?
      html`<anypoint-button
        class="action-button"
        @click="${this.add}"
        title="Add new parameter"
        aria-label="Press to create a new parameter"
        ?disabled="${readOnly || disabled}">
        <iron-icon
          class="action-icon"
          icon="arc:add-circle-outline"
          alt="Add parameter icon"></iron-icon>
        Add next
      </anypoint-button>` : ''}
    `;
  }

  static get properties() {
    return {
      /**
       * The editor value
       */
      value: { type: String },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean, reflect: true },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get model() {
    return this._model;
  }

  set model(value) {
    if (this._sop('model', value)) {
      this._notifyChanged('model', value);
      this.renderEmptyMessage = this._computeRenderEmptyMessage(this.allowCustom, value);
      this.hasOptional = this._computeHasOptionalParameters(this.allowHideOptional, value);
      this._updateValue();
    }
  }

  get value() {
    return this._value;
  }

  set value(value) {
    if (this._sop('value', value)) {
      this._notifyChanged('value', value);
      this._valueChanged(value);
    }
  }
  /**
   * @return {Function} Previously registered handler for `model-changed` event
   */
  get onmodel() {
    return this['_onmodel-changed'];
  }
  /**
   * Registers a callback function for `model-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onmodel(value) {
    this._registerCallback('model-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `value-changed` event
   */
  get onchange() {
    return this['_onvalue-changed'];
  }
  /**
   * Registers a callback function for `value-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onchange(value) {
    this._registerCallback('value-changed', value);
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }

  firstUpdated() {
    if (!this.model || !this.model.length) {
      this.add();
    }
  }
  /**
   * Appends an empty header to the list.
   */
  add() {
    if (!this.allowCustom) {
      return;
    }
    this.addCustom('query', {
      inputLabel: 'Parameter value'
    });

    setTimeout(() => this.focusLast());
  }
  /**
   * Focuses on last added item.
   */
  focusLast() {
    const node = this.shadowRoot.querySelector('.form-item:last-child form-data-editor-item');
    if (node) {
      node.focus();
    }
  }
  /**
   * Encodes the payload
   */
  _encodePaylod() {
    this.encodeUrlEncoded(this.model);
    this.requestUpdate();
  }

  /**
   * Decodes the payload
   */
  _decodePaylod() {
    this.decodeUrlEncoded(this.model);
    this.requestUpdate();
  }
  /**
   * Computes for item class.
   *
   * @param {Object} item Model for form item
   * @param {Boolean} narrow
   * @param {Boolean} allowHideOptional
   * @param {Boolean} optionalOpened
   * @param {Boolean} allowDisableParams
   * @return {String}
   */
  _computeItemClass(item, narrow, allowHideOptional, optionalOpened, allowDisableParams) {
    let cls = 'form-item form-item-row ';
    cls += this.computeFormRowClass(item, allowHideOptional, optionalOpened, allowDisableParams);
    if (item && item.schema.isCustom) {
      cls += ' is-custom';
    }
    if (narrow) {
      cls += ' is-narrow';
    }
    return cls;
  }
  /**
   * Updates the value when model changes.
   */
  _updateValue() {
    const { model } = this;
    const hasModel = !!(model && model.length);
    const value = hasModel ? this.formArrayToString(model) : '';
    this.__internalChange = true;
    this.value = value;
    this.__internalChange = false;
  }
  /**
   * Updates the model from value, if not cause by internal setters.
   *
   * @param {String} value
   */
  _valueChanged(value) {
    if (this.__internalChange) {
      return;
    }
    this.model = undefined;
    const params = this.stringToArray(value);
    if (!params || !params.length) {
      return;
    }
    params.forEach((item) => this._paramToModel(item));
  }
  /**
   * Creates a model item from parser's name => value pairs.
   *
   * @param {Object} param Object with `value` and `name` properties.
   */
  _paramToModel(param) {
    const name = this.decodeQueryString(param.name);
    const value = this.decodeQueryString(param.value);
    this.addCustom('query', {
      inputLabel: 'Parameter value',
      name: name,
      value: value
    });
  }

  _optionalHanlder(e) {
    this.optionalOpened = e.detail.value;
  }

  _enableCheckedHandler(e) {
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const { checked } = e.target;
    // const old = this.model[index].schema.enabled;
    this.model[index].schema.enabled = checked;
    this._updateValue();
  }

  _valueChangeHanlder(e) {
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const { value } = e.detail;
    this.model[index].value = value;
    this._updateValue();
  }

  _nameChangeHanlder(e) {
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const { value } = e.detail;
    this.model[index].name = value;
    this._updateValue();
  }
}
window.customElements.define('form-data-editor', FormDataEditor);

var jsonlint=function(){var a=!0,b=!1,c={},d=function(){var a={trace:function(){},yy:{},symbols_:{error:2,JSONString:3,STRING:4,JSONNumber:5,NUMBER:6,JSONNullLiteral:7,NULL:8,JSONBooleanLiteral:9,TRUE:10,FALSE:11,JSONText:12,JSONValue:13,EOF:14,JSONObject:15,JSONArray:16,"{":17,"}":18,JSONMemberList:19,JSONMember:20,":":21,",":22,"[":23,"]":24,JSONElementList:25,$accept:0,$end:1},terminals_:{2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},productions_:[0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],performAction:function(b,c,d,e,f,g,h){var i=g.length-1;switch(f){case 1:this.$=b.replace(/\\(\\|")/g,"$1").replace(/\\n/g,"\n").replace(/\\r/g,"\r").replace(/\\t/g,"	").replace(/\\v/g,"").replace(/\\f/g,"\f").replace(/\\b/g,"\b");break;case 2:this.$=Number(b);break;case 3:this.$=null;break;case 4:this.$=!0;break;case 5:this.$=!1;break;case 6:return this.$=g[i-1];case 13:this.$={};break;case 14:this.$=g[i-1];break;case 15:this.$=[g[i-2],g[i]];break;case 16:this.$={},this.$[g[i][0]]=g[i][1];break;case 17:this.$=g[i-2],g[i-2][g[i][0]]=g[i][1];break;case 18:this.$=[];break;case 19:this.$=g[i-1];break;case 20:this.$=[g[i]];break;case 21:this.$=g[i-2],g[i-2].push(g[i]);}},table:[{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],defaultActions:{16:[2,6]},parseError:function(b,c){throw new Error(b)},parse:function(b){function o(a){d.length=d.length-2*a,e.length=e.length-a,f.length=f.length-a;}function p(){var a;return a=c.lexer.lex()||1,typeof a!="number"&&(a=c.symbols_[a]||a),a}var c=this,d=[0],e=[null],f=[],g=this.table,h="",i=0,j=0,k=0,l=2,m=1;this.lexer.setInput(b),this.lexer.yy=this.yy,this.yy.lexer=this.lexer,typeof this.lexer.yylloc=="undefined"&&(this.lexer.yylloc={});var n=this.lexer.yylloc;f.push(n),typeof this.yy.parseError=="function"&&(this.parseError=this.yy.parseError);var q,r,s,t,v,w={},x,y,z,A;for(;;){s=d[d.length-1],this.defaultActions[s]?t=this.defaultActions[s]:(q==null&&(q=p()),t=g[s]&&g[s][q]);if(typeof t=="undefined"||!t.length||!t[0]){if(!k){A=[];for(x in g[s])this.terminals_[x]&&x>2&&A.push("'"+this.terminals_[x]+"'");var B="";this.lexer.showPosition?B="Parse error on line "+(i+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+A.join(", ")+", got '"+this.terminals_[q]+"'":B="Parse error on line "+(i+1)+": Unexpected "+(q==1?"end of input":"'"+(this.terminals_[q]||q)+"'"),this.parseError(B,{text:this.lexer.match,token:this.terminals_[q]||q,line:this.lexer.yylineno,loc:n,expected:A});}if(k==3){if(q==m)throw new Error(B||"Parsing halted.");j=this.lexer.yyleng,h=this.lexer.yytext,i=this.lexer.yylineno,n=this.lexer.yylloc,q=p();}for(;;){if(l.toString()in g[s])break;if(s==0)throw new Error(B||"Parsing halted.");o(1),s=d[d.length-1];}r=q,q=l,s=d[d.length-1],t=g[s]&&g[s][l],k=3;}if(t[0]instanceof Array&&t.length>1)throw new Error("Parse Error: multiple actions possible at state: "+s+", token: "+q);switch(t[0]){case 1:d.push(q),e.push(this.lexer.yytext),f.push(this.lexer.yylloc),d.push(t[1]),q=null,r?(q=r,r=null):(j=this.lexer.yyleng,h=this.lexer.yytext,i=this.lexer.yylineno,n=this.lexer.yylloc,k>0&&k--);break;case 2:y=this.productions_[t[1]][1],w.$=e[e.length-y],w._$={first_line:f[f.length-(y||1)].first_line,last_line:f[f.length-1].last_line,first_column:f[f.length-(y||1)].first_column,last_column:f[f.length-1].last_column},v=this.performAction.call(w,h,j,i,this.yy,t[1],e,f);if(typeof v!="undefined")return v;y&&(d=d.slice(0,-1*y*2),e=e.slice(0,-1*y),f=f.slice(0,-1*y)),d.push(this.productions_[t[1]][0]),e.push(w.$),f.push(w._$),z=g[d[d.length-2]][d[d.length-1]],d.push(z);break;case 3:return !0}}return !0}},b=function(){var a={EOF:1,parseError:function(b,c){if(!this.yy.parseError)throw new Error(b);this.yy.parseError(b,c);},setInput:function(a){return this._input=a,this._more=this._less=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this},input:function(){var a=this._input[0];this.yytext+=a,this.yyleng++,this.match+=a,this.matched+=a;var b=a.match(/\n/);return b&&this.yylineno++,this._input=this._input.slice(1),a},unput:function(a){return this._input=a+this._input,this},more:function(){return this._more=!0,this},less:function(a){this._input=this.match.slice(a)+this._input;},pastInput:function(){var a=this.matched.substr(0,this.matched.length-this.match.length);return (a.length>20?"...":"")+a.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var a=this.match;return a.length<20&&(a+=this._input.substr(0,20-a.length)),(a.substr(0,20)+(a.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var a=this.pastInput(),b=(new Array(a.length+1)).join("-");return a+this.upcomingInput()+"\n"+b+"^"},next:function(){if(this.done)return this.EOF;this._input||(this.done=!0);var a,b,c,d,f;this._more||(this.yytext="",this.match="");var g=this._currentRules();for(var h=0;h<g.length;h++){c=this._input.match(this.rules[g[h]]);if(c&&(!b||c[0].length>b[0].length)){b=c,d=h;if(!this.options.flex)break}}if(b){f=b[0].match(/\n.*/g),f&&(this.yylineno+=f.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:f?f[f.length-1].length-1:this.yylloc.last_column+b[0].length},this.yytext+=b[0],this.match+=b[0],this.yyleng=this.yytext.length,this._more=!1,this._input=this._input.slice(b[0].length),this.matched+=b[0],a=this.performAction.call(this,this.yy,this,g[d],this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1);if(a)return a;return}if(this._input==="")return this.EOF;this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno});},lex:function(){var b=this.next();return typeof b!="undefined"?b:this.lex()},begin:function(b){this.conditionStack.push(b);},popState:function(){return this.conditionStack.pop()},_currentRules:function(){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules},topState:function(){return this.conditionStack[this.conditionStack.length-2]},pushState:function(b){this.begin(b);}};return a.options={},a.performAction=function(b,c,d,e){switch(d){case 0:break;case 1:return 6;case 2:return c.yytext=c.yytext.substr(1,c.yyleng-2),4;case 3:return 17;case 4:return 18;case 5:return 23;case 6:return 24;case 7:return 22;case 8:return 21;case 9:return 10;case 10:return 11;case 11:return 8;case 12:return 14;case 13:return "INVALID"}},a.rules=[/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],a.conditions={INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13],inclusive:!0}},a}();return a.lexer=b,a}();return typeof c!="undefined"&&(c.parser=d,c.parse=function(){return d.parse.apply(d,arguments)},c.main=function(d){if(!d[1])throw new Error("Usage: "+d[0]+" FILE");if(typeof process!="undefined")var e=a("fs").readFileSync(a("path").join(process.cwd(),d[1]),"utf8");else var f=a("file").path(a("file").cwd()),e=f.join(d[1]).read({charset:"utf-8"});return c.parser.parse(e)},a.main===b&&c.main(typeof process!="undefined"?process.argv.slice(1):a("system").args)),c}();

var codemirror = createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   module.exports = factory() ;
}(commonjsGlobal, (function () {
  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {this.id = null;};
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range$$1;
    try {range$$1 = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range$$1 || range$$1.parentElement() != te) { return false }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
      var this$1 = this;

    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
      var this$1 = this;

    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this$1.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range$$1.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range$$1, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range$$1.from(), sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
        cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      onBlur(cm);
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
      var this$1 = this;

    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this$1.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
      var this$1 = this;

    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
      var this$1 = this;

    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
      var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++)
      { if (!this$1.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
      var this$1 = this;

    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at)
        { if (op(this$1.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    var this$1 = this;

    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this$1[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
      var this$1 = this;

    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
      var this$1 = this;

    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this$1; }
  };

  SharedTextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this$1.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range$$1 = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range$$1.head; }
      else if (start == "anchor") { pos = range$$1.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
      else { pos = range$$1.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                           clipPos(this$1, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var this$1 = this;

      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var this$1 = this;

      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this$1, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                span.from == null && lineNo$$1 != from.line ||
                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo$$1;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      var this$1 = this;

      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this$1.linked[i];
        if (link.doc != other) { continue }
        this$1.linked.splice(i, 1);
        other.unlinkDoc(this$1);
        detachSharedMarkers(findSharedMarkers(this$1));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          { return }

        var reader = new FileReader;
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
        { return lookupKey(key, map$$1.fallthrough, handle, context) }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () { return display.input.focus(); }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
      else
        { ourRange = range$$1; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
    var order = getOrder(anchorLine);
    if (!order) { return range$$1 }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range$$1 }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(bind(onFocus, this), 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this$1, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(), to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
          { indented = indentLine(cm, range$$1.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function(map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(), to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this$1, j, how); }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range$$1 = this.doc.sel.primary();
        if (start == null) { pos = range$$1.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range$$1.from() : range$$1.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range$$1.from() : range$$1.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse)
            { return dir < 0 ? range$$1.from() : range$$1.to() }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range$$1 == "number") {
          range$$1 = {from: Pos(range$$1, 0), to: null};
        } else if (range$$1.from == null) {
          range$$1 = {from: range$$1, to: null};
        }
        if (!range$$1.to) { range$$1.to = range$$1.from; }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor())
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0)))
            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.49.0";

  return CodeMirror;

})));
});

var lint = createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  mod(codemirror);
})(function(CodeMirror) {
  var GUTTER_ID = "CodeMirror-lint-markers";

  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0;
  }

  function parseOptions(_cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
        tip.innerHTML = ann.messageHTML;
    } else {
        tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint;
    var id = ++state.waitingFor;
    function abort() {
      id = -1;
      cm.off("change", abort);
    }
    cm.on("change", abort);
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort);
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2;
      cm.operation(function() {updateLinting(cm, annotations);});
    }, passOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var passOptions = options.options || options;
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions);
    } else {
      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function(issues) {
        cm.operation(function() {updateLinting(cm, issues);});
      });
      else cm.operation(function() {updateLinting(cm, annotations);});
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupTooltips(annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter")
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    if (this.state.lint) startLinting(this);
  });
});
});

/**
@license
Copyright 2017 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

var linterStyles = css`/* The lint marker gutter */
.CodeMirror-lint-markers {
  width: 16px;
}

.CodeMirror-lint-tooltip {
  background-color: infobackground;
  border: 1px solid black;
  border-radius: 4px 4px 4px 4px;
  color: infotext;
  font-family: monospace;
  font-size: 10pt;
  overflow: hidden;
  padding: 2px 5px;
  position: fixed;
  white-space: pre;
  white-space: pre-wrap;
  z-index: 100;
  max-width: 600px;
  opacity: 0;
  transition: opacity .4s;
}

.CodeMirror-lint-mark-error,
.CodeMirror-lint-mark-warning {
  background-position: left bottom;
  background-repeat: repeat-x;
}

.CodeMirror-lint-mark-error {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==");
}

.CodeMirror-lint-mark-warning {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=");
}

.CodeMirror-lint-marker-error,
.CodeMirror-lint-marker-warning {
  background-position: center center;
  background-repeat: no-repeat;
  cursor: pointer;
  display: inline-block;
  height: 16px;
  width: 16px;
  vertical-align: middle;
  position: relative;
}

.CodeMirror-lint-message-error,
.CodeMirror-lint-message-warning {
  padding-left: 18px;
  background-position: top left;
  background-repeat: no-repeat;
}

.CodeMirror-lint-marker-error,
.CodeMirror-lint-message-error {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=");
}

.CodeMirror-lint-marker-warning,
.CodeMirror-lint-message-warning {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=");
}

.CodeMirror-lint-marker-multiple {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC");
  background-repeat: no-repeat;
  background-position: right bottom;
  width: 100%;
  height: 100%;
}`;

/**
@license
Copyright 2019 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * A raw payload input editor based on CodeMirror.
 *
 * The element additionally shows Encode / Decode buttons if current content type value contains
 * "x-www-form-urlencoded".
 *
 * The element listens for `content-type-changed` custom event and updates the `contentType` property
 * automatically. This event is commonly used in ARC elements.
 *
 * ### Example
 * ```
 * <raw-payload-editor content-type="application/json"></raw-payload-editor>
 * ```
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 * @polymerBehavior Polymer.IronResizableBehavior
 * @appliesMixin EventsTargetMixin
 * @appliesMixin PayloadParserMixin
 */
class RawPayloadEditor extends ArcResizableMixin(PayloadParserMixin(EventsTargetMixin(LitElement))) {
  static get styles() {
    return [
      linterStyles,
      css`:host {
        display: block;
      }

      .action-buttons > * {
        margin: 8px 0;
      }

      *[hidden] {
        display: none !important;
      }`
    ];
  }

  render() {
    const { _encodeEnabled, _isJson, lineNumbers } = this;
    return html`
    <div class="action-buttons">
      ${_encodeEnabled ? html`
        <anypoint-button
          data-action="encode"
          @click="${this.encodeValue}"
          emphasis="medium"
          title="Encodes payload to x-www-form-urlencoded data">Encode payload</anypoint-button>
        <anypoint-button
          data-action="decode"
          @click="${this.decodeValue}"
          emphasis="medium"
          title="Decodes payload to human readable form">Decode payload</anypoint-button>
      ` : undefined}
      ${_isJson ? html`
        <anypoint-button
          data-action="format-json"
          emphasis="medium"
          @click="${this.formatValue}"
          title="Formats JSON input.">Format JSON</anypoint-button>
        <anypoint-button
          data-action="minify-json"
          @click="${this.minifyValue}"
          emphasis="medium"
          title="Removed whitespaces from the input">Minify JSON</anypoint-button>
      ` : undefined}
      <slot name="content-action"></slot>
    </div>
    <code-mirror
      mode="application/json"
      @value-changed="${this._editorValueChanged}"
      gutters='["CodeMirror-lint-markers"]'
      .lineNumbers="${lineNumbers}"></code-mirror>
    <paper-toast id="invalidJsonToast">JSON value is invalid. Cannot parse value.</paper-toast>`;
  }

  static get properties() {
    return {
      /**
       * Raw payload value
       */
      value: { type: String },
      /**
       * Renders line number when set.
       * @type {Object}
       */
      lineNumbers: { type: Boolean },
      /**
       * Content-Type header value. Determines current code mirror mode.
       */
      contentType: { type: String },
      // Computed value, true if `contentType` contains `x-www-form-urlencoded`
      _encodeEnabled: { type: Boolean },
      // Computed value, true if `contentType` contains `/json`
      _isJson: { type: Boolean }
    };
  }

  get _editor() {
    return this.shadowRoot.querySelector('code-mirror');
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    if (old === value) {
      return;
    }
    this._value = value;
    this._valueChanged(value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get contentType() {
    return this._contentType;
  }

  set contentType(value) {
    const old = this._contentType;
    if (old === value) {
      return;
    }
    this._contentType = value;
    this._onContentTypeChanged(value);
    this._encodeEnabled = this.__computeIs(value, 'x-www-form-urlencoded');
    this._isJson = this._computeIsJson(value);
  }

  get onvalue() {
    return this._onValue;
  }

  set onvalue(value) {
    if (this._onValue) {
      this.removeEventListener('value-changed', this._onValue);
    }
    if (typeof value !== 'function') {
      this._onValue = null;
      return;
    }
    this._onValue = value;
    this.addEventListener('value-changed', this._onValue);
  }

  constructor() {
    super();
    this._contentTypeHandler = this._contentTypeHandler.bind(this);
    this._resizeHandler = this._resizeHandler.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('content-type-changed', this._contentTypeHandler);
    this.addEventListener('iron-resize', this._resizeHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('content-type-changed', this._contentTypeHandler);
    this.removeEventListener('iron-resize', this._resizeHandler);
  }

  firstUpdated() {
    this.refresh();
    if (this.contentType) {
      this._onContentTypeChanged(this.contentType);
    }
    if (this.value) {
      this._valueChanged(this.value);
    }
  }

  /**
   * Forces render code-mirror content.
   * Should be used to when the element becomes visible after being hidden.
   */
  refresh() {
    this._editor.refresh();
  }

  /**
   * Changes CodeMirror mode when the content type value is updated.
   *
   * @param {String} ct
   */
  _onContentTypeChanged(ct) {
    const editor = this._editor;
    if (!editor) {
      return;
    }
    this._setupLinter(ct);
    if (!ct) {
      return;
    }
    if (ct.indexOf && ct.indexOf(';') !== -1) {
      ct = ct.substr(0, ct.indexOf(';'));
    }
    this._editor.mode = ct;
  }

  _computeIsJson(ct) {
    return this.__computeIs(ct, '/json');
  }

  __computeIs(ct, needle) {
    if (!ct) {
      return false;
    }
    if (ct.indexOf && ct.indexOf(needle) !== -1) {
      return true;
    }
    return false;
  }

  /**
   * Handler for the `content-type-changed` event. Sets the `contentType` property.
   *
   * @param {CustomEvent} e
   */
  _contentTypeHandler(e) {
    this.contentType = e.detail.value;
  }
  /**
   * Handler for value change.
   * If the element is opened then it will fire change event.
   *
   * @param {String} value
   */
  _valueChanged(value) {
    const editor = this._editor;
    if (this.__editorValueChange || !editor) {
      return;
    }
    editor.value = value;
  }
  /**
   * Called when the editor fires change event
   *
   * @param {CustomEvent} e
   */
  _editorValueChanged(e) {
    e.stopPropagation();
    this.__editorValueChange = true;
    this.value = e.detail.value;
    this.__editorValueChange = false;
  }

  _setupLinter(ct) {
    /* global CodeMirror */
    const editor = this._editor;
    if (this._computeIsJson(ct) && CodeMirror.lint) {
      editor.lint = CodeMirror.lint.json;
      editor.gutters = ['code-mirror-lint', 'CodeMirror-lint-markers'];
    } else {
      editor.lint = false;
      editor.gutters = ['CodeMirror-lint-markers'];
    }
    editor.refresh();
  }
  /**
   * Formats current value as it is a JSON object.
   */
  formatValue() {
    try {
      let value = this.value;
      value = JSON.parse(value);
      value = JSON.stringify(value, null, 2);
      this.value = value;
      this.refresh();
    } catch (e) {
      this.shadowRoot.querySelector('#invalidJsonToast').opened = true;
    }
  }
  /**
   * Minifies JSON value by removing whitespaces.
   */
  minifyValue() {
    try {
      let value = this.value;
      value = JSON.parse(value);
      value = JSON.stringify(value);
      this.value = value;
      this.refresh();
    } catch (e) {
      this.shadowRoot.querySelector('#invalidJsonToast').opened = true;
    }
  }

  _resizeHandler() {
    this.refresh();
  }

  /**
   * URL encodes payload value and resets the same value property.
   * This should be used only for payloads with x-www-form-urlencoded content-type.
   */
  encodeValue() {
    const value = this.encodeUrlEncoded(this.value);
    this.__internalChange = true;
    this.value = value;
    this.__internalChange = false;
  }
  /**
   * URL decodes payload value and resets the same value property.
   * This should be used only for payloads with x-www-form-urlencoded content-type.
   */
  decodeValue() {
    const value = this.decodeUrlEncoded(this.value);
    this.__internalChange = true;
    this.value = value;
    this.__internalChange = false;
  }
}
window.customElements.define('raw-payload-editor', RawPayloadEditor);

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// For each part, remember the value that was last rendered to the part by the
// unsafeHTML directive, and the DocumentFragment that was last set as a value.
// The DocumentFragment is used as a unique key to check if the last value
// rendered to the part was with unsafeHTML. If not, we'll always re-render the
// value passed to unsafeHTML.
const previousValues = new WeakMap();
/**
 * Renders the result as HTML, rather than text.
 *
 * Note, this is unsafe to use with any user-provided input that hasn't been
 * sanitized or escaped, as it may lead to cross-site-scripting
 * vulnerabilities.
 */
const unsafeHTML = directive((value) => (part) => {
    if (!(part instanceof NodePart)) {
        throw new Error('unsafeHTML can only be used in text bindings');
    }
    const previousValue = previousValues.get(part);
    if (previousValue !== undefined && isPrimitive(value) &&
        value === previousValue.value && part.value === previousValue.fragment) {
        return;
    }
    const template = document.createElement('template');
    template.innerHTML = value; // innerHTML casts to string internally
    const fragment = document.importNode(template.content, true);
    part.setValue(fragment);
    previousValues.set(part, { value, fragment });
});

/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const templateCaches$1 = new WeakMap();
/**
 * Enables fast switching between multiple templates by caching the DOM nodes
 * and TemplateInstances produced by the templates.
 *
 * Example:
 *
 * ```
 * let checked = false;
 *
 * html`
 *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
 * `
 * ```
 */
const cache = directive((value) => (part) => {
    if (!(part instanceof NodePart)) {
        throw new Error('cache can only be used in text bindings');
    }
    let templateCache = templateCaches$1.get(part);
    if (templateCache === undefined) {
        templateCache = new WeakMap();
        templateCaches$1.set(part, templateCache);
    }
    const previousValue = part.value;
    // First, can we update the current TemplateInstance, or do we need to move
    // the current nodes into the cache?
    if (previousValue instanceof TemplateInstance) {
        if (value instanceof TemplateResult &&
            previousValue.template === part.options.templateFactory(value)) {
            // Same Template, just trigger an update of the TemplateInstance
            part.setValue(value);
            return;
        }
        else {
            // Not the same Template, move the nodes from the DOM into the cache.
            let cachedTemplate = templateCache.get(previousValue.template);
            if (cachedTemplate === undefined) {
                cachedTemplate = {
                    instance: previousValue,
                    nodes: document.createDocumentFragment(),
                };
                templateCache.set(previousValue.template, cachedTemplate);
            }
            reparentNodes(cachedTemplate.nodes, part.startNode.nextSibling, part.endNode);
        }
    }
    // Next, can we reuse nodes from the cache?
    if (value instanceof TemplateResult) {
        const template = part.options.templateFactory(value);
        const cachedTemplate = templateCache.get(template);
        if (cachedTemplate !== undefined) {
            // Move nodes out of cache
            part.setValue(cachedTemplate.nodes);
            part.commit();
            // Set the Part value to the TemplateInstance so it'll update it.
            part.value = cachedTemplate.instance;
        }
    }
    part.setValue(value);
});

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element that contains methods to transform FormData object
 * into Multipart message and ArrayBuffer
 *
 * ## Example
 *
 * ```html
 * <multipart-payload-transformer form-data="[[formData]]"></multipart-payload-transformer>
 * ```
 *
 * ## Legacy dependencies
 *
 * If targeting legacy browsers add polyfill for Fetch API.
 *
 * @customElement
 * @polymer
 * @memberof LogicElements
 */
class MultipartPayloadTransformer extends LitElement {
  static get properties() {
    return {
      /**
       * A form data object to transform.
       *
       * @type {FormData}
       */
      formData: { type: Object },
      /**
       * Latest generated boundary value for the multipart forms.
       * Each call to `generateMessage()` or `generatePreview()` will
       * generate new content type and therefore boundary value.
       */
      boundary: { type: String },
      /**
       * Latest generated content-type value for the multipart forms.
       * Each call to `generateMessage()` or `generatePreview()` will
       * generate new content type value.
       */
      contentType: { type: String }
    };
  }

  get boundary() {
    return this._boundary;
  }

  set boundary(value) {
    const old = this._boundary;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._boundary = value;
    this.dispatchEvent(new CustomEvent('boundary-changed', {
      detail: {
        value
      }
    }));
  }

  get contentType() {
    return this._contentType;
  }

  set contentType(value) {
    const old = this._contentType;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._contentType = value;
    this.dispatchEvent(new CustomEvent('contenttype-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Function} Previously registered handler for `boundary-changed` event
   */
  get onboundary() {
    return this['_onboundary-changed'];
  }
  /**
   * Registers a callback function for `boundary-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onboundary(value) {
    this._registerCallback('boundary-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `contenttype-changed` event
   */
  get oncontenttype() {
    return this['_oncontenttype-changed'];
  }
  /**
   * Registers a callback function for `contenttype-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set oncontenttype(value) {
    this._registerCallback('contenttype-changed', value);
  }


  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.setAttribute('aria-hidden', 'true');
  }

  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }
  /**
   * Generates an ArrayBuffer instance from the FormData object.
   *
   * @return {Promise<String>} A resolved promise when produces ArrayBuffer.
   */
  generateMessage() {
    /* global Request */
    const request = new Request('/', {
      method: 'POST',
      body: this.formData
    });
    const ct = request.headers.get('content-type');
    this._processContentType(ct);
    if (!request.arrayBuffer) {
      return Promise.reject(new Error('Your browser do not support this method.'));
    }
    return request.arrayBuffer();
  }
  /**
   * Informs other ARC elements about content type change.
   * If boundary is added to the content type string then it is reported in
   * a separate event.
   *
   * @param {String} contentType New cintent type.
   */
  _processContentType(contentType) {
    this.contentType = contentType;
    this.dispatchEvent(new CustomEvent('content-type-changed', {
      bubbles: true,
      composed: true,
      detail: {
        value: contentType
      }
    }));
    const match = contentType.match(/boundary=(.*)/);
    if (!match) {
      return;
    }
    const boundary = match[1];
    this.boundary = boundary;
    this.dispatchEvent(new CustomEvent('multipart-boundary-changed', {
      bubbles: true,
      composed: true,
      detail: {
        value: boundary
      }
    }));
  }
  /**
   * Generates a preview of the multipart messgae.
   *
   * @return {Promise<String>} A promise resolved to a string message.
   */
  async generatePreview() {
    if (!this.formData) {
      return Promise.reject(new Error('The FormData property is not set.'));
    }
    const ab = await this.generateMessage();
    return this.arrayBufferToString(ab);
  }
  /**
   * Convert ArrayBuffer to readable form
   * @param {ArrayBuffer} buffer
   * @return {String} Converted string
   */
  arrayBufferToString(buffer) {
    if (buffer.buffer) {
      // Not a ArrayBuffer, need and instance of AB
      // It can't just get buff.buffer because it will use original buffer if the buff is a slice
      // of it.
      const b = buffer.slice(0);
      buffer = b.buffer;
    }
    if ('TextDecoder' in window) {
      const view = new DataView(buffer);
      const decoder = new TextDecoder('utf-8');
      return decoder.decode(view);
    }
    const array = new Uint8Array(buffer);
    let str = '';
    for (let i = 0; i < array.length; ++i) {
      str += String.fromCharCode(array[i]);
    }
    return str;
  }
  /**
   * Dispatched when a message is generated from the FormData. This operation
   * changes boundary added to the header.
   *
   * @event content-type-changed
   * @param {String} value New value of the content type.
   */
  /**
   * Dispatched when boundary is generated
   *
   * @event multipart-boundary-changed
   * @param {String} value New value of the boundary
   */
}
window.customElements.define('multipart-payload-transformer', MultipartPayloadTransformer);

(function (Prism) {
	Prism.languages.http = {
		'request-line': {
			pattern: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\s(?:https?:\/\/|\/)\S+\sHTTP\/[0-9.]+/m,
			inside: {
				// HTTP Verb
				'property': /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\b/,
				// Path or query argument
				'attr-name': /:\w+/
			}
		},
		'response-status': {
			pattern: /^HTTP\/1.[01] \d+.*/m,
			inside: {
				// Status, e.g. 200 OK
				'property': {
					pattern: /(^HTTP\/1.[01] )\d+.*/i,
					lookbehind: true
				}
			}
		},
		// HTTP header name
		'header-name': {
			pattern: /^[\w-]+:(?=.)/m,
			alias: 'keyword'
		}
	};

	// Create a mapping of Content-Type headers to language definitions
	var langs = Prism.languages;
	var httpLanguages = {
		'application/javascript': langs.javascript,
		'application/json': langs.json || langs.javascript,
		'application/xml': langs.xml,
		'text/xml': langs.xml,
		'text/html': langs.html,
		'text/css': langs.css
	};

	// Declare which types can also be suffixes
	var suffixTypes = {
		'application/json': true,
		'application/xml': true
	};

	/**
	 * Returns a pattern for the given content type which matches it and any type which has it as a suffix.
	 *
	 * @param {string} contentType
	 * @returns {string}
	 */
	function getSuffixPattern(contentType) {
		var suffix = contentType.replace(/^[a-z]+\//, '');
		var suffixPattern = '\\w+/(?:[\\w.-]+\\+)+' + suffix + '(?![+\\w.-])';
		return '(?:' + contentType + '|' + suffixPattern + ')';
	}

	// Insert each content type parser that has its associated language
	// currently loaded.
	var options;
	for (var contentType in httpLanguages) {
		if (httpLanguages[contentType]) {
			options = options || {};

			var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
			options[contentType] = {
				pattern: RegExp('(content-type:\\s*' + pattern + '[\\s\\S]*?)(?:\\r?\\n|\\r){2}[\\s\\S]*', 'i'),
				lookbehind: true,
				inside: {
					rest: httpLanguages[contentType]
				}
			};
		}
	}
	if (options) {
		Prism.languages.insertBefore('http', 'header-name', options);
	}

}(Prism));

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

/**
 * A text form item.
 *
 * If the browser has native support for FormData (and iterators) then it will also render
 * a content type selector for the input field.
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin ValidatableMixin
 */
class MultipartTextFormItem extends ValidatableMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      css`:host {
        display: block;
        flex: 1;
      }

      .multipart-item {
        display: flex;
        flex-direction: column;
        flex: 1;
      }

      .mime-selector {
        position: relative;
      }

      .value-selector {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      api-property-form-item {
        flex: 1;
        margin-left: 12px;
      }

      .mime-selector anypoint-input {
        max-width: 360px;
      }

      .name-field {
        max-width: 360px;
        flex: 1;
      }`
    ];
  }

  render() {
    const {
      hasFormData,
      type,
      name,
      value,
      docsOpened,
      readOnly,
      disabled,
      compatibility,
      outlined,
    } = this;
    const model = this.model || { schema: {} };
    return html`
    <div class="multipart-item">
      ${hasFormData ? html`<div class="mime-selector">
        <anypoint-input
          class="type-field"
          .value="${type}"
          @value-changed="${this._typeHandler}"
          type="text"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          .readOnly="${readOnly}"
          .disabled=${disabled}
        >
          <label slot="label">Content type (Optional)</label>
        </anypoint-input>
      </div>` : undefined}

      <div class="value-selector">
        <anypoint-input
          class="name-field"
          invalidmessage="The name is required"
          required
          autovalidate
          .value="${name}"
          @value-changed="${this._nameHandler}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          .readOnly="${readOnly}"
          .disabled=${disabled}
          >
            <label slot="label">Field name</label>
        </anypoint-input>
        <api-property-form-item
          class="value-field"
          .model="${model}"
          name="${name}"
          .value="${value}"
          @value-changed="${this._valueHandler}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          .readOnly="${readOnly}"
          .disabled=${disabled}
        ></api-property-form-item>
        ${model.hasDescription ? html`<anypoint-icon-button
          class="hint-icon"
          title="Toggle documentation"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          ?disabled="${disabled}"
          @click="${this.toggleDocumentation}">
          <iron-icon icon="arc:help"></iron-icon>
        </anypoint-icon-button>` : undefined}
      </div>
    </div>

    ${docsOpened && model.hasDescription ? html`<div class="docs">
      <arc-marked .markdown="${model.description}">
        <div slot="markdown-html" class="markdown-body"></div>
      </arc-marked>
    </div>` : undefined}`;
  }

  static get properties() {
    return {
      /**
       * Name of this control
       */
      name: { type: String },
      /**
       * Valuie of this control.
       */
      value: { type: String },
      /**
       * A view model.
       */
      model: { type: Object },
      /**
       * True to render documentation (if set in model)
       */
      docsOpened: { type: Boolean },
      /**
       * A content type of the form field to be presented in the Multipart request.
       */
      type: { type: String },
      /**
       * When set it will also renders mime type selector for the input data.
       */
      hasFormData: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean }
    };
  }
  
  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }
  /**
   * Toggles documentation (if available)
   */
  toggleDocumentation() {
    this.docsOpened = !this.docsOpened;
  }

  _getValidity() {
    return !!(this.name && this.value);
  }

  _typeHandler(e) {
    this._changeHandler('type', e);
  }

  _nameHandler(e) {
    this._changeHandler('name', e);
  }

  _valueHandler(e) {
    this._changeHandler('value', e);
  }

  _changeHandler(prop, e) {
    const { value } = e.detail;
    if (this[prop] === value) {
      return;
    }
    this[prop] = value;
    this.dispatchEvent(new CustomEvent(`${prop}-changed`, {
      detail: {
        value
      }
    }));
  }
}
window.customElements.define('multipart-text-form-item', MultipartTextFormItem);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * A file form item.
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin ValidatableMixin
 */
class MultipartFileFormItem extends ValidatableMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      formStyles,
      css`:host {
        display: block;
        flex: 1;
      }

      *[hidden] {
        display: none !important;
      }

      .file-row {
        margin: 8px 0;
      }

      .controls {
        display: flex;
        flex-direction: row;
        align-items: center;
        flex: 1;
      }

      .controls > *:not(:last-child) {
        margin-right: 12px;
      }

      .file-trigger,
      .param-name {
        margin-right: 12px;
      }

      .files-counter-message {
        color: var(--multipart-file-form-item-counter-color, rgba(0, 0, 0, 0.74));
        flex: 1;
        font-size: var(--arc-font-body1-font-size);
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
      }

      .name-field {
        max-width: 360px;
        flex: 1;
      }`
    ];
  }

  render() {
    const {
      name,
      value,
      docsOpened,
      readOnly,
      disabled,
      compatibility,
      outlined,
      _hasFile
    } = this;
    const model = this.model || { };
    return html`
    <div class="file-row">
      <div class="controls">
        <anypoint-input
          class="name-field"
          invalidmessage="The name is required"
          required
          autovalidate
          .value="${name}"
          @value-changed="${this._nameHandler}"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          .readOnly="${readOnly}"
          .disabled=${disabled}
          >
            <label slot="label">Field name</label>
        </anypoint-input>

        <anypoint-button
          emphasis="high"
          @click="${this._selectFile}"
          class="file-trigger"
          ?disabled="${disabled || readOnly}">Choose file</anypoint-button>

        ${_hasFile ?
          html`<span
          class="files-counter-message">
            ${value.name} (${value.size} bytes)
          </span>` : undefined}

        ${model.hasDescription ? html`<anypoint-icon-button
          class="hint-icon"
          title="Toggle documentation"
          ?outlined="${outlined}"
          ?compatibility="${compatibility}"
          ?disabled="${disabled}"
          @click="${this.toggleDocumentation}">
          <iron-icon icon="arc:help"></iron-icon>
        </anypoint-icon-button>` : undefined}
      </div>

      ${docsOpened && model.hasDescription ? html`<div class="docs">
        <arc-marked .markdown="${model.description}">
          <div slot="markdown-html" class="markdown-body"></div>
        </arc-marked>
      </div>` : undefined}
    </div>

    <input type="file" hidden @change="${this._fileObjectChanged}" accept="${this._computeAccept(model)}">`;
  }


  static get properties() {
    return {
      /**
       * Computed value, true if the control has a file.
       */
      _hasFile: { type: Boolean },
      /**
       * Name of this control
       */
      name: { type: String },
      /**
       * Valuie of this control.
       */
      value: { type: String },
      /**
       * A view model.
       */
      model: { type: Object },
      /**
       * True to render documentation (if set in model)
       */
      docsOpened: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._value = value;
    this._hasFile = this._computeHasFile(value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * Toggles documentation (if available)
   */
  toggleDocumentation() {
    this.docsOpened = !this.docsOpened;
  }

  _getValidity() {
    return !!(this.name && this.value instanceof Blob);
  }
  /**
   * Tests if current value is a type of `Blob`.
   *
   * @param {String|Blob|File|undefined} value Value to test
   * @return {Boolean}
   */
  _computeHasFile(value) {
    return !!(value && value instanceof Blob);
  }

  /**
   * A handler to choose file button click.
   * This function will find a proper input[type="file"] and programatically click on it to open
   * file dialog.
   */
  _selectFile() {
    const file = this.shadowRoot.querySelector('input[type="file"]');
    file.click();
  }

  /**
   * A handler to file change event for input[type="file"].
   * This will update files array for corresponding `this.filesList` array object.
   *
   * @param {Event} e
   */
  _fileObjectChanged(e) {
    const [file] = e.target.files;
    this.value = file;
  }
  /**
   * Computes the `accept`attribute for file input.
   *
   * @param {Object} model
   * @return {String}
   */
  _computeAccept(model) {
    if (!model) {
      return;
    }
    let types;
    if (model.fileTypes && model.fileTypes.length && typeof model.fileTypes[0] === 'string') {
      types = model.fileTypes;
    } else if (model.fixedFacets && model.fixedFacets.fileTypes && model.fixedFacets.fileTypes.length) {
      types = model.fixedFacets.fileTypes;
    }
    if (types) {
      return types.join(',');
    }
  }

  _nameHandler(e) {
    const { value } = e.detail;
    this.name = value;
    this.dispatchEvent(new CustomEvent('name-changed', {
      detail: {
        value
      }
    }));
  }
}
window.customElements.define('multipart-file-form-item', MultipartFileFormItem);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
let hasFormDataSupport;
try {
  const fd = new FormData();
  fd.append('test', new Blob(['.'], {type: 'image/jpg'}), 'test.jpg');
  hasFormDataSupport = ('entries' in fd);
} catch (e) {
  /* istanbul ignore next  */
  hasFormDataSupport = false;
}
/**
 * Multipart payload editor for ARC/API Console body editor.
 *
 * On supported browsers (full support for FormData, Iterator and ArrayBuffer) it will render a
 * UI controls to generate payload message preview.
 *
 * It produces a FormData object that can be used in XHR / Fetch or transformed to ArrayBuffer to be
 * used in socket connection.
 *
 * ### Example
 * ```html
 * <multipart-payload-editor value="{{form}}"></multipart-payload-editor>
 * ```
 *
 * ## Data model from FormData
 *
 * The element creates a data model for the form view from FormData object.
 * The limitation of this solution is that the information about initial part type
 * is lost. In case when the user specified the part as a text part but also added
 * part content type it will be recognized as the file part.
 *
 * Note: this only works in browsers that support full FormData spec which rules
 * out any Microsoft product. **You have to include polyfills for the FormData.**
 *
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin ValidatableMixin
 * @appliesMixin ApiFormMixin
 * @memberof ApiComponents
 */
class MultipartPayloadEditor extends ApiFormMixin(ValidatableMixin(LitElement)) {
  static get styles() {
    return [
      styles$1,
      formStyles,
      css`:host {
        display: block;
      }

      [hidden] {
        display: none !important;
      }

      .form-item {
        display: flex;
        flex-direction: row;
      }

      .delete-action {
        display: block;
      }

      multipart-text-form-item,
      multipart-file-form-item {
        margin: 8px 0;
      }

      code {
        font-family: var(--arc-font-code-family);
        white-space: pre-line;
        word-break: break-all;
        overflow: auto;
        margin: 20px;
        box-sizing: border-box;
        display: block;
      }

      .editor-actions {
        display: flex;
        flex-direction: row;
        align-items: center;
      }`
    ];
  }

  _previewTemplate() {
    return html`<code>${unsafeHTML(this._messagePreviewCode || '')}</code>`;
  }

  _formItemTemplate(item, index) {
    const {
      readOnly,
      disabled,
      compatibility,
      outlined,
      hasOptional
    } = this;
    const isOptional = this.computeIsOptional(hasOptional, item);
    return html`<div class="form-item" data-file="${item.schema.isFile}" ?data-optional="${isOptional}">
    ${item.schema.isFile ?
      html`<multipart-file-form-item
        data-index="${index}"
        .name="${item.name}"
        @name-changed="${this._nameChangeHandler}"
        .value="${item.value}"
        @value-changed="${this._valueChangeHandler}"
        .model="${item}"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled=${disabled}
        ></multipart-file-form-item>` :
      html`<multipart-text-form-item
        .hasFormData="${hasFormDataSupport}"
        data-index="${index}"
        .name="${item.name}"
        @name-changed="${this._nameChangeHandler}"
        .value="${item.value}"
        @value-changed="${this._valueChangeHandler}"
        .type="${item.contentType}"
        @type-changed="${this._typeChangeHandler}"
        .model="${item}"
        .outlined="${outlined}"
        .compatibility="${compatibility}"
        .readOnly="${readOnly}"
        .disabled=${disabled}></multipart-text-form-item>`}

      <anypoint-icon-button
        title="Remove this parameter"
        aria-label="Press to remove parameter ${item.name}"
        class="action-icon delete-icon"
        data-index="${index}"
        @click="${this._removeCustom}"
        slot="suffix"
        ?disabled="${readOnly || disabled}"
        ?outlined="${outlined}"
        ?compatibility="${compatibility}">
        <iron-icon icon="arc:remove-circle-outline"></iron-icon>
      </anypoint-icon-button>
    </div>`;
  }

  _formTemplate() {
    const { renderOptionalCheckbox, optionalOpened } = this;
    const model = this.model || [];
    return html`
      ${renderOptionalCheckbox ? html`<div class="optional-checkbox">
        <anypoint-checkbox
          class="toggle-checkbox"
          .checked="${optionalOpened}"
          @checked-changed="${this._optionalHanlder}"
          title="Shows or hides optional parameters">Show optional parameters</anypoint-checkbox>
      </div>` : undefined}
      <iron-form>
        <form enctype="multipart/form-data" method="post">
          ${model.map((item, index) => this._formItemTemplate(item, index))}
        </form>
      </iron-form>`;
  }

  render() {
    const {
      previewOpened,
      generatingPreview,
      messagePreview,
      readOnly,
      disabled,
    } = this;

    return html`
    <div class="editor-actions">
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="add-file"
        @click="${this._addFileHandler}"
        ?disabled="${disabled || readOnly || previewOpened}"
        emphasis="medium">Add file part</anypoint-button>
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="add-text"
        @click="${this.addText}"
        ?disabled="${disabled || readOnly || previewOpened}"
        emphasis="medium">Add text part</anypoint-button>
      ${hasFormDataSupport ? html`
        <anypoint-button
          part="content-action-button, code-content-action-button"
          class="action-button"
          data-action="preview"
          emphasis="low"
          toggles
          .active="${previewOpened}"
          @active-changed="${this._previewHandler}"
          aria-label="Press to toggle payload preview"
          title="Toggles generated payload message preview"
          ?disabled="${generatingPreview}">Preview</anypoint-button>
        ${messagePreview && previewOpened ? html`<anypoint-button
          part="content-action-button, code-content-action-button"
          class="action-button"
          data-action="copy"
          emphasis="low"
          @click="${this._copyToClipboard}"
          aria-label="Press to copy payload to clipboard"
          title="Copy payload to clipboard"
          ?disabled="${generatingPreview}">Copy</anypoint-button>` :
          ''}
      ` : undefined}
      <slot name="content-action"></slot>
    </div>
    ${generatingPreview ? html`<p>Generating the preview</p>` : ''}
    <section>
    ${cache(previewOpened ? this._previewTemplate() : this._formTemplate())}
    </section>

    <prism-highlighter></prism-highlighter>
    <multipart-payload-transformer></multipart-payload-transformer>
    <clipboard-copy .content="${messagePreview}"></clipboard-copy>
    <paper-toast horizontal-align="right"></paper-toast>`;
  }


  static get properties() {
    return {
      /**
       * Value of this form
       *
       * @type {FormData}
       */
      value: { type: Object },

      // true if the message preview is opened
      previewOpened: { type: Boolean },
      // true if the transformer is generating the message
      generatingPreview: { type: Boolean },
      // Generated body message preview
      messagePreview: { type: String },
      _messagePreviewCode: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get model() {
    return this._model;
  }

  set model(value) {
    /* istanbul ignore else */
    if (this._sop('model', value)) {
      this._notifyChanged('model', value);
      this.renderEmptyMessage = this._computeRenderEmptyMessage(this.allowCustom, value);
      this.hasOptional = this._computeHasOptionalParameters(this.allowHideOptional, value);
      this._modelChanged(value);
    }
  }

  get value() {
    return this._value;
  }

  set value(value) {
    if (this._sop('value', value)) {
      this._notifyChanged('value', value);
      this._valueChanged(value);
    }
  }

  get previewOpened() {
    return this._previewOpened;
  }

  set previewOpened(value) {
    if (this._sop('previewOpened', value)) {
      this._previewOpenedChanged(value);
    }
  }
  /**
   * @return {Function} Previously registered handler for `model-changed` event
   */
  get onmodel() {
    return this['_onmodel-changed'];
  }
  /**
   * Registers a callback function for `model-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onmodel(value) {
    this._registerCallback('model-changed', value);
  }
  /**
   * @return {Function} Previously registered handler for `value-changed` event
   */
  get onchange() {
    return this['_onvalue-changed'];
  }
  /**
   * Registers a callback function for `value-changed` event
   * @param {Function} value A callback to register. Pass `null` or `undefined`
   * to clear the listener.
   */
  set onchange(value) {
    this._registerCallback('value-changed', value);
  }
  /**
   * Registers an event handler for given type
   * @param {String} eventType Event type (name)
   * @param {Function} value The handler to register
   */
  _registerCallback(eventType, value) {
    const key = `_on${eventType}`;
    if (this[key]) {
      this.removeEventListener(eventType, this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener(eventType, value);
  }

  firstUpdated() {
    if (!this.model) {
      this.addFile();
    }
  }
  /**
   * Overrides `ApiFormMixin.addCustom` to keep current value of `optionalOpened`
   * @param {String} binding
   * @param {Object} opts
   */
  addCustom(binding, opts) {
    const old = this.optionalOpened;
    super.addCustom(binding, opts);
    this.optionalOpened = old;
  }

  _addFileHandler() {
    this.addFile();
    this.optionalOpened = true;
  }
  /**
   * Appends new file form row.
   * This changes `model`.
   */
  addFile() {
    this.addCustom('type', {
      inputLabel: 'Property value'
    });
    const index = this.model.length - 1;
    const item = this.model[index];
    item.schema.isFile = true;
    item.schema.inputType = 'file';
    this.requestUpdate();
  }
  /**
   * Appends empty text field to the form.
   * This changes `model`.
   */
  addText() {
    this.addCustom('type', {
      inputLabel: 'Property value'
    });
    const index = this.model.length - 1;
    const item = this.model[index];
    item.schema.isFile = false;
    item.schema.inputType = 'text';
    /* istanbul ignore else */
    if (hasFormDataSupport) {
      item.contentType = '';
    }
    this.requestUpdate();
  }
  /**
   * Handler for value change.
   * If the element is opened then it will fire change event.
   *
   * @param {FormData} value
   */
  _valueChanged(value) {
    if (this.__internalChange || !(value instanceof FormData)) {
      return;
    }
    const currentModel = this.model;
    if (currentModel) {
      if (!this._modelAndValueMatch(currentModel, value)) {
        this._restoreFormData(value);
        return;
      }
    } else if (value) {
      this._restoreFormData(value);
      return;
    }
  }
  /**
   * Transforms FormData into the data model.
   * Sets new model data.
   *
   * @param {FormData} data Form data to be restored.
   * @return {Promise}
   */
  async _restoreFormData(data) {
    /* istanbul ignore if */
    if (!hasFormDataSupport) {
      return;
    }
    let textParts;
    if (data._arcMeta && data._arcMeta.textParts) {
      textParts = data._arcMeta.textParts;
    }
    const it = data.entries();
    const model = await this._modelForParts(it, textParts);
    this._cancelModelChange = true;
    this.model = model;
    this._cancelModelChange = false;
  }
  /**
   * @param {Iterator} entries
   * @param {Array} textParts
   * @param {Array} result
   * @return {Promise<Array>}
   */
  async _modelForParts(entries, textParts, result) {
    result = result || [];
    const item = entries.next();
    if (item.done) {
      return result;
    }
    const part = item.value;
    let modelItem = {
      name: part[0]
    };
    let restoreBlobValue = false;
    if (typeof part[1] === 'string') {
      modelItem.type = 'text';
    } else {
      if (textParts && textParts.indexOf(modelItem.name) !== -1) {
        modelItem.type = 'text';
        restoreBlobValue = true;
      } else {
        modelItem.type = 'file';
      }
    }
    let value;
    if (restoreBlobValue) {
      value = await this._blobToString(part[1]);
    } else {
      value = {
        result: part[1]
      };
    }
    modelItem.value = value.result;
    modelItem = this._createModelObject(modelItem, {});
    if (!modelItem.schema) {
      modelItem.schema = {};
    }
    modelItem.schema.isFile = modelItem.type === 'file' ? true : false;
    if (modelItem.schema.isFile) {
      modelItem.value = part[1];
    }
    if (restoreBlobValue) {
      modelItem.contentType = value.type;
    }
    result.push(modelItem);
    return this._modelForParts(entries, textParts, result);
  }
  /**
   * It dispatches `api-property-model-build` custom event that is handled by
   * `api-view-model-transformer` to build model item.
   * This assumes that the transformer element is already in the DOM.
   *
   * @param {Object} defs Defaults for model
   * @return {Object} Tranformed object.
   */
  _createModelObject(defs) {
    const e = new CustomEvent('api-property-model-build', {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: defs
    });
    this.dispatchEvent(e);
    return e.detail;
  }
  /**
   * Transforms `Blob` to string.
   *
   * @param {Blob} blob A blob to read.
   * @return {Promise<String>} Read content.
   */
  _blobToString(blob) {
    return new Promise(function(resolve) {
      const reader = new FileReader();
      reader.addEventListener('loadend', function(e) {
        resolve({
          result: e.target.result,
          type: blob.type
        });
      });
      reader.addEventListener('error', function() {
        resolve({
          result: 'Unable to restore part value',
          type: ''
        });
      });
      reader.readAsText(blob);
    });
  }

  /**
   * Tests if current model and FormData object represent the same form data.
   *
   * @param {Array} model Model to test
   * @param {FormData} value Form data with values
   * @return {Boolean} True if model represents data in FormData object
   */
  _modelAndValueMatch(model, value) {
    /* istanbul ignore if */
    if (!hasFormDataSupport) {
      return true;
    }
    if ((!model || !model.length) && value) {
      return false;
    }
    if (!value) {
      return true;
    }
    const modelSize = model.length;
    const it = value.keys();
    const item = it.next();
    while (!item.done) {
      let hasItem = false;
      for (let i = 0; i < modelSize; i++) {
        if (model[i].name === item.value) {
          hasItem = true;
          break;
        }
      }
      if (!hasItem) {
        return false;
      }
    }
    return true;
  }
  // Generates a message and displays highlighted content of the message.
  async _previewOpenedChanged(opened) {
    if (!opened) {
      return;
    }
    if (!this.value) {
      this._toastMessage('Add a valid form items before generating a preview');
      this.previewOpened = false;
      return;
    }
    this.messagePreview = undefined;
    this._messagePreviewCode = undefined;
    const preview = await this._generatePreview();
    if (!preview) {
      this.previewOpened = false;
      return;
    }
    const e = new CustomEvent('syntax-highlight', {
      bubbles: true,
      composed: true,
      detail: {
        code: preview,
        lang: 'http'
      }
    });
    this.dispatchEvent(e);
    this._messagePreviewCode = e.detail.code || preview;
    this.messagePreview = preview;
  }
  /**
   * Renders a message in the paper-toast
   * @param {String} text A message to render
   */
  _toastMessage(text) {
    const toast = this.shadowRoot.querySelector('paper-toast');
    toast.text = text;
    toast.opened = true;
  }
  /**
   * Called when the model chage. Regenerates the FormData object.
   *
   * @param {Array} model
   */
  _modelChanged(model) {
    if (this._cancelModelChange) {
      return;
    }
    this.__internalChange = true;
    const formData = this.createFormData(model);
    this.value = formData;
    this.__internalChange = false;
  }
  /**
   * Generates FormData from the model.
   * For the browsers with full FormData support it will generate Form data object from form
   * element. It means that it will have only basic support.
   * For browsers with full FormData support it will contain all properties (including
   * mime types).
   *
   * @param {Array} model View data model.
   * @return {FormData}
   */
  createFormData(model) {
    if (hasFormDataSupport) {
      return this._getFormData(model);
    } else {
      return this._getLegacyFormData(model);
    }
  }
  /**
   * Generates the FormData object from the model instead of the form.
   *
   * Text form parts with a mime type are added to the form as instance of Blob.
   * Name of such item is added to generated from data's `_arcMeta.textParts`
   * list so the processors can identify them.
   *
   * @param {Array} model The model to generate form data from.
   * @return {FormData|undefined} Form data from model or undefined if model is empty.
   */
  _getFormData(model) {
    if (!model || !model.length) {
      return;
    }
    const fd = new FormData();
    let hasValue = false;
    model.forEach((item) => {
      if (!item.name) {
        return;
      }
      if (item.schema.isFile) {
        if (!item.value) {
          return;
        }
        fd.append(item.name, item.value);
        hasValue = true;
      } else {
        if (item.contentType) {
          const blob = new Blob([item.value], { type: item.contentType });
          fd.append(item.name, blob);
          if (!fd._arcMeta) {
            fd._arcMeta = {};
          }
          if (!fd._arcMeta.textParts) {
            fd._arcMeta.textParts = [];
          }
          fd._arcMeta.textParts.push(item.name);
        } else {
          fd.append(item.name, item.value);
        }
        hasValue = true;
      }
    });
    return hasValue ? fd : undefined;
  }
  /**
   * Returns a FormData object depending if current form has any value.
   * Text items can be empty.
   *
   * @param {Array} model The model to generate form data from.
   * @return {FormData|undefined} Form data from model or undefined if model
   * is empty.
   */
  _getLegacyFormData(model) {
    if (!model || !model.length) {
      return;
    }
    let hasValue = false;
    for (let i = 0, len = model.length; i < len; i++) {
      if (model[i].value) {
        hasValue = true;
      }
    }
    return hasValue ? new FormData(this._getForm().children[0]) : undefined;
  }
  /**
   * Generates a preview message from the FormData object.
   *
   * @return {Promise} A promise fulfilled with the content. Content can be undefined
   * if message couldn't be generated because of lack of support.
   */
  async _generatePreview() {
    this.generatingPreview = true;
    const transformer = this.shadowRoot.querySelector('multipart-payload-transformer');
    transformer.formData = this.value;
    try {
      const message = await transformer.generatePreview();
      this.generatingPreview = false;
      return message;
    } catch (cause) {
      this.generatingPreview = false;
      this._toastMessage(cause.message);
    }
  }
  /**
   * Coppies current response text value to clipboard.
   * @param {Event} e
   */
  _copyToClipboard(e) {
    const button = e.target;
    const copy = this.shadowRoot.querySelector('clipboard-copy');
    if (copy.copy()) {
      button.innerText = 'Done';
    } else {
      button.innerText = 'Error';
    }
    button.disabled = true;
    if ('part' in button) {
      button.part.add('content-action-button-disabled');
      button.part.add('code-content-action-button-disabled');
    }
    setTimeout(() => this._resetCopyButtonState(button), 1000);
    const ev = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: 'Usage',
        action: 'Click',
        label: 'Multipart payload editor clipboard copy',
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }

  _resetCopyButtonState(button) {
    button.innerText = 'Copy';
    button.disabled = false;
    if ('part' in button) {
      button.part.remove('content-action-button-disabled');
      button.part.remove('code-content-action-button-disabled');
    }
  }

  _previewHandler(e) {
    this.previewOpened = e.detail.value;
  }

  _nameChangeHandler(e) {
    this._propertyHandler('name', e);
  }

  _valueChangeHandler(e) {
    this._propertyHandler('value', e);
  }

  _typeChangeHandler(e) {
    this._propertyHandler('contentType', e);
  }

  _propertyHandler(prop, e) {
    const index = Number(e.target.dataset.index);
    /* istanbul ignore if  */
    if (index !== index) {
      return;
    }
    const { value } = e.detail;
    this.model[index][prop] = value;
    this.model = [...this.model];
  }

  _optionalHanlder(e) {
    this.optionalOpened = e.detail.value;
  }
}
window.customElements.define('multipart-payload-editor', MultipartPayloadEditor);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `<files-payload-editor>` A request body editor to add files as a payload.
 *
 * With this element the user can select single file that will be used in the request body.
 *
 * The element can be used in forms when `iron-form` is used. It contains validation methods to
 * validate user input.
 *
 * ### Example
 *
 * ```html
 * <files-payload-editor></files-payload-editor>
 * ```
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin ValidatableMixin
 * @memberof UiElements
 */
class FilesPayloadEditor extends ValidatableMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
      padding: 12px 0;
    }

    .selector {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    .list {
      margin: 0 0.29em;
      display: inline-block;
      margin-top: 12px;
    }

    .file-trigger {
      margin-right: 12px;
    }

    .files-counter-message {
      flex: 1;
      flex-basis: 0.000000001px;
    }

    .file-name {
      margin-left: 8px;
    }

    .card {
      display: flex;
      flex-direction: row;
      align-items: center;
    }`;
  }

  render() {
    const { hasFile, fileSize, fileName } = this;
    return html`<div class="selector">
      <anypoint-button emphasis="high" @click="${this._selectFile}" class="file-trigger">Choose a file</anypoint-button>
      ${hasFile ? html`
        <span class="files-counter-message">1 file selected, ${fileSize} bytes</span>` : undefined}
    </div>

    ${hasFile ? html`<div class="list">
      <div class="card">
        <iron-icon class="file-icon" icon="${this._computeIcon('insert-drive-file')}"></iron-icon>
        <span class="file-name">${fileName}</span>
        <anypoint-icon-button
          class="action-icon delete-icon"
          title="Clear file"
          @click="${this.removeFile}">
          <iron-icon icon="${this._computeIcon('remove-circle-outline')}"></iron-icon>
        </anypoint-icon-button>
      </div>
    </div>` : undefined}
    <input type="file" hidden @change="${this._fileObjectChanged}">`;
  }

  static get properties() {
    return {
      // Computed value, true if the control has files.
      _hasFile: {
        type: Boolean
      },
      /**
       * If set the value will be base64 encoded.
       */
      base64Encode: { type: Boolean },
      // Selected file name
      fileName: { type: String },
      // Selected file size,
      fileSize: { type: Number },
      /**
       * Value produced by this control.
       *
       * @type {Blob}
       */
      value: { },
      /**
       * Icon prefix from the svg icon set. This can be used to replace the set
       * without changing the icon.
       *
       * Defaults to `arc`.
       */
      iconPrefix: { type: String }
    };
  }
  /**
   * @return {Boolean} true if the control has files.
   */
  get hasFile() {
    return this._hasFile || false;
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    if (old === value) {
      return;
    }
    this._value = value;
    this._valueChnaged(value);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }
  /**
   * @return {Function|null} Prefiously registered function, if any.
   */
  get onchange() {
    return this._onchange || null;
  }
  /**
   * Registers a callback function for `value-changed` event.
   * @param {?Function} value A function to register. Pass null to clear.
   */
  set onchange(value) {
    const key = '_onchange';
    if (this[key]) {
      this.removeEventListener('value-changed', this[key]);
    }
    if (typeof value !== 'function') {
      this[key] = null;
      return;
    }
    this[key] = value;
    this.addEventListener('value-changed', value);
  }

  constructor() {
    super();
    this.iconPrefix = 'arc';
  }
  /**
   * Returns a reference to the input element.
   *
   * @return {HTMLElement}
   */
  _getInput() {
    return this.shadowRoot.querySelector('input[type="file"]');
  }

  _valueChnaged(value) {
    if (!value) {
      return;
    }
    if (value instanceof Blob) {
      this.fileName = value.name || 'blob';
      this.fileSize = value.size;
      this._hasFile = true;
      this.latestFile = value;
    } else {
      this._hasFile = false;
    }
    if (!this.fileName || (!this.fileSize && this.fileSize !== 0)) {
      this._updateFileMeta(value);
      return;
    }
    let type;
    if (value.type) {
      type = value.type;
    } else {
      type = 'application/octet-stream';
    }
    setTimeout(() => this._informContentType(type));
  }
  /**
   * Updated `fileName` and `fileSize` from a base64 encoded string value
   *
   * @param {String} value File as base64 string
   */
  _updateFileMeta(value) {
    if (!value || typeof value !== 'string') {
      if (this.latestFile) {
        this.value = this.latestFile;
        return;
      }
      this._hasFile = false;
      return;
    }
    let type;
    if (value.indexOf('data:') === 0) {
      value = value.substr(5);
      const comaIndex = value.indexOf(',');
      type = value.substr(0, value.indexOf(';'));
      value = value.substr(comaIndex + 1);
    }
    let byteChars;
    try {
      byteChars = atob(value);
      this._hasFile = true;
    } catch (e) {
      if (this.latestFile) {
        this.value = this.latestFile;
        return;
      }
      this._hasFile = false;
    }
    type = type || 'application/octet-stream';
    this._informContentType(type);
    this.fileName = 'blob';
    this.fileSize = byteChars ? byteChars.length : -1;
  }
  /**
   * Dispatches `content-type-changed` custom event change when a
   * file is selected.
   *
   * @param {String} ct File content type
   */
  _informContentType(ct) {
    const e = new CustomEvent('content-type-changed', {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: {
        value: ct
      }
    });
    this.dispatchEvent(e);
  }
  /**
   * A handler to choose file button click.
   * This function will find a proper input[type="file"] and programatically click on it to open
   * file dialog.
   */
  _selectFile() {
    const file = this._getInput();
    file.click();
  }

  /**
   * A handler to file change event for input[type="file"].
   * This will update files array for corresponding `this.value` array object.
   *
   * @param {Event} e Input change event
   */
  _fileObjectChanged(e) {
    this._setFileValue(e.target.files[0]);
    this._getInput().blur();
  }
  /**
   * Sets the `value` depending on `base64Encode` option.
   *
   * @param {Blob} file A file to set as a value.
   */
  _setFileValue(file) {
    if (!file) {
      this.value = undefined;
      return;
    }
    if (!this.base64Encode) {
      this.value = file;
      return;
    }
    const reader = new FileReader();
    const context = this;
    reader.addEventListener('load', function() {
      const typed = new Uint8Array(reader.result);
      const result = btoa(String.fromCharCode.apply(null, typed));
      context.value = result;
      context.__informBase64Conversion();
    });
    reader.addEventListener('error', function() {
      context.value = 'Invalid file';
      context.__informBase64Conversion();
    });
    reader.readAsArrayBuffer(file);
  }
  // Send an event when base64 conversion ends
  __informBase64Conversion() {
    const e = new CustomEvent('base64-value-set', {
      bubbles: false,
      cancelable: true
    });
    this.dispatchEvent(e);
  }
  // Overides ValidatableMixin
  _getValidity() {
    return this._computeHasFile(this.value);
  }

  _computeHasFile(file) {
    if (!file) {
      return false;
    }
    const enc = this.base64Encode;
    if (enc) {
      return !!file;
    }
    return file instanceof Blob;
  }
  /**
   * Removed added file from the editor.
   */
  removeFile() {
    this.value = undefined;
    this.fileName = undefined;
    this.fileSize = undefined;
    this._hasFile = (false);
    const file = this._getInput();
    file.value = '';
  }
  /**
   * The element keeps in memory last selected file so it can be restored.
   * This removes reference to the object so it can be GSd.
   */
  clearCache() {
    this.latestFile = undefined;
  }

  _computeIcon(name) {
    let icon = '';
    if (this.iconPrefix) {
      icon = this.iconPrefix + ':';
    }
    return icon + name;
  }
}
window.customElements.define('files-payload-editor', FilesPayloadEditor);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `<content-type-selector>` is an element that provides an UI for selecting common
 * content type values.
 *
 * The element do not renders a value that is not defined on the list.
 * Instead it shows the default label.
 *
 * If the content type is more complex, mening has additional information like
 * `multipart/form-data; boundary=something` then, in this case` only the
 * `multipart/form-data` is taken into the account when computing selected item.
 *
 * The element fires the `content-type-changed` custom event when the user change
 * the value in the drop down container. It is not fired when the change has not
 * beem cause by the user.
 *
 * ### Example
 * ```
 * <content-type-selector></content-type-selector>
 * ```
 *
 * The list of content type values can be extended by setting child `<anypoint-item>`
 * elements with the `data-type` attribute set to content type value.
 *
 * ### Example
 * ```
 * <content-type-selector>
 *    <anypoint-item data-type="application/zip">Zip file</anypoint-item>
 *    <anypoint-item data-type="application/7z">7-zip file</anypoint-item>
 * </content-type-selector>
 * ```
 *
 * ### Listening for content type change event
 *
 * By default the element listens for the `content-type-changed` custom event on
 * global `window` object. This can be controlled by setting the `eventsTarget`
 * property to an element that will be used as an event listeners target.
 * This way the application can scope events accepted by this element.
 *
 * This will not work for events dispatched on this element. The scoped element
 * should handle `content-type-changed` custom event and stop it's propagation
 * if appropriate.
 *
 * Once the `content-type-changed` custom event it changes value of current
 * content type on this element unless the event has been canceled.
 *
 * ### Styling
 *
 * The element support styles for `anypoint-dropdown-menu`, `anypoint-listbox` and `anypoint-item`
 *
 * @demo demo/index.html
 * @memberof UiElements
 * @appliesMixin EventsTargetMixin
 */
class ContentTypeSelector extends EventsTargetMixin(LitElement) {
  static get styles() {
    return css`
      :host {
        display: inline-block;
        margin: 12px 8px;
        height: 56px;
      }

      :host([legacy]),
      :host([nolabelfloat]) {
        height: 40px;
      }

      anypoint-dropdown-menu {
        margin: 0;
      }
    `;
  }

  render() {
    const { readOnly, disabled, legacy, outlined, noLabelFloat } = this;
    return html`
      <anypoint-dropdown-menu
        ?noLabelFloat="${noLabelFloat}"
        aria-label="Select request body content type"
        aria-expanded="false"
        .outlined="${outlined}"
        .legacy="${legacy}"
        .readOnly="${readOnly}"
        .disabled="${disabled}"
        @opened-changed="${this._handleDropdownOpened}"
      >
        <label slot="label">Body content type</label>
        <anypoint-listbox
          slot="dropdown-content"
          @iron-select="${this._contentTypeSelected}"
          .selected="${this.selected}"
          .disabled="${disabled}"
          selectable="[data-type]"
        >
          <anypoint-item .legacy="${legacy}" data-type="application/json">application/json</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="application/xml">application/xml</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="application/atom+xml">application/atom+xml</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="multipart/form-data">multipart/form-data</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="multipart/alternative">multipart/alternative</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="multipart/mixed">multipart/mixed</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="application/x-www-form-urlencoded"
            >application/x-www-form-urlencoded</anypoint-item
          >
          <anypoint-item .legacy="${legacy}" data-type="application/base64">application/base64</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="application/octet-stream"
            >application/octet-stream</anypoint-item
          >
          <anypoint-item .legacy="${legacy}" data-type="text/plain">text/plain</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="text/css">text/css</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="text/html">text/html</anypoint-item>
          <anypoint-item .legacy="${legacy}" data-type="application/javascript">application/javascript</anypoint-item>
          <slot name="item"></slot>
        </anypoint-listbox>
      </anypoint-dropdown-menu>
    `;
  }

  static get properties() {
    return {
      /**
       * A value of a Content-Type header.
       */
      contentType: { type: String },
      /**
       * Index of currently selected item.
       */
      selected: { type: Number },
      /**
       * Passes the value to the dropdown element
       */
      noLabelFloat: { type: Boolean, reflect: true },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean, reflect: true },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean }
    };
  }

  get contentType() {
    return this._contentType;
  }

  set contentType(value) {
    const old = this._contentType;
    if (old === value) {
      return;
    }
    // no need calling requestUpdate
    this._contentType = value;
    this.dispatchEvent(
      new CustomEvent('contenttype-changed', {
        detail: {
          value
        }
      })
    );
    this._contentTypeChanged(value);
  }

  get oncontenttypechanged() {
    return this._oncontenttypechanged;
  }

  set oncontenttypechanged(value) {
    if (this._oncontenttypechanged) {
      this.removeEventListener('contenttype-changed', this._oncontenttypechanged);
    }
    if (typeof value !== 'function') {
      this._oncontenttypechanged = null;
      return;
    }
    this._oncontenttypechanged = value;
    this.addEventListener('contenttype-changed', this._oncontenttypechanged);
  }

  constructor() {
    super();
    this._contentTypeHandler = this._contentTypeHandler.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('content-type-changed', this._contentTypeHandler);
  }

  _detachListeners(node) {
    node.removeEventListener('content-type-changed', this._contentTypeHandler);
  }

  firstUpdated() {
    this._contentTypeChanged(this.contentType);
  }
  /**
   * Handles change of content type value
   *
   * @param {String} contentType New value
   */
  _contentTypeChanged(contentType) {
    this.__cancelSelectedEvents = true;
    if (!contentType) {
      this.selected = undefined;
      this.__cancelSelectedEvents = false;
      return;
    }
    const index = contentType.indexOf(';');
    if (index > 0) {
      contentType = contentType.substr(0, index);
    }
    contentType = contentType.toLowerCase();
    const supported = this.__getDropdownChildrenTypes();
    const selected = supported.findIndex((item) => item.toLowerCase() === contentType);
    if (selected !== -1) {
      this.selected = selected;
    } else {
      this.selected = undefined;
    }
    this.__cancelSelectedEvents = false;
  }

  /**
   * If the event comes from different source then this element then it
   * updates `contentType` value.
   *
   * @param {CustomEvent} e
   */
  _contentTypeHandler(e) {
    if (e.defaultPrevented || e.composedPath()[0] === this) {
      return;
    }
    const ct = e.detail.value;
    if (ct !== this.contentType) {
      this.contentType = ct;
    }
  }
  /**
   * When chanding the editor it mey require to also change the content type header.
   * This function updates Content-Type.
   *
   * @param {CustomEvent} e
   */
  _contentTypeSelected(e) {
    if (this.__cancelSelectedEvents) {
      return;
    }
    const selected = e.target.selected;
    if (this.selected !== selected) {
      this.selected = selected;
    }
    const ct = e.detail.item.dataset.type;
    if (this.contentType !== ct) {
      this.__cancelSelectedEvents = true;
      this.dispatchEvent(
        new CustomEvent('content-type-changed', {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: {
            value: ct
          }
        })
      );
      this.contentType = ct;
      this.__cancelSelectedEvents = false;
    }
  }
  /**
   * Creates a list of all content types added to this element.
   * This includes pre-existing onces and any added to loght DOM.
   *
   * @return {Array} Array of ordered content types (values of the
   * `data-type` attribute).
   */
  __getDropdownChildrenTypes() {
    let children = Array.from(this.shadowRoot.querySelectorAll('anypoint-listbox anypoint-item'));
    const slot = this.shadowRoot.querySelector('slot[name="item"]');
    if (!slot) {
      return [];
    }
    const lightChildren = slot.assignedNodes();
    children = children.concat(lightChildren);
    const result = [];
    children.forEach((item) => {
      if (!item.dataset || !item.dataset.type) {
        return;
      }
      result[result.length] = item.dataset.type;
    });
    return result;
  }

  _handleDropdownOpened(e) {
    e.target.setAttribute('aria-expanded', String(e.target.opened));
  }
  /**
   * Dispatched when selected value changes
   *
   * @event content-type-changed
   * @param {String} value New value of the content type.
   */
}
window.customElements.define('content-type-selector', ContentTypeSelector);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * Adds AMF support to body editor.
 *
 * This mixin's only purpose is to keep AMF support separated from the
 * body editor code so it's clearer to read it.
 *
 * @polymer
 * @mixinFunction
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 * @param {Class} base
 * @return {Class}
 */
const ApiBodyEditorAmfOverlay = (base) => class extends AmfHelperMixin(base) {
  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * AMF json/ld model for body.
       * When set it resets editor settings and transform it to work with
       * data types defined in AMF only.
       * @type {Object}
       */
      amfBody: { type: Object },
      // Computed final model for payload.
      _effectiveModel: { type: Object },
      /**
       * List of supported mime types by this endpoint.
       * This information is read from AMF data model.
       */
      _mimeTypes: { type: Array },
      /**
       * Computed value.
       * It's `true` when the endpint supports single mime type.
       * In this case it won't render type selector.
       *
       * @type {Object}
       */
      _singleMimeType: { type: Boolean },

      _panelModel: { type: Object }
    };
  }

  get _effectiveModel() {
    return this.__effectiveModel;
  }

  set _effectiveModel(value) {
    const old = this.__effectiveModel;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__effectiveModel = value;
    if (value) {
      this._updatePanelAmf(this.contentType);
    }
  }

  get amfBody() {
    return this._amfBody;
  }

  set amfBody(value) {
    const old = this._amfBody;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.value = '';
    this._amfBody = value;
    this.__amfChanged();
  }

  firstUpdated() {
    if (this.__effectiveModel) {
      this._updatePanelAmf(this.contentType);
    }
  }

  _contentTypeChanged(contentType) {
    if (this._effectiveModel) {
      this._updatePanelAmf(contentType);
    }
  }
  /**
   * Overrides `AmfHelperMixin.__amfChanged`
   */
  __amfChanged() {
    if (this.__bodyChangeDebouncer) {
      return;
    }
    this.__bodyChangeDebouncer = true;
    setTimeout(() => {
      this.__bodyChangeDebouncer = false;
      this.__processAmfData(this.amfBody);
    });
  }
  /**
   * A handler for `amfBody` property change.
   * Resets `mediaTypes` property as defined in the model.
   *
   * @param {Array|Object} bodyShape Passed model
   */
  __processAmfData(bodyShape) {
    this._effectiveModel = undefined;
    if (!bodyShape || (bodyShape instanceof Array && !bodyShape.length)) {
      // Clears view model from the value.
      this._panelModel = undefined;
      return;
    }

    bodyShape = this._ensurePayloadModel(bodyShape);
    if (!bodyShape) {
      this._panelModel = undefined;
      return;
    }
    this._updateAmfMediaTypes(bodyShape);
    this._selectDefaultMediaType(bodyShape);
    this._effectiveModel = bodyShape;
  }

  /**
   * Ensures that the passed model is an array of
   * `http://raml.org/vocabularies/http#Payload`
   * in the AMF vocabulary.
   * The element accepts `http://www.w3.org/ns/hydra/core#Operation`,
   * `http://raml.org/vocabularies/http#Request` or array of
   * `http://raml.org/vocabularies/http#Payload` definitions.
   * It selectes the array from the model.
   *
   * @param {Array|Object} model Passed model
   * @return {Array|undefined} Payload model of undefined if the model
   * is invalid for this element.
   */
  _ensurePayloadModel(model) {
    if (model instanceof Array) {
      if (this._hasType(model[0], this.ns.raml.vocabularies.http + 'Payload')) {
        return model;
      }
      model = model[0];
    }
    if (!this._hasType(model, this.ns.w3.hydra.core + 'Operation')) {
      return;
    }
    const opKey = this._getAmfKey(this.ns.w3.hydra.core + 'expects');
    model = model[opKey];
    if (model instanceof Array) {
      model = model[0];
    }
    if (!this._hasType(model, this.ns.raml.vocabularies.http + 'Request')) {
      return;
    }
    const pKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'payload');
    return this._ensureArray(model[pKey]);
  }

  /**
   * Creates a list of media types supported by the endpoint as defined in
   * API spec file.
   * @param {Array} model List of `Payload` definitions
   */
  _updateAmfMediaTypes(model) {
    this._mimeTypes = undefined;
    const ns = this.ns.raml.vocabularies;
    const key = ns.http + 'mediaType';
    const mediaTypes = model.map((item) => this._getValue(item, key));
    this._mimeTypes = mediaTypes;
    this._singleMimeType = mediaTypes && mediaTypes.length === 1;
  }
  /**
   * Sets a content type property based on AMF mode's available options.
   * It sets the first defined media type in the model.
   *
   * This function **always** triggers the change by clearing `contentType`
   * first and then assigning new value.
   *
   * If the AMF model is a file model then it sets `fileAccept` property
   *
   * @param {Array} model List of `Payload` definitions
   */
  _selectDefaultMediaType(model) {
    const types = this._mimeTypes;
    if (!types || !types[0]) {
      return;
    }
    const ns = this.ns.raml.vocabularies;
    // Types corresponds to model array in order.
    const schemaKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let shape = model[0][schemaKey];
    if (shape instanceof Array) {
      shape = shape[0];
    }
    // this.contentType = undefined;
    let ct;
    if (this._hasType(shape, ns.shapes + 'FileShape')) {
      this.fileAccept = types;
      ct = 'application/octet-stream';
    } else {
      if (this.fileAccept) {
        this.fileAccept = undefined;
      }
      const index = types.indexOf(this.contentType);
      ct = index === -1 ? types[0] : types[index];
    }
    this.contentType = ct;
    this._notifyContentTypeChange(ct);
  }

  _updatePanelAmf(contentType) {
    if (!contentType) {
      return;
    }
    const [payload, schema] = this._schemaForMedia(contentType);
    if (!schema) {
      return;
    }
    this._updatePanelModel(contentType, schema);
    this._updatePanelValue(contentType, payload);
  }

  _schemaForMedia(mediaType) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'mediaType');
    for (let i = 0, len = this._effectiveModel.length; i < len; i++) {
      const payload = this._effectiveModel[i];
      let itemMedia = payload[key];
      if (!itemMedia) {
        continue;
      }
      if (itemMedia instanceof Array) {
        itemMedia = itemMedia[0];
      }
      if (typeof itemMedia !== 'string') {
        itemMedia = itemMedia['@value'];
      }
      if (itemMedia === mediaType) {
        const sKey = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
        let schema = payload[sKey];
        if (schema instanceof Array) {
          schema = schema[0];
        }
        this._resolve(payload);
        this._resolve(schema);
        return [payload, schema];
      }
    }
    return [];
  }
  /**
   * Tests if the panel that supports given content-type supports data model.
   * XML and JSON do not use view data model to render the view.
   * @param {String} contentType A content type value to test
   * @return {Boolean} True if the content type's panel support data model
   */
  _typeHasModel(contentType) {
    const allowed = ['application/x-www-form-urlencoded', 'multipart/form-data'];
    return allowed.indexOf(contentType) !== -1;
  }

  /**
   * Updates view model on panels that support the model.
   *
   * @param {String} contentType Current content type
   * @param {Object} schema A schema for current payload.
   */
  _updatePanelModel(contentType, schema) {
    const node = this.shadowRoot.querySelector('api-view-model-transformer');
    if (!node || !this._typeHasModel(contentType)) {
      return;
    }
    if (!node.amf) {
      node.amf = this.amf;
    }
    let data;
    this._resolve(schema);
    if (this._hasType(schema, this.ns.raml.vocabularies.shapes + 'UnionShape')) {
      data = this._getUnionObjectProperties(schema);
    } else if (this._hasType(schema, this.ns.w3.shacl.name + 'NodeShape')) {
      const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
      data = this._ensureArray(schema[pKey]);
    }
    if (!data) {
      // It could be an array but it doesn't make any sens with this
      // media types.
      return;
    }
    const model = node.computeViewModel(data);
    this._panelModel = model;
  }
  /**
   * To simplify things, this searches for first **object** from the union type
   * definition and returns its properties.
   *
   * The component do not offer an UI to selected union type.
   *
   * @param {Object} schema Payload's schema definition
   * @return {Array<Object>|undefined} Properies of first object, if any.
   */
  _getUnionObjectProperties(schema) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.shapes + 'anyOf');
    const list = this._ensureArray(schema[key]);
    if (!list) {
      return;
    }
    const pKey = this._getAmfKey(this.ns.w3.shacl.name + 'property');
    for (let i = 0, len = list.length; i < len; i++) {
      let item = list[i];
      if (item instanceof Array) {
        item = item[0];
      }
      this._resolve(item);
      if (this._hasType(item, this.ns.w3.shacl.name + 'NodeShape')) {
        item = this._resolve(item);
        const data = this._ensureArray(item[pKey]);
        if (data) {
          return data;
        }
      }
    }
  }
  /**
   * Updates panel value depending on examples or type schema availability.
   *
   * @param {String} type Current content type
   * @param {Object} schema A schema for current payload.
   */
  _updatePanelValue(type, schema) {
    const node = this.shadowRoot.querySelector('api-example-generator');
    if (!node) {
      return;
    }
    if (!node.amf) {
      node.amf = this.amf;
    }
    const examples = node.generatePayloadExamples(schema, type, {});
    if (!examples) {
      return;
    }
    for (let i = 0, len = examples.length; i < len; i++) {
      const item = examples[i];
      if (typeof item.value !== 'undefined') {
        this.value = item.value;
        return;
      }
      if (item.values) {
        this.value = item.values[0].value;
        return;
      }
    }
  }
};

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

/**
 * `api-body-editor`
 * Renders different types of body editors. It works with AMF data model
 * but can be used separately.
 *
 * ## AMF support
 *
 * The element supports [AMF](https://github.com/mulesoft/amf/)
 * `json-ld` model. The model can be generated from OAS or RAML spec by
 * default and other specs with appropriate plugin.
 *
 * The element accepts `http://www.w3.org/ns/hydra/core#Operation`,
 * `http://raml.org/vocabularies/http#Request` or array of
 * `http://raml.org/vocabularies/http#Payload` definitions in AMF
 * vocabulary.
 *
 * When AMF model is accepted it alters the UI to render only allowed
 * by the spec content types and therefore editors.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin EventsTargetBehavior
 * @appliesMixin ApiBodyEditorAmfOverlay
 */
class ApiBodyEditor extends ApiBodyEditorAmfOverlay(EventsTargetMixin(LitElement)) {
  static get styles() {
    return [
      formStyles,
      css`:host {
        display: block;
      }

      [hidden] {
        display: none !important;
      }

      .content-actions {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      anypoint-dropdown-menu {
        margin-right: 12px;
      }

      anypoint-dropdown-menu.type {
        margin: 0 12px;
        min-width: 280px;
      }

      .single-ct-label {
        margin: 12px 0px;
        font-size: var(--arc-font-body1-font-size);
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
        color: var(--api-body-editor-single-media-type-label);
      }`
    ];
  }

  render() {
    const {
      aware,
      amf,
      _effectiveModel,
      value
    } = this;
    return html`
    <api-view-model-transformer .amf="${amf}"></api-view-model-transformer>
    <api-example-generator .amf="${amf}"></api-example-generator>
    ${aware ? html`<raml-aware .api-changed="${this._modelHandler}" .scope="${aware}"></raml-aware>` : ''}

    <div class="content-actions">
      ${_effectiveModel ? this._getApiMimeSelector() : this._getDefaultMimeSelector()}
    </div>

    <section class="body-panel">${this.__createBodyPanel()}</section>

    <clipboard-copy .content="${value}"></clipboard-copy>`;
  }

  static get properties() {
    return {
      /**
       * Currently selected editor.
       *
       * - 0 for Raw editor
       * - 1 for Form data
       * - 2 for Multipart
       * - 3 for File
       */
      selected: { type: Number },
      /**
       * A HTTP body.
       *
       * Depending of current editor selection the type can vary.
       *
       * @type {String|FormData|File}
       */
      value: { },
      /**
       * When set it attempts to run associated code mirror mode
       * (raw editor).
       * This element listens for the `content-type-changed` event and when
       * handled it will automatically update content type and `mode`.
       */
      contentType: { type: String },
      // Computed value, if set then raw text input is hidden
      noTextInput: { type: Boolean },
      // Computed value, if set then form data input is hidden
      noFormData: { type: Boolean },
      // Computed value, if set then multipart input is hidden
      noMultipart: { type: Boolean },
      // Computed value, if set then file input is hidden
      noFile: { type: Boolean },
      // Computed value, true if the editor type selector is hidden.
      _editorSelectorHidden: { type: Boolean },
      /**
       * If set it computes `hasOptional` property and shows checkbox in the
       * form to show / hide optional properties.
       */
      allowHideOptional: { type: Boolean },
      /**
       * If set, enable / disable param checkbox is rendered next to each
       * form item.
       */
      allowDisableParams: { type: Boolean },
      /**
       * When set, renders "add custom" item button.
       * If the element is to be used withouth AMF model this should always
       * be enabled. Otherwise users won't be able to add a parameter.
       */
      allowCustom: { type: Boolean },
      /**
       * Renders items in "narrow" view
       */
      narrow: { type: Boolean },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * Renders line number on "raw" editor.
       * @type {Object}
       */
      lineNumbers: { type: Boolean }
    };
  }

  /**
   * @return {HTMLElement} Currently rendered body panel.
   */
  get currentPanel() {
    const selector = '[data-bodypanel]';
    return this.shadowRoot.querySelector(selector);
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    /* istanbul ignore if */
    if (old === value || isNaN(value)) {
      return;
    }
    this._selected = value;
    this.requestUpdate('selected', old);
    this._selectedChanged(value, old);
  }

  get value() {
    return this._value;
  }

  set value(value) {
    const old = this._value;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._value = value;
    this.requestUpdate('value', old);
    this.dispatchEvent(new CustomEvent('value-changed', {
      detail: {
        value
      }
    }));
  }

  get contentType() {
    return this._contentType;
  }

  set contentType(value) {
    const old = this._contentType;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._contentType = value;
    this.requestUpdate('contentType', old);
    this._contentTypeChanged(value, old);
  }

  /**
   * @constructor
   */
  constructor() {
    super();
    this._contentTypeHandler = this._contentTypeHandler.bind(this);
    this._payloadKeyDown = this._payloadKeyDown.bind(this);

    this.selected = 0;
    this.value = '';
  }

  _attachListeners(node) {
    node.addEventListener('content-type-changed', this._contentTypeHandler);
    this.addEventListener('keydown', this._payloadKeyDown);
  }

  _detachListeners(node) {
    node.removeEventListener('content-type-changed', this._contentTypeHandler);
    this.removeEventListener('keydown', this._payloadKeyDown);
  }

  _getApiMimeSelector() {
    const {
      _singleMimeType,
      contentType,
      readOnly,
      disabled,
      legacy,
      outlined,
    } = this;
    if (!_singleMimeType) {
      const item = this._mimeTypes || [];
      return html`<anypoint-dropdown-menu
        class="amf-types"
        .outlined="${outlined}"
        .legacy="${legacy}"
        .readOnly="${readOnly}"
        .disabled="${disabled}">
        <label slot="label">Body content type</label>
        <anypoint-listbox
          slot="dropdown-content"
          attrforselected="data-mime"
          .selected="${contentType}"
          .disabled="${disabled}"
          @selected-changed="${this._typeSelectedChanged}">
          ${item.map((item) => html`<anypoint-item .legacy="${legacy}" data-mime="${item}">${item}</anypoint-item>`)}
        </anypoint-listbox>
      </anypoint-dropdown-menu>`;
    }
  }

  _getDefaultMimeSelector() {
    const {
      contentType,
      eventsTarget,
      _editorSelectorHidden,
      selected,
      noTextInput,
      noFormData,
      noMultipart,
      noFile,
      readOnly,
      disabled,
      legacy,
      outlined
    } = this;
    return html`<content-type-selector
      .contentType="${contentType}"
      .eventsTarget="${eventsTarget}"
      .outlined="${outlined}"
      .legacy="${legacy}"
      .readOnly="${readOnly}"
      .disabled="${disabled}">
        <anypoint-item .legacy="${legacy}" data-type="application/octet-stream">Any file data</anypoint-item>
      </content-type-selector>
      ${!_editorSelectorHidden ? html`<anypoint-dropdown-menu
        class="type"
        .outlined="${outlined}"
        .legacy="${legacy}"
        .readOnly="${readOnly}"
        .disabled="${disabled}">
        <label slot="label">Editor view</label>
        <anypoint-listbox
          slot="dropdown-content"
          .selected="${selected}"
          .disabled="${disabled}"
          @selected-changed="${this._typeSelectionHandler}">
          <anypoint-item
            data-source="raw"
            .legacy="${legacy}"
            ?hidden="${noTextInput}">Raw input</anypoint-item>
          <anypoint-item
            data-source="urlencode"
            .legacy="${legacy}"
            ?hidden="${noFormData}">Form data (www-url-form-encoded)</anypoint-item>
          <anypoint-item
            data-source="multipart"
            .legacy="${legacy}"
            ?hidden="${noMultipart}">Multipart form data (multipart/form-data)</anypoint-item>
          <anypoint-item
            data-source="file"
            .legacy="${legacy}"
            ?hidden="${noFile}">Single file</anypoint-item>
        </anypoint-listbox>
      </anypoint-dropdown-menu>` : ''}
    `;
  }

  __createBodyPanel() {
    switch (this.selected) {
      case 0: return this._createRawPanel();
      case 1: return this._createFormDataPanel();
      case 2: return this._createMultipartPanel();
      case 3: return this._createFilePanel();
    }
  }

  /**
   * Creates instance of Raw body panel in a TemplateResult
   *
   * @return {TemplateResult}
   */
  _createRawPanel() {
    const {
      eventsTarget,
      allowDisableParams,
      allowCustom,
      allowHideOptional,
      contentType,
      narrow,
      readOnly,
      disabled,
      legacy,
      outlined,
      value,
      noDocs,
      lineNumbers
    } = this;
    return html`<raw-payload-editor
      data-type="raw"
      data-bodypanel
      .contentType="${contentType}"
      .value="${value}"
      .allowDisableParams="${allowDisableParams}"
      .allowCustom="${allowCustom}"
      .allowHideOptional="${allowHideOptional}"
      .noDocs="${noDocs}"
      .eventsTarget="${eventsTarget}"
      .narrow="${narrow}"
      .outlined="${outlined}"
      .legacy="${legacy}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      .lineNumbers="${lineNumbers}"
      @value-changed="${this._panelValueChanged}"
    >
    <anypoint-button
      part="content-action-button, code-content-action-button"
      class="action-button"
      data-action="copy"
      emphasis="low"
      slot="content-action"
      @click="${this._copyToClipboard}"
      aria-label="Press to copy payload to clipboard"
      title="Copy payload to clipboard"
    >Copy</anypoint-button>
    </raw-payload-editor>`;
  }
  /**
   * Creates instance of x-www-urlencoded body panel.
   *
   * @return {TemplateResult}
   */
  _createFormDataPanel() {
    const {
      eventsTarget,
      allowDisableParams,
      allowCustom,
      allowHideOptional,
      contentType,
      narrow,
      readOnly,
      disabled,
      legacy,
      outlined,
      value,
      noDocs,
      _panelModel
    } = this;
    return html`<form-data-editor
    data-type="urlencode"
    data-bodypanel
    .value="${value}"
    .model="${_panelModel}"
    .allowDisableParams="${allowDisableParams}"
    .allowCustom="${allowCustom}"
    .allowHideOptional="${allowHideOptional}"
    .noDocs="${noDocs}"
    .eventsTarget="${eventsTarget}"
    .narrow="${narrow}"
    .contentType="${contentType}"
    .outlined="${outlined}"
    .legacy="${legacy}"
    .readOnly="${readOnly}"
    .disabled="${disabled}"
    @value-changed="${this._panelValueChanged}">
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="copy"
        emphasis="low"
        slot="content-action"
        @click="${this._copyToClipboard}"
        aria-label="Press to copy payload to clipboard"
        title="Copy payload to clipboard"
      >Copy</anypoint-button>
    </form-data-editor>`;
  }
  /**
   * Creates instance of File body panel.
   * @return {TemplateResult}
   */
  _createFilePanel() {
    const {
      eventsTarget,
      allowDisableParams,
      allowCustom,
      allowHideOptional,
      contentType,
      narrow,
      value,
      noDocs,
      _panelModel
    } = this;
    return html`<files-payload-editor
    data-type="file"
    data-bodypanel
    .value="${value}"
    .allowDisableParams="${allowDisableParams}"
    .allowCustom="${allowCustom}"
    .allowHideOptional="${allowHideOptional}"
    .noDocs="${noDocs}"
    .eventsTarget="${eventsTarget}"
    .narrow="${narrow}"
    .contentType="${contentType}"
    .model="${_panelModel}"
    @value-changed="${this._panelValueChanged}">
    </files-payload-editor>`;
  }
  /**
   * Creates instance of Multipart body panel.
   * @return {TemplateResult}
   */
  _createMultipartPanel() {
    const {
      eventsTarget,
      allowDisableParams,
      allowCustom,
      allowHideOptional,
      contentType,
      narrow,
      readOnly,
      disabled,
      legacy,
      outlined,
      value,
      noDocs,
      _panelModel
    } = this;
    return html`<multipart-payload-editor
    data-type="formdata"
    data-bodypanel
    .value="${value}"
    .allowDisableParams="${allowDisableParams}"
    .allowCustom="${allowCustom}"
    .allowHideOptional="${allowHideOptional}"
    .noDocs="${noDocs}"
    .eventsTarget="${eventsTarget}"
    .narrow="${narrow}"
    .contentType="${contentType}"
    .outlined="${outlined}"
    .legacy="${legacy}"
    .readOnly="${readOnly}"
    .disabled="${disabled}"
    .model="${_panelModel}"
    @value-changed="${this._panelValueChanged}">
    </multipart-payload-editor>`;
  }
  /**
   * Handler for content type changed event.
   * @param {CustomEvent} e
   */
  _contentTypeHandler(e) {
    if (this.readonly) {
      return;
    }
    this.contentType = e.detail.value;
  }
  /**
   * Handler for content type change.
   * Updates state of the UI depending on AMF model.
   *
   * @param {String} contentType New content type value.
   * @param {String} oldValue Previous value
   */
  _contentTypeChanged(contentType, oldValue) {
    super._contentTypeChanged(contentType, oldValue);
    this._updateEditorsState(contentType, oldValue);
    this._updateEditorSelectorHidden(contentType);
  }

  _hideAllEditors() {
    this.noTextInput = true;
    this.noFormData = true;
    this.noMultipart = true;
    this.noFile = true;
  }

  _renderAllEditors() {
    this.noTextInput = false;
    this.noFormData = false;
    this.noMultipart = false;
    this.noFile = false;
  }
  /**
   * Updates editors availability state depending on content type.
   * @param {String} contentType New content type value.
   * @param {String} oldValue Previous value
   */
  _updateEditorsState(contentType, oldValue) {
    if (!contentType) {
      this._renderAllEditors();
      return;
    }
    const value = this.value;
    this._hideAllEditors();
    if (contentType.indexOf('multipart/form-data') === 0) {
      this.noTextInput = false;
      this.noMultipart = false;
      this.selected = 2;
      return;
    }
    if (oldValue && oldValue.indexOf('multipart/form-data') === 0) {
      this.value = '';
    }
    const blobValue = value instanceof Blob;
    if (contentType === 'application/octet-stream' || (blobValue && oldValue !== undefined)) {
      this.noFile = false;
      this.selected = 3;
      return;
    }
    if (contentType.indexOf('json') !== -1) {
      this.noTextInput = false;
      this.selected = 0;
      return;
    }
    if (contentType === 'application/x-www-form-urlencoded') {
      this.noTextInput = false;
      this.noFormData = false;
      this.selected = 1;
      return;
    }
    this.noTextInput = false;
    this.selected = 0;
  }
  /**
   * Replaces active body editor with new one.
   *
   * @param {Number} selected
   * @param {Number} oldValue
   */
  _selectedChanged(selected, oldValue) {
    if (selected === -1 || selected === undefined || selected === null) {
      this._notifyBodyChanged();
      return;
    }
    if (oldValue !== undefined) {
      this._analyticsEvent('api-body-editor', 'usage-selection', selected);
    }
  }
  /**
   * Notifies application about body change.
   *
   * @param {String|FormData|File|undefined} value Value to notify
   */
  _notifyBodyChanged(value) {
    if (this.readonly) {
      return;
    }
    const e = new CustomEvent('body-value-changed', {
      detail: {
        value: value,
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(e);
  }
  /**
   * Dispatches analytics event.
   *
   * @param {String} category Event category
   * @param {String} action Event action
   * @param {String} label Event label
   */
  _analyticsEvent(category, action, label) {
    const e = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: category,
        action: action,
        label: label
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(e);
  }
  /**
   * Dispatches `send-request` custom event when the user pressed
   * `meta+enter` on Mac or `ctrl+enter` eklsewhere keys combination.
   *
   * @param {CustomEvent} e
   */
  _payloadKeyDown(e) {
    if (e.key !== 'Enter') {
      return;
    }
    if (!e.metaKey && !e.ctrlKey) {
      return;
    }
    this.dispatchEvent(new CustomEvent('send-request', {
      cancelable: true,
      bubbles: true,
      composed: true
    }));
  }
  /**
   * Computes a value of the hidden attribute of the editory type selector.
   * Some content types are supported by only one type of the editor so in
   * this cases the editor should be hidden.
   *
   * @param {String} contentType Current content type.
   */
  _updateEditorSelectorHidden(contentType) {
    let result;
    const value = this.value;
    if (!contentType) {
      result = false;
    } else if (value instanceof Blob) {
      result = true;
    } else if (contentType.indexOf('json') !== -1) {
      result = true;
    } else if (contentType.indexOf('x-www-form-urlencoded') !== -1) {
      result = false;
    } else if (contentType.indexOf('multipart/') !== -1) {
      result = false;
    } else {
      result = true;
    }
    this._editorSelectorHidden = result;
  }
  /**
   * Coppies current response text value to clipboard.
   * @param {Event} e
   */
  _copyToClipboard(e) {
    const button = e.target;
    const copy = this.shadowRoot.querySelector('clipboard-copy');
    if (copy.copy()) {
      button.innerText = 'Done';
    } else {
      button.innerText = 'Error';
    }
    button.disabled = true;
    if ('part' in button) {
      button.part.add('content-action-button-disabled');
      button.part.add('code-content-action-button-disabled');
    }
    setTimeout(() => this._resetCopyButtonState(button), 1000);
    const ev = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: 'Usage',
        action: 'Click',
        label: 'Multipart payload editor clipboard copy',
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }

  _resetCopyButtonState(button) {
    button.innerText = 'Copy';
    button.disabled = false;
    if ('part' in button) {
      button.part.remove('content-action-button-disabled');
      button.part.remove('code-content-action-button-disabled');
    }
  }
  /**
   * Dispatches `content-type-changed` custom event when CT changes by
   * using type selection.
   * @param {String} type Content type value to announce.
   */
  _notifyContentTypeChange(type) {
    if (this.readOnly) {
      return;
    }
    this.dispatchEvent(new CustomEvent('content-type-changed', {
      bubbles: true,
      composed: true,
      detail: {
        value: type
      }
    }));
  }
  /**
   * Notifies about content type change when type selection changes.
   * @param {CustomEvent} e
   */
  _typeSelectedChanged(e) {
    if (!e.detail.value) {
      return;
    }
    this._notifyContentTypeChange(e.detail.value);
  }
  /**
   * A function to be called to refres current state of editor panel.
   * It is only called for the panels that support refreshing (raw editor)
   */
  refreshPanel() {
    if (this.selected === 0) {
      const panel = this.currentPanel;
      if (panel) {
        panel.refresh();
      }
    }
  }

  _modelHandler(e) {
    this.amf = e.detail.value;
  }

  _typeSelectionHandler(e) {
    this.selected = e.detail.value;
  }

  _panelValueChanged(e) {
    const { value } = e.detail;
    this.value = value;
    this._notifyBodyChanged(value);
  }
  /**
   * Fires when the value change.
   *
   * @event body-value-changed
   * @param {String} value Current editor value
   */
  /**
   * Dispatched when the request should be invoked.
   *
   * @event send-request
   */

  /**
   * Dispatched when the user select media type from the list of available types.
   *
   * @event content-type-changed
   * @param {String} value New content type value.
   */
}

window.customElements.define('api-body-editor', ApiBodyEditor);

/**
@license
Copyright 2018 Pawel Psztyc, The ARC team
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An UUID generator.
 *
 * ## Example
 * ```html
 * <uuid-generator auto last-uuid="{{generatedUuid}}"></uuid-generator>
 * ```
 * @customElement
 * @memberof LogicElements
 * @demo demo/index.html
 */
class UuidGenerator extends HTMLElement {
  constructor() {
    super();
    this._lut = this._genLut();
  }

  get auto() {
    return this._auto;
  }
  /**
   * If set it generates uuid and sets it to `lastUuid` once the element
   * is ready.
   *
   * @param {Boolean} value
   */
  set auto(value) {
    if (this._auto === value) {
      return;
    }
    this._auto = value;
    if (value && !this.hasAttribute('auto')) {
      this.setAttribute('auto', '');
    } else if (!value && this.hasAttribute('auto')) {
      this.removeAttribute('auto');
    }
    this._autoChanged(value);
  }

  get lastUuid() {
    return this.__lastUuid;
  }

  set lastUuid(value) {
    this.__lastUuid = value;
    // Compatibility with Polymer.
    this.dispatchEvent(new CustomEvent('last-uuid-changed', {
      detail: {
        value
      }
    }));
  }

  static get observedAttributes() {
    return ['auto'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // Only "auto" is allowed to run this callback
    if (newValue === null) {
      this.auto = false;
    } else {
      this.auto = true;
    }
  }

  connectedCallback() {
    if (!this.hasAttribute('aria-hidden')) {
      this.setAttribute('aria-hidden', 'true');
    }
  }

  _genLut() {
    const result = [];
    for (let i = 0; i < 256; i++) {
      result[i] = (i < 16 ? '0' : '') + (i).toString(16);
    }
    return result;
  }

  _autoChanged(state) {
    if (!state) {
      return;
    }
    this.generate();
  }
  /**
   * Creates an UUID string
   * @return {String} Generated value
   */
  _hash() {
    const d0 = Math.random() * 0xffffffff | 0;
    const d1 = Math.random() * 0xffffffff | 0;
    const d2 = Math.random() * 0xffffffff | 0;
    const d3 = Math.random() * 0xffffffff | 0;
    const lut = this._lut;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] +
      lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' +
      lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] +
      lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +
      lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  }
  /**
   * Generate a RFC4122, version 4 ID. Example:
   * "92329D39-6F5C-4520-ABFC-AAB64544E172"
   * http://stackoverflow.com/a/21963136/1127848
   * @return {String} The UUID string.
   */
  generate() {
    const value = this._hash();
    this.lastUuid = value;
    return this.lastUuid;
  }
}

/**
@license
Copyright 2018 Pawel Psztyc, The ARC team
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
window.customElements.define('uuid-generator', UuidGenerator);

/**
 * `api-request-editor`
 *
 * @customElement
 * @demo demo/index.html
 * @appliesMixin EventsTargetMixin
 * @appliesMixin AmfHelperMixin
 * @memberof ApiElements
 */
class ApiRequestEditor extends AmfHelperMixin(EventsTargetMixin(LitElement)) {
  static get styles() {
    return [
      formStyles,
      css`:host {
        display: block;
      }

      .content {
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .content > * {
        margin: 0;
      }

      [hidden] {
        display: none !important;
      }

      .panel-warning {
        width: 16px;
        height: 16px;
        margin-left: 4px;
        color: var(--error-color, #FF7043);
      }

      .invalid-info {
        color: var(--error-color);
        margin-left: 12px;
      }

      paper-spinner {
        margin-right: 8px;
      }

      .action-bar {
        display: flex;
        flex-direction: row;
        align-items: center;
        margin-top: 8px;
      }

      .url-editor {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      api-url-editor {
        flex: 1;
      }

      .section-title {
        margin: 0.83em 8px;
        letter-spacing: 0.1rem;
        font-size: 20px;
        font-weight: 200;
      }

      .editor-section {
        margin: 8px 0;
      }

      api-body-editor,
      api-headers-editor,
      api-url-params-editor,
      authorization-panel {
        margin: 0;
        padding: 0;
      }

      :host([legacy]) .section-title {
        font-size: 18px;
        font-weight: 400;
        letter-spacing: initial;
      }

      :host([narrow]) .content {
        display: flex;
        flex-direction: columns;
      }

      :host([narrow]) api-url-editor {
        width: auto;
      }`
    ];
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * An `@id` of selected AMF shape. When changed it computes
       * method model for the selection.
       */
      selected: { type: String },
      /**
       * Hides the URL editor from the view.
       * The editor is still in the DOM and the `urlInvalid` property still will be set.
       */
      noUrlEditor: { type: Boolean },
      /**
       * A base URI for the API. To be set if RAML spec is missing `baseUri`
       * declaration and this produces invalid URL input. This information
       * is passed to the URL editor that prefixes the URL with `baseUri` value
       * if passed URL is a relative URL.
       */
      baseUri: { type: String },
      /**
       * If set it computes `hasOptional` property and shows checkbox in the
       * form to show / hide optional properties.
       */
      allowHideOptional: { type: Boolean },
      /**
       * If set, enable / disable param checkbox is rendered next to each
       * form item.
       */
      allowDisableParams: { type: Boolean },
      /**
       * When set, renders "add custom" item button.
       * If the element is to be used withouth AMF model this should always
       * be enabled. Otherwise users won't be able to add a parameter.
       */
      allowCustom: { type: Boolean },
      /**
       * API server definition from the AMF model.
       *
       * This value to be set when partial AMF mnodel for an endpoint is passed
       * instead of web api to be passed to the `api-url-data-model` element.
       *
       * Do not set with full AMF web API model.
       */
      server: { type: Object },
      /**
       * Supported protocl versions.
       *
       * E.g.
       *
       * ```json
       * ["http", "https"]
       * ```
       *
       * This value to be set when partial AMF mnodel for an endpoint is passed
       * instead of web api to be passed to the `api-url-data-model` element.
       *
       * Do not set with full AMF web API model.
       */
      protocols: { type: Array },
      /**
       * API version name.
       *
       * This value to be set when partial AMF mnodel for an endpoint is passed
       * instead of web api to be passed to the `api-url-data-model` element.
       *
       * Do not set with full AMF web API model.
       */
      version: { type: String },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean, reflect: true },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
      /**
       * OAuth2 redirect URI.
       * This value **must** be set in order for OAuth 1/2 to work properly.
       */
      redirectUri: { type: String },
      /**
       * If set it will renders the view in the narrow layout.
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * Computed value, true if any of the editors has invalid state.
       */
      invalid: { type: Boolean },
      /**
       * Computed from AMF model for the metod HTTP method name.
       *
       * @type {String}
       */
      _httpMethod: { type: String },
      /**
       * Headers for the request.
       *
       * @type {String|undefined}
       */
      _headers: { type: String },
      /**
       * Body for the request. The type of the body depends on
       * defined in the API media type.7
       *
       * @type {String|FormData|File}
       */
      _payload: { type: String },
      /**
       * Final request URL including settings like `baseUri`, AMF
       * model settings and user provided parameters.
       * This value is always computed by the `api-url-editor` even if it's
       * hidden from the view.
       */
      _url: { type: String },
      /**
       * Current content type.
       *
       * @type {String|undefined}
       */
      _contentType: { type: String },
      /**
       * Computed value of security scheme from selected method.
       *
       * @type {Array<Object>}
       */
      _securedBy: { type: Array },
      /**
       * Computed list of headers in the AMF model
       *
       * @type {Array<Object>}
       */
      _apiHeaders: { type: Array },
      /**
       * Defined by the API payload data.
       *
       * @type {Array<Object>|undefined}
       */
      _apiPayload: { type: Array },
      /**
       * Computed value if the method can carry a payload.
       */
      _isPayloadRequest: { type: Boolean },
      /**
       * Inheritet from the authorization panel state if authorization
       * data is valid.
       */
      _authInvalid: { type: Boolean },
      /**
       * Flag set when the request is being made.
       */
      _loadingRequest: { type: Boolean },

      // Selected by the user auth method (if any)
      _authMethod: { type: String },
      // Current authorization settings.
      _authSettings: { type: Object },
      /**
       * Generated request ID when the request is sent. This value is reported
       * in send and abort events
       */
      _requestId: { type: String },
      /**
       * Request query parameters view model
       * @type {Array<Object>}
       */
      _queryModel: { type: Array },
      /**
       * Request path parameters view model
       * @type {Array<Object>}
       */
      _pathModel: { type: Array },
      /**
       * Computed when URL params editor is invalid.
       */
      _paramsInvalid: { type: Boolean },
      /**
       * Computed when headers editor is invalid.
       */
      _headersInvalid: { type: Boolean },
      /**
       * Validity state of the URL editor
       */
      _urlInvalid: { type: Boolean },

      _endpointUri: { type: String },
      _apiBaseUri: { type: String }
    };
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._selected = value;
    this.requestUpdate('selected', old);
    this._selectedChanged();
  }

  get url() {
    return this._url;
  }

  set url(value) {
    const old = this._url;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._url = value;
    this._urlChanged(value);
  }

  get invalid() {
    return this._invalid;
  }

  set invalid(value) {
    const old = this._invalid;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._invalid = value;
    this._invalidChnaged(value);
    this.requestUpdate('invalid', old);
  }

  get httpMethod() {
    return this._httpMethod;
  }

  get headers() {
    return this._headers;
  }

  get payload() {
    return this._payload;
  }

  get contentType() {
    return this._contentType;
  }

  get securedBy() {
    return this._securedBy;
  }

  get apiHeaders() {
    return this._apiHeaders;
  }

  get apiPayload() {
    return this._apiPayload;
  }

  get isPayloadRequest() {
    return this._isPayloadRequest;
  }

  get authInvalid() {
    return this._authInvalid;
  }

  get loadingRequest() {
    return this._loadingRequest;
  }

  get requestId() {
    return this._requestId;
  }
  /**
   * @constructor
   */
  constructor() {
    super();
    this._authSettingsChanged = this._authSettingsChanged.bind(this);
    this._responseHandler = this._responseHandler.bind(this);
    this._authRedirectChangedHandler = this._authRedirectChangedHandler.bind(this);
  }

  _attachListeners(node) {
    this.addEventListener('authorization-settings-changed', this._authSettingsChanged);
    window.addEventListener('api-response', this._responseHandler);
    node.addEventListener('oauth2-redirect-uri-changed', this._authRedirectChangedHandler);
  }

  _detachListeners(node) {
    this.removeEventListener('authorization-settings-changed', this._authSettingsChanged);
    window.removeEventListener('api-response', this._responseHandler);
    node.removeEventListener('oauth2-redirect-uri-changed', this._authRedirectChangedHandler);
  }
  /**
   * Overrides `AmfHelperMixin.__amfChanged`
   */
  __amfChanged() {
    this._selectedChanged();
  }
  /**
   * Dispatches bubbling and composed custom event.
   * By default the event is cancelable until `cancelable` property is set to false.
   * @param {String} type Event type
   * @param {?any} detail A detail to set
   * @param {?Boolean} cancelable When false the event is not cancelable.
   * @return {CustomEvent}
   */
  _dispatch(type, detail, cancelable) {
    if (typeof cancelable !== 'boolean') {
      cancelable = true;
    }
    const e = new CustomEvent(type, {
      bubbles: true,
      composed: true,
      cancelable,
      detail
    });
    this.dispatchEvent(e);
    return e;
  }

  /**
   * Sends usage google analytics event
   * @param {String} action Action description
   * @param {String} label Event label
   * @return {CustomEvent}
   */
  _sendGaEvent(action, label) {
    return this._dispatch('send-analytics', {
      type: 'event',
      category: 'Request editor',
      action,
      label
    }, false);
  }
  /**
   * Clears the request properties.
   */
  clearRequest() {
    this._url = '';
    this._headers = '';
    this._payload = '';
    const node = this.shadowRoot.querySelector('authorization-panel');
    if (node) {
      node.clear();
    }
    this._dispatch('request-clear-state');
    this._sendGaEvent('Clear request');
  }

  _selectedChanged() {
    const { amf, selected } = this;
    if (!amf || !selected) {
      return;
    }
    const model = this._computeMethodAmfModel(amf, selected);
    if (!model) {
      return;
    }
    this._authInvalid = false;
    this._headersInvalid = false;
    this._paramsInvalid = false;
    this._authSettings = undefined;
    this._authMethod = undefined;
    const method = this._httpMethod = this._getValue(model, this.ns.w3.hydra.core + 'method');
    this._isPayloadRequest = this._computeIsPayloadRequest(method);
    this._securedBy = this._computeSecuredBy(model);
    this._apiHeaders = this. _computeHeaders(model);
    this._apiPayload = this._computeApiPayload(model);
    this._reValidate();
  }

  _computeMethodAmfModel(model, selected) {
    if (!model || !selected) {
      return;
    }
    if (model instanceof Array) {
      model = model[0];
    }
    if (this._hasType(model, this.ns.raml.vocabularies.document + 'Document')) {
      const webApi = this._computeWebApi(model);
      return this._computeMethodModel(webApi, selected);
    }
    const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
    const methods = this._ensureArray(model[key]);
    if (!methods) {
      return;
    }
    for (let i = 0; i < methods.length; i++) {
      if (methods[i]['@id'] === selected) {
        return methods[i];
      }
    }
  }
  /**
   * Computes AMF model for authorization panel.
   *
   * @param {Object} model Current method model.
   * @return {Array|undefined} List of security definitions for the endpoint.
   */
  _computeSecuredBy(model) {
    if (!model) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.security + 'security');
    let data = model[key];
    if (data && !(data instanceof Array)) {
      data = [data];
    }
    return data;
  }
  /**
   * Computes model definition for headers.
   *
   * @param {?Object} model Method model
   * @return {Array|undefined} List of headers or undefined.
   */
  _computeHeaders(model) {
    if (!model) {
      return;
    }
    const expects = this._computeExpects(model);
    if (!expects) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'header');
    let headers = expects[key];
    if (headers && !(headers instanceof Array)) {
      headers = [headers];
    }
    return headers;
  }
  /**
   * Computes value for `apiPayload` property from AMF model for current
   * method.
   *
   * @param {Object} model Operation model.
   * @return {Array<Object>|undefined} Method payload.
   */
  _computeApiPayload(model) {
    if (!model) {
      return;
    }
    const expects = this._computeExpects(model);
    if (!expects) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'payload');
    let payload = expects[key];
    if (payload && !(payload instanceof Array)) {
      payload = [payload];
    }
    return payload;
  }
  /**
   * Computes value for `isPayloadRequest`.
   * Only `GET` and `HEAD` methods are known as ones that can't carry a
   * payload. For any other HTTP method this always returns true.
   *
   * @param {String} method HTTP method value
   * @return {Boolean}
   */
  _computeIsPayloadRequest(method) {
    return ['get', 'head'].indexOf(method) === -1;
  }
  /**
   * Handles send button click.
   * Depending on authorization validity it either sends the
   * request or forces authorization and sends the request.
   */
  _sendHandler() {
    if (this._authInvalid || this._additionalAuth) {
      this.authAndExecute();
    } else {
      this.execute();
    }
  }
  /**
   * To be called when the user want to execute the request but
   * authorization is invalid (missin values).
   * This function brings the auth panel to front and displays error toast
   *
   * TODO: There is a case when the user didn't requested OAuth2 token
   * but provided all the data. This function should check for this
   * condition and call authorization function automatically.
   */
  authAndExecute() {
    this.__requestAuthAwaiting = true;
    const panel = this.shadowRoot.querySelector('authorization-panel');
    let result;
    if (panel) {
      result = panel.forceTokenAuthorization();
    }
    if (!result) {
      const toast = this.shadowRoot.querySelector('#authFormError');
      toast.opened = true;
    }
  }
  /**
   * Executes the request by dispatching `api-request` custom event.
   * The event must be handled by hosting application to ensure transport.
   * Use `advanced-rest-client/xhr-simple-request` component to add logic
   * that uses XHR as a transport.
   *
   * Hosting application also must reset state of `loadingRequest` property
   * once the response is ready. It also can dispatch `api-response`
   * custom event handled by this element to reset state. This is also
   * handled by `xhr-simple-request` component.
   */
  execute() {
    this._loadingRequest = true;
    const request = this.serializeRequest();
    const uuid = this.shadowRoot.querySelector('#uuid').generate();
    this._requestId = uuid;
    request.id = uuid;
    this._dispatch('api-request', request);
    this._sendGaEvent('request-execute', 'true');
  }
  /**
   * Sends the `abort-api-request` custom event to cancel the request.
   * Calling this method befor sending request may have unexpected
   * behavior because `requestId` is only set with `execute()` method.
   */
  abort() {
    this._dispatch('abort-api-request', {
      url: this.url,
      id: this.requestId
    });
    this._sendGaEvent('request-abort', 'true');
    this._loadingRequest = false;
    this._requestId = undefined;
  }
  /**
   * Event handler for abort click.
   */
  _abortRequest() {
    this.abort();
  }
  /**
   * Returns an object with the request properties.
   * The object contains:
   * - `method` (String)
   * - `url` (String)
   * - `headers` (String)
   * - `payload` (String)
   * - `auth` (Object)
   *
   * The `auth` property is optional and is only added to the request if
   * simple `authorization` header will not work. For example NTLM auth
   * method has to be made on a single socket connection (authorization
   * and the request) so it can't be made before the request.
   *
   * The `auth` object contains 2 properties:
   * - `type` (String) the authorization type - one of from the
   * `auth-methods` element
   * - `settings` (Object) Authorization parameters entered by the user.
   * It vary and depends on selected auth method.
   * For example in case of the NTLM it will be: `username`, `password` and
   * `domain`. See `advanced-rest-client/auth-methods` for model descriptions.
   *
   * @return {Object}
   */
  serializeRequest() {
    const result = {
      method: (this._httpMethod || 'get').toUpperCase(),
      url: this._url,
      headers: this._headers || '',
      payload: this._payload,
      queryModel: this._queryModel,
      pathModel: this._pathModel,
      headersModel: this.shadowRoot.querySelector('api-headers-editor').viewModel
    };
    if (this._authMethod && this._authSettings) {
      result.auth = this._authSettings;
      result.authType = this._authMethod;
    }
    return result;
  }
  /**
   * Handler for the `authorization-settings-changed` dispatched by
   * authorization panel. Sets auth settings and executes the request if
   * any pending if valid.
   *
   * @param {CustomEvent} e
   */
  _authSettingsChanged(e) {
    this._authMethod = e.detail.type;
    this._authSettings = e.detail.settings;
    if (e.detail.valid && this.__requestAuthAwaiting) {
      this.__requestAuthAwaiting = false;
      this.execute();
    }
    this._reValidate();
  }
  /**
   * Handler for the `api-response` custom event.
   * Clears the loading state.
   *
   * @param {CustomEvent} e
   */
  _responseHandler(e) {
    if (!e.detail || (e.detail.id !== this.requestId)) {
      return;
    }
    this._loadingRequest = false;
  }
  /**
   * Handler for the `oauth2-redirect-uri-changed` custom event. Changes
   * the `redirectUri` property.
   * @param {CustomEvent} e
   */
  _authRedirectChangedHandler(e) {
    this.redirectUri = e.detail.value;
  }
  /**
   * Dispatches `url-value-changed` event when url value change.
   * @param {String} value
   */
  _urlChanged(value) {
    this._dispatch('url-value-changed', {
      value
    });
  }
  /**
   * Sets `invalid` and `aria-invalid` attributes on the element.
   * @param {Boolean} invalid Current state of ivalid state
   */
  _invalidChnaged(invalid) {
    if (invalid) {
      this.setAttribute('invalid', '');
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('invalid');
      this.removeAttribute('aria-invalid');
    }
  }

  get _sendLabel() {
    return this._additionalAuth ? 'Authorize and send' : 'Send';
  }

  _apiChanged(e) {
    this.amf = e.detail.value;
  }

  _urlHandler(e) {
    this.url = e.detail.value;
  }

  async _endpointUriHandler(e) {
    await this.updateComplete;
    this._endpointUri = e.detail.value;
  }

  async _apiBaseUriHandler(e) {
    await this.updateComplete;
    this._apiBaseUri = e.detail.value;
  }

  async _pathModelHandler(e) {
    await this.updateComplete;
    this._pathModel = e.detail.value;
  }

  async _queryModelHandler(e) {
    await this.updateComplete;
    this._queryModel = e.detail.value;
  }

  async _contentTypeHandler(e) {
    await this.updateComplete;
    this._contentType = e.detail.value;
  }

  _authInvalidChanged(e) {
    this._authInvalid = e.detail.value;
    this._reValidate();
  }

  _paramsInvalidChanged(e) {
    this._paramsInvalid = e.detail.value;
    this._reValidate();
  }

  _headersInvalidChanged(e) {
    this._headersInvalid = e.detail.value;
    this._reValidate();
  }

  _urlInvalidChanged(e) {
    this._urlInvalid = e.detail.value;
    this._reValidate();
  }

  _headersHandler(e) {
    this._headers = e.detail.value;
  }

  _payloadHandler(e) {
    this._payload = e.detail.value;
  }

  async _reValidate() {
    await this.updateComplete;
    const { _authInvalid, _urlInvalid, _paramsInvalid, _headersInvalid, _authMethod, _authSettings } = this;
    const state = !!(_authInvalid || _urlInvalid || _headersInvalid || _paramsInvalid);
    const noOauthToken = _authMethod === 'OAuth 2.0' && (!_authSettings || !_authSettings.accessToken);
    this.invalid = state;
    if (noOauthToken) {
      this._additionalAuth = true;
    } else {
      this._additionalAuth = false;
    }
    this.requestUpdate();
  }

  get _hideParamsEditor() {
    if (this.allowCustom) {
      return false;
    }
    const { _pathModel, _queryModel } = this;
    return (!_pathModel || _pathModel.length === 0) && (!_queryModel || _queryModel.length === 0);
  }

  render() {
    const {
      aware,
      amf,
      baseUri,
      selected,
      server,
      protocols,
      version,
      noUrlEditor,
      eventsTarget,
      redirectUri,
      noDocs,
      narrow,
      allowCustom,
      allowDisableParams,
      allowHideOptional,
      readOnly,
      disabled,
      legacy,
      outlined,
      invalid,

      _endpointUri,
      _apiBaseUri,
      _pathModel,
      _queryModel,
      _securedBy,
      _apiHeaders,
      _isPayloadRequest,
      _apiPayload,
      _loadingRequest,
      _contentType,
      _sendLabel,
      _hideParamsEditor
    } = this;
    return html`
    ${aware ? html`<raml-aware
      .scope="${aware}"
      @api-changed="${this._apiChanged}"></raml-aware>` : ''}

    <api-url-data-model
      @apibaseuri-changed="${this._apiBaseUriHandler}"
      @pathmodel-changed="${this._pathModelHandler}"
      @querymodel-changed="${this._queryModelHandler}"
      @endpointpath-changed="${this._endpointUriHandler}"
      .amf="${amf}"
      .apiUri="${baseUri}"
      .selected="${selected}"
      .server="${ifDefined(server)}"
      .protocols="${ifDefined(protocols)}"
      .version="${ifDefined(version)}"
    ></api-url-data-model>

    <div class="content">
      <div class="url-editor" ?hidden="${noUrlEditor}">
        <api-url-editor
          @value-changed="${this._urlHandler}"
          @invalid-changed="${this._urlInvalidChanged}"
          ?required="${!noUrlEditor}"
          autovalidate
          .baseUri="${_apiBaseUri}"
          .endpointPath="${_endpointUri}"
          .queryModel="${_queryModel}"
          .pathModel="${_pathModel}"
          .eventsTarget="${eventsTarget}"
          .readOnly="${readOnly}"
          .disabled="${disabled}"
          ?outlined="${outlined}"
          ?legacy="${legacy}"
        ></api-url-editor>
      </div>

      <div class="editor-section" ?hidden="${_hideParamsEditor}">
        <api-url-params-editor
          @invalid-changed="${this._paramsInvalidChanged}"
          @urimodel-changed="${this._pathModelHandler}"
          @querymodel-changed="${this._queryModelHandler}"
          .uriModel="${_pathModel}"
          .queryModel="${_queryModel}"
          .noDocs="${noDocs}"
          ?narrow="${narrow}"
          ?allowcustom="${allowCustom}"
          .readOnly="${readOnly}"
          .disabled="${disabled}"
          ?outlined="${outlined}"
          ?legacy="${legacy}"
        ></api-url-params-editor>
      </div>

      <div class="editor-section" ?hidden="${!_apiHeaders}">
        <div role="heading" aria-level="2" class="section-title">Headers</div>
        <api-headers-editor
          @contenttype-changed="${this._contentTypeHandler}"
          @value-changed="${this._headersHandler}"
          @invalid-changed="${this._headersInvalidChanged}"
          .eventsTarget="${eventsTarget}"
          .amf="${amf}"
          .amfHeaders="${_apiHeaders}"
          .noDocs="${noDocs}"
          .isPayload="${_isPayloadRequest}"
          ?narrow="${narrow}"
          .readOnly="${readOnly}"
          .disabled="${disabled}"
          ?outlined="${outlined}"
          ?legacy="${legacy}"
          ?allowcustom="${allowCustom}"
          ?allowDisableParams="${allowDisableParams}"
          ?allowHideOptional="${allowHideOptional}"
          autovalidate
          ></api-headers-editor>
      </div>

      ${_isPayloadRequest && _apiPayload ? html`
        <div class="editor-section">
          <div role="heading" aria-level="2" class="section-title">Body</div>
          <api-body-editor
            @value-changed="${this._payloadHandler}"
            .eventsTarget="${eventsTarget}"
            .amf="${amf}"
            .amfBody="${_apiPayload}"
            ?narrow="${narrow}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            ?outlined="${outlined}"
            ?legacy="${legacy}"
            .contentType="${_contentType}"
            ?allowcustom="${allowCustom}"
            ?allowDisableParams="${allowDisableParams}"
            ?allowHideOptional="${allowHideOptional}"
            linenumbers></api-body-editor>
        </div>` : ''}

      ${_securedBy ? html`
        <div class="editor-section">
          <div role="heading" aria-level="2" class="section-title">Credentials</div>
          <authorization-panel
            .amf="${amf}"
            .eventsTarget="${eventsTarget}"
            .securedBy="${_securedBy}"
            .redirectUri="${redirectUri}"
            .noDocs="${noDocs}"
            .readOnly="${readOnly}"
            .disabled="${disabled}"
            ?outlined="${outlined}"
            ?legacy="${legacy}"
            @invalid-changed="${this._authInvalidChanged}"
          ></authorization-panel>
      </div>` : undefined}

      <div class="action-bar">
        ${_loadingRequest ?
          html`<anypoint-button
            class="send-button abort"
            emphasis="high"
            ?legacy="${legacy}"
            @click="${this._abortRequest}">Abort</anypoint-button>` :
          html`<anypoint-button
            class="send-button"
            emphasis="high"
            ?legacy="${legacy}"
            @click="${this._sendHandler}">${_sendLabel}</anypoint-button>`}
        ${invalid ? html`<span class="invalid-info">Fill in required parameters</span>` : ''}
        <paper-spinner alt="Loading request" .active="${_loadingRequest}"></paper-spinner>
      </div>

      <paper-toast
        text="Authorization for this endpoint is required"
        id="authFormError"
        horizontal-align="right" horizontal-offset="12"></paper-toast>
      <uuid-generator id="uuid"></uuid-generator>
    </div>
    `;
  }
  /**
   * Dispatched when the user requests to send current request.
   *
   * This event can be cancelled.
   *
   * @event api-request
   * @param {String} url The request URL. Can be empty string.
   * @param {String} method HTTP method name. Can be empty.
   * @param {String} headers HTTP headers string. Can be empty.
   * @param {String|File|FormData} payload Message body. Can be undefined.
   * @param {?Object} auth Authorization settings from the auth panel.
   * May be `undefined`.
   * @param {?String} authType Name of the authorization methods. One of
   * `advanced-rest-client/auth-methods`.
   * @param {String} id Generated UUID for the request. Each call of
   * `execute()` function regenerates the `id`.
   * @param {?Array<Object>} queryModel Query parameters data view model
   * @param {?Array<Object>} pathModel URI parameters data view model
   * @param {?Array<Object>} headersModel Headers data view model
   */
  /**
   * Fired when the user requests to abort current request.
   *
   * This event can be cancelled.
   *
   * @event abort-api-request
   * @param {String} url The request URL. Can be empty string. Also, it may be
   * different URL that the one used to send the request if the user changed
   * it in between. Use the `id` property to compare requests.
   * @param {String} id Generated UUID of the request with `send-request`
   * event.
   */

  /**
   * Dispatched when query model changed.
   *
   * @event request-query-model-changed
   * @param {Array<Object>} value List of current query parameters.
   * Each object contains `name`, `value` and `enabled` property.
   * If `enable` equals `false` (boolean) it means that the user disabled
   * this property in the editor.
   */
  /**
   * Dispatched when path variables model changed.
   *
   * @event request-path-model-changed
   * @param {Array<Object>} value List of current path parameters.
   * Each object contains `name`, `value` and `enabled` property.
   * Enabled property is here only for consistency with
   * `request-query-model-changed`. The UI does not offer turning this
   * properties off. It's always true
   */
  /**
   * Dispatched when request URL change
   * @event url-value-changed
   * @param {String} value New value of request URL
   */
}
window.customElements.define('api-request-editor', ApiRequestEditor);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * Common function for response status view
 *
 * @mixinFunction
 * @memberof UiElements
 * @param {Function} base
 * @return {Function}
 */
const ResponseStatusMixin = (base) => class extends base {
  /**
   * Comnputes CSS class name depending on response status code.
   * @param {Number} code Status code
   * @return {String} Css class name for status code.
   */
  _computeStatusClass(code) {
    let cls = 'status-code-value';
    if (code >= 500 || code === 0) {
      cls += ' error';
    }
    if (code >= 400 && code < 500) {
      cls += ' warning';
    }
    if (code >= 300 && code < 400) {
      cls += ' info';
    }
    return cls;
  }
  /**
   * Click event listener to recognize click on a `link` element.
   * Dispatches `action-link-change` custom event when event's source is
   * an anchor.
   * @param {ClickEvent} e
   */
  _handleLink(e) {
    e.preventDefault();
    const path = e.composedPath();
    if (path[0] && path[0].nodeName === 'A') {
      const ev = new CustomEvent('action-link-change', {
        detail: {
          url: path[0].href
        },
        bubbles: true,
        composed: true,
        cancelable: true
      });
      this.dispatchEvent(ev);
    }
  }
};

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element to display formatted date and time.
 *
 * The `date` propery accepts Date object, Number as a timestamp or string
 * that will be parsed to the Date object.
 *
 * This element uses the `Intl` interface which is available in IE 11+ browsers.
 *
 * To format the date use [Intl.DateTimeFormat]
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat)
 * inteface options.
 *
 * The default value for each date-time component property is undefined,
 * but if all component properties are undefined, then year, month, and day
 * are assumed to be "numeric" (per spec).
 *
 * ### Example
 *
 * ```html
 * <date-time date="2010-12-10T11:50:45Z" year="numeric" month="narrow" day="numeric"></date-time>
 * ```
 *
 * The element provides accessibility by using the `time` element and setting
 * the `datetime` attribute on it.
 *
 * ### Styling
 *
 * `<date-time>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--date-time` | Mixin applied to the element | `{}`
 *
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 */
class DateTime extends HTMLElement {
  static get observedAttributes() {
    return [
      'locales', 'date', 'year', 'month', 'day', 'hour', 'minute', 'second',
      'weekday', 'time-zone-name', 'era', 'time-zone', 'hour12', 'itemprop'
    ];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._observer = new MutationObserver(() => this._mutationHandler());
  }

  connectedCallback() {
    this._observer.observe(this.shadowRoot, {
      childList: true,
      characterData: true,
      subtree: true
    });
    this._updateLabel();
  }

  disconnectedCallback() {
    this._observer.disconnect();
  }

  _mutationHandler() {
    this.setAttribute('aria-label', this.shadowRoot.textContent);
  }

  /**
   * A string with a BCP 47 language tag, or an array of such strings.
   * For the general form and interpretation of the locales argument,
   * see the Intl page.
   * The following Unicode extension keys are allowed:
   * - nu - Numbering system. Possible values include: "arab", "arabext",
   * "bali", "beng", "deva", "fullwide", "gujr", "guru", "hanidec", "khmr",
   * "knda", "laoo", "latn", "limb", "mlym", "mong", "mymr", "orya",
   * "tamldec", "telu", "thai", "tibt".
   * - ca - Calendar. Possible values include: "buddhist", "chinese",
   * "coptic", "ethioaa", "ethiopic", "gregory", "hebrew", "indian",
   * "islamic", "islamicc", "iso8601", "japanese", "persian", "roc".
   *
   * @type {String}
   */
  get locales() {
    return this.getAttribute('locales');
  }
  /**
   * A string with a BCP 47 language tag, or an array of such strings.
   * For the general form and interpretation of the locales argument,
   * see the Intl page.
   * The following Unicode extension keys are allowed:
   * - nu - Numbering system. Possible values include: "arab", "arabext",
   * "bali", "beng", "deva", "fullwide", "gujr", "guru", "hanidec", "khmr",
   * "knda", "laoo", "latn", "limb", "mlym", "mong", "mymr", "orya",
   * "tamldec", "telu", "thai", "tibt".
   * - ca - Calendar. Possible values include: "buddhist", "chinese",
   * "coptic", "ethioaa", "ethiopic", "gregory", "hebrew", "indian",
   * "islamic", "islamicc", "iso8601", "japanese", "persian", "roc".
   *
   * @param {String} v
   * @type {String}
   */
  set locales(v) {
    this.setAttribute('locales', v);
  }
  /**
   * The representation of the year.
   * Possible values are "numeric", "2-digit".
   */
  get year() {
    return this.getAttribute('year');
  }
  /**
   * The representation of the year.
   * @param {String} v Possible values are "numeric", "2-digit".
   */
  set year(v) {
    this.setAttribute('year', v);
  }
  /**
   * The representation of the month.
   * Possible values are "numeric", "2-digit", "narrow", "short", "long".
   */
  get month() {
    return this.getAttribute('month');
  }
  /**
   * The representation of the month.
   * @param {String} v Possible values are "numeric", "2-digit", "narrow", "short", "long".
   */
  set month(v) {
    this.setAttribute('month', v);
  }
  /**
   * The representation of the day.
   * Possible values are "numeric", "2-digit".
   */
  get day() {
    return this.getAttribute('day');
  }
  /**
   * The representation of the day.
   * @param {String} v Possible values are "numeric", "2-digit".
   */
  set day(v) {
    this.setAttribute('day', v);
  }
  /**
   * The representation of the hour.
   * Possible values are "numeric", "2-digit".
   */
  get hour() {
    return this.getAttribute('hour');
  }
  /**
   * The representation of the hour.
   * @param {String} v Possible values are "numeric", "2-digit".
   */
  set hour(v) {
    this.setAttribute('hour', v);
  }
  /**
   * The representation of the minute.
   * Possible values are "numeric", "2-digit".
   */
  get minute() {
    return this.getAttribute('minute');
  }
  /**
   * The representation of the minute.
   * @param {String} v Possible values are "numeric", "2-digit".
   */
  set minute(v) {
    this.setAttribute('minute', v);
  }
  /**
   * The representation of the second.
   * Possible values are "numeric", "2-digit".
   */
  get second() {
    return this.getAttribute('second');
  }
  /**
   * The representation of the second.
   * @param {String} v Possible values are "numeric", "2-digit".
   */
  set second(v) {
    this.setAttribute('second', v);
  }
  /**
   * The representation of the weekday.
   * Possible values are "narrow", "short", "long".
   */
  get weekday() {
    return this.getAttribute('weekday');
  }
  /**
   * The representation of the weekday.
   * @param {String} v Possible values are "narrow", "short", "long".
   */
  set weekday(v) {
    this.setAttribute('weekday', v);
  }
  /**
   * The representation of the time zone name.
   *
   * Possible values are "short", "long".
   */
  get timeZoneName() {
    return this.getAttribute('time-zone-name');
  }
  /**
   * The representation of the time zone name.
   *
   * @param {String} v Possible values are "short", "long".
   */
  set timeZoneName(v) {
    this.setAttribute('time-zone-name', v);
  }
  /**
   * The time zone to use. The only value implementations must recognize
   * is "UTC"; the default is the runtime's default time zone.
   * Implementations may also recognize the time zone names of the IANA
   * time zone database, such as "Asia/Shanghai", "Asia/Kolkata",
   * "America/New_York".
   */
  get timeZone() {
    return this.getAttribute('time-zone');
  }
  /**
   * The time zone to use. The only value implementations must recognize
   * is "UTC"; the default is the runtime's default time zone.
   * Implementations may also recognize the time zone names of the IANA
   * time zone database, such as "Asia/Shanghai", "Asia/Kolkata",
   * "America/New_York".
   * @param {String} v
   */
  set timeZone(v) {
    this.setAttribute('time-zone', v);
  }
  /**
   * The representation of the era.
   *
   * Possible values are "narrow", "short", "long".
   */
  get era() {
    return this.getAttribute('era');
  }
  /**
   * The representation of the era.
   *
   * @param {String} v Possible values are "narrow", "short", "long".
   */
  set era(v) {
    this.setAttribute('era', v);
  }
  /**
   * Whether to use 12-hour time (as opposed to 24-hour time).
   * Possible values are `true` and `false`; the default is locale
   * dependent.
   *
   * @type {Boolean}
   */
  get hour12() {
    if (!this.hasAttribute('hour12') && !this.__hour12set) {
      return null;
    }
    return this.hasAttribute('hour12');
  }
  /**
   * Whether to use 12-hour time (as opposed to 24-hour time).
   * Possible values are `true` and `false`; the default is locale
   * dependent.
   *
   * @param {Boolean} v
   */
  set hour12(v) {
    this.__hour12set = true;
    if (v) {
      this.setAttribute('hour12', '');
    } else {
      this.removeAttribute('hour12');
    }
  }
  /**
   * A date object to render.
   * It can be a `Date` object, number representing a timestamp
   * or valid date string. The argument is parsed by `Date` constructor
   * to produce the value.
   *
   * @type {Date|String|number}
   */
  get date() {
    if (this.__date) {
      return this.__date;
    }
    return this.getAttribute('date');
  }
  /**
   * A date object to render.
   * It can be a `Date` object, number representing a timestamp
   * or valid date string. The argument is parsed by `Date` constructor
   * to produce the value.
   *
   * @param {Date|String|number} v The date to render
   */
  set date(v) {
    this.__date = v;
    if (typeof v === 'string') {
      this.setAttribute('date', v);
    } else {
      this._updateLabel();
    }
  }

  get itemprop() {
    return this._getTimeNode().getAttribute('itemprop');
  }

  set itemprop(value) {
    const old = this.itemprop;
    if (old === value) {
      return;
    }
    if (old && value === null) {
      // This setter moves attribute from this element to "<time>" elsement.
      // When the attribute is removed from this then it becomes null.
      return;
    }
    const node = this._getTimeNode();
    if (value) {
      node.setAttribute('itemprop', value);
      this.removeAttribute('itemprop');
    } else {
      node.removeAttribute('itemprop');
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'itemprop') {
      this[name] = newValue;
      return;
    }
    this._updateLabel();
  }
  /**
   * Parses input `date` to a Date object.
   * @param {String|Number|Date} date A date to parse
   * @return {Date}
   */
  _getParsableDate(date) {
    if (!date) {
      date = new Date();
    } else if (typeof date === 'string') {
      try {
        date = new Date(date);
        const _test = date.getDate();
        if (_test !== _test) {
          date = new Date();
        }
      } catch (e) {
        date = new Date();
      }
    } else if (!isNaN(date)) {
      date = new Date(date);
    } else if (!(date instanceof Date)) {
      date = new Date();
    }
    return date;
  }

  _getIntlOptions() {
    const options = {};
    if (this.year) {
      options.year = this.year;
    }
    if (this.month) {
      options.month = this.month;
    }
    if (this.day) {
      options.day = this.day;
    }
    if (this.hour) {
      options.hour = this.hour;
    }
    if (this.minute) {
      options.minute = this.minute;
    }
    if (this.second) {
      options.second = this.second;
    }
    if (this.weekday) {
      options.weekday = this.weekday;
    }
    if (this.era) {
      options.era = this.era;
    }
    if (this.timeZoneName) {
      options.timeZoneName = this.timeZoneName;
    }
    if (this.timeZone) {
      options.timeZone = this.timeZone;
    }
    if (this.hour12 !== undefined) {
      options.hour12 = this.hour12;
    }
    return options;
  }
  /**
   * @return {Element} A reference to a `<time>` element that is in the shadow DOM of this element.
   */
  _getTimeNode() {
    let node = this.shadowRoot.querySelector('time');
    if (!node) {
      node = document.createElement('time');
      this.shadowRoot.appendChild(node);
    }
    return node;
  }

  _updateLabel() {
    if (!this.parentElement) {
      return;
    }
    const date = this._getParsableDate(this.date);
    const node = this._getTimeNode();
    node.setAttribute('datetime', date.toISOString());
    /* istanbul ignore if */
    if (typeof Intl === 'undefined') {
      node.innerText = date.toString();
      return;
    }
    let locales;
    if (this.locales) {
      locales = this.locales;
    }
    const options = this._getIntlOptions();
    const value = new Intl.DateTimeFormat(locales, options).format(date);
    node.innerText = value;
  }
}
window.customElements.define('date-time', DateTime);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* eslint-disable max-len */
/**
 * An element to display request timings information as a timeline according to the HAR 1.2 spec.
 *
 * The `timings` property should contain timings object as defined in
 * [HAR 1.2 spec](https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HAR/Overview.html#sec-object-types-timings).
 *
 * The timings object is consisted of:
 * - **blocked** [number, optional] - Time spent in a queue waiting for a network connection. Use -1 if the timing does not apply to the current request.
 * - **dns** [number, optional] - DNS resolution time. The time required to resolve a host name. Use -1 if the timing does not apply to the current request.
 * - **connect** [number, optional] - Time required to create TCP connection. Use -1 if the timing does not apply to the current request.
 * - **send** [number] - Time required to send HTTP request to the server.
 * - **wait** [number] - Waiting for a response from the server.
 * - **receive** [number] - Time required to read entire response from the server (or cache).
 * - **ssl** [number, optional] - Time required for SSL/TLS negotiation. If this field is defined then the time is also included in the connect field (to ensure backward compatibility with HAR 1.1). Use -1 if the timing does not apply to the current request.
 *
 * Additionally the object can contain the `startTime` property that indicates
 * the request start time. If can be Date object, timestamp or formatted string
 * representing a date.
 *
 * The timeline for `connect`, `send`, `wait` and `receive` are always shown.
 * `blocked`, `dns` and `ssl` are visible only if values for it was set and value
 * was > 0.
 *
 * ### Example
 *
 * ```html
 * <request-timings timings="[[requestTimings]]"></request-timings>
 *```
 *
 * ### Styling
 * `<request-timings>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--request-timings` | Mixin applied to the element | `{}`
 * `--select-text` | Mixin applied to the text elements that should have text selection enabled (in some platforms text selection is disabled by default) | `{}`
 * `--form-label` | Mixin applied to labels elements | `{}`
 * `--request-timings-progress-height` | The height of the progress bar | `12px`
 * `--request-timings-progress-background` | Background color of the progress bar. | `#F5F5F5`
 * `--request-timings-progress-color` | Color of the progress bar. | `#4a4`
 * `--request-timings-label-width` | Width of the label | `160px`
 * `--request-timings-value-width` | Width of the value column | `120px`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof UiElements
 */
class RequestTimings extends LitElement {
  static get styles() {
    return css`
      :host {
        display: block;
        --paper-progress-height: var(--request-timings-progress-height, 12px);
        --paper-progress-container-color: var(--request-timings-progress-background, #f5f5f5);
        --paper-progress-active-color: var(--request-timings-progress-background, #f5f5f5);
        --paper-progress-secondary-color: var(--request-timings-progress-color, #4a4);
      }

      .row {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      paper-progress {
        flex: 1;
        flex-basis: 0.000000001px;
      }

      .label,
      .date-value {
        user-select: text;
        cursor: text;
      }

      .label {
        margin-right: 8px;
      }

      .timing-label {
        width: var(--request-timings-label-width, 160px);
      }

      .timing-value {
        width: var(--request-timings-value-width, 120px);
        text-align: right;
        user-select: text;
        cursor: text;
      }

      .total {
        margin-top: 12px;
        padding-top: 12px;
        font-weight: 500;
        border-top: 2px var(--paper-grey-200, rgba(255, 0, 0, 0.74)) solid;
      }

      .row.is-total {
        justify-content: flex-end;
      }

      :host([narrow]) .row {
        flex-direction: column;
        align-items: start;
        margin: 8px 0;
      }

      :host([narrow]) paper-progress {
        width: 100%;
        flex: auto;
        order: 3;
      }

      :host([narrow]) .timing-value {
        text-align: left;
        order: 2;
      }

      :host([narrow]) .timing-label {
        order: 1;
        width: auto;
      }
    `;
  }

  render() {
    const {
      _startTime: startTime,
      _blocked: blocked,
      _fullTime: fullTime,
      _dns: dns,
      _connect: connect,
      _ssl: ssl,
      _send: send,
      _wait: wait,
      _receive: receive
    } = this;
    const hasStartTime = this._hasValue(startTime);
    const hasBlockedTime = this._hasValue(blocked);
    const hasDnsTime = this._hasValue(dns);
    const hasConnectTime = this._hasValue(connect);
    const hasSslTime = this._hasValue(ssl);
    const hasSendTime = this._hasValue(send);
    const hasWaitTime = this._hasValue(wait);
    const hasReceiveTime = this._hasValue(receive);
    const blockedProgressValue = this._computeSum(blocked);
    const ttcProgressValue = this._computeSum(blocked, dns);
    const sslProgressValue = this._computeSum(ttcProgressValue, connect);
    const sendProgressValue = this._computeSum(sslProgressValue, ssl);
    const ttfbProgressValue = this._computeSum(sendProgressValue, send);
    const receiveProgressValue = this._computeSum(ttfbProgressValue, wait);
    const receive2ProgressValue = this._computeSum(receiveProgressValue, receive);

    return html`
      ${hasStartTime
        ? html`
            <div class="row" data-type="start-time">
              <span class="label">Start date:</span>
              <date-time
                year="numeric"
                month="numeric"
                day="numeric"
                hour="numeric"
                minute="numeric"
                second="numeric"
                class="date-value"
                .date="${startTime}"
              ></date-time>
            </div>
          `
        : undefined}
      ${hasBlockedTime
        ? html`
            <div class="row" data-type="block-time">
              <div class="timing-label label">
                Queueing:
              </div>
              <paper-progress
                aria-label="Queueing time"
                value="0"
                .secondaryProgress="${blocked}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(blocked)} ms</span>
            </div>
          `
        : undefined}
      ${hasDnsTime
        ? html`
            <div class="row" data-type="dns-time">
              <div class="timing-label label">
                DNS Lookup:
              </div>
              <paper-progress
                aria-label="DNS lookup time"
                .value="${blockedProgressValue}"
                .secondaryProgress="${ttcProgressValue}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(dns)} ms</span>
            </div>
          `
        : undefined}
      ${hasConnectTime
        ? html`
            <div class="row" data-type="ttc-time">
              <div class="timing-label label">
                Time to connect:
              </div>
              <paper-progress
                aria-label="Time to connect"
                .value="${ttcProgressValue}"
                .secondaryProgress="${sslProgressValue}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(connect)} ms</span>
            </div>
          `
        : undefined}
      ${hasSslTime
        ? html`
            <div class="row" data-type="ssl-time">
              <div class="timing-label label">
                SSL negotiation:
              </div>
              <paper-progress
                aria-label="SSL negotiation time"
                .value="${sslProgressValue}"
                .secondaryProgress="${sendProgressValue}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(ssl)} ms</span>
            </div>
          `
        : undefined}
      ${hasSendTime
        ? html`
            <div class="row" data-type="send-time">
              <div class="timing-label label">
                Send time:
              </div>
              <paper-progress
                aria-label="Send time"
                value="${sendProgressValue}"
                .secondaryProgress="${ttfbProgressValue}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(send)} ms</span>
            </div>
          `
        : undefined}
      ${hasWaitTime
        ? html`
            <div class="row" data-type="ttfb-time">
              <div class="timing-label label">
                Wait time (TTFB):
              </div>
              <paper-progress
                aria-label="Time to first byte"
                .value="${ttfbProgressValue}"
                .secondaryProgress="${receiveProgressValue}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(wait)} ms</span>
            </div>
          `
        : undefined}
      ${hasReceiveTime
        ? html`
            <div class="row" data-type="receive-time">
              <div class="timing-label label">
                Content download:
              </div>
              <paper-progress
                aria-label="Receiving time"
                .value="${receiveProgressValue}"
                .secondaryProgress="${receive2ProgressValue}"
                .max="${fullTime}"
                step="0.0001"
              ></paper-progress>
              <span class="timing-value">${this._round(receive)} ms</span>
            </div>
          `
        : undefined}
      <div class="row is-total">
        <span class="timing-value total">${this._round(fullTime)} ms</span>
      </div>
    `;
  }

  static get properties() {
    return {
      /**
       * A timings object as described in HAR 1.2 spec.
       */
      timings: { type: Object },
      /**
       * Request stat time. It can be either Date object,
       * timestamp or a string representing the date.
       *
       * If the `timings` property contains the `startTime` property it
       * will be overwritten.
       *
       * @type {String|Date}
       */
      _startTime: {},
      /**
       * Computed value. Calculated full time of the request and response
       */
      _fullTime: { type: Number },
      // Computed value. Time required to establish the connection
      _connect: { type: Number },

      // Computed value. Time of receiving data from the remote machine.
      _receive: { type: Number },
      // Computed value. Time to send data to the remote machine.
      _send: { type: Number },
      // Computed value. Wait time for the first byte to arrive.
      _wait: { type: Number },
      // Computed value. Time spent in a queue waiting for a network connection
      _blocked: { type: Number },
      // Computed value. DNS resolution time.
      _dns: { type: Number },
      // Computed value. Time required for SSL/TLS negotiation.
      _ssl: { type: Number }
    };
  }

  get timings() {
    return this._timings;
  }

  set timings(value) {
    const old = this._timings;
    if (old === value) {
      return;
    }
    this._timings = value;
    this._update(value);
  }

  // Updates the view after `timings` change.
  _update() {
    const timings = this.timings || {};
    let fullTime = 0;
    let connect = Number(timings.connect);
    let receive = Number(timings.receive);
    let send = Number(timings.send);
    let wait = Number(timings.wait);
    let blocked = Number(timings.blocked);
    let dns = Number(timings.dns);
    let ssl = Number(timings.ssl);
    if (connect !== connect || connect < 0) {
      connect = 0;
    }
    if (receive !== receive || receive < 0) {
      receive = 0;
    }
    if (send !== send || send < 0) {
      send = 0;
    }
    if (wait !== wait || wait < 0) {
      wait = 0;
    }
    if (dns !== dns || dns < 0) {
      dns = -1;
    }
    if (blocked !== blocked || blocked < 0) {
      blocked = -1;
    }
    if (ssl !== ssl || ssl < 0) {
      ssl = -1;
    }
    fullTime += connect + receive + send + wait;
    if (dns > 0) {
      fullTime += dns;
    }
    if (blocked > 0) {
      fullTime += blocked;
    }
    if (ssl > 0) {
      fullTime += ssl;
    }
    this._fullTime = fullTime;
    this._connect = connect;
    this._receive = receive;
    this._send = send;
    this._wait = wait;
    this._dns = dns;
    this._blocked = blocked;
    this._ssl = ssl;
    if (timings.startTime) {
      this._startTime = timings.startTime;
    } else {
      this._startTime = this._startTime || -1;
    }
  }
  /**
   * Round numeric value to presision defined in the `power` argument.
   *
   * @param {Number} value The value to round
   * @return {Number} Rounded value.
   */
  _round(value) {
    value = Number(value);
    if (value !== value) {
      return 'unknown';
    }
    const factor = Math.pow(10, 4);
    return Math.round(value * factor) / factor;
  }
  /**
   * Sums two HAR times.
   * If any argument is `undefined` or `-1` then `0` is assumed.
   * @param {Number} a Time #1
   * @param {Number} b Time #2
   * @return {Number} Sum of both
   */
  _computeSum(a, b) {
    if (a === undefined) {
      a = 0;
    } else {
      a = Number(a);
      if (a < 0) {
        a = 0;
      }
    }
    if (b === undefined) {
      b = 0;
    } else {
      b = Number(b);
      if (b < 0) {
        b = 0;
      }
    }
    return a + b;
  }

  _hasValue(num) {
    if (num === undefined) {
      return false;
    }
    if (typeof num === 'string') {
      return !!num;
    }
    return num > 0;
  }
}
window.customElements.define('request-timings', RequestTimings);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* eslint-disable max-len */
/**
 * The `request-timings-panel` element is a panel to display a set of timings
 * for the request / response. The use case is to display timings for the request
 * where redirects are possible and timings for the redirects are calculated.
 *
 * The timings accepted by this element is defined in the HAR 1.2 spec. See The
 * `request-timings` element docs for more info.
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--request-timings-panel` | Mixin applied to the element | `{}`
 * `--arc-font-subhead` | Mixin applied to the headers element. Similar to `--paper-font-subhead` mixin in Paper elements. | `{}`
 *
 * Use `request-timings` properties an mixins to style the charts.
 *
 * ## Changes in version 2
 * - `redirects` property rendamed to `redirectTimings`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof UiElements
 */
class RequestTimingsPanel extends LitElement {
  static get styles() {
    return css`
      :host {
        display: block;
      }

      .status-row,
      .timings-row {
        flex-direction: row;
        display: flex;
        align-items: center;
        min-height: 56px;
      }

      .status-row {
        flex-direction: row;
        display: flex;
        justify-content: flex-end;
      }

      .sub-title {
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
      }

      .status-label {
        width: 60px;
        font-size: var(--request-timings-panel-timing-total-size, 16px);
        font-weight: var(--request-timings-panel-timing-total-weigth, 400);
      }

      .text {
        user-select: text;
        cursor: text;
      }

      .redirect-value {
        margin-top: 12px;
        flex: 1;
        flex-basis: 0.000000001px;
      }

      :host([narrow]) .timings-row {
        flex-direction: column;
        align-items: start;
        margin: 20px 0;
      }

      :host([narrow]) .redirect-value {
        width: 100%;
        flex: auto;
      }

      :host([narrow]) .status-row {
        justify-content: flex-start;
      }
    `;
  }

  render() {
    const { redirectTimings, timings, narrow } = this;
    const hasRedirects = !!(redirectTimings && redirectTimings.length);
    const requestTotalTime = this._computeRequestTime(redirectTimings, timings);

    return html`
      ${hasRedirects
        ? html`
            <section class="redirects">
              <h3 class="sub-title">Redirects</h3>
              ${redirectTimings.map(
                (item, index) => html`
                  <div class="timings-row">
                    <div class="status-label text">#<span>${index + 1}</span></div>
                    <div class="redirect-value">
                      <request-timings .timings="${item}" ?narrow="${narrow}"></request-timings>
                    </div>
                  </div>
                `
              )}
              <h3 class="sub-title">Final request</h3>
              <div class="timings-row">
                <div class="redirect-value">
                  <request-timings .timings="${timings}" ?narrow="${narrow}"></request-timings>
                </div>
              </div>
              <div class="status-row">
                <div class="flex"></div>
                <span class="timing-value total text">Total: ${requestTotalTime} ms</span>
              </div>
            </section>
          `
        : html`
            <request-timings .timings="${timings}" ?narrow="${narrow}"></request-timings>
          `}
    `;
  }

  static get properties() {
    return {
      /**
       * An array of HAR 1.2 timings object.
       * It should contain a timings objects for any redirect object during
       * the request.
       * List should be arelady ordered by the time of occurence.
       */
      redirectTimings: { type: Array },
      // The request / response HAR timings.
      timings: { type: Object },
      /**
       * When set it renders mobile friendly view
       */
      narrow: { type: Boolean, reflect: true }
    };
  }

  _computeRequestTime(redirects, timings) {
    let time = 0;
    if (redirects && redirects.length) {
      redirects.forEach((timing) => (time += this._computeHarTime(timing)));
    }
    const add = this._computeHarTime(timings);
    if (add) {
      time += add;
    }
    time = Math.round(time * 10000) / 10000;
    return time;
  }

  _computeHarTime(har) {
    let fullTime = 0;
    if (!har) {
      return fullTime;
    }
    let connect = Number(har.connect);
    let receive = Number(har.receive);
    let send = Number(har.send);
    let wait = Number(har.wait);
    let blocked = Number(har.blocked);
    let dns = Number(har.dns);
    let ssl = Number(har.ssl);
    if (connect !== connect || connect < 0) {
      connect = 0;
    }
    if (receive !== receive || receive < 0) {
      receive = 0;
    }
    if (send !== send || send < 0) {
      send = 0;
    }
    if (wait !== wait || wait < 0) {
      wait = 0;
    }
    if (dns !== dns || dns < 0) {
      dns = -1;
    }
    if (blocked !== blocked || blocked < 0) {
      blocked = -1;
    }
    if (ssl !== ssl || ssl < 0) {
      ssl = -1;
    }
    fullTime += connect + receive + send + wait;
    if (dns > 0) {
      fullTime += dns;
    }
    if (blocked > 0) {
      fullTime += blocked;
    }
    if (ssl > 0) {
      fullTime += ssl;
    }
    return fullTime;
  }
}
window.customElements.define('request-timings-panel', RequestTimingsPanel);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element that displays a list of headers.
 *
 * On double click on the list the `query-headers` event is dispatched to
 * get header definition. When information is handled by the application
 * then it dispays a dialog with header documentation.
 * Use `advanced-rest-client/arc-definitions` element to handle queries.
 *
 * The `headers` property accepts a HTTP headers string or `Headers` object
 * as defined in Fetch spec.
 *
 * ### Example
 *
 * ```html
 * <headers-list-view headers="Content-Type: application/json"></headers-list-view>
 * ```
 *
 * ### Styling
 * `<headers-list-view>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--headers-list-view` | Mixin applied to the element | `{}`
 * `--arc-font-body1` | Mixin applied to the example section in the details dialog. | `{}`
 * `--arc-font-body2` | Mixin applied to the description section in the details dialog. | `{}`
 * `--arc-font-code1` | Mixin apllied to the list | `{}`
 * `--headers-list-item-min-height` | Min height of the list item. | `20px`
 * `--arc-link` | Mixin applied to a link | `{}`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @appliesMixin HeadersParserMixin
 * @memberof UiElements
 */
class HeadersListView extends HeadersParserMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
      font-size: var(--arc-font-body1-font-size);
      font-weight: var(--arc-font-body1-font-weight);
      line-height: var(--arc-font-body1-line-height);
    }

    .dialog-header-example {
      margin-top: 16px;
    }

    .dialog-header-desc {
      font-size: var(--arc-font-body2-font-size);
      font-weight: var(--arc-font-body2-font-weight);
      line-height: var(--arc-font-body2-line-height);
    }

    .list-item {
      min-height: var(--headers-list-item-min-height, 20px);
      user-select: text;
      word-break: break-all;
      font-family: var(--arc-font-code-family);
    }

    .list-item > span {
      display: inline-block;
    }

    .header-name {
      margin-right: 8px;
    }

    .auto-link {
      color: var(--link-color);
    }`;
  }

  _listTemplate(headers) {
    return html`<div class="container">
      ${headers.map((item) => html`<div class="list-item" data-name="${item.name}">
        <span class="header-name">${item.name}:</span>
        <span class="header-value">${this._autoLink(item.value)}</span>
      </div>`)}
    </div>`;
  }

  render() {
    const { _headersList } = this;
    const hasList = !!(_headersList && _headersList.length);
    return html`
    ${hasList ? this._listTemplate(_headersList) : undefined}`;
  }

  static get properties() {
    return {
      /**
       * A HTTP headers to display.
       */
      headers: { type: String },
      /**
       * Parsed headers to the array of headers.
       *
       * @type {Array<Object>}
       */
      _headersList: { type: Array },
      /**
       * Type of the header.
       * Can be either `request` or `response`.
       * It is required for displaying the help for the headers. The element
       * fires the `query-headers` event on double click which requires this
       * information to be set.
       */
      type: { type: String },
      /**
       * A regexp used to match links in headers string.
       *
       * @type {RegExp}
       */
      _linkR: { type: Object }
    };
  }

  get headers() {
    return this._headers;
  }

  set headers(value) {
    const old = this._headers;
    if (old === value) {
      return;
    }
    this._headers = value;
    this._headersChanged(value);
  }

  constructor() {
    super();
    this._linkR = /(https?:\/\/([^" >]*))/gim;
    this.type = 'response';
  }
  /**
   * The list view requires to add some markup dynamically therefore it cannot
   * use Polymer's replates and binding system.
   * Heaqders list is generated manually when headers string has changed.
   *
   * @param {String} headers Headers to render
   */
  _headersChanged(headers) {
    if (!headers) {
      this._headersList = undefined;
      return;
    }
    const list = this.headersToJSON(headers);
    this._headersList = list;
  }
  // Finds URLs in input string and adds anchors tags.
  _autoLink(input) {
    if (typeof input !== 'string') {
      return input;
    }
    const matches = input.match(this._linkR);
    if (!matches) {
      return input;
    }
    let index = input.indexOf(matches[0]);
    const start = input.substr(0, index);
    const url = matches[0];
    index += url.length;
    const end = input.substr(index);

    return html`${start}<a target="_blank"
      class="auto-link" href="${url}">${url}</a>${end}`;
  }
}
window.customElements.define('headers-list-view', HeadersListView);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * The element displays the HTTP source message that has been sent to the remote mchine.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof UiElements
 */
class HttpSourceMessageView extends LitElement {
  static get styles() {
    return css`:host {
      overflow: auto;
      display: block;
    }

    pre {
      word-break: break-all;
      user-select: text;
      font-family: var(--arc-font-code-family, initial);
      margin-bottom: 0;
    }

    .title {
      margin: 0;
      display: flex;
      align-items: center;
      cursor: pointer;

    }`;
  }

  render() {
    const { opened, message } = this;
    return html`
    <div class="title" @click="${this.toggle}">
      Source message
      <anypoint-icon-button
        title="Toggles source view"
        aria-label="Press to toggle source view">
          <iron-icon icon="${this._computeIcon(opened)}"></iron-icon>
      </anypoint-icon-button>
    </div>
    <iron-collapse id="collapse" .opened="${opened}">
      <pre>${message}</pre>
    </iron-collapse>`;
  }

  static get properties() {
    return {
      // A HTTP message to display.
      message: { type: String },
      // True if the message is visible.
      opened: { type: Boolean },
      /**
       * Icon prefix from the svg icon set. This can be used to replace the set
       * without changing the icon.
       *
       * Defaults to `arc`.
       */
      iconPrefix: { type: String }
    };
  }

  get opened() {
    return this._opened;
  }

  set opened(value) {
    const old = this._opened;
    if (old === value) {
      return;
    }
    this._opened = value;
    this.requestUpdate('opened', old);
    if (value) {
      this.setAttribute('aria-expanded', 'true');
    } else {
      this.setAttribute('aria-expanded', 'false');
    }
  }

  constructor() {
    super();
    this.iconPrefix = 'arc';
  }
  /**
   * Toggles source message visibility
   */
  toggle() {
    this.opened = !this.opened;
  }
  /**
   * Computes icon name depending on `opened` state
   * @param {Boolean} opened
   * @return {String}
   */
  _computeIcon(opened) {
    let icon = '';
    if (this.iconPrefix) {
      icon = this.iconPrefix + ':';
    }
    return icon + (opened ? 'expand-less' : 'expand-more');
  }
}
window.customElements.define('http-source-message-view', HttpSourceMessageView);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
var statusStypes = css`
.status-row {
  display: flex;
  flex-direction: row;
  align-items: center;
  font-size: var(--arc-font-subhead-font-size);
  font-weight: var(--arc-font-subhead-font-weight);
  line-height: var(--arc-font-subhead-line-height);
  min-height: 56px;
  padding: 20px 0;
}

:host([narrow]) .status-row {
  align-items: start;
  flex-direction: column;
}

.status-value {
  display: flex;
  flex: 1;
  flex-direction: row;
  align-items: center;
}

.status-value > span {
  display: block;
}

.status-value.status.text > span:not(:first-child) {
  margin-left: 8px;
}

.text {
  user-select: text;
}

headers-list-view {
  margin-top: 12px;
}

.status-code-value {
  padding: 4px 8px;
  color: var(--response-status-view-code-value-color, #fff);
  border-radius: 3px;
  display: block;
  background-color: var(--arc-status-code-color-200, rgb(36, 107, 39));
}

.info.status-code-value {
  background-color: var(--arc-status-code-color-300, rgb(48, 63, 159));
}

.warning.status-code-value {
  background-color: var(--arc-status-code-color-400, rgb(171, 86, 0));
}

.error.status-code-value {
  background-color: var(--arc-status-code-color-500, rgb(211, 47, 47));
}

.no-info-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.no-info {
  font-style: italic;
}`;

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * HTTP redirects info panel.
 * Renders list of redirects and headers in the response.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 * @appliesMixin ResponseStatusMixin
 */
class ResponseRedirectsPanel extends ResponseStatusMixin(LitElement) {
  static get styles() {
    return [
      statusStypes,
      css`.status-label {
        width: 40px;
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
      }

      .redirect-value {
        margin-top: 12px;
        flex: 1;
      }

      .redirect-location {
        margin-left: 8px;
      }

      .auto-link {
        color: var(--link-color);
      }`
    ];
  }

  _listItemTemplate(item, index) {
    const loc = this._computeRedirectLocation(item.headers);
    return html`<div class="status-label text">
      #<span>${index + 1}</span>
    </div>
    <div class="redirect-value" @click="${this._handleLink}">
      <div class="status-value status text">
        <span class="${this._computeStatusClass(item.status)}">${item.status} ${item.statusText}</span>
        <span class="redirect-location">
          to: <a href="${loc}" class="auto-link">${loc}</a></span>
      </div>
      <headers-list-view .headers="${item.headers}"></headers-list-view>
    </div>`;
  }

  render() {
    const { redirects } = this;
    const hasRedirects = !!(redirects && redirects.length);
    return html`
    ${hasRedirects ?
      redirects.map((item, index) =>
        html`<div class="status-row">
          ${this._listItemTemplate(item, index)}
          </div>`) :
      html`<div class="no-info-container">
          <p class="no-info">There is no redirects information to display</p>
        </div>`}
    `;
  }

  static get properties() {
    return {
      /**
       * List of redirects information.
       */
      redirects: { type: Array }
    };
  }
  /**
   * Extracts a location URL form the headers.
   *
   * @param {String} headers A HTTP headers string.
   * @return {String} A value of the location header or `unknown` if not
   * found.
   */
  _computeRedirectLocation(headers) {
    const def = 'unknown';
    if (!headers) {
      return def;
    }
    if (typeof headers === 'string') {
      const match = headers.match(/^location: (.*)$/im);
      if (!match) {
        return def;
      }
      return match[1];
    }
    const location = headers.get('location');
    return location || def;
  }
}
window.customElements.define('response-redirects-panel', ResponseRedirectsPanel);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* eslint-disable max-len */
/**
 * A class that reads response status code and returns default HTTP status
 * message associated with it.
 */
class StatusMessage {
  /**
   * Translates status code into status message.
   *
   * @param {Number|String} code Status code
   * @return {String|undefined} Status text if the code is recognized.
   */
  static getMessage(code) {
    code = Number(code);
    let message;
    switch (code) {
      case 0:
        message = 'Request error';
        break;
      case 100:
        message = 'Continue';
        break;
      case 101:
        message = 'Switching Protocols';
        break;
      case 200:
        message = 'OK';
        break;
      case 201:
        message = 'Created';
        break;
      case 202:
        message = 'Accepted';
        break;
      case 203:
        message = 'Non-Authoritative Information';
        break;
      case 204:
        message = 'No Content';
        break;
      case 205:
        message = 'Reset Content';
        break;
      case 206:
        message = 'Partial Content';
        break;
      case 300:
        message = 'Multiple Choices';
        break;
      case 301:
        message = 'Moved Permanently';
        break;
      case 302:
        message = 'Found';
        break;
      case 303:
        message = 'See Other';
        break;
      case 304:
        message = 'Not Modified';
        break;
      case 305:
        message = 'Use Proxy';
        break;
      case 306:
        message = '(Unused)';
        break;
      case 307:
        message = 'Temporary Redirect';
        break;
      case 400:
        message = 'Bad Request';
        break;
      case 401:
        message = 'Unauthorized';
        break;
      case 402:
        message = 'Payment Required';
        break;
      case 403:
        message = 'Forbidden';
        break;
      case 404:
        message = 'Not Found';
        break;
      case 405:
        message = 'Method Not Allowed';
        break;
      case 406:
        message = 'Not Acceptable';
        break;
      case 407:
        message = 'Proxy Authentication Required';
        break;
      case 408:
        message = 'Request Timeout';
        break;
      case 409:
        message = 'Conflict';
        break;
      case 410:
        message = 'Gone';
        break;
      case 411:
        message = 'Length Required';
        break;
      case 412:
        message = 'Precondition Failed';
        break;
      case 413:
        message = 'Request Entity Too Large';
        break;
      case 414:
        message = 'Request-URI Too Long';
        break;
      case 415:
        message = 'Unsupported Media Type';
        break;
      case 416:
        message = 'Requested Range Not Satisfiable';
        break;
      case 417:
        message = 'Expectation Failed';
        break;
      case 500:
        message = 'Internal Server Error';
        break;
      case 501:
        message = 'Not Implemented';
        break;
      case 502:
        message = 'Bad Gateway';
        break;
      case 503:
        message = 'Service Unavailable';
        break;
      case 504:
        message = 'Gateway Timeout';
        break;
      case 505:
        message = 'HTTP Version Not Supported';
        break;
    }
    return message;
  }
}
/**
 * HTTP response status view, including status, headers redirects and timings
 *
 * ### Full example
 *
 * ```html
 * <response-status-view
 *  status-code="[[statusCode]]"
 *  status-message="[[statusMessage]]"
 *  request-headers="[[requestHeaders]]"
 *  response-headers="[[responseHeaders]]"
 *  loading-time="[[loadingTime]]"
 *  http-message="[[_computeHttpMessage(requestHeaders)]]"
 *  redirects="[[redirects]]"
 *  redirect-timings="[[redirectTimings]]"
 *  timings="[[timings]]"></response-status-view>
 * ```
 *
 * ### Minimal example
 *
 * ```html
 * <response-status-view
 *  status-code="[[statusCode]]"
 *  status-message="[[statusMessage]]"
 *  response-headers="[[responseHeaders]]"
 *  loading-time="[[loadingTime]]"></response-status-view>
 * ```
 *
 * ## Understanding `is-xhr`
 *
 * ARC (Advanced REST client) uses it's own HTTP client library to connect to
 * the server. Because of that it collects much more information about the
 * connection itself. When the response ends it reports detailed redirects
 * information. Each response (including redirects) has detailed timing
 * infomration. The timing object applies HAT 1.2 spec. When `is-xhr`
 * attribute is not set, the element expect to received additional data
 * available in ARC app. Element renders additional tabs to list redirects
 * and table of timing information.
 *
 * Simple requerst objects like XHR or Fetch does not allow to collect this
 * information in such details. In this case `is-xhr` should be set so the
 * element won't render a view that can never be used.
 *
 * ## Data model
 *
 * ### Redirects
 *
 * #### `redirects`
 *
 * Array of objects. Each object has `headers` property as a HTTP headers
 * string, `status` as a HTTP status and optionally `statusText`.
 *
 * #### `redirectTimings`
 *
 * Array of objects. Each object represent a HAR 1.2 timings object.
 * See the `request-timings` element documentation for more information.
 *
 * ### `responseError`
 *
 * A JavaScript Error object.
 *
 * ### `timings`
 *
 * Object that represent a HAR 1.2 timings object. See the `request-timings`
 * element documentation for more information.
 *
 * ## Status message
 *
 * The element sets a status message if, after ~100 ms of setting status code
 * property, the `statusMessage` property is not set. This is to ensure that
 * the user will always see any status message.
 *
 * ## Styling
 *
 * `<response-status-view>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--response-status-view` | Mixin applied to the element | `{}`
 * `--raml-docs-response-panel` | Mixin applied to the element | `{}`
 * `--arc-status-code-color-200` | Color of the 200 status code (ARC theme option) | `rgba(56, 142, 60, 1)` |
 * `--arc-status-code-color-300` | Color of the 300 status code (ARC theme option) | `rgba(48, 63, 159, 1)` |
 * `--arc-status-code-color-400` | Color of the 400 status code (ARC theme option) | `rgba(245, 124, 0, 1)` |
 * `--arc-status-code-color-500` | Color of the 500 status code (ARC theme option) | `rgba(211, 47, 47, 1)` |
 * `--arc-font-subhead` | Mixin applied to sub headers (low implortance headers). It's a theme mixin. | `{}`
 * `--no-info-message` | Mixin applied to the messages information that there's no information available. | `{}`
 * `--arc-font-code1` | Mixin applied to the source message. It's a theme mixin. | `{}`
 * `--response-status-view-badge-color` | Color of the badge with number of the headers / redirections in advanced view | `#fff`
 * `--response-status-view-badge-background` | Background color of the badge with number of the headers / redirections in advanced view | `--accent-color`
 * `--response-status-view-empty-badge-color` | Color of the badge with number of the headers / redirections in advanced view | `#fff`
 * `--response-status-view-empty-badge-background` | Background color of the badge with number of the headers / redirections in advanced view | `#9e9e9e`
 * `--response-status-view-status-info-border-color` | Border color separating status from the response headers | `#e5e5e5`
 * `--response-status-view-status-container` | Mixin applied to the status row in the main view and in the redirects view (in advanced mode). | `{}`
 *
 * ## Changes in version 2.0
 *
 * - `status-message` element was removed. The `StatusMessage` class is included
 * with this element.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 * @appliesMixin ResponseStatusMixin
 */
class ResponseStatusView extends ResponseStatusMixin(LitElement) {
  static get styles() {
    return [
      statusStypes,
      css`:host {
        display: flex;
        flex-direction: column;

        font-size: var(--arc-font-body1-font-size);
        font-weight: var(--arc-font-body1-font-weight);
        line-height: var(--arc-font-body1-line-height);
      }

      .badge {
        display: block;
        background-color: var(--response-status-view-badge-background, var(--accent-color));
        color: var(--response-status-view-badge-color, #fff);
        width: 20px;
        height: 20px;
        border-radius: 50%;
        font-size: 12px;
        margin-left: 12px;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
      }

      .badge.empty {
        background-color: var(--response-status-view-empty-badge-background, #9e9e9e);
        color: var(--response-status-view-empty-badge-color, #fff);
      }

      .response-time {
        color: var(--response-status-view-loading-time-color, rgba(0, 0, 0, 0.54));
        margin-left: 8px;
        display: block;
      }

      .status-info {
        display: flex;
        flex-direction: row;
        align-items: center;
        flex: 1;
        padding: 0 4px;
      }

      .toggle-icon {
        transform: rotateZ(0deg);
        transition: transform 0.3s linear;
      }

      .toggle-icon.opened {
        transform: rotateZ(-180deg);
      }

      .xhr-title {
        display: flex;
        flex-direction: row;
        align-items: center;
        padding: 0px 16px;
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
      }

      .response-error-label {
        margin-left: 12px;
        color: var(--arc-status-code-color-500, rgba(211, 47, 47, 1));
      }

      .status-url {
        display: flex;
        flex-direction: row;
        align-items: center;
        padding-top: 12px;
        padding-bottom: 12px;
        font-size: 120%;
        padding-left: 16px;
        background: var(--response-status-view-request-url-background-color, #6B6C6D);
        color: var(--response-status-view-request-url-color, #fff);
        font-family: var(--arc-font-code-family, initial);
      }

      .http-method {
        margin-right: 12px;
      }

      .request-url {
        word-break: break-all;
      }

      .no-info {
        padding-left: 16px;
        font-style: italic;
      }

      [hidden] {
        display: none !important;
      }`
    ];
  }

  render() {
    const {
      responseError,
      loadingTime,
      statusMessage,
      statusCode,
      opened,
      requestUrl,
      requestMethod,
      selectedTab,
      responseHeaders,
      requestHeaders,
      isXhr,
      scrollableTab
    } = this;
    let  {
      redirects
    } = this;
    if (!redirects) {
      redirects = [];
    }
    const isError = !!responseError;

    return html`
    <div class="status-row">
      <div class="status-value status">
      ${isError ?
        html`<span class="error status-code-value">0</span>
        ${loadingTime ? html`<span class="response-time">${this._roundTime(loadingTime)} ms</span>` : undefined}
        <p class="response-error-label">Error in the response.</p>` :
        html`<div class="status-info text">
          <span class="${this._computeStatusClass(statusCode)}">${statusCode} ${statusMessage}</span>
          ${loadingTime ? html`<span class="response-time">${this._roundTime(loadingTime)} ms</span>` : undefined}
        </div>
        <div class="status-details">
          <anypoint-button @click="${this.toggleCollapse}" class="toggle-button" title="Toogles response headers">
            Details
            <iron-icon icon="${this._computeIcon('expand-more')}" class="${this._computeToggleIconClass(opened)}"></iron-icon>
          </anypoint-button>
        </div>`}
      </div>
    </div>

    <iron-collapse .opened="${opened}">
      ${requestUrl ? html`<div class="status-url">
        ${requestMethod ? html`<span class="http-method">${requestMethod}</span>` : undefined}
        <span class="request-url">${requestUrl}</span>
      </div>` : undefined}

      <anypoint-tabs .selected="${selectedTab}" ?scrollable="${scrollableTab}" @selected-changed="${this._tabChangeHandler}">
        <anypoint-tab>
          <span>Response headers</span>
          <span class="${this._computeBageClass(responseHeaders)}">${this._computeHeadersLength(responseHeaders)}</span>
        </anypoint-tab>
        <anypoint-tab>
          <span>Request headers</span>
          <span class="${this._computeBageClass(requestHeaders)}">${this._computeHeadersLength(requestHeaders)}</span>
        </anypoint-tab>
        ${isXhr ? undefined : html`<anypoint-tab>
          <span>Redirects</span>
          <span class="${this._computeBageClass(redirects.length)}">${redirects.length}</span>
        </anypoint-tab>
        <anypoint-tab>Timings</anypoint-tab>`}
      </anypoint-tabs>
      ${this._selectedTemplate(selectedTab)}
    </iron-collapse>`;
  }

  _selectedTemplate(selected) {
    const { narrow } = this;
    switch (selected) {
      case 0: return html`<section class="response-headers-panel">
      ${this.responseHeaders ?
        html`<headers-list-view
          type="response"
          ?narrow="${narrow}"
          @click="${this._handleLink}"
          .headers="${this.responseHeaders}"
          data-source="response-headers"></headers-list-view>` :
        html`<div class="no-info-container">
          <p class="no-info">No response headers recorded.</p>
        </div>`}
      </section>`;
      case 1: return html`<section class="request-headers-panel">
        ${this.requestHeaders ?
          html`<headers-list-view
            ?narrow="${narrow}"
            type="request"
            @click="${this._handleLink}"
            .headers="${this.requestHeaders}"
            data-source="request-headers"></headers-list-view>` :
          html`<div class="no-info-container">
            <p class="no-info">No request headers recorded.</p>
          </div>`}
        ${this.httpMessage ? html`<http-source-message-view
          .message="${this.httpMessage}"
          .iconPrefix="${this.iconPrefix}"></http-source-message-view>` : undefined}
      </section>`;
      case 2: return html`<response-redirects-panel
        .redirects="${this.redirects}"
        ?narrow="${narrow}"></response-redirects-panel>`;
      case 3: return html`<request-timings-panel
        .redirectTimings="${this.redirectTimings}"
        .timings="${this.timings}"
        ?narrow="${narrow}"></request-timings-panel>`;
    }
  }

  static get properties() {
    return {
      // Response status code.
      statusCode: { type: Number },
      // Status message (if any)
      statusMessage: { type: String },
      // The request/response loading time.
      loadingTime: { type: Number },
      /**
       * The response headers as a HTTP headers string
       */
      responseHeaders: { type: String },
      // The request headers as a HTTP headers string
      requestHeaders: { type: String },
      /**
       * Raw HTTP message sent to the server.
       * It will be displayed in the request headers tab.
       * Optional for transports that do not expose this information.
       */
      httpMessage: { type: String },
      /**
       * An Error object representing the response error.
       * It uses this property only to determine if the request is errored
       */
      responseError: { type: Object },
      /**
       * An array of redirect responses.
       * Each of the response objects should be regular Response objects.
       *
       * @type {Array<Object>}
       */
      redirects: { type: Array },
      /**
       * List of timings occured during the redirects.
       * This list should be ordered by the time of redirection.
       * See the `request-timings` element documentation for more
       * information.
       *
       * @type {Array<Object>}
       */
      redirectTimings: { type: Array },
      /**
       * Currently selected tab.
       */
      selectedTab: { type: Number },
      /**
       * When set renders tabs in a scrollable view.
       */
      scrollableTab: { type: Boolean },
      /**
       * The timings object to display request/response timing information
       * as defined in HAR 1.2 spec.
       * See the `request-timings` element documentation for more
       * information.
       */
      timings: { type: Object },
      /**
       * If true it means that the request has been made by the basic
       * transport and advanced details of the request/response like
       * redirects, timings, source message are not available.
       * It this case it will hide unused tabs.
       */
      isXhr: { type: Boolean },
      /**
       * True if the element is expanded
       */
      opened: { type: Boolean },
      /**
       * A request URL that has been used to make a request
       */
      requestUrl: { type: String },
      /**
       * A HTTP method used to make a request.
       */
      requestMethod: { type: String },
      /**
       * Renders mobile frinedly view
       */
      narrow: { type: Boolean },
      /**
       * Icon prefix from the svg icon set. This can be used to replace the set
       * without changing the icon.
       *
       * Defaults to `arc`.
       */
      iconPrefix: { type: String }
    };
  }

  get statusCode() {
    return this._statusCode;
  }

  set statusCode(value) {
    const old = this._statusCode;
    if (old === value) {
      return;
    }
    if (!value) {
      value = 0;
    }
    this._statusCode = value;
    this.requestUpdate('statusCode', old);
    this._statusCodeChanged();
  }

  get statusMessage() {
    return this._statusMessage;
  }

  set statusMessage(value) {
    const old = this._statusMessage;
    if (old === value) {
      return;
    }
    if (!value) {
      value = 0;
    }
    this._statusMessage = value;
    this.requestUpdate('statusMessage', old);
    this._statusCodeChanged();
  }

  get responseError() {
    return this._responseError;
  }

  set responseError(value) {
    const old = this._responseError;
    if (old === value) {
      return;
    }
    this._responseError = value;
    this.requestUpdate('responseError', old);
    if (value && this.opened) {
      this.opened = false;
    }
  }

  get isXhr() {
    return this._isXhr;
  }

  set isXhr(value) {
    const old = this._isXhr;
    if (old === value) {
      return;
    }
    this._isXhr = value;
    this.requestUpdate('isXhr', old);
    this._isXhrChanged(value);
  }

  get opened() {
    return this._opened;
  }

  set opened(value) {
    const old = this._opened;
    if (old === value) {
      return;
    }
    this._opened = value;
    this.requestUpdate('opened', old);
    if (value) {
      this.setAttribute('aria-expanded', 'true');
    } else {
      this.setAttribute('aria-expanded', 'false');
    }
  }

  constructor() {
    super();
    this.loadingTime = 0;
    this.selectedTab = 0;
    this.opened = false;
    this.iconPrefix = 'arc';
  }

  connectedCallback() {
    /* istanbul ignore else */
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.statusCode) {
      this._statusCodeChanged();
    }
  }

  _statusCodeChanged() {
    setTimeout(() => this.assignStatusMessage());
  }
  /**
   * Computes CSS class for the badge in the tabs.
   * If passed `input` is string it only check if string is not empty.
   * Otherwise it checks if passed value is !== 0.
   *
   * @param {String|Number} input String or number to check.
   * @return {String} Computed class name for this badge.
   */
  _computeBageClass(input) {
    const cls = 'badge';
    const clsEmpty = cls + ' empty';
    if (input === undefined) {
      return clsEmpty;
    }
    if (typeof input === 'string') {
      return input ? cls : clsEmpty;
    }
    return input === 0 ? clsEmpty : cls;
  }
  /**
   * Compute size of the HTTP headers.
   * Note, it only checks for number of lines. It doeasn't check if each line
   * contains string.
   *
   * @param {String} headers The headers strings to count.
   * @return {Number} Size of the headers in passed string.
   */
  _computeHeadersLength(headers) {
    if (!headers) {
      return 0;
    }
    return headers.split('\n').length;
  }

  _roundTime(num) {
    num = Number(num);
    if (num !== num) {
      return '';
    }
    return num.toFixed(2);
  }
  // Toggles collapsable element.
  toggleCollapse() {
    this.opened = !this.opened;
  }
  // Computes class for the toggle's button icon.
  _computeToggleIconClass(opened) {
    let clazz = 'toggle-icon';
    if (opened) {
      clazz += ' opened';
    }
    return clazz;
  }
  /**
   * Runs status text recognition after ~100 ms to ensure a status message
   * is displayed even if there wasn't any.
   */
  assignStatusMessage() {
    if (this.statusMessage) {
      return;
    }
    this.statusMessage = StatusMessage.getMessage(this.statusCode);
  }
  /**
   * Resets current tab when isXhr is true.
   * @param {Boolean} value current state of `isXhr`
   */
  _isXhrChanged(value) {
    if (value === undefined) {
      return;
    }
    if (value && this.selectedTab > 1) {
      this.selectedTab = 0;
    }
    const tabs = this.shadowRoot.querySelector('anypoint-tabs');
    if (!tabs) {
      return;
    }
    tabs.notifyResize();
  }
  /**
   * A handler for the selection change on the anypoint-tabs elemet.
   * @param {CustomEvent} e
   */
  _tabChangeHandler(e) {
    this.selectedTab = e.detail.value;
  }
  /**
   * Computes icon name depending on `opened` state
   * @param {String} iconName
   * @return {String}
   */
  _computeIcon(iconName) {
    let icon = '';
    if (this.iconPrefix) {
      icon = this.iconPrefix + ':';
    }
    return icon + iconName;
  }
}
window.customElements.define('response-status-view', ResponseStatusView);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* eslint-disable max-len */
/**
 * A view for the response error.
 *
 * The element displays predefined error message with icon and depending on the
 * `message` property it will display custom message or a predefined explanation
 * if the message is one of the Chrome's network errors (net::*).
 *
 * If the `message` property is not set then a defaulot message will be displayed.
 *
 * ### Examples
 *
 * #### Custom message
 *
 * ```html
 * <response-error-view message="Unable to run the request"></response-error-view>
 * ```
 *
 * ### predefined message (chrome network error)
 *
 * ```html
 * <response-error-view message="net::ERR_BAD_SSL_CLIENT_AUTH_CERT"></response-error-view>
 * <response-error-view message="net::ERR_CONNECTION_REFUSED"></response-error-view>
 * ```
 *
 * ## Predefined messages
 * - Request aborted
 * - net::ERR_CERT_AUTHORITY_INVALID
 * - net::ERR_CONNECTION_REFUSED
 * - net::ERR_CERT_COMMON_NAME_INVALID
 * - net::ERR_ADDRESS_UNREACHABLE
 * - net::ERR_BAD_SSL_CLIENT_AUTH_CERT
 * - net::ERR_BLOCKED_BY_ADMINISTRATOR
 * - net::ERR_BLOCKED_BY_CLIENT
 * - net::ERR_BLOCKED_ENROLLMENT_CHECK_PENDING
 * - net::ERR_CERT_CONTAINS_ERRORS
 * - net::ERR_CERT_DATE_INVALID
 * - net::ERR_CERT_END
 * - net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION
 * - net::ERR_CERT_INVALID
 * - net::ERR_CERT_NAME_CONSTRAINT_VIOLATION
 * - net::ERR_CERT_NON_UNIQUE_NAME
 * - net::ERR_CERT_NO_REVOCATION_MECHANISM
 * - net::ERR_CERT_REVOKED
 * - net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION
 * - net::ERR_CERT_VALIDITY_TOO_LONG
 * - net::ERR_CERT_WEAK_KEY
 * - net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM
 * - net::ERR_CONNECTION_CLOSED
 * - net::ERR_CONNECTION_RESET
 * - net::ERR_CONNECTION_FAILED
 * - net::ERR_CONNECTION_REFUSED
 * - net::ERR_CONNECTION_TIMED_OUT
 * - net::ERR_CONTENT_LENGTH_MISMATCH
 * - net::ERR_INCOMPLETE_CHUNKED_ENCODING
 * - net::ERR_FILE_NOT_FOUND
 * - net::ERR_ICANN_NAME_COLLISION
 * - net::ERR_INTERNET_DISCONNECTED
 * - net::ERR_NAME_NOT_RESOLVED
 * - net::ERR_NAME_RESOLUTION_FAILED
 * - net::ERR_NETWORK_ACCESS_DENIED
 * - net::ERR_NETWORK_CHANGED
 * - net::ERR_NETWORK_IO_SUSPENDED
 * - net::ERR_PROXY_CONNECTION_FAILED
 * - net::ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION
 * - net::ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH
 * - net::ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION
 * - net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION
 * - net::ERR_SSL_PROTOCOL_ERROR
 * - net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN
 * - net::ERR_SSL_SERVER_CERT_BAD_FORMAT
 * - net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH
 * - net::ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY
 * - net::ERR_TEMPORARY_BACKOFF
 * - net::ERR_TIMED_OUT
 * - net::ERR_TOO_MANY_REDIRECTS
 *
 * ### Styling
 * The styling is consistent with the `error-message` element styling options.
 *
 * `<response-error-view>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--response-error-view` | Mixin applied to the element | `{}`
 * `--error-message-icon-color` | Color of the icon | `rgba(0, 0, 0, 0.56)`
 * `--error-message-icon` | Mixin apllied to the icon | `{}`
 * `--arc-font-subhead` | Theme mixin, applied to the predefined description message. | `{}`
 * `--error-message-color` | Color of the predefined description message | `#db4437`
 * `--error-message-text` | Mixin applied ot the predefined description message | `{}`
 * `--error-message-code-color` | Color of the message passed to the element. It's meant to be a less visible information and probably define an error code. | `#9e9e9e`
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 */
class ResponseErrorView extends LitElement {
  static get styles() {
    return css`
      :host {
        display: flex;
        flex-direction: column;
        flex: 1;
        flex-basis: 0.000000001px;
        user-select: text;
        margin: 0 16px;
      }

      .message-wrapper {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      .error-icon {
        width: 128px;
        height: 128px;
        color: var(--error-message-icon-color, rgba(0, 0, 0, 0.56));
      }

      .error-desc {
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
        color: var(--error-message-color, #db4437);
      }

      .error-code {
        color: var(--error-message-code-color, #9e9e9e);
      }

      .inherit {
        color: inherit !important;
        background-color: inherit !important;
        text-decoration: inherit !important;
      }

      p,
      h3 {
        cursor: text;
      }
    `;
  }

  _renderPageTemplate(selected, message) {
    switch (selected) {
      case 0:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service might be temporarily down or it may have moved permanently to a new web address.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 1:
        return html`
          <section>
            <h3>Install self signed certificate in Chrome</h3>
            <p>The app can't work if the self-signed certificate is not installed in Chrome.</p>
            <a
              class="inherit"
              href="http://restforchrome.blogspot.co.uk/2016/04/advanced-rest-client.html"
              target="_blank"
            >
              <anypoint-button emphasis="high" tabindex="-1">Tell me more</anypoint-button>
            </a>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 2:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service refused to connect.</p>
            <p>
              Please, check if:
            </p>
            <ul>
              <li>you and remote machine are connected to the internet,</li>
              <li>all required services (like www) are up and running on server</li>
              <li>port number is correct</li>
              <li>url is correct</li>
            </ul>
            <p>
              Search Google for
              <a href="https://www.google.com/search?q=chrome%20network%20error%20102" target="_blank"
                >chrome network error 102</a
              >
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 3:
        return html`
          <section>
            <h3>Certificate is invalid for given domain</h3>
            <p>Certificate presented to the app has different CN (common name) than the domain of the request.</p>
            <p>
              Please, generate certificate again with valid domain name or use free certificate service like
              <a href="https://letsencrypt.org/" target="_blank">letsencrypt.org</a> to get a new certificate.
            </p>
            <a
              class="inherit"
              href="http://restforchrome.blogspot.co.uk/2016/04/advanced-rest-client.html"
              target="_blank"
            >
              <anypoint-button emphasis="high" tabindex="-1">Tell me more</anypoint-button>
            </a>
            <a class="inherit" href="https://bugs.chromium.org/p/chromium/issues/detail?id=603104" target="_blank">
              <anypoint-button emphasis="high" tabindex="-1">See CR bug</anypoint-button>
            </a>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 4:
        return html`
          <section>
            <h3>Abort / timeout</h3>
            <p>
              The request has been aborted manually or because of the conection timeout. There were no response from the
              server but the connection wasn't closed.
            </p>
            <p>You can adjust timeout in settings.</p>
            <p>
              Try to:
            </p>
            <ul>
              <li>
                add "Connection: close" header which should be used by the server to close the connection after it
                finish generating response
              </li>
            </ul>
            <p>
              Please, check if:
            </p>
            <ul>
              <li>all required services (like www) are up and running on server</li>
              <li>method is correct</li>
              <li>port number is correct</li>
              <li>url is correct</li>
              <li>all required headers and/or payload has been added to the request</li>
            </ul>
            <h4>Example</h4>
            <p>
              Sometimes it may happen when you use <b>http</b> protocol instead of <b>https</b>. Also it may happen when
              you use different URL (port / protocol) and the server is not configured properly.
            </p>
          </section>
        `;
      case 5:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service is unreachable.</p>
            <p>
              Search Google for
              <a href="https://www.google.com/search?q=chrome%20network%20error%20109" target="_blank"
                >chrome network error 109</a
              >
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 6:
        return html`
          <section>
            <h3>The requested URL cant provide a secure connection</h3>
            <p><b>The URL</b> didnt accept your login certificate or your login certificate may have expired.</p>
            <p>Try contacting the system admin.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 7:
        return html`
          <section>
            <h3>The URL is blocked</h3>
            <p>The person who set up this computer has chosen to block this site.</p>
            <p>Try contacting the system admin.</p>
            <p><b>Check your administrator's policies</b></p>
            <p>
              Visit <b>chrome://policy</b> to see the list of blacklisted URLs and other policies enforced by your
              system administrator.
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 8:
        return html`
          <section>
            <h3>The URL is blocked</h3>
            <p>Requests to the server have been blocked by an extension.</p>
            <p>Try</p>
            <ul>
              <li>Again...</li>
              <li>Disabling your extensions</li>
            </ul>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 9:
        return html`
          <section>
            <h3>There is no Internet connection</h3>
            <p>Chrome OS hasnt completed its initial setup.</p>
            <ul>
              <li>
                Fix your connection using the
                <a href="data:text/html,chromewebdata#buttons" target="_blank">diagnostics app</a>
              </li>
              <li>Sign out and complete setup</li>
            </ul>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 10:
        return html`
          <section>
            <h3>Certificate error</h3>
            <p>Certificate presented to the app is invalid.</p>
            <p>
              Please, generate certificate again or use free certificate service like
              <a href="https://letsencrypt.org/" target="_blank">letsencrypt.org</a> to get a new certificate.
            </p>
            <a
              class="inherit"
              href="http://restforchrome.blogspot.co.uk/2016/04/advanced-rest-client.html"
              target="_blank"
            >
              <anypoint-button emphasis="high" tabindex="-1">Tell me more</anypoint-button>
            </a>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 11:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service unexpectedly closed the connection.</p>
            <p>Try</p>
            <ul>
              <li>Again...</li>
              <li>Checking the connection</li>
              <li>Checking the proxy and the firewall</li>
            </ul>
            <p class="error-code">${message}</p>
            <p><b>Check your Internet connection</b></p>
            <p>Check any cables and reboot any routers, modems or other network devices you may be using.</p>
            <p><b>Allow Chrome to access the network in your firewall or antivirus settings.</b></p>
            <p>
              If it is already listed as a program allowed to access the network, try removing it from the list and
              adding it again.
            </p>
            <p><b>If you use a proxy server...</b></p>
            <p>
              Check your proxy settings or contact your network administrator to make sure that the proxy server is
              working. If you don't believe you should be using a proxy server: Go to the Chrome menu &gt; Settings &gt;
              + Show advanced settings &gt; Change proxy settings... and make sure your configuration is set to "no
              proxy" or "direct."
            </p>
          </section>
        `;
      case 12:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service is unreachable.</p>
            <p>
              Search Google for
              <a href="https://www.google.co.uk/search?q=chrome%20network%20error%20104" target="_blank"
                >chrome network error 104</a
              >
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 13:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service took too long to respond.</p>
            <p>
              Search Google for
              <a href="https://www.google.com/search?q=chrome%20network%20error%20118" target="_blank"
                >chrome network error 118</a
              >
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 14:
        return html`
          <section>
            <h3>The requested URL isnt working</h3>
            <p>The service unexpectedly closed the connection.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 15:
        return html`
          <section>
            <h3>The requested URL was not found</h3>
            <p>It may have been moved or deleted.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 16:
        return html`
          <section>
            <h3>The requested URL cant be reached</h3>
            <p>This site on the company, organisation or school intranet has the same URL as an external website.</p>
            <p>Try contacting your system administrator.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 17:
        return html`
          <section>
            <h3>There is no Internet connection</h3>
            <p>Your computer is offline.</p>
            <p>Try:</p>
            <ul>
              <li>Checking the network cable or router</li>
              <li>Resetting the modem or router</li>
              <li>Reconnecting to Wi-Fi</li>
            </ul>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 18:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service's server DNS address could not be found.</p>
            <p>
              Search Google for
              <a href="https://www.google.com/search?q=chrome%20network%20error%20105" target="_blank"
                >chrome network error 105</a
              >
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 19:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service might be temporarily down or it may have moved permanently to a new web address.</p>
            <p>
              Search Google for
              <a href="https://www.google.com/search?q=chrome%20network%20error%20137" target="_blank"
                >chrome network error 137</a
              >
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 20:
        return html`
          <section>
            <h3>Your Internet access is blocked</h3>
            <p>Firewall or antivirus software may have blocked the connection.</p>
            <p>Try:</p>
            <ul>
              <li>Checking the connection</li>
              <li>Checking firewall and antivirus configurations</li>
            </ul>
            <p class="error-code">${message}</p>
            <p><b>Check your Internet connection</b></p>
            <p>Check any cables and reboot any routers, modems or other network devices you may be using.</p>
            <p><b>Allow Chrome to access the network in your firewall or antivirus settings</b></p>
            <p>
              If it is already listed as a program allowed to access the network, try removing it from the list and
              adding it again.
            </p>
          </section>
        `;
      case 21:
        return html`
          <section>
            <h3>Your connection was interrupted</h3>
            <p>A network change was detected.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 22:
        return html`
          <section>
            <h3>Your connection was interrupted</h3>
            <p>Your computer went to sleep. Zzzzzzz.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 23:
        return html`
          <section>
            <h3>There is no Internet connection</h3>
            <p>There is something wrong with the proxy server or the address is incorrect.</p>
            <p>Try:</p>
            <ul>
              <li>Checking the proxy address</li>
              <li>Contacting the system admin</li>
            </ul>
            <p class="error-code">${message}</p>
            <p><b>If you use a proxy server...</b></p>
            <p>
              Check your proxy settings or contact your network administrator to make sure that the proxy server is
              working. If you don't believe you should be using a proxy server: Go to the Chrome menu &gt; Settings &gt;
              + Show advanced settings &gt; Change proxy settings... and make sure your configuration is set to "no
              proxy" or "direct."
            </p>
          </section>
        `;
      case 24:
        return html`
          <section>
            <h3>The requested URL isnt working</h3>
            <p>The service sent an invalid response.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 25:
        return html`
          <section>
            <h3>The requested URL cant provide a secure connection</h3>
            <p><b>The URL</b> sent an invalid response.</p>
            <p>
              <a href="https://support.google.com/chrome?p=ir_ssl_error" target="_blank">Learn more</a> about this
              problem.
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 26:
        return html`
          <section>
            <h3>The requested URL cant provide a secure connection</h3>
            <p>
              The server presented a certificate that doesn't match built-in expectations. These expectations are
              included for certain, high-security websites in order to protect you.
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 27:
        return html`
          <section>
            <h3>The requested URL cant provide a secure connection</h3>
            <p>The server doesn't adhere to security standards.</p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 28:
        return html`
          <section>
            <h3>The requested URL cant provide a secure connection</h3>
            <p>The server uses an unsupported protocol.</p>
            <p class="error-code">${message}</p>
            <p><b>Unsupported protocol</b></p>
            <p>
              The client and server don't support a common SSL protocol version or cipher suite. This is likely to be
              caused when the server needs RC4, which is no longer considered secure.
            </p>
          </section>
        `;
      case 29:
        return html`
          <section>
            <h3>The requested URL cant provide a secure connection</h3>
            <p>The server doesn't adhere to security standards.</p>
            <p>
              <a href="https://support.google.com/chrome?p=dh_error&amp;" target="_blank">Learn more</a> about this
              problem.
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 30:
        return html`
          <section>
            <h3>Access to network-error was denied</h3>
            <p>
              The server hosting the web page might be overloaded or under maintenance. In order to avoid generating too
              much traffic and make the situation worse, requests to this URL have been temporarily disallowed.
            </p>
            <p class="error-code">${message}</p>
          </section>
        `;
      case 31:
        return html`
          <section>
            <h3>The requested URL can't be reached</h3>
            <p>The service took too long to respond.</p>
            <p>Try</p>
            <ul>
              <li>Again...</li>
              <li>Checking the connection</li>
              <li>Checking the proxy and the firewall</li>
            </ul>
            <p class="error-code">${message}</p>
            <p><b>Check your Internet connection</b></p>
            <p>Check any cables and reboot any routers, modems or other network devices you may be using.</p>
            <p><b>Allow the browser to access the network in your firewall or antivirus settings.</b></p>
            <p>
              If it is already listed as a program allowed to access the network, try removing it from the list and
              adding it again.
            </p>
            <p><b>If you use a proxy server...</b></p>
            <p>
              Check your proxy settings or contact your network administrator to make sure that the proxy server is
              working. If you don't believe you should be using a proxy server: Go to the Chrome menu &gt; Settings &gt;
              + Show advanced settings &gt; Change proxy settings... and make sure your configuration is set to "no
              proxy" or "direct."
            </p>
          </section>
        `;
      case 32:
        return html`
          <section>
            <h3>The requested URL isnt working</h3>
            <p>The service redirected you too many times.</p>
            <p>Try</p>
            <ul>
              <li>Again...</li>
              <li>Clearing your cookies</li>
            </ul>
            <p class="error-code">${message}</p>
            <p><b>Clearing your cookies</b></p>
            <p>Go to app's settings and click on "Clear cookies".</p>
          </section>
        `;
    }
  }

  render() {
    const { icon, detailsPage, message } = this;
    return html`
      <div class="message-wrapper">
        <div>
          <iron-icon class="error-icon" .icon="${icon}"></iron-icon>
        </div>
        <div class="error-desc">
          ${this._renderPageTemplate(detailsPage, message)}
        </div>
      </div>
    `;
  }

  static get properties() {
    return {
      /**
       * Message to display.
       *
       * The message can be one of the Chrome's net::* error codes. In this
       * case the element will display predefined message.
       */
      message: { type: String },
      /**
       * An icon to display.
       */
      icon: { type: String },
      // Opened detailed message page.
      detailsPage: { type: Number }
    };
  }

  get message() {
    return this._message;
  }

  set message(value) {
    const old = this._message;
    if (old === value) {
      return;
    }
    this.requestUpdate('message', old);
    this._messageChanged(value);
  }

  constructor() {
    super();
    this.icon = 'arc:sentiment-very-dissatisfied';
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.detailsPage === undefined) {
      this.detailsPage = 0;
    }
  }

  // handler to the message change event.
  _messageChanged(msg) {
    if (msg) {
      msg = msg.trim();
    }
    switch (msg) {
      case 'net::ERR_CERT_AUTHORITY_INVALID':
        this.detailsPage = 1;
        break;
      case 'net::ERR_CONNECTION_REFUSED':
        this.detailsPage = 2;
        break;
      case 'net::ERR_CERT_COMMON_NAME_INVALID':
        this.detailsPage = 3;
        break;
      case 'Request aborted':
        this.detailsPage = 4;
        break;
      case 'net::ERR_ADDRESS_UNREACHABLE':
        this.detailsPage = 5;
        break;
      case 'net::ERR_BAD_SSL_CLIENT_AUTH_CERT':
        this.detailsPage = 6;
        break;
      case 'net::ERR_BLOCKED_BY_ADMINISTRATOR':
        this.detailsPage = 7;
        break;
      case 'net::ERR_BLOCKED_BY_CLIENT':
        this.detailsPage = 8;
        break;
      case 'net::ERR_BLOCKED_ENROLLMENT_CHECK_PENDING':
        this.detailsPage = 9;
        break;
      case 'net::ERR_CERT_CONTAINS_ERRORS':
      case 'net::ERR_CERT_DATE_INVALID':
      case 'net::ERR_CERT_END':
      case 'net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION':
      case 'net::ERR_CERT_INVALID':
      case 'net::ERR_CERT_NAME_CONSTRAINT_VIOLATION':
      case 'net::ERR_CERT_NON_UNIQUE_NAME':
      case 'net::ERR_CERT_NO_REVOCATION_MECHANISM':
      case 'net::ERR_CERT_REVOKED':
      case 'net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION':
      case 'net::ERR_CERT_VALIDITY_TOO_LONG':
      case 'net::ERR_CERT_WEAK_KEY':
      case 'net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM':
        this.detailsPage = 10;
        break;
      case 'net::ERR_CONNECTION_CLOSED':
      case 'net::ERR_CONNECTION_RESET':
        this.detailsPage = 11;
        break;
      case 'net::ERR_CONNECTION_FAILED':
        this.detailsPage = 12;
        break;
      case 'net::ERR_CONNECTION_TIMED_OUT':
        this.detailsPage = 13;
        break;
      case 'net::ERR_CONTENT_LENGTH_MISMATCH':
      case 'net::ERR_INCOMPLETE_CHUNKED_ENCODING':
        this.detailsPage = 14;
        break;
      case 'net::ERR_FILE_NOT_FOUND':
        this.detailsPage = 15;
        break;
      case 'net::ERR_ICANN_NAME_COLLISION':
        this.detailsPage = 16;
        break;
      case 'net::ERR_INTERNET_DISCONNECTED':
        this.detailsPage = 17;
        break;
      case 'net::ERR_NAME_NOT_RESOLVED':
        this.detailsPage = 18;
        break;
      case 'net::ERR_NAME_RESOLUTION_FAILED':
        this.detailsPage = 19;
        break;
      case 'net::ERR_NETWORK_ACCESS_DENIED':
        this.detailsPage = 20;
        break;
      case 'net::ERR_NETWORK_CHANGED':
        this.detailsPage = 21;
        break;
      case 'net::ERR_NETWORK_IO_SUSPENDED':
        this.detailsPage = 22;
        break;
      case 'net::ERR_PROXY_CONNECTION_FAILED':
        this.detailsPage = 23;
        break;
      case 'net::ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION':
      case 'net::ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH':
      case 'net::ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION':
        this.detailsPage = 24;
        break;
      case 'net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION':
      case 'net::ERR_SSL_PROTOCOL_ERROR':
        this.detailsPage = 25;
        break;
      case 'net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN':
        this.detailsPage = 26;
        break;
      case 'net::ERR_SSL_SERVER_CERT_BAD_FORMAT':
        this.detailsPage = 27;
        break;
      case 'net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH':
        this.detailsPage = 28;
        break;
      case 'net::ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY':
        this.detailsPage = 29;
        break;
      case 'net::ERR_TEMPORARY_BACKOFF':
        this.detailsPage = 30;
        break;
      case 'net::ERR_TIMED_OUT':
        this.detailsPage = 31;
        break;
      case 'net::ERR_TOO_MANY_REDIRECTS':
        this.detailsPage = 32;
        break;
      default:
        this.detailsPage = 0;
        break;
    }
  }
}
window.customElements.define('response-error-view', ResponseErrorView);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element to display the raw response data without syntax highlighting.
 *
 * ### Example
 *
 * ```html
 * <response-raw-viewer responsetext="Some response"></response-raw-viewer>
 * <script>
 * const display = document.querySelector('response-raw-viewer');
 * display.responseText = someResponse;
 * < /script>
 * ```
 *
 * ## Content actions
 *
 * Custom actions can be defined by adding a child with `slot="content-action"`
 * attribute set. Eny element will be rendered in content action field.
 *
 * ### Example
 *
 * ```html
 * <response-raw-viewer>
 *  <paper-icon-button slot="content-action"
 *    title="Copy content to clipboard" icon="arc:content-copy"></paper-icon-button>
 * </response-raw-viewer>
 * ```
 *
 * See demo for more examples.
 *
 * ## Content text wrapping
 *
 * Set `wraptext` attribute on the element to force the wiewer to wrap text.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin PayloadParserMixin
 */
class ResponseRawViewer extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
      overflow: overlay;
      width: 100%;
    }

    .raw-content {
      font-family: var(--arc-font-code-family);
      user-select: text;
      white-space: pre;
      width: 100%;
      min-height: 52px;
      display: block;
      overflow: auto;
      max-width: 100%;
      margin: 12px 0;
    }

    .raw-content[tabindex="-1"] {
      outline: none;
    }

    :host([wraptext]) .raw-content {
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .actions-panel {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    .actions-panel.hidden {
      display: none;
    }

    .no-info {
      font-style: var(--no-info-message-font-style, italic);
      font-size: var(--no-info-message-font-size, 16px);
      color: var(--no-info-message-color, rgba(0, 0, 0, 0.74));
    }`;
  }

  render() {
    const {
      _actionsPanelClass,
      responseText,
      wrapText
    } = this;
    const tabIndex = wrapText ? '-1' : '0';
    return html`
    <div class="${_actionsPanelClass}">
      <slot name="content-action"></slot>
    </div>
    ${responseText ?
      html`<code class="raw-content" tabindex="${tabIndex}">${this._responseValue(responseText)}</code>`:
      html`<p class="no-info">Nothing to display.</p>`}`;
  }

  static get properties() {
    return {
      /**
       * The response text to display.
       */
      responseText: { type: String },
      // If set to true then the text in the panel will be wrapped.
      wrapText: { type: Boolean, reflect: true }
    };
  }

  get _actionsPanelClass() {
    let klas = 'actions-panel';
    if (!this.responseText) {
      klas += ' hidden';
    }
    return klas;
  }
  /**
   * ARC stores workspace data with response object in a file.
   * It may happen that the data is a buffer when saving. This restores
   * the string if needed.
   * @param {String|Object} response Usually string response but may be
   * ARC converted object.
   * @return {String} Safe to process string.
   */
  _responseValue(response) {
    if (!response) {
      return response;
    }
    if (typeof response === 'string') {
      return response;
    }
    if (response.type === 'Buffer') {
      let str = '';
      for (let i = 0, len = response.data.length; i < len; i++) {
        str += String.fromCharCode(response.data[i]);
      }
      return str;
    }
    return '';
  }
}
window.customElements.define('response-raw-viewer', ResponseRawViewer);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* eslint-disable max-len */
class JsMaxNumberError extends LitElement {
  static get styles() {
    return css`:host {
      display: inline-block;
      vertical-align: text-bottom;
    }

    .parsed-value ::slot > * {
      color: #D32F2F;
      font-weight: 500;
    }

    .content {
      display: flex;
      flex-direction: row;
      align-items: center;
      color: #D32F2F;
      font-weight: 500;
      cursor: pointer;
    }

    iron-icon {
      height: 18px;
      width: 18px;
      margin-right: 8px;
    }

    #collapse {
      white-space: initial;
      font-size: var(--arc-font-body2-font-size);
      font-weight: var(--arc-font-body2-font-weight);
      line-height: var(--arc-font-body2-line-height);
      color: rgba(0, 0, 0, 0.74);
    }

    p {
      margin: 0;
    }

    .message {
      padding: 12px;
      background-color: #FFECB3;
      margin: 12px 24px;
    }

    .expected {
      font-weight: 700;
    }`;
  }


  render() {
    return html`
    <div class="content" @click="${this.toggle}">
      <iron-icon icon="arc:info"></iron-icon>
      <div class="parsed-value">
        <slot></slot>
      </div>
    </div>
    <iron-collapse>
      <div class="message">
        <p>The number used in the response is unsafe in JavaScript environment and therefore as a JSON value.</p>
        <p>Original value for the number (represented as string) is <span class="expected">"${this.expectedNumber}"</span></p>
        <p>This number will not work in web environment and should be passed as a string, not a number.</p>
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" target="_blank">Read more about numbers in JavaScript</a>.</p>
      </div>
    </iron-collapse>`;
  }

  static get properties() {
    return {
      // A number that is expected to be true.
      expectedNumber: { type: String }
    };
  }

  constructor() {
    super();
    this.expectedNumber = '[unknown]';
    this._keyDown = this._keyDown.bind(this);
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.setAttribute('role', 'button');
    this.setAttribute('tabindex', 0);
    this.setAttribute('aria-expanded', 'false');
    this.setAttribute('aria-label', 'Activate to see warning details');
    this.addEventListener('keydown', this._keyDown);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    this.removeEventListener('keydown', this._keyDown);
  }

  // Toggles the collapse element.
  toggle() {
    const node = this.shadowRoot.querySelector('iron-collapse');
    node.toggle();
    if (node.opened) {
      this.setAttribute('aria-expanded', 'true');
    } else {
      this.setAttribute('aria-expanded', 'false');
    }
  }

  _keyDown(e) {
    if (e.code === 'Enter' || e.code === 'NumpadEnter' || e.code === 'Space') {
      e.preventDefault();
      this.toggle();
    }
  }
}
window.customElements.define('js-max-number-error', JsMaxNumberError);

const SafeHtmlUtils$1 = {
  AMP_RE: new RegExp(/&/g),
  GT_RE: new RegExp(/>/g),
  LT_RE: new RegExp(/</g),
  SQUOT_RE: new RegExp(/'/g),
  QUOT_RE: new RegExp(/"/g),
  htmlEscape: function(s) {
    if (s.indexOf('&') !== -1) {
      s = s.replace(SafeHtmlUtils$1.AMP_RE, '&amp;');
    }
    if (s.indexOf('<') !== -1) {
      s = s.replace(SafeHtmlUtils$1.LT_RE, '&lt;');
    }
    if (s.indexOf('>') !== -1) {
      s = s.replace(SafeHtmlUtils$1.GT_RE, '&gt;');
    }
    if (s.indexOf('"') !== -1) {
      s = s.replace(SafeHtmlUtils$1.QUOT_RE, '&quot;');
    }
    if (s.indexOf('\'') !== -1) {
      s = s.replace(SafeHtmlUtils$1.SQUOT_RE, '&#39;');
    }
    return s;
  }
};

class JsonParser {
  constructor(opts) {
    this.rawData = opts.raw || '';
    this.cssPrefix = opts.cssPrefix || '';
    this._numberIndexes = {}; // Regexp number indexes
    this.jsonValue = null;
    this.latestError = null;
    this.elementsCounter = 0;
    this._setJson(opts.json);
    this.hasPerformanceApi = typeof performance !== 'undefined';
  }

  _setJson(jsonData) {
    if (typeof jsonData === 'string') {
      try {
        this.jsonValue = JSON.parse(jsonData);
        if (!this.rawData) {
          this.rawData = jsonData;
        }
      } catch (e) {
        this.latestError = e.message;
      }
    } else {
      this.jsonValue = jsonData;
    }
  }
  /**
   * Get created HTML content.
   * @return {String}
   */
  getHTML() {
    let parsedData = '<div class="' + this.cssPrefix + 'prettyPrint">';
    parsedData += this.parse(this.jsonValue);
    parsedData += '</div>';
    return parsedData;
  }
  /**
   * Parse JSON data
   * @param {*} data
   * @param {Object} opts
   * @return {Stirng}
   */
  parse(data, opts) {
    opts = opts || {};
    let result = '';
    if (data === null) {
      result += this.parseNullValue();
    } else if (typeof data === 'number') {
      result += this.parseNumericValue(data);
    } else if (typeof data === 'boolean') {
      result += this.parseBooleanValue(data);
    } else if (typeof data === 'string') {
      result += this.parseStringValue(data);
    } else if (data instanceof Array) {
      result += this.parseArray(data);
    } else {
      result += this.parseObject(data);
    }
    if (opts.hasNextSibling && !opts.holdComa) {
      result += '<span class="' + this.cssPrefix + 'punctuation dimmed">,</span>';
    }
    return result;
  }

  parseNullValue() {
    let result = '';
    result += '<span class="' + this.cssPrefix + 'nullValue">';
    result += 'null';
    result += '</span>';
    return result;
  }

  parseNumericValue(number) {
    let expectedNumber;
    let max = Number.MAX_SAFE_INTEGER;
    if (!max) {
      max = 9007199254740991;
    }
    if (number > max) { // IE doesn't support Number.MAX_SAFE_INTEGER
      let comp = String(number);
      comp = comp.substr(0, String(max).length);
      const r = new RegExp(comp + '(\\d+),?', 'gim');
      if (comp in this._numberIndexes) {
        r.lastIndex = this._numberIndexes[comp];
      }
      const _result = r.exec(this.rawData);
      if (_result) {
        this._numberIndexes[comp] = _result.index;
        expectedNumber = comp + _result[1];
      }
    }

    let result = '';
    result += '<span class="' + this.cssPrefix + 'numeric">';
    if (expectedNumber) {
      result += '<js-max-number-error class="' + this.cssPrefix +
        'number-error" expectednumber="' + expectedNumber + '">';
    }
    result += number + '';
    if (expectedNumber) {
      result += '</js-max-number-error>';
    }
    result += '</span>';
    return result;
  }

  parseBooleanValue(bool) {
    let result = '';
    result += '<span class="' + this.cssPrefix + 'booleanValue">';
    if (bool !== null && bool !== undefined) {
      result += bool + '';
    } else {
      result += 'null';
    }
    result += '</span>';
    return result;
  }

  parseStringValue(str) {
    let result = '';
    let value = str || '';
    if (value !== null && value !== undefined) {
      value = SafeHtmlUtils$1.htmlEscape(value);
      if (value.slice(0, 1) === '/' || value.substr(0, 4) === 'http') {
        value = '<a class="' + this.cssPrefix + '" title="Click to insert into URL field" ' +
          'response-anchor add-root-url href="' + value + '">' + value + '</a>';
      }
    } else {
      value = 'null';
    }
    result += '&quot;';
    result += '<span class="' + this.cssPrefix + 'stringValue">';
    result += value;
    result += '</span>';
    result += '&quot;';
    return result;
  }

  parseObject(object) {
    let result = '';
    result += '{';
    result += '<div collapse-indicator class="' + this.cssPrefix + 'info-row">...</div>';
    Object.keys(object).forEach((key, i, arr) => {
      const value = object[key];
      const lastSibling = (i + 1) === arr.length;
      const parseOpts = {
        hasNextSibling: !lastSibling
      };
      if (value instanceof Array) {
        parseOpts.holdComa = true;
      }
      const elementNo = this.elementsCounter++;
      const data = this.parse(value, parseOpts);
      const hasManyChildren = this.elementsCounter - elementNo > 1;
      result += '<div data-element="' + elementNo + '" style="margin-left: 24px" class="' +
        this.cssPrefix + 'node">';
      const _nan = isNaN(key);
      if (_nan) {
        result += '&quot;';
      }
      result += this.parseKey(key);
      if (_nan) {
        result += '&quot;';
      }
      result += ': ' + data;
      if (hasManyChildren) {
        result += '<div data-toggle="' + elementNo + '" class="' + this.cssPrefix +
          'rootElementToggleButton"></div>';
      }
      result += '</div>';
    });
    result += '}';
    return result;
  }

  parseArray(array) {
    const cnt = array.length;
    let result = '';
    result += '<span class="' + this.cssPrefix + 'punctuation dimmed">[</span>';
    result += '<span class="' + this.cssPrefix + 'array-counter brace punctuation" count="' +
      cnt + '"></span>';
    for (let i = 0; i < cnt; i++) {
      const elementNo = this.elementsCounter++;

      const lastSibling = (i + 1) === cnt;
      const data = this.parse(array[i], {
        hasNextSibling: !lastSibling
      });
      const hasManyChildren = this.elementsCounter - elementNo > 1;
      result += '<div data-element="' + elementNo +
        '" style="margin-left: 24px" class="' + this.cssPrefix + 'node">';
      result += '<span class="' + this.cssPrefix + 'array-key-number" index="' + i +
        '"> &nbsp;</span>';
      result += data;
      if (hasManyChildren) {
        result += '<div data-toggle="' + elementNo + '" class="' + this.cssPrefix +
          'rootElementToggleButton"></div>';
      }
      result += '</div>';
    }
    result += '<span class="' + this.cssPrefix + 'punctuation dimmed">],</span>';
    return result;
  }

  parseKey(key) {
    let result = '';
    result += '<span class="' + this.cssPrefix + 'key-name">' + key + '</span>';
    return result;
  }
}

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * `<json-viewer>` A JSON payload viewer for the JSON response.
 *
 * This element uses a web worker to process the JSON data.
 * To simplify our lives and app build process the worker script is embeded in the
 * imported template body. It will extract worker data from it and create the
 * worker. Otherwise build process would need to incude a worker script file
 * into set path which is not very programmer friendly.
 *
 * ### Example
 *
 * ```html
 * <json-viewer json='{"json": "test"}'></json-viewer>
 * ```
 *
 * ## Custom search
 *
 * If the platform doesn't support native text search, this element implements
 * `ArcBehaviors.TextSearchBehavior` and exposes the `query` attribute.
 * Set any text to the `query` attribute and it will automatically highlight
 * occurance of the text.
 * See demo for example.
 *
 * ## Big numbers in JavaScript
 *
 * This element marks all numbers that are above `Number.MAX_SAFE_INTEGER` value
 * and locates the numeric value in source json if passed json was a string or
 * when `raw` attribute was set. In this case it will display a warning and
 * explanation about use of big numbers in JavaScript.
 * See js-max-number-error element documentation for more information.
 *
 * ## Content actions
 *
 * The element can render a actions pane above the code view. Action pane is to
 * display content actions that is relevan in context of the response displayed
 * below the icon buttons. It should be icon buttons or just buttons added to this
 * view.
 *
 * ```html
 * <json-viewer json='{"json": "test"}'>
 *  <paper-icon-button slot="content-action"
 *    title="Copy content to clipboard" icon="arc:content-copy"></paper-icon-button>
 * </json-viewer>
 * ```
 *
 * ### Styling
 *
 * `<json-viewer>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--json-viewer` | Mixin applied to the element | `{}`
 * `--code-type-null-value-color` | Color of the null value. | `#708`
 * `--code-type-boolean-value-color` | Color of the boolean value | `#708`
 * `--code-punctuation-value-color` | Punctuation color. | `black`
 * `--code-type-number-value-color` | Color of the numeric value | `blue`
 * `--code-type-text-value-color` | Color of the string value. | `#295469`
 * `--code-array-index-color` | Color of the array counter. | `rgb(119, 119, 119)`
 * `--code-type-link-color` | Color of link inserted into the viewer. | `#1976d2`
 * `--json-viewer-node` | Mixin applied to a "node" | `{}`
 * `--code-dimmed-punctuation-opacity` | Value of the opacity on the "dimmed" punctuation | `0.34`
 * `--code-background-color` | Background color of the code area | ``
 *
 * @group UiElements
 * @element json-viewer
 * @demo demo/index.html
 */
class JsonViewer extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
      font-family: var(--arc-font-code-family, monospace);
      font-size: var(--arc-font-code-font-size, 1rem);
      color: inherit;
      cursor: text;
      user-select: text;
    }

    .prettyPrint {
      padding: 8px;
    }

    .stringValue {
      white-space: normal;
      color: var(--code-type-text-value-color, #295469);
    }

    .brace {
      display: inline-block;
    }

    .numeric {
      color: var(--code-type-number-value-color, blue);
    }

    .nullValue {
      color: var(--code-type-null-value-color, #708);
    }

    .booleanValue {
      color: var(--code-type-boolean-value-color, #708);
    }

    .punctuation {
      color: var(--code-punctuation-value-color, black);
    }

    .node {
      position: relative;
      margin-bottom: 4px;
      word-break: break-all;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }

    .array-counter {
      color: gray;
      font-size: 11px;
    }

    .array-counter::before {
      content: "Array[" attr(count) "]";
      user-select: none;
      pointer-events: none;
    }

    *[data-expanded="false"] > .array-counter::before {
      content: "Array[" attr(count) "] ...";
      user-select: none;
      pointer-events: none;
    }

    .array-key-number::before {
      content: "" attr(index) ":";
      user-select: none;
      pointer-events: none;
    }

    .key-name {
      color: var(--code-type-text-value-color, #295469);
    }

    .rootElementToggleButton {
      position: absolute;
      top: 0;
      left: -9px;
      font-size: 14px;
      cursor: pointer;
      font-weight: bold;
      user-select: none;
    }

    .rootElementToggleButton::after {
      content: "-";
    }

    .array-key-number {
      color: var(--code-array-index-color, rgb(119, 119, 119));
    }

    .info-row {
      display: none;
      margin: 0 8px;
      text-indent: 0;
    }

    div[data-expanded="false"] div[collapse-indicator] {
      display: inline-block !important;
    }

    div[data-expanded="false"] div[data-element] {
      display: none !important;
    }

    .arc-search-mark.selected {
      background-color: #ff9632;
    }

    div[data-expanded="false"] .punctuation.dimmed {
      opacity: 0;
    }

    .dimmed {
      opacity: var(--code-dimmed-punctuation-opacity, 0.54);
    }

    a[response-anchor] {
      color: var(--code-type-link-color, #1976d2);
    }

    paper-spinner:not([active]) {
      display: none;
    }

    .actions-panel {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    .actions-panel.hidden {
      display: none;
    }

    [hidden] {
      display: none !important;
    }

    output {
      display: block;
      background-color: var(--code-background-color);
    }`;
  }

  render() {
    const { working, isError, json } = this;
    const showOutput = this._computeShowOutput(working, isError, json);
    return html`<paper-spinner .active="${working}"></paper-spinner>
    ${isError ? html`<div class="error">
      <p>There was an error parsing JSON data</p>
    </div>` : undefined}

    <div class="${this._computeActionsPanelClass(showOutput)}">
      <slot name="content-action"></slot>
    </div>
    <output ?hidden="${!showOutput}" @click="${this._handleDisplayClick}"></output>`;
  }

  static get properties() {
    return {
      /**
       * JSON data to parse and display.
       * It can be either JS object (already parsed string) or string value.
       * If the passed object is a string then JSON.parse function will be
       * used to parse string.
       */
      json: { type: String },
      /**
       * If it's possible, set this property to the JSON string.
       * It will help to handle big numbers that are not parsed correctly by
       * the JSON.parse function. The parser will try to locate the number
       * in the source string and display it in the correct form.
       *
       * P.S.
       * Calling JSON.stringify on a JS won't help here :) Must be source
       * string.
       */
      raw: { type: String },
      /**
       * True if error ocurred when parsing the `json` data.
       * An error message will be displayed.
       */
      _isError: { type: Boolean },
      /**
       * True when JSON is beeing parsed.
       */
      _working: { type: Boolean }
    };
  }

  get isError() {
    return this._isError;
  }

  get _isError() {
    return this.__isError;
  }

  set _isError(value) {
    const old = this.__isError;
    if (old === value) {
      return;
    }
    this.__isError = value;
    this.requestUpdate('_isError', old);
    this.dispatchEvent(new CustomEvent('iserror-changed', {
      detail: {
        value
      }
    }));
  }

  get working() {
    return this._working;
  }

  get _working() {
    return this.__working;
  }

  set _working(value) {
    const old = this.__working;
    if (old === value) {
      return;
    }
    this.__working = value;
    this.requestUpdate('_working', old);
    this.dispatchEvent(new CustomEvent('working-changed', {
      detail: {
        value
      }
    }));
  }

  get json() {
    return this._json;
  }

  set json(value) {
    const old = this._json;
    if (old === value) {
      return;
    }
    this._json = value;
    this._changed(value);
  }

  constructor() {
    super();
    this._isError = false;
    this._working = false;
  }

  firstUpdated() {
    this._isReady = true;
    if (this.json) {
      this._changed(this.json);
    }
  }

  _clearOutput() {
    const node = this.shadowRoot.querySelector('output');
    node.innerHTML = '';
  }

  _writeOutput(text) {
    const node = this.shadowRoot.querySelector('output');
    node.innerHTML = text;
  }

  // Called when `json` property changed. It starts parsing the data.
  _changed(json) {
    if (!this._isReady) {
      return;
    }
    this._isError = false;
    this._clearOutput();
    if (json === undefined) {
      return;
    }
    this._working = true;
    if (json === null) {
      this._printPrimitiveValue('null', 'nullValue');
      return;
    }
    if (json === false || json === true) {
      this._printPrimitiveValue(String(json), 'booleanValue');
      return;
    }
    try {
      const parser = new JsonParser({
        json,
        raw: this.raw,
        cssPrefix: this.nodeName.toLowerCase() + ' style-scope '
      });
      if (parser.latestError !== null) {
        throw new Error(parser.latestError);
      }
      const html = parser.getHTML();
      this._reportResult(html);
    } catch (cause) {
      this._reportError(cause);
    }
  }

  _printPrimitiveValue(value, klas) {
    const html = `<div class="prettyPrint"><span class="${klas}">${value}</span></div>`;
    this._writeOutput(html);
    this._working = false;
    this.dispatchEvent(new CustomEvent('json-viewer-parsed'));
  }

  _reportResult(html) {
    this._writeOutput(html);
    this._isError = false;
    this._working = false;
    this.dispatchEvent(new CustomEvent('json-viewer-parsed'));
  }

  // Called when workr error received.
  _reportError() {
    this._isError = true;
    this._working = false;
    this.dispatchEvent(new CustomEvent('json-viewer-parsed'));
  }
  // Compute if output should be shown.
  _computeShowOutput(working, isError, json) {
    if (working) {
      return false;
    }
    if (isError) {
      return true;
    }
    return typeof json !== 'undefined';
  }
  // Called when the user click on the display area. It will handle view toggle and links clicks.
  _handleDisplayClick(e) {
    if (!e.target) {
      return;
    }

    if (e.target.nodeName === 'A') {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const newEntity = e.ctrlKey || e.metaKey;
      const url = e.target.getAttribute('href');
      if (newEntity) {
        this._dispatchNewRequest(url);
      } else {
        this._dispatchChangeUrl(url);
      }
      return;
    }
    const toggleId = e.target.dataset.toggle;
    if (!toggleId) {
      return;
    }
    const parent = this.shadowRoot.querySelector('div[data-element="' + toggleId + '"]');
    if (!parent) {
      return;
    }
    const expanded = parent.dataset.expanded;
    if (!expanded || expanded === 'true') {
      parent.dataset.expanded = 'false';
    } else {
      parent.dataset.expanded = 'true';
    }
  }

  _dispatchChangeUrl(url) {
    this.dispatchEvent(new CustomEvent('url-change-action', {
      detail: {
        url
      },
      bubbles: true,
      cancelable: true,
      composed: true
    }));
  }

  _dispatchNewRequest(url) {
    this.dispatchEvent(new CustomEvent('request-workspace-append', {
      detail: {
        kind: 'ARC#Request',
        request: { url }
      },
      bubbles: true,
      cancelable: true,
      composed: true
    }));
  }
  /**
   * Computes CSS class for the actions pane.
   *
   * @param {Boolean} showOutput The `showOutput` propety value of the element.
   * @return {String} CSS class names for the panel depending on state of the
   * `showOutput`property.
   */
  _computeActionsPanelClass(showOutput) {
    let clazz = 'actions-panel';
    if (!showOutput) {
      clazz += ' hidden';
    }
    return clazz;
  }
  /**
   * Event called when the user click on the anchor in display area.
   *
   * @event url-change-action
   * @param {String} url The URL handled by this event.
   * @param {Boolean} asNew When true it should be treated as "new tab" action.
   */
  /**
   * Fired when web worker finished work and the data are displayed.
   *
   * @event json-viewer-parsed
   */
}
window.customElements.define('json-viewer', JsonViewer);

Prism.languages.json={property:{pattern:/"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,greedy:!0},string:{pattern:/"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,greedy:!0},comment:/\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,number:/-?\d+\.?\d*(e[+-]?\d+)?/i,punctuation:/[{}[\],]/,operator:/:/,boolean:/\b(?:true|false)\b/,null:{pattern:/\bnull\b/,alias:"keyword"}};

!function(d){function n(n,e){return n=n.replace(/<inner>/g,"(?:\\\\.|[^\\\\\\n\r]|(?:\r?\n|\r)(?!\r?\n|\r))"),e&&(n=n+"|"+n.replace(/_/g,"\\*")),RegExp("((?:^|[^\\\\])(?:\\\\{2})*)(?:"+n+")")}var e="(?:\\\\.|``.+?``|`[^`\r\\n]+`|[^\\\\|\r\\n`])+",t="\\|?__(?:\\|__)+\\|?(?:(?:\r?\n|\r)|$)".replace(/__/g,e),a="\\|?[ \t]*:?-{3,}:?[ \t]*(?:\\|[ \t]*:?-{3,}:?[ \t]*)+\\|?(?:\r?\n|\r)";d.languages.markdown=d.languages.extend("markup",{}),d.languages.insertBefore("markdown","prolog",{blockquote:{pattern:/^>(?:[\t ]*>)*/m,alias:"punctuation"},table:{pattern:RegExp("^"+t+a+"(?:"+t+")*","m"),inside:{"table-data-rows":{pattern:RegExp("^("+t+a+")(?:"+t+")*$"),lookbehind:!0,inside:{"table-data":{pattern:RegExp(e),inside:d.languages.markdown},punctuation:/\|/}},"table-line":{pattern:RegExp("^("+t+")"+a+"$"),lookbehind:!0,inside:{punctuation:/\||:?-{3,}:?/}},"table-header-row":{pattern:RegExp("^"+t+"$"),inside:{"table-header":{pattern:RegExp(e),alias:"important",inside:d.languages.markdown},punctuation:/\|/}}}},code:[{pattern:/(^[ \t]*(?:\r?\n|\r))(?: {4}|\t).+(?:(?:\r?\n|\r)(?: {4}|\t).+)*/m,lookbehind:!0,alias:"keyword"},{pattern:/``.+?``|`[^`\r\n]+`/,alias:"keyword"},{pattern:/^```[\s\S]*?^```$/m,greedy:!0,inside:{"code-block":{pattern:/^(```.*(?:\r?\n|\r))[\s\S]+?(?=(?:\r?\n|\r)^```$)/m,lookbehind:!0},"code-language":{pattern:/^(```).+/,lookbehind:!0},punctuation:/```/}}],title:[{pattern:/\S.*(?:\r?\n|\r)(?:==+|--+)(?=[ \t]*$)/m,alias:"important",inside:{punctuation:/==+$|--+$/}},{pattern:/(^\s*)#+.+/m,lookbehind:!0,alias:"important",inside:{punctuation:/^#+|#+$/}}],hr:{pattern:/(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,lookbehind:!0,alias:"punctuation"},list:{pattern:/(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,lookbehind:!0,alias:"punctuation"},"url-reference":{pattern:/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,inside:{variable:{pattern:/^(!?\[)[^\]]+/,lookbehind:!0},string:/(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,punctuation:/^[\[\]!:]|[<>]/},alias:"url"},bold:{pattern:n("__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__",!0),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^..)[\s\S]+(?=..$)/,lookbehind:!0,inside:{}},punctuation:/\*\*|__/}},italic:{pattern:n("_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_",!0),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^.)[\s\S]+(?=.$)/,lookbehind:!0,inside:{}},punctuation:/[*_]/}},strike:{pattern:n("(~~?)(?:(?!~)<inner>)+?\\2",!1),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^~~?)[\s\S]+(?=\1$)/,lookbehind:!0,inside:{}},punctuation:/~~?/}},url:{pattern:n('!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\t ]+"(?:\\\\.|[^"\\\\])*")?\\)| ?\\[(?:(?!\\])<inner>)+\\])',!1),lookbehind:!0,greedy:!0,inside:{variable:{pattern:/(\[)[^\]]+(?=\]$)/,lookbehind:!0},content:{pattern:/(^!?\[)[^\]]+(?=\])/,lookbehind:!0,inside:{}},string:{pattern:/"(?:\\.|[^"\\])*"(?=\)$)/}}}}),["url","bold","italic","strike"].forEach(function(e){["url","bold","italic","strike"].forEach(function(n){e!==n&&(d.languages.markdown[e].inside.content.inside[n]=d.languages.markdown[n]);});}),d.hooks.add("after-tokenize",function(n){"markdown"!==n.language&&"md"!==n.language||!function n(e){if(e&&"string"!=typeof e)for(var t=0,a=e.length;t<a;t++){var i=e[t];if("code"===i.type){var r=i.content[1],o=i.content[3];if(r&&o&&"code-language"===r.type&&"code-block"===o.type&&"string"==typeof r.content){var l="language-"+r.content.trim().split(/\s+/)[0].toLowerCase();o.alias?"string"==typeof o.alias?o.alias=[o.alias,l]:o.alias.push(l):o.alias=[l];}}else n(i.content);}}(n.tokens);}),d.hooks.add("wrap",function(n){if("code-block"===n.type){for(var e="",t=0,a=n.classes.length;t<a;t++){var i=n.classes[t],r=/language-(.+)/.exec(i);if(r){e=r[1];break}}var o=d.languages[e];if(o){var l=n.content.replace(/&lt;/g,"<").replace(/&amp;/g,"&");n.content=d.highlight(l,o,e);}else if(e&&"none"!==e&&d.plugins.autoloader){var s="md-"+(new Date).valueOf()+"-"+Math.floor(1e16*Math.random());n.attributes.id=s,d.plugins.autoloader.loadLanguages(e,function(){var n=document.getElementById(s);n&&(n.innerHTML=d.highlight(n.textContent,d.languages[e],e));});}}}),d.languages.md=d.languages.markdown;}(Prism);

Prism.languages.yaml={scalar:{pattern:/([\-:]\s*(?:![^\s]+)?[ \t]*[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)[^\r\n]+(?:\2[^\r\n]+)*)/,lookbehind:!0,alias:"string"},comment:/#.*/,key:{pattern:/(\s*(?:^|[:\-,[{\r\n?])[ \t]*(?:![^\s]+)?[ \t]*)[^\r\n{[\]},#\s]+?(?=\s*:\s)/,lookbehind:!0,alias:"atrule"},directive:{pattern:/(^[ \t]*)%.+/m,lookbehind:!0,alias:"important"},datetime:{pattern:/([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?)?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?)(?=[ \t]*(?:$|,|]|}))/m,lookbehind:!0,alias:"number"},boolean:{pattern:/([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:true|false)[ \t]*(?=$|,|]|})/im,lookbehind:!0,alias:"important"},null:{pattern:/([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:null|~)[ \t]*(?=$|,|]|})/im,lookbehind:!0,alias:"important"},string:{pattern:/([:\-,[{]\s*(?:![^\s]+)?[ \t]*)("|')(?:(?!\2)[^\\\r\n]|\\.)*\2(?=[ \t]*(?:$|,|]|}|\s*#))/m,lookbehind:!0,greedy:!0},number:{pattern:/([:\-,[{]\s*(?:![^\s]+)?[ \t]*)[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+\.?\d*|\.?\d+)(?:e[+-]?\d+)?|\.inf|\.nan)[ \t]*(?=$|,|]|})/im,lookbehind:!0},tag:/![^\s]+/,important:/[&*][\w]+/,punctuation:/---|[:[\]{}\-,|>?]|\.\.\./},Prism.languages.yml=Prism.languages.yaml;

(function(){

if (
	typeof self !== 'undefined' && !self.Prism ||
	typeof commonjsGlobal !== 'undefined' && !commonjsGlobal.Prism
) {
	return;
}

var url = /\b([a-z]{3,7}:\/\/|tel:)[\w\-+%~/.:=&@]+(?:\?[\w\-+%~/.:=?&!$'()*,;@]*)?(?:#[\w\-+%~/.:#=?&!$'()*,;@]*)?/,
    email = /\b\S+@[\w.]+[a-z]{2}/,
    linkMd = /\[([^\]]+)]\(([^)]+)\)/,

	// Tokens that may contain URLs and emails
    candidates = ['comment', 'url', 'attr-value', 'string'];

Prism.plugins.autolinker = {
	processGrammar: function (grammar) {
		// Abort if grammar has already been processed
		if (!grammar || grammar['url-link']) {
			return;
		}
		Prism.languages.DFS(grammar, function (key, def, type) {
			if (candidates.indexOf(type) > -1 && !Array.isArray(def)) {
				if (!def.pattern) {
					def = this[key] = {
						pattern: def
					};
				}

				def.inside = def.inside || {};

				if (type == 'comment') {
					def.inside['md-link'] = linkMd;
				}
				if (type == 'attr-value') {
					Prism.languages.insertBefore('inside', 'punctuation', { 'url-link': url }, def);
				}
				else {
					def.inside['url-link'] = url;
				}

				def.inside['email-link'] = email;
			}
		});
		grammar['url-link'] = url;
		grammar['email-link'] = email;
	}
};

Prism.hooks.add('before-highlight', function(env) {
	Prism.plugins.autolinker.processGrammar(env.grammar);
});

Prism.hooks.add('wrap', function(env) {
	if (/-link$/.test(env.type)) {
		env.tag = 'a';

		var href = env.content;

		if (env.type == 'email-link' && href.indexOf('mailto:') != 0) {
			href = 'mailto:' + href;
		}
		else if (env.type == 'md-link') {
			// Markdown
			var match = env.content.match(linkMd);

			href = match[2];
			env.content = match[1];
		}

		env.attributes.href = href;

		// Silently catch any error thrown by decodeURIComponent (#1186)
		try {
			env.content = decodeURIComponent(env.content);
		} catch(e) {}
	}
});

})();

/**
@license
Copyright 2018 The Advanced REST Client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/* global Prism */
/**
 * Syntax highlighting via Prism
 *
 * ### Example
 *
 * ```html
 * <prism-highlight id="c1" lang="markdown"></prism-highlight>
 * <script>
 *  document.querySelector('#c1').code = '# Test highlight';
 * &lt;/script>
 * ```
 *
 * The `lang` attribute is required and the component will not start parsing data without it.
 *
 * Changing the `lang` and `code` properties together, do it in less than 10 ms.
 * The element is set to commit changes after this persiod. Otherwise it may display
 * old and new code due to the asynchronius nature of the code highligter.
 *
 * ## Changes in version 4
 *
 * The component supports only few syntax highlighting by default. It won't
 * load other languages at runtime.The component consumer has to download definition
 * before highlighting the code.
 *
 * The component no longer uses Web Workers.
 *
 * ### Styling
 *
 * `<prism-highlight>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--prism-highlight` | Mixin applied to the element | `{}`
 * `--prism-highlight-code` | Mixin applied to the `<pre>` element | `{}`
 * `--error-color` | Color of the error message when script error ocurred in the worker | ``
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof UiElements
 */
class PrismHighlight extends LitElement {
  static get styles() {
    return css`
      :host {
        display: block;
      }

      pre {
        user-select: text;
        margin: 8px;
      }

      .worker-error {
        color: var(--error-color);
      }

      .token a {
        color: inherit;
      }

      ${styles$1}
    `;
  }

  render() {
    return html`
      <pre class="parsed-content">
      <code id="output" class="language-" @click="${this._handleLinks}"></code>
    </pre>
    `;
  }

  static get properties() {
    return {
      /**
       * A data to be highlighted and dispayed.
       */
      code: { type: String },
      /**
       * Prism supported language.
       */
      lang: { type: String },
      /**
       * Adds languages outside of the core Prism languages.
       *
       * Prism includes a few languages in the core library:
       *   - JavaScript
       *   - Markup
       *   - CSS
       *   - C-Like
       * Use this property to extend the core set with other Prism
       * components and custom languages.
       *
       * Example:
       *   ```
       *   <!-- with languages = {'custom': myCustomPrismLang}; -->
       *   <!-- or languages = Prism.languages; -->
       *   <prism-highlighter languages="[[languages]]"></prism-highlighter>
       *   ```
       *
       * @attribute languages
       * @type {!Object}
       */
      languages: { type: Object }
    };
  }

  get code() {
    return this._code;
  }

  set code(value) {
    const old = this._code;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._code = value;
    this._highlight();
  }

  get lang() {
    return this._lang;
  }

  set lang(value) {
    const old = this._lang;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._lang = value;
    this._highlight();
  }

  get _output() {
    return this.shadowRoot.querySelector('code');
  }

  constructor() {
    super();
    this.languages = {};
  }

  firstUpdated() {
    /* istanbul ignore if */
    if (this.__results) {
      this._output.innerHTML += this.__results;
      this.__results = undefined;
    }
  }

  // Resets the state of the display to initial state.
  reset() {
    const node = this._output;
    if (node) {
      node.innerHTML = '';
    }
  }
  /**
   * Hightligt the code.
   */
  _highlight() {
    const { code, lang } = this;
    if (!code || !lang) {
      return;
    }
    this.reset();
    if (this._highlightDebounce) {
      return;
    }
    this._highlightDebounce = true;
    setTimeout(() => {
      this._highlightDebounce = false;
      this._tokenize(this.code, this.lang);
    });
  }

  _tokenize(code, lang) {
    const grammar = this._detectLang(code, lang);
    const env = {
      code: code,
      grammar,
      language: lang
    };
    Prism.hooks.run('before-highlight', env);
    const result = Prism.highlight(code, grammar, lang);
    const node = this._output;
    /* istanbul ignore else */
    if (node) {
      node.innerHTML += result;
    } else {
      if (!this.__results) {
        this.__results = '';
      }
      this.__results += result;
    }
  }
  /**
   * Handler for click events.
   * It dispatches `url-change-action` custom event when a link is clicked.
   *
   * @param {ClickEvent} e
   */
  _handleLinks(e) {
    const el = e.target;
    if (el.nodeName !== 'A') {
      return;
    }
    const newEntity = e.ctrlKey || e.metaKey;
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    const url = el.href;
    if (newEntity) {
      this._dispatchNewRequest(url);
    } else {
      this._dispatchChangeUrl(url);
    }
  }
  _dispatchChangeUrl(url) {
    this.dispatchEvent(
      new CustomEvent('url-change-action', {
        detail: {
          url
        },
        bubbles: true,
        cancelable: true,
        composed: true
      })
    );
  }

  _dispatchNewRequest(url) {
    this.dispatchEvent(
      new CustomEvent('request-workspace-append', {
        detail: {
          kind: 'ARC#Request',
          request: { url }
        },
        bubbles: true,
        cancelable: true,
        composed: true
      })
    );
  }
  /**
   * Picks a Prism formatter based on the `lang` hint and `code`.
   *
   * @param {string} code The source being highlighted.
   * @param {string=} lang A language hint (e.g. ````LANG`).
   * @return {!Prism.Lang}
   */
  _detectLang(code, lang) {
    if (!lang) {
      // Stupid simple detection if we have no lang, courtesy of:
      // https://github.com/robdodson/mark-down/blob/ac2eaa/mark-down.html#L93-101
      return code.match(/^\s*</) ? Prism.languages.markup : Prism.languages.javascript;
    }
    if (this.languages[lang]) {
      return this.languages[lang];
    } else if (Prism.languages[lang]) {
      return Prism.languages[lang];
    }
    switch (lang.substr(0, 2)) {
      case 'js':
      case 'es':
      case 'mj':
        return Prism.languages.javascript;
      case 'c':
        return Prism.languages.clike;
      default:
        // The assumption is that you're mostly documenting HTML when in HTML.
        return Prism.languages.markup;
    }
  }
  /**
   * An event fired when the user clicked on any link in the response
   * panels or the headers
   *
   * @event url-change-action
   * @param {String} url An url value
   * @param {Boolean} asNew When true it should be treated as "new tab" action.
   */
  /**
   * Fired when highlighting is applied to the code view.
   *
   * @event prism-highlight-parsed
   */
}
window.customElements.define('prism-highlight', PrismHighlight);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element that parses the HTTP response and displays highlighted result.
 *
 * It splits the response by line (by default it's 500) and if the response has
 * more than that it shows only first 500 lines and the user can request to
 * display the rest or next 500 lines. This is to make the element work faster.
 * If the response is very long it may take some time to parse and tokenize it.
 * Control number of lines by setting the maxRead attribute.
 *
 * ### Example
 *
 * ```html
 * <response-highlighter></response-highlighter>
 * ```
 * ```javascript
 * const display = document.querySelector('response-highlighter');
 * display.responseText = someJsonResponse;
 * display.contentType = 'application/json';
 * ```
 *
 * ## Content actions
 *
 * Child elements added to light DOM with slot name `content-action` are rendered
 * in actions container. It is a way to render additional actions related to
 * the response text.
 *
 * ### Example
 *
 * ```html
 * <response-highlighter>
 *  <paper-icon-button title="Additional action" icon="arc:cached"></paper-icon-button>
 *  <paper-icon-button title="Clear the code" icon="arc:clear"></paper-icon-button>
 * </response-highlighter>
 * ```
 *
 * See demo for more information.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof UiElements
 */
class ResponseHighlighter extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
    }

    .actions-panel {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    .actions-panel.hidden {
      display: none;
    }

    .no-info {
      font-style: var(--no-info-message-font-style, italic);
      font-size: var(--no-info-message-font-size, 16px);
      color: var(--no-info-message-color, rgba(0, 0, 0, 0.74));
    }

    [hidden] {
      display: none !important;
    }`;
  }

  render() {
    const {
      responseText,
      lang
    } = this;
    return html`
    <div class="${this._actionsPanelClass}">
      <slot name="content-action"></slot>
    </div>
    ${responseText ?
      html`<prism-highlight .code="${responseText}" .lang="${lang}"></prism-highlight>`:
      html`<p class="no-info">Nothing to display.</p>`}`;
  }

  static get properties() {
    return {
      /**
       * The response text to display.
       */
      responseText: { type: String },
      /**
       * Response content type.
       * It will be used to determine which syntaxt highlighter to use.
       */
      contentType: { type: String }
    };
  }

  get _actionsPanelClass() {
    let clazz = 'actions-panel';
    if (!this.responseText) {
      clazz += ' hidden';
    }
    return clazz;
  }
  /**
   * The lang property for the Prism.
   */
  get lang() {
    return this._computeLang(this.contentType);
  }
  /**
   * Computes a `lang` property for the Prism from the response content-type.
   *
   * @param {String} contentType
   * @return {String}
   */
  _computeLang(contentType) {
    if (!contentType || !contentType.indexOf) {
      return undefined;
    }
    if (contentType.indexOf(';') !== -1) {
      return contentType.split(';')[0];
    }
    return contentType;
  }
}
window.customElements.define('response-highlighter', ResponseHighlighter);

/**
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/

let hasLocalStorage;
/* global chrome */
/* istanbul ignore next */
if (typeof chrome !== 'undefined' && chrome.i18n) {
  // Chrome apps have `chrome.i18n` property, regular website doesn't.
  // This is to avoid annoying warning message in Chrome apps.
  hasLocalStorage = false;
} else {
  try {
    localStorage.getItem('test');
    hasLocalStorage = true;
    /* istanbul ignore next */
  } catch (_) {
    /* istanbul ignore next */
    hasLocalStorage = false;
  }
}

/**
 * An element to display a HTTP response body.
 *
 * The element will try to select best view for given `contentType`. It will
 * choose the JSON viewer for JSON response and XML viewer for XML responses.
 * Otherise it will display a syntax hagligter.
 *
 * Note that the `contentType` property **must** be set in order to display any
 * view.
 *
 * ### Save content to file
 *
 * The element uses the web way of file saving. However, it sends the
 * `export-data` custom event first to check if hosting application implements
 * other save functionality. See event description for more information.
 *
 *
 * @customElement
 * @memberof UiElements
 */
class ResponseBodyView extends LitElement {
  static get styles() {
    return css`:host {
      display: block;
      position: relative;
      color: var(--response-body-view-color, inherit);
      background-color: var(--response-body-view-background-color, inherit);
    }

    .close-preview {
      position: absolute;
      top: 8px;
      right: 12px;
      background-color: var(--response-body-view-preview-close-background-color, #fff);
      color: var(--response-body-view-preview-close-color, rgba(0,0,0,0.74));
    }

    [hidden] {
      display: none !important;
    }

    .content-actions {
      display: flex;
      flex-direction: row;
      align-items: center;
    }

    .download-link {
      text-decoration: none;
      color: inherit;
      outline: none;
    }

    .save-dialog {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 12px 0;
    }

    .save-dialog h2 {
      font-size: 1.5rem;
      font-weight: 400;
      letter-spacing: 0.01rem;
    }`;
  }

  _activeTemplate(activeView, content) {
    switch (activeView) {
      case 0: return html`<response-raw-viewer
        .responseText="${content}"
        .wrapText="${this.rawTextWrap}"></response-raw-viewer>`;
      case 1: return html`<response-highlighter
        .responseText="${content}"
        .contentType="${this.contentType}"></response-highlighter>`;
      case 2: return html`<json-viewer .json="${content}"></json-viewer>`;
      case 3: return html`<json-table .json="${content}"></json-table>`;
      default:
    }
  }

  _downloadTemplate() {
    const {
      _downloadFileUrl,
      _downloadFileName
    } = this;
    return html`<div class="save-dialog">
      <h2>Saving to file</h2>
      <div>
        <p>Your file is now ready to download.</p>
      </div>
      <div>
        <anypoint-button emphasis="low" @click="${this._downloadDialogClose}">Cancel</anypoint-button>
        <a
          href="${_downloadFileUrl}"
          download="${_downloadFileName}"
          @click="${this._downloadHandler}"
          target="_blank"
          class="download-link">
          <anypoint-button emphasis="high">Download file</anypoint-button>
        </a>
      </div>
    </div>`;
  }

  render() {
    const {
      contentType,
      rawView,
      activeView,
      jsonTableView,
      rawTextWrap,
      _downloadFileUrl,
      _raw,
      _isJson
    } = this;
    const content = _raw && this._getRawContent(_raw);
    return html `
    ${contentType && content ? html`<div class="content-actions">
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="copy"
        emphasis="medium"
        @click="${this._copyToClipboard}"
        aria-label="Press to copy response to clipboard"
        title="Copy response to clipboard">Copy</anypoint-button>
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="save-file"
        emphasis="medium"
        @click="${this._saveFile}"
        aria-label="Press to save content to file"
        title="Save content to file">Save</anypoint-button>
      <anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="raw-toggle"
        emphasis="medium"
        toggles
        .active="${rawView}"
        @active-changed="${this._sourceViewHandler}"
        aria-label="Press to toggle source view"
        title="Toogle source view">Source view</anypoint-button>

      ${_isJson ? html`<anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="json-table"
        toggles
        .active="${jsonTableView}"
        @active-changed="${this._jsonTableViewHandler}"
        aria-label="Press to activate table view for JSON data"
        title="Toggle structured table view">Data table</anypoint-button>` : undefined}

      ${activeView === 0 ? html`<anypoint-button
        part="content-action-button, code-content-action-button"
        class="action-button"
        data-action="text-wrap"
        toggles
        .active="${rawTextWrap}"
        @active-changed="${this._rawTextWrapViewHandler}"
        aria-label="Press to toggle text wrapping in the view"
        title="Toggle text wrapping">Wrap text</anypoint-button>` : undefined}
    </div>` : undefined}

    ${_downloadFileUrl ? this._downloadTemplate() : this._activeTemplate(activeView, content)}

    <clipboard-copy .content="${content}"></clipboard-copy>`;
  }

  static get properties() {
    return {
      /**
       * Raw response as a response text.
       */
      responseText: { type: String },
      /**
       * A variable to be set after the `responseText` change
       */
      _raw: { type: String },
      /**
       * The response content type.
       */
      contentType: { type: String },
      /**
       * Current value of charset encoding, if available.
       * It should be set to correctly decode buffer to string
       */
      charset: { type: String },
      /**
       * Computed value, true if the parsed view can be displayed.
       * If false then the syntax highligter will be removed from the DOM
       * so it will not try to do the parsing job if it is not necessary.
       */
      _isParsed: { type: Boolean },
      /**
       * Computed value, true if the JSON view can be displayed.
       * If false then the syntax highligter will be removed from the DOM
       * so it will not try to do the parsing job if it is not necessary.
       */
      _isJson: { type: Boolean },
      /**
       * Selected view.
       */
      activeView: { type: Number },
      /**
       * When saving a file this will be the download URL created by the
       * `URL.createObjectURL` function.
       */
      _downloadFileUrl: { type: String },
      /**
       * Autogenerated file name for the download file.
       */
      _downloadFileName: { type: String },
      /**
       * When true then the text in "raw" preview will be wrapped.
       */
      rawTextWrap: { type: Boolean },
      /**
       * When set it opens the "raw" view.
       */
      rawView: { type: Boolean },
      /**
       * If set it opens the JSON table view.
       */
      jsonTableView: { type: Boolean }
    };
  }

  get responseText() {
    return this._responseText;
  }

  set responseText(value) {
    const old = this._responseText;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._responseText = value;
    if (this._downloadFileUrl) {
      this._downloadDialogClose();
    }
    this._responseTextChanged(value);
  }

  get rawView() {
    return this._rawView;
  }

  set rawView(value) {
    const old = this._rawView;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._rawView = value;
    this.requestUpdate('rawView', old);
    this._toggleViewSource(value);
  }

  get jsonTableView() {
    return this._jsonTableView;
  }

  set jsonTableView(value) {
    const old = this._jsonTableView;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._jsonTableView = value;
    this.requestUpdate('jsonTableView', old);
    this._jsonTableViewChanged(value);
  }

  get contentType() {
    return this._contentType;
  }

  set contentType(value) {
    const old = this._contentType;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._contentType = value;
    this.requestUpdate('contentType', old);
    this._contentTypeChanged(value, this._raw);
  }

  get _raw() {
    return this.__raw;
  }

  set _raw(value) {
    const old = this.__raw;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__raw = value;
    this.requestUpdate('_raw', old);
    this._contentTypeChanged(this.contentType, value);
  }
  /**
   * @constructor
   */
  constructor() {
    super();
    this._onStorageChanged = this._onStorageChanged.bind(this);
    this._onJsonTableStateChanged = this._onJsonTableStateChanged.bind(this);
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    window.addEventListener('storage', this._onStorageChanged);
    window.addEventListener('json-table-state-changed', this._onJsonTableStateChanged);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    if (this._downloadFileUrl) {
      this._downloadDialogClose();
    }
    window.removeEventListener('storage', this._onStorageChanged);
    window.removeEventListener('json-table-state-changed', this._onJsonTableStateChanged);
  }

  /**
   * Set's `_raw` property that it propagated to current viewer.
   * The operation is async for performance reasons.
   *
   * @param {String} payload
   */
  _responseTextChanged(payload) {
    if (this.__setRawDebouncer) {
      return;
    }
    this._isJson = false;
    this._isParsed = false;
    this._raw = undefined;
    if (payload === undefined) {
      return;
    }
    this.__setRawDebouncer = true;
    setTimeout(() => {
      this.__setRawDebouncer = false;
      this._raw = this.responseText;
    }, 1);
  }
  /**
   * Updates `activeView` property based on `contentType` value.
   *
   * @param {?String} contentType Current content type of the response
   */
  _contentTypeChanged(contentType) {
    let parsed = false;
    let json = false;
    if (contentType) {
      if (contentType.indexOf('json') !== -1) {
        this.activeView = 2;
        json = true;
      } else {
        this.activeView = 1;
        parsed = true;
      }
    }
    this._isJson = json;
    this._isParsed = parsed;
    if (json) {
      this._ensureJsonTable();
    }
  }
  /**
   * When response's content type is JSON the view renders the
   * JSON table element. This function reads current state for the table
   * (if it is turned on) and handles view change if needed.
   */
  _ensureJsonTable() {
    /* istanbul ignore if */
    if (!hasLocalStorage) {
      return;
    }
    const isTable = this._localStorageValueToBoolean(localStorage.jsonTableEnabled);
    if (this.jsonTableView !== isTable) {
      this.jsonTableView = isTable;
    }
    if (this.jsonTableView) {
      this.activeView = 3;
    } else if (this.activeView === 3) {
      this.activeView = 1;
    }
  }
  /**
   * The component may work in Electron app where Buffer can be returned from
   * the transport library. This ensures that string is always returned.
   * @return {String} String value of `_raw` property
   */
  _getRawContent() {
    let raw = this._raw;
    const type = typeof raw;
    if (['string', 'boolean', 'undefined'].indexOf(type) !== -1) {
      return raw;
    }
    if (raw && raw.type === 'Buffer') {
      raw = new Uint16Array(raw.data);
    }
    const ce = this.charset || 'utf-8';
    const decoder = new TextDecoder(ce);
    try {
      return decoder.decode(raw);
    } catch (e) {
      return '';
    }
  }
  /**
   * Coppies current response text value to clipboard.
   * @param {Event} e
   */
  _copyToClipboard(e) {
    const button = e.target;
    const copy = this.shadowRoot.querySelector('clipboard-copy');
    if (copy.copy()) {
      button.innerText = 'Done';
    } else {
      button.innerText = 'Error';
    }
    button.disabled = true;
    if ('part' in button) {
      button.part.add('content-action-button-disabled');
      button.part.add('code-content-action-button-disabled');
    }
    setTimeout(() => this._resetCopyButtonState(button), 1000);
    const ev = new CustomEvent('send-analytics', {
      detail: {
        type: 'event',
        category: 'Usage',
        action: 'Click',
        label: 'Headers editor clipboard copy',
      },
      bubbles: true,
      composed: true
    });
    this.dispatchEvent(ev);
  }

  _resetCopyButtonState(button) {
    button.innerText = 'Copy';
    button.disabled = false;
    if ('part' in button) {
      button.part.remove('content-action-button-disabled');
      button.part.remove('code-content-action-button-disabled');
    }
  }

  /**
   * Fires the `export-data` custom event. If the event is not canceled
   * then it will use default web implementation for file saving.
   */
  _saveFile() {
    const e = new CustomEvent('export-data', {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {
        destination: 'file',
        data: this._getRawContent(),
        file: 'response-data',
        providerOptions: {
          contentType: this.contentType
        }
      }
    });
    this.dispatchEvent(e);
    if (e.defaultPrevented) {
      return;
    }
    this.saveToFile();
  }
  /**
   * Creates a file object form current response text and opens a dialog
   * with the link to a file.
   */
  saveToFile() {
    let ext = '.';
    if (this.isJson) {
      ext += 'json';
    } else {
      ext += 'txt';
    }
    const ct = this.contentType || 'text/plain';
    const raw = this._getRawContent();
    const file = new Blob([raw], {
      type: ct
    });
    const fileName = 'response-' + new Date().toISOString() + ext;
    this._downloadFileUrl = URL.createObjectURL(file);
    this._downloadFileName = fileName;
  }
  /**
   * Handler for download link click to prevent default and close the dialog.
   */
  _downloadHandler() {
    setTimeout(() => this._downloadDialogClose(), 250);
  }
  /**
   * Handler for file download dialog close.
   */
  _downloadDialogClose() {
    URL.revokeObjectURL(this.downloadFileUrl);
    this._downloadFileUrl = undefined;
    this._downloadFileName = undefined;
  }
  /**
   * Toggles "view source" or raw message view.
   *
   * @param {Boolean} opened
   */
  _toggleViewSource(opened) {
    if (!opened) {
      if (!this.__parsedView) {
        return;
      }
      this.activeView = this.__parsedView;
      this.__parsedView = undefined;
      if (this.activeView === 2 && this.jsonTableView) {
        this.jsonTableView = false;
      }
    } else {
      if (this.jsonTableView) {
        this._skipJsonTableEvent = true;
        this.jsonTableView = false;
        this._skipJsonTableEvent = false;
      }
      this.__parsedView = this.activeView;
      this.activeView = 0;
    }
  }
  // Handler for the `jsonTableView` property change.
  _jsonTableViewChanged(state) {
    if (state) {
      if (this.rawView) {
        this.__parsedView = undefined;
        this.rawView = false;
      }
      this.activeView = 3;
    } else {
      this.activeView = 1;
    }
    if (this._skipJsonTableEvent) {
      return;
    }
    /* istanbul ignore if */
    if (hasLocalStorage) {
      if (localStorage.jsonTableEnabled !== String(state)) {
        window.localStorage.setItem('jsonTableEnabled', state);
      }
    }
    this.dispatchEvent(new CustomEvent('json-table-state-changed', {
      detail: {
        enabled: state
      },
      bubbles: true,
      composed: true
    }));
  }
  /**
   * Updates the value of the `jsonTableView` property when the
   * corresponding localStorage property change.
   *
   * @param {StorageEvent} e
   */
  _onStorageChanged(e) {
    if (e.key !== 'jsonTableEnabled') {
      return;
    }
    if (!e.newValue) {
      return;
    }
    const v = this._localStorageValueToBoolean(e.newValue);
    if (this.jsonTableView !== v) {
      this._skipJsonTableEvent = true;
      this.jsonTableView = v;
      this._skipJsonTableEvent = false;
    }
  }
  /**
   * Reads the local value (always a string) as a boolean value.
   *
   * @param {String} value The value read from the local storage.
   * @return {Boolean} Boolean value read from the value.
   */
  _localStorageValueToBoolean(value) {
    if (typeof value === 'boolean') {
      return value;
    }
    if (value === 'true') {
      value = true;
    } else {
      value = false;
    }
    return value;
  }

  _onJsonTableStateChanged(e) {
    if (e.target === this) {
      return;
    }
    const enabled = e.detail.enabled;
    if (enabled !== this.jsonTableView) {
      this._skipJsonTableEvent = true;
      this.jsonTableView = enabled;
      this._skipJsonTableEvent = false;
    }
  }

  _sourceViewHandler(e) {
    this.rawView = e.detail.value;
  }

  _jsonTableViewHandler(e) {
    this.jsonTableView = e.detail.value;
  }

  _rawTextWrapViewHandler(e) {
    this.rawTextWrap = e.detail.value;
  }
  /**
   * Fired when the element request to export data outside the application.
   *
   * Application can handle this event if it support native UX of file saving.
   * In this case this event must be canceled by calling `preventDefault()`
   * on it. If the event is not canceled then save to file dialog appears
   * with a regular download link.
   *
   * @event export-data
   * @param {String} data A text to save in the file.
   * @param {String} destination Always 'file'
   * @param {String} file Suggested file name
   * @param {Object} providerOptions File provider options.
   * Contains `contentType` property.
   */
  /**
   * Fired when the `jsonTableView` property change to inform other
   * elements to switch corresponding view as well.
   *
   * @event json-table-state-changed
   * @param {Boolean} enabled If true then the view is enabled.
   */
}
window.customElements.define('response-body-view', ResponseBodyView);

/**
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
*/
/**
 * An element to display HTTP response view.
 *
 * It accepts request data object to render additional information in the
 * status bar (method & URL).
 *
 * ## Data model
 *
 * ## Request data model
 *
 * The request is ARC (Advanced REST client) request data model. It expects
 * the following properties:
 * - url (`String`) - Request URL
 * - method (`String`) - Request HTTP method.
 * - headers (`String|undefined`) - HTTP headers string
 * - payload (`String|FormData|File|ArrayBuffer|undefined`) Request body
 *
 * ## Response data model
 *
 * The response is ARC response data model:
 * - status (`Number`) - Response status code
 * - statusText (`String`) - Response status text. Can be empty string.
 * - payload (`String|Document|ArrayBuffer|Blob|undefined`) - Response body
 * - headers (`String|undefined`) - Response headers
 *
 * Response object is created by `advanced-rest-client/xhr-simple-request`.
 * However, any transport library can generate similar object.
 *
 * ## Advanced transport properties
 *
 * When using own transport libraries or server side transport you may have
 * access to more information about the request and response like redirects
 * and timings. The response status view can render additional UI for this
 * data.
 * To enable this feature, set `isXhr` to false and any of the following
 * properties:
 *
 * - sentHttpMessage `String` - Raw HTTP message sent to server
 * - redirects `Array<Object>` - A list of redirect information. Each object has
 * the following properties:
 *  - status (`Number`) - Response status code
 *  - statusText (`String`) - Response status text. Can be empty string.
 *  - headers (`String|undefined`) - Response headers
 *  - payload (`String|Document|ArrayBuffer|Blob|undefined`) - Response body
 * - redirectTimings `Array<Object>` - List of HAR 1.2 timing objects for
 * each redirected request. The order must corresponds with order in `redirects`
 * array.
 * - timings `Object` - HAR 1.2 timings object
 *
 * Read [response-status-view]
 * (https://elements.advancedrestclient.com/elements/response-status-view)
 * element documentation for more details.
 *
 * ## Error reporting
 *
 * If there's a request error set `isError` property and the `responseError`
 * that is an `Error` object.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof UiElements
 */
class ResponseView extends LitElement {
  static get styles() {
    return css`
    :host { display: block; }

    response-body-view,
    response-error-view {
      margin-top: 24px;
    }
    `;
  }

  _errorTemplate() {
    const { responseError } = this;
    const message = responseError && responseError.message || 'unknown error';
    return html`<response-error-view .message="${message}"></response-error-view>`;
  }

  _responseTemplate() {
    const { _charset, isError, responseBody, contentType } = this;
    const _renderError = !!(isError && !responseBody);
    return html`
    ${_renderError ? this._errorTemplate() : ''}
    ${responseBody ? html`<response-body-view
      .responseText="${responseBody}"
      .contentType="${contentType}"
      .charset="${_charset}"></response-body-view>` : ''}`;
  }

  render() {
    const {
      _hasResponse,
      statusCode,
      statusMessage,
      requestHeaders,
      responseHeaders,
      loadingTime,
      redirects,
      redirectTimings,
      responseTimings,
      isXhr,
      requestUrl,
      requestMethod
    } = this;
    return html`
    <response-status-view
      .statusCode="${statusCode}"
      .statusMessage="${statusMessage}"
      .requestHeaders="${requestHeaders}"
      .responseHeaders="${responseHeaders}"
      .loadingTime="${loadingTime}"
      .httpMessage="${this.sentHttpMessage}"
      .redirects="${redirects}"
      .redirectTimings="${redirectTimings}"
      .timings="${responseTimings}"
      isxhr="${isXhr}"
      .requestUrl="${requestUrl}"
      .requestMethod="${requestMethod}"></response-status-view>

    ${_hasResponse ?
      this._responseTemplate() :
      html`<p class="empty-info">This response does not carry a payload.</p>`}`;
  }

  static get properties() {
    return {
      /**
       * ARC response object.
       *
       * Properties -
       * - status (`Number`) - Response status code
       * - statusText (`String`) - Response status text. Can be empty string.
       * - headers (`String|undefined`) - Response headers
       * - payload (`String|Document|ArrayBuffer|Blob|undefined`) - Response body
       *
       * @type {{
       *  status: String,
       *  statusText: String,
       *  headers: (String|undefined),
       *  payload: (String|Document|ArrayBuffer|Blob|undefined)}}
       */
      response: { type: Object },
      /**
       * ARC request object
       *
       * Properties -
       * - url (`String`) - Request URL
       * - method (`String`) - Request HTTP method.
       * - headers (`String|undefined`) - HTTP headers string
       * - payload (`String|FormData|File|ArrayBuffer|undefined`) Request body
       *
       * @type {{
       *  url: String.
       *  method: String,
       *  headers: (String|undefined),
       *  payload: (String|FormData|File|ArrayBuffer|undefined)
       * }}
       */
      request: { type: Object },
      /**
       * An Error object associated with the request if the response was errored.
       * It should have a `message` property set to the human readable
       * explenation of the error.
       * If not set the default message will be displaed.
       *
       * `isError` must be set with thit object.
       *
       * @type {Error}
       */
      responseError: { type: Object },
      /**
       * Response body.
       *
       * Ths value is computed from `response` property.
       *
       * @type {String|FormData|File|ArrayBuffer|undefined}
       */
      responseBody: { type: String },
      /**
       * Returned status code.
       * Ths value is computed from `response` property.
       */
      statusCode: { type: Number },
      /**
       * Returned status message (if any).
       * Ths value is computed from `response` property.
       */
      statusMessage: { type: String },
      /**
       * Request headers sent to the server.
       * Ths value is computed from `request` property.
       */
      requestHeaders: { type: String },
      /**
       * Returned from the server headers.
       * Ths value is computed from `response` property.
       */
      responseHeaders: { type: String },
      /**
       * The response content type header if present
       * Ths value is computed from `response` property.
       */
      contentType: { type: String },
      /**
       * If available, the request / response timings as defined in HAR 1.2
       * spec.
       */
      responseTimings: { type: Object },
      /**
       * The total time of the request / response load.
       */
      loadingTime: { type: Number },
      /**
       * If this information available, the source HTTP message sent to
       * the remote machine.
       */
      sentHttpMessage: { type: String },
      /**
       * List of ordered redirects.
       * Each object has the following properties:
       * - status (`Number`) - Response status code
       * - statusText (`String`) - Response status text. Can be empty string.
       * - headers (`String|undefined`) - Response headers
       * - payload (`String|Document|ArrayBuffer|Blob|undefined`) - Response body
       */
      redirects: { type: Array },
      /**
       * If timings stats are available for redirects, the list of the
       * `timings` objects as defined in HAR 1.2 specification.
       * The list should be ordered list.
       */
      redirectTimings: { type: Array },
      /**
       * Computed value, false if the response is set and it is a HEAD type
       * request (which can't have the response).
       */
      _hasResponse: { type: Boolean },
      // Set to `true` if the response has error object set.
      isError: { type: Boolean },
      /**
       * If true it means that the request has been made by the basic
       * transport and advanced details of the request/response like
       * redirects, timings, source message are not available.
       * It this case it will hide unused tabs.
       */
      isXhr: { type: Boolean },
      // A request URL that has been used to make a request
      requestUrl: { type: String },
      // A HTTP method used to make a request
      requestMethod: { type: String },
      /**
       * Response's character encoding.
       * This value is set when the response is changed. Can be undefined in which case
       * default `utf-8` is used.
       * It is read from `content-type` header value, e.g.: `Content-Type: text/html; charset=iso-8859-1`
       */
      _charset: { type: String }
    };
  }

  get request() {
    return this._request;
  }

  set request(value) {
    const old = this._request;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._request = value;
    this.requestUpdate('request', old);
    this._requestChanged(value);
  }

  get response() {
    return this._response;
  }

  set response(value) {
    const old = this._response;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._response = value;
    this.requestUpdate('response', old);
    this._responseChanged(value);
  }

  constructor() {
    super();
    this.statusCode = 0;
  }

  /**
   * Resets the initial variables for the Response change handler.
   */
  _reset() {
    this.statusCode = 0;
    this.statusMessage = undefined;
    this.responseHeaders = undefined;
    this.responseBody = undefined;
    this.contentType = undefined;
  }
  /**
   * Propagate response properties when response object changes.
   *
   * @param {Object} response The response object
   */
  _responseChanged(response) {
    this._reset();
    if (!response) {
      return;
    }
    this.statusCode = response.status;
    this.statusMessage = response.statusText;
    this.responseHeaders = response.headers;
    let [contentType, charset] = this._readContentType(response.headers);
    if (!contentType) {
      contentType = 'text/plain';
    }
    this._charset = charset;
    this.responseBody = response.payload;
    this.contentType = contentType;
  }
  /**
   * Reads content-type header from the response headers.
   *
   * @param {?String} headers Headers received from the server
   * @return {Array<String>} When present an array where first item is
   * the content type and second is charset value. Otherwise empty array.
   */
  _readContentType(headers) {
    if (!headers || typeof headers !== 'string') {
      return [];
    }
    const ctMatches = headers.match(/^\s*content-type\s*:\s*(.*)$/im);
    if (!ctMatches) {
      return [];
    }
    let mime = ctMatches[1];
    const charset = this._computeCharset(mime);
    const index = mime.indexOf(';');
    if (index !== -1) {
      mime = mime.substr(0, index);
    }
    return [mime, charset];
  }
  /**
   * Propagate request data when the `request` object changes.
   *
   * @param {Object} request The ARC request object
   */
  _requestChanged(request) {
    this.requestHeaders = undefined;
    this._hasResponse = this._computeHasResponse(request);
    if (!request) {
      return;
    }
    this.requestUrl = request.url;
    this.requestMethod = request.method;
    this.requestHeaders = request.headers;
  }
  /**
   * Computes if the response panel should be displayed.
   * If the request method is `HEAD` then it never can have response.
   *
   * @param {Object} request ARC request object.
   * @return {Boolean}
   */
  _computeHasResponse(request) {
    if (request && request.method === 'HEAD') {
      return false;
    }
    return true;
  }
  /**
   * Computes charset value from the `content-type` header.
   * @param {String} contentType Content type header string
   * @return {String|undefined}
   */
  _computeCharset(contentType) {
    if (!contentType || !contentType.split) {
      return;
    }
    if (contentType.indexOf('charset') === -1) {
      return;
    }
    const parts = contentType.split(';');
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i].trim();
      const _tmp = part.split('=');
      if (_tmp[0] === 'charset') {
        return _tmp[1].trim();
      }
    }
  }
}
window.customElements.define('response-view', ResponseView);

/* eslint-disable max-len */
/**
 * Request editor and response view panels in a single element.
 *
 * This element is to replace `api-console-request` element from `mulesoft/api-console`
 * project repository.
 *
 * This is also a base case for any application that renders request and
 * response views.
 *
 * The element uses AMF model to render view based on API mnodel and current user
 * selection.
 *
 * It uses both `api-request-editor` and `response-view` elements and
 * listens to `api-request` and `api-response` events.
 * It also adds additional configuration options that exists in API console
 * (proxy, additional headers).
 *
 * ## `api-request` and `api-response` events
 *
 * See full documentation here:
 * https://github.com/advanced-rest-client/api-components-api/blob/master/docs/api-request-and-response.md
 *
 * ## Dependencies and changelog from included elements
 *
 * - XHR element is not included in the element. Use
 * `advanced-rest-client/xhr-simple-request` in your application or handle
 * `api-request` custom event to make a request.
 * - The element does not include any polyfills
 * - `redirectUrl` is now `redirectUri`
 * - `api-console-request` event is now `api-request` event
 * - `api-console-response` event is now `api-response` event
 * - Added more details to `api-request` custom event (comparing to
 * `api-console-request`)
 * - The user is able to enable/disable query parameters and headers. Set
 * `allow-disable-params` attribute to enable this behavior.
 * - The user is able to add custom query parameters or headers.
 * Set `allow-custom` attribute to enable this behavior.
 * - From authorization panel changes:
 *  - `auth-settings-changed` custom event is stopped from bubbling.
 *  Listen for `authorization-settings-changed` event instead.
 * - From auth-method-oauth2 changes:
 *  - Added `deliveryMethod` and `deliveryName` properties to the
 *  `detail.setting` object.
 * - Crypto library is no longer included into the element. Use
 *  `advanced-rest-client/cryptojs-lib` component to include the library
 *  if your project doesn't use crypto libraries already.
 *
 * ## Narrow view
 *
 * Generally the API components are flexible and mobile friendly. However,
 * it is possible to set `narrow` property to render form elements in
 * a mobile fieldly view. In most cases it means that forms controls are
 * rendered in different layout.
 *
 * ## api-navigation integration
 *
 * The element works with `api-navigation` element. Set `handle-navigation-events`
 * attribute when using `api-navigation` so the component will automatically
 * update selection when internal API navigation occurres.
 *
 * @customElement
 * @demo demo/index.html
 * @demo demo/navigation.html Automated navigation
 * @appliesMixin HeadersParserMixin
 * @appliesMixin EventsTargetMixin
 * @memberof ApiElements
 */
class ApiRequestPanel extends EventsTargetMixin(HeadersParserMixin(LitElement)) {
  static get styles() {
    return css`
    :host { display: block; }
    response-view {
      margin-top: var(--api-request-panel-response-margin-top, 48px);
    }
    `;
  }

  get _hasResponse() {
    return !!this.response || !!this.responseError;
  }

  render() {
    const {
      aware,
      narrow,
      redirectUri,
      selected,
      amf,
      noUrlEditor,
      baseUri,
      noDocs,
      eventsTarget,
      allowHideOptional,
      allowDisableParams,
      allowCustom,
      server,
      protocols,
      version,
      readOnly,
      disabled,
      legacy,
      outlined,

      _hasResponse
    } = this;


    return html`
    ${aware ? html`<raml-aware
      .scope="${aware}"
      @api-changed="${this._apiChanged}"></raml-aware>` : ''}

    <api-request-editor
      ?narrow="${narrow}"
      .redirectUri="${redirectUri}"
      .selected="${selected}"
      .amf="${amf}"
      .noUrlEditor="${noUrlEditor}"
      .baseUri="${baseUri}"
      .noDocs="${noDocs}"
      .eventsTarget="${eventsTarget}"
      .allowHideOptional="${allowHideOptional}"
      .allowDisableParams="${allowDisableParams}"
      .allowCustom="${allowCustom}"
      .server="${server}"
      .protocols="${protocols}"
      .version="${version}"
      .readOnly="${readOnly}"
      .disabled="${disabled}"
      .outlined="${outlined}"
      .legacy="${legacy}"></api-request-editor>
    ${_hasResponse ? html`<response-view
      .request="${this.request}"
      .response="${this.response}"
      .responseError="${this.responseError}"
      .isError="${this.isErrorResponse}"
      .isXhr="${this.responseIsXhr}"
      .loadingTime="${this.loadingTime}"
      .redirects="${this.redirects}"
      .redirectTimings="${this.redirectsTiming}"
      .responseTimings="${this.timing}"
      .sentHttpMessage="${this.sourceMessage}"
      .legacy="${legacy}"></response-view>` : ''}
    `;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * AMF HTTP method (operation in AMF vocabulary) ID.
       */
      selected: { type: String },
      /**
       * By default application hosting the element must set `selected`
       * property. When using `api-navigation` element
       * by setting this property the element listens for navigation events
       * and updates the state
       */
      handleNavigationEvents: { type: Boolean },
      /**
       * A model's `@id` of selected documentation part.
       * Special case is for `summary` view. It's not part of an API
       * but most applications has some kind of summary view for the
       * API.
       */
      amf: { type: Object },
      /**
       * Hides the URL editor from the view.
       * The editor is still in the DOM and the `urlInvalid` property still will be set.
       */
      noUrlEditor: { type: Boolean },
      /**
       * A base URI for the API. To be set if RAML spec is missing `baseUri`
       * declaration and this produces invalid URL input. This information
       * is passed to the URL editor that prefixes the URL with `baseUri` value
       * if passed URL is a relative URL.
       */
      baseUri: { type: String },
      /**
       * OAuth2 redirect URI.
       * This value **must** be set in order for OAuth 1/2 to work properly.
       */
      redirectUri: { type: String },
      /**
       * If set it will renders the view in the narrow layout.
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * Enables Anypoint legacy styling
       */
      legacy: { type: Boolean, reflect: true },
      /**
       * Enables Material Design outlined style
       */
      outlined: { type: Boolean },
      /**
       * When set the editor is in read only mode.
       */
      readOnly: { type: Boolean },
      /**
       * When set all controls are disabled in the form
       */
      disabled: { type: Boolean },
      /**
       * Created by the transport ARFC `request` object
       */
      request: { type: Object },
      /**
       * Created by the transport ARC `response` object.
       */
      response: { type: Object },

      /**
       * A flag indincating request error.
       */
      isErrorResponse: { type: Boolean },
      /**
       * True if the response is made by the Fetch / XHR api.
       */
      responseIsXhr: { type: Boolean },
      /**
       * An error object associated with the response when error.
       */
      responseError: { type: Object },
      /**
       * Response full loading time. This information is received from the
       * transport library.
       */
      loadingTime: { type: Number },
      /**
       * If the transport method is able to collect detailed information about request timings
       * then this value will be set. It's the `timings` property from the HAR 1.2 spec.
       */
      timing: { type: Object },
      /**
       * If the transport method is able to collect detailed information about redirects timings
       * then this value will be set. It's a list of `timings` property from the HAR 1.2 spec.
       */
      redirectsTiming: { type: Array },
      /**
       * It will be set if the transport method can generate information about redirections.
       */
      redirects: { type: Array },
      /**
       * Http message sent to the server.
       *
       * This information should be available only in case of advanced HTTP transport.
       */
      sourceMessage: { type: String },
      /**
       * Forces the console to send headers defined in this string overriding any used defined
       * header.
       * This should be an array of headers with `name` and `value` keys, e.g.:
       * ```
       * [{
       *   name: "x-token",
       *   value: "value"
       * }]
       * ```
       */
      appendHeaders: { type: Array },
      /**
       * If set every request made from the console will be proxied by the service provided in this
       * value.
       * It will prefix entered URL with the proxy value. so the call to
       * `http://domain.com/path/?query=some+value` will become
       * `https://proxy.com/path/http://domain.com/path/?query=some+value`
       *
       * If the proxy require a to pass the URL as a query parameter define value as follows:
       * `https://proxy.com/path/?url=`. In this case be sure to set `proxy-encode-url`
       * attribute.
       */
      proxy: { type: String },
      /**
       * If `proxy` is set, it will URL encode the request URL before appending it to the proxy URL.
       * `http://domain.com/path/?query=some+value` will become
       * `https://proxy.com/?url=http%3A%2F%2Fdomain.com%2Fpath%2F%3Fquery%3Dsome%2Bvalue`
       */
      proxyEncodeUrl: { type: Boolean },
      /**
       * Location of the `node_modules` folder.
       * It should be a path from server's root path including node_modules.
       */
      authPopupLocation: { type: String },
      /**
       * ID of latest request.
       * It is received from the `api-request-editor` when `api-request`
       * event is dispatched. When `api-response` event is handled
       * the id is compared and if match it dispays the result.
       *
       * This system allows to use different request panels on single app
       * and don't mix the results.
       *
       * @type {String|Number}
       */
      lastRequestId: { type: String },
      /**
       * Prohibits rendering of the documentation (the icon and the
       * description).
       */
      noDocs: { type: Boolean },
      /**
       * If set it computes `hasOptional` property and shows checkbox in the
       * form to show / hide optional properties.
       */
      allowHideOptional: { type: Boolean },
      /**
       * If set, enable / disable param checkbox is rendered next to each
       * form item.
       */
      allowDisableParams: { type: Boolean },
      /**
       * When set, renders "add custom" item button.
       * If the element is to be used withouth AMF model this should always
       * be enabled. Otherwise users won't be able to add a parameter.
       */
      allowCustom: { type: Boolean },
      /**
       * API server definition from the AMF model.
       *
       * This value to be set when partial AMF mnodel for an endpoint is passed
       * instead of web api to be passed to the `api-url-data-model` element.
       *
       * Do not set with full AMF web API model.
       */
      server: { type: Object },
      /**
       * Supported protocl versions.
       *
       * E.g.
       *
       * ```json
       * ["http", "https"]
       * ```
       *
       * This value to be set when partial AMF mnodel for an endpoint is passed
       * instead of web api to be passed to the `api-url-data-model` element.
       *
       * Do not set with full AMF web API model.
       */
      protocols: { type: Array },
      /**
       * API version name.
       *
       * This value to be set when partial AMF mnodel for an endpoint is passed
       * instead of web api to be passed to the `api-url-data-model` element.
       *
       * Do not set with full AMF web API model.
       */
      version: { type: String }
    };
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._selected = value;
    this.requestUpdate('selected', old);
    this._selectedChanged(value);
  }

  get handleNavigationEvents() {
    return this._handleNavigationEvents;
  }

  set handleNavigationEvents(value) {
    const old = this._handleNavigationEvents;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._handleNavigationEvents = value;
    this._handleNavChanged(value);
  }

  get authPopupLocation() {
    return this._authPopupLocation;
  }

  set authPopupLocation(value) {
    const old = this._authPopupLocation;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._authPopupLocation = value;
    this._updateRedirectUri(value);
  }
  /**
   * @constructor
   */
  constructor() {
    super();
    this._apiResponseHandler = this._apiResponseHandler.bind(this);
    this._apiRequestHandler = this._apiRequestHandler.bind(this);
    this._navigationHandler = this._navigationHandler.bind(this);

    this.responseIsXhr = true;
  }

  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (!this.redirectUri) {
      this._updateRedirectUri(this.authPopupLocation);
    }
  }

  _attachListeners() {
    window.addEventListener('api-response', this._apiResponseHandler);
    this.addEventListener('api-request', this._apiRequestHandler);
  }

  _detachListeners() {
    window.removeEventListener('api-response', this._apiResponseHandler);
    this.removeEventListener('api-request', this._apiRequestHandler);
    if (this.__navEventsRegistered) {
      this._unregisterNavigationEvents();
    }
  }
  /**
   * Registers `api-navigation-selection-changed` event listener handler
   * on window object.
   */
  _registerNavigationEvents() {
    this.__navEventsRegistered = true;
    window.addEventListener('api-navigation-selection-changed', this._navigationHandler);
  }
  /**
   * Removes event listener from window object for
   * `api-navigation-selection-changed` event.
   */
  _unregisterNavigationEvents() {
    this.__navEventsRegistered = false;
    window.removeEventListener('api-navigation-selection-changed', this._navigationHandler);
  }
  /**
   * Registers / unregisters event listeners depending on `state`
   *
   * @param {Boolean} state
   */
  _handleNavChanged(state) {
    if (state) {
      this._registerNavigationEvents();
    } else {
      this._unregisterNavigationEvents();
    }
  }
  /**
   * Handler for `api-navigation-selection-changed` event.
   *
   * @param {CustomEvent} e
   */
  _navigationHandler(e) {
    const { type, selected } = e.detail;
    this.selected = type === 'method' ? selected : undefined;
  }
  /**
   * Sets OAuth 2 redirect URL for the authorization panel
   *
   * @param {?String} location Bower components location
   */
  _updateRedirectUri(location) {
    const a = document.createElement('a');
    if (!location) {
      location = 'node_modules/';
    }
    if (location && location[location.length - 1] !== '/') {
      location += '/';
    }
    a.href = location + '@advanced-rest-client/oauth-authorization/oauth-popup.html';
    this.redirectUri = a.href;
  }
  /**
   * A handler for the API call.
   * This handler will only check if there is authorization required
   * and if the user is authorizaed.
   *
   * @param {CustomEvent} e `api-request` event
   */
  _apiRequestHandler(e) {
    this.lastRequestId = e.detail.id;
    this._appendConsoleHeaders(e);
    this._appendProxy(e);
  }
  /**
   * Appends headers defined in the `appendHeaders` array.
   * @param {CustomEvent} e The `api-request` event.
   */
  _appendConsoleHeaders(e) {
    const headersToAdd = this.appendHeaders;
    if (!headersToAdd) {
      return;
    }
    let eventHeaders = e.detail.headers || '';
    for (let i = 0, len = headersToAdd.length; i < len; i++) {
      const header = headersToAdd[i];
      eventHeaders = this.replaceHeaderValue(eventHeaders, header.name, header.value);
    }
    e.detail.headers = eventHeaders;
  }
  /**
   * Sets the proxy URL if the `proxy` property is set.
   * @param {CustomEvent} e The `api-request` event.
   */
  _appendProxy(e) {
    const proxy = this.proxy;
    if (!proxy) {
      return;
    }
    let url = this.proxyEncodeUrl ? encodeURIComponent(e.detail.url) : e.detail.url;
    url = proxy + url;
    e.detail.url = url;
  }
  /**
   * Handler for the `api-response` custom event. Sets values on the response
   * panel when response is ready.
   *
   * @param {CustomEvent} e
   */
  _apiResponseHandler(e) {
    if (this.lastRequestId !== e.detail.id) {
      return;
    }
    this._propagateResponse(e.detail);
  }
  /**
   * Propagate `api-response` detail object.
   *
   * @param {Object} data Event's detail object
   */
  _propagateResponse(data) {
    this.isErrorResponse = data.isError;
    this.responseError = data.isError ? data.error : undefined;
    this.loadingTime = data.loadingTime;
    this.request = data.request;
    this.response = data.response;
    const isXhr = data.isXhr === false ? false : true;
    this.responseIsXhr = isXhr;
    this.redirects = isXhr ? undefined : data.redirects;
    this.redirectsTiming = isXhr ? undefined : data.redirectsTiming;
    this.timing = isXhr ? undefined : data.timing;
    this.sourceMessage = data.sentHttpMessage;
  }
  /**
   * Clears response panel when selected id changed.
   * @param {String} id
   */
  _selectedChanged(id) {
    if (!id) {
      return;
    }
    this.clearResponse();
  }
  /**
   * Clears response panel.
   */
  clearResponse() {
    this.isErrorResponse = undefined;
    this.responseError = undefined;
    if (this.loadingTime) {
      this.loadingTime = undefined;
    }
    if (this.request) {
      this.request = undefined;
    }
    if (this.response) {
      this.response = undefined;
    }
    if (this.responseIsXhr !== undefined) {
      this.responseIsXhr = undefined;
    }
    if (this.redirects) {
      this.redirects = undefined;
    }
    if (this.redirectsTiming) {
      this.redirectsTiming = undefined;
    }
    if (this.timing) {
      this.timing = undefined;
    }
    if (this.sourceMessage) {
      this.sourceMessage = undefined;
    }
  }

  _apiChanged(e) {
    this.amf = e.detail.value;
  }
}

window.customElements.define('api-request-panel', ApiRequestPanel);

/**
 * `api-endpoint-documentation`
 *
 * A component to generate documentation for an endpoint from AMF model
 *
 * This element works with [AMF](https://github.com/mulesoft/amf) data model.
 * To properly compute all the information relevant to endpoint documentation
 * set the following properties:
 *
 * - amf - as AMF's WebApi data model
 * - endpoint - As AMF's EndPoint data model
 *
 * When set, this will automatically populate the wiew with data.
 *
 * ## Updating API's base URI
 *
 * By default the component render the documentation as it is defined
 * in the AMF model. Sometimes, however, you may need to replace the base URI
 * of the API with something else. It is useful when the API does not
 * have base URI property defined (therefore this component render relative
 * paths instead of URIs) or when you want to manage different environments.
 *
 * To update base URI value either update `baseUri` property or use
 * `iron-meta` with key `ApiBaseUri`. First method is easier but the second
 * gives much more flexibility since it use a
 * [monostate pattern](http://wiki.c2.com/?MonostatePattern)
 * to manage base URI property.
 *
 * When the component constructs the funal URI for the endpoint it does the
 * following:
 * - if `baseUri` is set it uses this value as a base uri for the endpoint
 * - else if `iron-meta` with key `ApiBaseUri` exists and contains a value
 * it uses it uses this value as a base uri for the endpoin
 t
 * - else if `amf` is set then it computes base uri value from main
 * model document
 * Then it concatenates computed base URI with `endpoint`'s path property.
 *
 * ### Example
 *
 * ```html
 * <iron-meta key="ApiBaseUri" value="https://domain.com"></iron-meta>
 * ```
 *
 * To update value of the `iron-meta`:
 * ```javascript
 * new Polymer.IronMeta({key: 'ApiBaseUri'}).value = 'https://other.domain';
 * ```
 *
 * Note: The element will not get notified about the change in `iron-meta`.
 * The change will be reflected whehn `amf` or `endpoint` property chnage.
 *
 * ## Inline methods layout
 *
 * When `inlineMethods` is set then methods (api-method-document) is rendered
 * instead of list of links to methods.
 * Deep linking is still supported. The page scrolls when navigation event
 * changes.
 *
 * In this layout the try it panel is rendered next to method documentation
 * (normal layout) or below method documentation (narrow layout).
 *
 * ## Styling
 *
 * `<api-endpoint-documentation>` provides the following custom properties
 * and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-endpoint-documentation` | Mixin applied to this elment | `{}`
 * `--arc-font-headline` | Theme mixin, Applied to h1 element (title) | `{}`
 * `--arc-font-code1` | Theme mixin, applied to the URL area | `{}`
 * `--api-endpoint-documentation-url-font-size` | Font size of endpoin URL | `16px`
 * `--api-endpoint-documentation-url-background-color` | Background color of the URL section | `#424242`
 * `--api-endpoint-documentation-url-font-color` | Font color of the URL area | `#fff`
 * `--api-endpoint-documentation-bottom-navigation-color` | Color of of the bottom navigartion (icon + text) | `#000`
 * `--api-endpoint-documentation-tryit-background-color` | Background color of inlined "try it" panel | `#ECEFF1`
 * `--api-endpoint-documentation-method-doc-border-top-color` | Method doc top border color |  `#E5E5E5`
 * `--api-endpoint-documentation-method-doc-border-top-style` | Method doc top border style | `dashed`
 * `--api-endpoint-documentation-tryit-panels-background-color` | Bg color of try it panels | `#fff`
 * `--api-endpoint-documentation-tryit-panels-border-radius` | Try it panels border radius | `3px`
 * `--api-endpoint-documentation-tryit-panels-border-color` | Try it panels border color | `#EEEEEE`
 * `--api-endpoint-documentation-tryit-panels-border-style` | Try it panels border style | `solid`
 * `--api-endpoint-documentation-tryit-section-title`
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiEndpointDocumentation extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      labelStyles,
      css`:host {
        display: block;
        font-size: var(--arc-font-body1-font-size, inherit);
        font-weight: var(--arc-font-body1-font-weight, inherit);
        line-height: var(--arc-font-body1-line-height, inherit);
      }

      .title {
        font-size: var(--arc-font-headline-font-size);
        letter-spacing: var(--arc-font-headline-letter-spacing);
        line-height: var(--arc-font-headline-line-height);
        font-weight: var(--api-method-documentation-title-method-font-weight,
          var(--arc-font-headline-font-weight, 500));
        text-transform: capitalize;
      }

      .heading2 {
        font-size: var(--arc-font-title-font-size);
        font-weight: var(--arc-font-title-font-weight);
        line-height: var(--arc-font-title-line-height);
        margin: 0.84em 0;
      }

      .heading3 {
        flex: 1;
        font-size: var(--arc-font-subhead-font-size);
        font-weight: var(--arc-font-subhead-font-weight);
        line-height: var(--arc-font-subhead-line-height);
      }

      :host([narrow]) .title {
        font-size: 20px;
        margin: 0;
      }

      :host([narrow]) .heading2 {
        font-size: 18px;
      }

      arc-marked {
        margin: 8px 0;
        padding: 0px;
      }

      .markdown-body {
        margin-bottom: 28px;
        color: var(--api-endpoint-documentation-description-color, rgba(0, 0, 0, 0.74));
      }

      .extensions {
        font-style: italic;
        margin: 12px 0;
      }

      .bottom-nav,
      .bottom-link {
        display: flex;
        flex-direction: row;
        align-items: center;
      }

      .bottom-nav {
        padding: 32px 0;
        margin: 16px 0;
        color: var(--api-endpoint-documentation-bottom-navigation-color, #000);
        font-size: 18px;
      }

      .bottom-link {
        cursor: pointer;
        max-width: 50%;
        word-break: break-all;
      }

      .bottom-link.previous {
        margin-right: 12px;
      }

      .bottom-link.next {
        margin-left: 12px;
      }

      .nav-separator {
        flex: 1;
      }

      .url-area {
        flex: 1;
        display: flex;
        flex-direction: row;
        align-items: center;
        font-family: var(--arc-font-code-family);
        font-size: var(--api-endpoint-documentation-url-font-size, 16px);
        margin-bottom: 40px;
        margin-top: 20px;
        background-color: var(--code-background-color);
        color: var(--code-color);
        padding: 8px;
        border-radius: var(--api-endpoint-documentation-url-border-radius, 4px);
      }

      .url-area[extra-margin] {
        margin-top: 20px;
      }

      .url-value {
        flex: 1;
        word-break: break-all;
      }

      .method-label {
        margin-bottom: 0px;
      }

      .method-anchor {
        text-decoration: none;
        color: inherit;
        font-size: var(--arc-font-body1-font-size, inherit);
        font-weight: var(--arc-font-body1-font-weight, inherit);
        line-height: var(--arc-font-body1-line-height, inherit);
        font-size: 16px;
      }

      .method-anchor:hover {
        text-decoration: underline;
      }

      .method {
        margin: 0.83em 0;
      }

      .method p {
        margin: 0;
      }

      .method-name + p {
        margin-top: 0.83em;
      }

      .method-container {
        display: flex;
        flex-direction: row;
        padding: 24px 0;
        box-sizing: border-box;
        border-top-width: 2px;
        border-top-color: var(--api-endpoint-documentation-method-doc-border-top-color, #E5E5E5);
        border-top-style: var(--api-endpoint-documentation-method-doc-border-top-style, dashed);
      }

      :host([narrow]) .method-container {
        flex-direction: column;
      }

      .method-container api-method-documentation {
        width: var(--api-endpoint-documentation-method-doc-width, 60%);
        max-width: var(--api-endpoint-documentation-method-doc-max-width);
        padding-right: 12px;
        box-sizing: border-box;
      }

      .method-container .try-it-column {
        width: var(--api-endpoint-documentation-tryit-width, 40%);
        max-width: var(--api-endpoint-documentation-tryit-max-width);
        background-color: var(--api-endpoint-documentation-tryit-background-color, #ECEFF1);
      }

      :host([narrow]) .method-container api-method-documentation,
      :host([narrow]) .method-container .try-it-column {
        border: none !important;
        max-width: 900px;
        width: 100%;
        margin: 0;
        padding: 0;
      }

      .try-it-column api-request-panel,
      .try-it-column http-code-snippets {
        padding: 4px 4px 12px 4px;
        margin: 4px;
        background-color: var(--api-endpoint-documentation-tryit-panels-background-color, #fff);
        box-sizing: border-box;
        border-radius: var(--api-endpoint-documentation-tryit-panels-border-radius, 3px);
        border-width: 1px;
        border-color: var(--api-endpoint-documentation-tryit-panels-border-color, #EEEEEE);
        border-style: var(--api-endpoint-documentation-tryit-panels-border-style, solid);
      }

      .try-it-column .heading3 {
        padding-left: 12px;
        padding-right: 12px;
        flex: 1;
      }

      .section-title-area {
        flex-direction: row;
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        border-bottom-width: 1px;
        border-bottom-color: var(--api-endpoint-documentation-tryit-title-border-bottom-color, #bac6cb);
        border-bottom-style: var(--api-endpoint-documentation-tryit-title-border-bottom-style, solid);
      }

      .toggle-icon {
        margin-left: 8px;
        transform: rotateZ(0deg);
        transition: transform 0.3s ease-in-out;
      }

      .toggle-icon.opened {
        transform: rotateZ(-180deg);
      }

      .noinfo {
        font-style: var(--no-info-message-font-style, italic);
        font-size: var(--no-info-message-font-size, 16px);
        color: var(--no-info-message-color, rgba(0, 0, 0, 0.74));
      }

      .icon {
        display: block;
        width: 24px;
        height: 24px;
        fill: currentColor;
      }
      `
    ];
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * Method's endpoint definition as a
       * `http://raml.org/vocabularies/http#endpoint` of AMF model.
       */
      endpoint: { type: Object },
      /**
       * The ID in `amf` of current selection. It can be this endpoint
       * or any of methods
       */
      selected: { type: String },
      /**
       * A property to set to override AMF's model base URI information.
       * When this property is set, the `endpointUri` property is recalculated.
       */
      baseUri: { type: String },
      /**
       * Computed value, API version name
       */
      apiVersion: { type: String },
      /**
       * Endpoint URI to display in main URL field.
       * This value is computed when `amf`, `endpoint` or `baseUri` change.
       */
      endpointUri: { type: String },
      /**
       * Computed value of the `http://raml.org/vocabularies/http#server`
       * from `amf`
       */
      server: { type: Object },
      /**
       * Endpoint name.
       * It should be either a "displayName" or endpoint's relative
       * path.
       */
      endpointName: { type: String },
      /**
       * Computed value of method description from `method` property.
       */
      description: { type: String },
      /**
       * Computed value of endpoint's path.
       */
      path: { type: String },
      /**
       * Computed value from current `method`. True if the model containsPATCH
       * custom properties (annotations in RAML).
       */
      hasCustomProperties: { type: Boolean },
      /**
       * If set it will renders the view in the narrow layout.
       */
      narrow: { type: Boolean, reflect: true },
      /**
       * List of traits and resource types, if any.
       *
       * @type {Array<Object>}
       */
      extendsTypes: { type: Array },
      /**
       * Computed value of a parent type.
       * In RAML it is resource type that can be applied to a resource.
       */
      parentType: { type: Object },
      /**
       * Computed value for parent type name.
       */
      parentTypeName: { type: String },
      /**
       * List of traits appied to this endpoint
       *
       * @type {Array<Object>}
       */
      traits: { type: Array },
      /**
       * Model to generate a link to previous HTTP endpoint.
       * It should contain `id` and `label` properties
       */
      previous: { type: Object },
      /**
       * Model to generate a link to next HTTP endpoint.
       * It should contain `id` and `label` properties
       */
      next: { type: Object },
      /**
       * Scroll target used to observe `scroll` event.
       * When set the element will observe scroll and inform other components
       * about changes in navigation while scrolling through methods list.
       * The navigation event contains `passive: true` property that
       * determines that it's not user triggered navigation but rather
       * context enforced.
       */
      scrollTarget: { type: Object },
      /**
       * Passing value of `noTryIt` to the method documentation.
       * Hiddes "Try it" button from the view.
       */
      noTryIt: { type: Boolean },
      /**
       * Computed list of operations to render in the operations list.
       * @type {Object}
       */
      operations: { type: Array },
      /**
       * Computed value if the endpoint contains operations.
       */
      hasOperations: { type: Boolean },
      /**
       * If set then it renders methods documentation inline with
       * the endpoint documentation.
       * When it's not set (or value is `false`, default) then it renders
       * just a list of methods with links.
       */
      inlineMethods: { type: Boolean },
      /**
       * In inline mode, passes the `noUrlEditor` value on the
       * `api-request-paqnel`
       */
      noUrlEditor: { type: Boolean },
      /**
       * OAuth2 redirect URI.
       * This value **must** be set in order for OAuth 1/2 to work properly.
       * This is only required in inline mode (`inlineMethods`).
       */
      redirectUri: { type: String },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * Applied outlined theme to the try it panel
       */
      outlined: { type: Boolean },
      /**
       * Passed to `api-type-document`. Enables internal links rendering for types.
       */
      graph: { type: Boolean },

      _editorEventTarget: { type: Object }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get _exampleGenerator() {
    if (!this.__exampleGenerator) {
      this.__exampleGenerator = document.createElement('api-example-generator');
    }
    this.__exampleGenerator.amf = this.amf;
    return this.__exampleGenerator;
  }

  get baseUri() {
    return this._baseUri;
  }

  set baseUri(value) {
    const old = this._baseUri;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._baseUri = value;
    this.endpointUri = this._computeEndpointUri(this.server, this.endpoint, value, this.apiVersion);
  }

  get scrollTarget() {
    return this._scrollTarget;
  }

  set scrollTarget(value) {
    const old = this._scrollTarget;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._scrollTarget = value;
    this._scrollTargetChanged(value);
  }

  get inlineMethods() {
    return this._inlineMethods;
  }

  set inlineMethods(value) {
    const old = this._inlineMethods;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._inlineMethods = value;
    this._inlineMethodsChanged(value);
    this.operations = this._computeOperations(this.endpoint, value, this.amf);
    this.requestUpdate('inlineMethods', old);
  }

  get operations() {
    return this._operations;
  }

  set operations(value) {
    const old = this._operations;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._operations = value;
    this.hasOperations = !!(value && value.length);
    this.requestUpdate('operations', old);
  }

  get endpoint() {
    return this._endpoint;
  }

  set endpoint(value) {
    const old = this._endpoint;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._endpoint = value;
    this._endpointChanged();
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._selected = value;
    this._selectedChanged(value);
  }

  constructor() {
    super();
    this._scrollHandler = this._scrollHandler.bind(this);

    this._editorEventTarget = this;
  }

  __amfChanged() {
    if (this.__amfProcessingDebouncer) {
      return;
    }
    this.__amfProcessingDebouncer = true;
    setTimeout(() => this._processModelChange());
  }

  _endpointChanged() {
    if (this.__endpointProcessingDebouncer) {
      return;
    }
    this.__endpointProcessingDebouncer = true;
    setTimeout(() => this._processEndpointChange());
  }

  _processModelChange() {
    this.__amfProcessingDebouncer = false;
    const { amf } = this;
    if (!amf) {
      return;
    }
    const apiVersion = this.apiVersion = this._computeApiVersion(amf);
    const server = this.server = this._computeServer(amf);
    this.endpointUri = this._computeEndpointUri(server, this.endpoint, this.baseUri, apiVersion);
    this.operations = this._computeOperations(this.endpoint, this.inlineMethods, amf);
  }

  _processEndpointChange() {
    this.__endpointProcessingDebouncer = false;
    const { endpoint } = this;
    if (!endpoint) {
      return;
    }
    this.endpointName = this._computeEndpointName(endpoint);
    this.description = this._computeDescription(endpoint);
    this.path = this._computePath(endpoint);
    this.hasCustomProperties = this._computeHasCustomProperties(endpoint);
    this.endpointUri = this._computeEndpointUri(this.server, endpoint, this.baseUri, this.apiVersion);
    const types = this.extendsTypes = this._computeExtendsTypes(endpoint);
    this.traits = this._computeTraits(types);
    const parent = this.parentType = this._computeParentType(types);
    this.parentTypeName = this._computeParentTypeName(parent);
    this.operations = this._computeOperations(endpoint, this.inlineMethods, this.amf);
  }

  /**
   * Computes method's endpoint name.
   * It looks for `http://schema.org/name` in the endpoint definition and
   * if not found it uses path as name.
   *
   * @param {Object} endpoint Endpoint model.
   * @return {String} Endpoint name.
   */
  _computeEndpointName(endpoint) {
    const name = this._getValue(endpoint, this.ns.schema.schemaName);
    // if (!name) {
    //   name = this._computePath(endpoint);
    // }
    return name;
  }
  /**
   * Computes value of `path` property
   *
   * @param {Object} endpoint Endpoint model.
   * @return {String}
   */
  _computePath(endpoint) {
    return this._getValue(endpoint, this.ns.raml.vocabularies.http + 'path');
  }
  /**
   * Computes `extendsTypes`
   *
   * @param {Object} shape AMF shape to get `#extends` model
   * @return {Array<Object>|undefined}
   */
  _computeExtendsTypes(shape) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.document + 'extends');
    return shape && this._ensureArray(shape[key]);
  }
  /**
   * Computes parent type as RAML's resource type.
   *
   * @param {Array<Object>} types Current value of `extendsTypes`
   * @return {Object|undefined}
   */
  _computeParentType(types) {
    if (!types || !types.length) {
      return;
    }
    return types.find((item) =>
      this._hasType(item, this.ns.raml.vocabularies.document + 'ParametrizedResourceType'));
  }
  /**
   * Computes vaolue for `parentTypeName`
   *
   * @param {?Object} type Parent type shape
   * @return {String|undefined}
   */
  _computeParentTypeName(type) {
    return this._getValue(type, this.ns.schema.schemaName);
  }
  /**
   * Computes value for `traits` property
   *
   * @param {Array<Object>} types Current value of `extendsTypes`
   * @return {Array<Object>|undefined}
   */
  _computeTraits(types) {
    if (!types || !types.length) {
      return;
    }
    const data = types.filter((item) =>
      this._hasType(item, this.ns.raml.vocabularies.document + 'ParametrizedTrait'));
    return data.length ? data : undefined;
  }
  /**
   * Computes list of trait names to render it in the doc.
   *
   * @param {Array<Object>} traits AMF trait definition
   * @return {String|undefined} Trait name if defined.
   */
  _computeTraitNames(traits) {
    if (!traits || !traits.length) {
      return;
    }
    const names = traits.map((trait) => this._getValue(trait, this.ns.schema.schemaName));
    if (names.length === 2) {
      return names.join(' and ');
    }
    return names.join(', ');
  }
  /**
   * Navigates to next method. Calls `_navigate` with id of previous item.
   */
  _navigatePrevious() {
    this._navigate(this.previous.id, 'endpoint');
  }
  /**
   * Navigates to next method. Calls `_navigate` with id of next item.
   */
  _navigateNext() {
    this._navigate(this.next.id, 'endpoint');
  }
  /**
   * Dispatches `api-navigation-selection-changed` so other components
   * can update their state.
   *
   * @param {String} id
   * @param {String} type
   */
  _navigate(id, type) {
    const e = new CustomEvent('api-navigation-selection-changed', {
      bubbles: true,
      composed: true,
      detail: {
        selected: id,
        type: type
      }
    });
    this.dispatchEvent(e);
  }
  /**
   * Computes value for `operations` property.
   * @param {Object} endpoint Endpoint model.
   * @param {Boolean} inlineMethods
   * @return {Array<Object>}
   */
  _computeOperations(endpoint, inlineMethods) {
    if (!endpoint) {
      return;
    }
    const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
    const ops = this._ensureArray(endpoint[key]);
    if (!ops || !ops.length) {
      return;
    }
    if (inlineMethods) {
      return ops.map((item) => {
        item._tryitOpened = true;
        return item;
      });
    }
    const result = [];
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      const method = this._getValue(op, this.ns.w3.hydra.core + 'method');
      const name = this._getValue(op, this.ns.schema.schemaName);
      const desc = this._getValue(op, this.ns.schema.desc);
      result[result.length] = {
        method,
        name,
        desc,
        id: op['@id']
      };
    }
    return result;
  }

  _methodNavigate(e) {
    e.stopPropagation();
    e.preventDefault();
    const target = e.composedPath().find((node) => node.nodeName === 'A');
    const id = target.dataset.apiId;
    this._navigate(id, 'method');
  }

  /**
   * Handles scroll target chane and adds scroll event.
   *
   * @param {Node} st The scroll target.
   */
  _scrollTargetChanged(st) {
    if (this._oldScrollTarget) {
      this._oldScrollTarget.removeEventListener('scroll', this._scrollHandler);
      this._oldScrollTarget = undefined;
    }
    if (st) {
      st.addEventListener('scroll', this._scrollHandler);
      this._oldScrollTarget = st;
    }
  }
  /**
   * Scroll handler for `scrollTarget`.
   * It does not stall main thred by executing the action after nex render.
   */
  _scrollHandler() {
    if (!this.inlineMethods) {
      return;
    }
    setTimeout(() => this._checkMethodsPosition());
  }
  /**
   * I hope this won't be required in final version :(
   */
  _checkMethodsPosition() {
    const st = this._oldScrollTarget;
    if (!st) {
      return;
    }
    // Window object has `scrollY` but HTML element has `scrollTop`
    const scroll = st.scrollY || st.scrollTop;
    if (scroll === undefined) {
      return;
    }
    const diff = (this._lastScrollPos || 0) - scroll;
    if (diff === 0) {
      return;
    }
    this._lastScrollPos = scroll;
    const dir = diff < 0 ? 'down' : 'up';
    const scrollHeigth = st.scrollHeight || st.innerHeight;
    const targetHeigth = st.offsetHeight || st.innerHeight;
    if (!this._methodsList) {
      const section = this.shadowRoot.querySelector('section.methods');
      // This list is a live node list so the reference has to be made
      // only once.
      this._methodsList = section.childNodes;
    }
    for (let i = 0, len = this._methodsList.length; i < len; i++) {
      const node = this._methodsList[i];
      if (node.nodeName !== 'DIV') {
        continue;
      }
      if (this._occupiesMainScrollArea(targetHeigth, scrollHeigth, dir, node)) {
        const doc = node.querySelector('api-method-documentation');
        this._notifyPassiveNavigation(doc.method['@id']);
        return;
      }
    }
  }
  /**
   * Function that checks if an `element` is in the main scrolling area.
   *
   * @param {Number} targetHeigth Height (visible) of the scroll target
   * @param {Number} scrollHeigth Height of the scroll target
   * @param {String} dir Direction where the scroll is going (up or down)
   * @param {Node} element The node to test
   * @return {Boolean} True when it determines that the element is in the main
   * scroll area,
   */
  _occupiesMainScrollArea(targetHeigth, scrollHeigth, dir, element) {
    const rect = element.getBoundingClientRect();
    if (rect.top < 0 && rect.bottom > targetHeigth) {
      // Occupies whole area
      return true;
    }
    if (rect.bottom < 0 || targetHeigth < rect.top ||
      (rect.top < 0 && rect.top + rect.height <= 0)) {
      // Completely out of screen
      return false;
    }
    if (rect.top < 0 && dir === 'down' && rect.top + rect.height < targetHeigth / 2) {
      // less than half screen
      return false;
    }
    if (dir === 'down' && (rect.top + rect.height) > targetHeigth / 2) {
      return true;
    }
    const padding = 60;
    if (rect.y > 0 && rect.y < padding) {
      if (dir === 'up') {
        return false;
      }
      return true;
    }
    if (dir === 'up' && (rect.bottom + padding) > scrollHeigth && rect.bottom < targetHeigth) {
      return true;
    }
    return false;
  }

  /**
   * Dispatches `api-navigation-selection-changed` custom event with
   * `passive: true` set on the detail object.
   * Listeners should not react on this event except for the ones that
   * should reflect passive navigation change.
   *
   * @param {String} selected Id of selected method as in AMF model.
   */
  _notifyPassiveNavigation(selected) {
    if (this.__notyfyingChange || this.__latestNotified === selected ||
      this.selected === selected) {
      return;
    }
    this.__latestNotified = selected;
    this.__notyfyingChange = true;
    setTimeout(() => {
      this.__notyfyingChange = false;
      this.dispatchEvent(new CustomEvent('api-navigation-selection-changed', {
        composed: true,
        bubbles: true,
        detail: {
          selected,
          type: 'method',
          passive: true
        }
      }));
    }, 200);
  }

  /**
   * Hadnler for either `selected` or `endpoint proerty change`
   * @param {String} selected Currently selected shape ID in AMF model
   * @param {Object} endpoint AMF model for the endpoint.
   * @param {Boolean} inlineMethods True if methods documentation is included
   */
  _selectedChanged(selected) {
    if (!selected) {
      return;
    }
    const { endpoint, inlineMethods } = this;
    if (!endpoint || !inlineMethods) {
      return;
    }
    setTimeout(() => this._repositionVerb(selected));
  }
  /**
   * Positions the method (operation) or endpoint (main title).
   *
   * @param {String} id Selected AMF id.
   */
  _repositionVerb(id) {
    let options;
    if ('scrollBehavior' in document.documentElement.style) {
      options = {
        block: 'start',
        inline: 'nearest'
      };
    } else {
      options = true;
    }
    const isEndpoint = (this.endpoint && this.endpoint['@id'] === id);
    if (isEndpoint) {
      const title = this.shadowRoot.querySelector('.title');
      if (title) {
        title.scrollIntoView(true);
      }
      return;
    }
    const selector = `[data-operation-id="${id}"]`;
    const node = this.shadowRoot.querySelector(selector);
    if (!node) {
      return;
    }
    node.scrollIntoView(options);
  }

  _computeOperationId(item) {
    return item && item['@id'];
  }
  // Computes a label for the section toggle buttons.
  _computeToggleActionLabel(opened) {
    return opened ? 'Hide' : 'Show';
  }
  // Computes class for the toggle's button icon.
  _computeToggleIconClass(opened) {
    let clazz = 'toggle-icon';
    if (opened) {
      clazz += ' opened';
    }
    return clazz;
  }

  /**
   * Computes example headers string for code snippets.
   * @param {Array} method Method (operation) model
   * @return {String|undefind} Computed example value for headers
   */
  _computeSnippetsHeaders(method) {
    if (!method) {
      return;
    }
    const expects = this._computeExpects(method);
    if (!expects) {
      return;
    }
    let result;
    const headers = this._computeHeaders(expects);
    if (headers && headers.length) {
      result = '';
      headers.forEach((item) => {
        const name = this._getValue(item, this.ns.schema.schemaName);
        const value = this._computePropertyValue(item) || '';
        result += `${name}: ${value}\n`;
      });
    }
    return result;
  }
  /**
   * Computes example payload string for code snippets.
   * @param {Array} payload Payload model from AMF
   * @return {String|undefind} Computed example value for payload
   */
  _computeSnippetsPayload(payload) {
    if (payload && payload instanceof Array) {
      payload = payload[0];
    }
    if (this._hasType(payload, this.ns.w3.hydra.core + 'Operation')) {
      const expects = this._computeExpects(payload);
      payload = this._computePayload(expects);
    }
    if (payload && payload instanceof Array) {
      payload = payload[0];
    }
    if (!payload) {
      return;
    }

    let mt = this._getValue(payload, this.ns.raml.vocabularies.http + 'mediaType');
    if (!mt) {
      mt = 'application/json';
    }
    const examples = this._exampleGenerator.generatePayloadExamples(payload, mt, {});
    if (!examples || !examples[0]) {
      return;
    }
    return examples[0].value;
  }
  /**
   * Tries to find an example value (whether it's default value or from an
   * example) to put it into snippet's values.
   *
   * @param {Object} item A http://raml.org/vocabularies/http#Parameter property
   * @return {String|undefined}
   */
  _computePropertyValue(item) {
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'schema');
    let schema = item && item[key];
    if (!schema) {
      return;
    }
    if (schema instanceof Array) {
      schema = schema[0];
    }
    let value = this._getValue(item, this.ns.w3.shacl.name + 'defaultValue');
    if (!value) {
      const examplesKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'examples');
      let example = item[examplesKey];
      if (example) {
        if (example instanceof Array) {
          example = example[0];
        }
        value = this._getValue(item, this.ns.raml.vocabularies.document + 'value');
      }
    }
    return value;
  }

  /**
   * Computes value for `httpMethod` property.
   *
   * @param {Object} method AMF `supportedOperation` model
   * @return {String|undefined} HTTP method name
   */
  _computeHttpMethod(method) {
    let name = this._getValue(method, this.ns.w3.hydra.core + 'method');
    if (name) {
      name = name.toUpperCase();
    }
    return name;
  }

  _toggleSnippets(e) {
    const index = Number(e.currentTarget.dataset.index);
    const newState = !this.operations[index]._snippetsOpened;
    this.operations[index]._snippetsOpened = newState;
    this.requestUpdate();
  }

  _toggleRequestPanel(e) {
    const index = Number(e.currentTarget.dataset.index);
    const newState = !this.operations[index]._tryitOpened;
    this.operations[index]._tryitOpened = newState;
    this.requestUpdate();
  }
  /**
   * A handler for the `inlineMethods` property change.
   * When set it automatically disables the try it button.
   *
   * @param {Boolean} value Current value of `inlineMethods`
   */
  _inlineMethodsChanged(value) {
    if (value && !this.noTryIt) {
      this.noTryIt = true;
    }
  }
  /**
   * Computes special class names for the method container.
   * It adds `first`, and `last` names to corresponding
   * containers.
   *
   * @param {Number} index
   * @param {Array} operations
   * @return {String}
   */
  _computeTryItColumClass(index, operations) {
    if (!operations || !operations.length || index === undefined) {
      return '';
    }
    let klass = '';
    if (index === 0) {
      klass += ' first';
    }
    if (index === operations.length - 1) {
      klass += ' last';
    }
    return klass;
  }

  _computeTryItSelected(item) {
    if (!item) {
      return;
    }
    return item['@id'];
  }

  _apiChanged(e) {
    this.amf = e.detail.value;
  }

  render() {
    const {
      aware,
      hasCustomProperties,
      endpoint,
      hasOperations,
      description
    } = this;
    return html`
    ${aware ? html`<raml-aware
      .scope="${aware}"
      @api-changed="${this._apiChanged}"></raml-aware>` : ''}
    ${this._getTitleTemplate()}
    ${this._getUrlTemplate()}
    ${this._getExtensionsTemplate()}
    ${hasCustomProperties ? html`<api-annotation-document .shape="${endpoint}"></api-annotation-document>` : ''}
    ${this._getDescriptionTemplate(description)}
    <div class="heading2 table-title" role="heading" aria-level="2">Methods</div>
    ${hasOperations ?
      this._getOperationsTemplate() :
      html`<p class="noinfo">This enpoint doesn't have HTTP methods defined in the API specification file.</p>`}
    ${this._getNavigationTemplate()}`;
  }

  _getDescriptionTemplate(description) {
    if (!description) {
      return html``;
    }
    return html`<arc-marked .markdown="${description}">
      <div slot="markdown-html" class="markdown-body"></div>
    </arc-marked>`;
  }

  _getTitleTemplate() {
    const { endpointName } = this;
    if (!endpointName) {
      return html``;
    }
    return html`
    <div role="heading" aria-level="1" class="title">${endpointName}</div>
    `;
  }

  _getUrlTemplate() {
    if (this.inlineMethods) {
      return html``;
    }
    const { endpointUri, endpointName } = this;
    return html`<section class="url-area" ?extra-margin="${!endpointName}">
      <div class="url-value">${endpointUri}</div>
    </section>`;
  }

  _getExtensionsTemplate() {
    const { parentTypeName, traits } = this;
    const hasTraits = !!(traits && traits.length);
    if (!hasTraits && !parentTypeName) {
      return html``;
    }
    const traitsLabel = hasTraits && this._computeTraitNames(traits);
    return html`<section class="extensions">
      ${parentTypeName ? html`<span>Implements </span>
      <span class="resource-type-name" title="Resource type applied to this endpoint">${parentTypeName}</span>.` : ''}
      ${hasTraits ? html`<span>Mixes in </span>
      <span class="trait-name">${traitsLabel}</span>.` : ''}
    </section>`;
  }

  _getOperationsTemplate() {
    return this.inlineMethods ?
      this._getInlineMethodsTemplate() :
      this._getMethodsListTemplate();
  }

  _getInlineMethodsTemplate() {
    const { operations } = this;
    if (!operations || !operations.length) {
      return;
    }
    return html`<section class="methods">
      ${operations.map((item, index) => this._inlineMethodTemplate(item, index, operations))}
    </section>`;
  }

  _inlineMethodTemplate(item, index, operations) {
    const {
      amf,
      endpoint,
      narrow,
      baseUri,
      noTryIt,
      compatibility,
      graph
    } = this;
    const klas = this._computeTryItColumClass(index, operations);
    return html`
    <div class="method-container ${klas}">
      <api-method-documentation
        data-operation-id="${item['@id']}"
        .amf="${amf}"
        .endpoint="${endpoint}"
        .method="${item}"
        .narrow="${narrow}"
        .baseUri="${baseUri}"
        .noTryIt="${noTryIt}"
        .compatibility="${compatibility}"
        ?graph="${graph}"
        rendersecurity></api-method-documentation>
      <div class="try-it-column">
        ${this._getRequestPanelTemplate(item, index)}
        ${this._getSnippetsTemplate(item, index)}

      </div>
    </div>`;
  }

  _getRequestPanelTemplate(item, index) {
    // TODO(pawel): maybe to use a directive that renders content asyncronously to
    // avoid cost of loading the try it panel with the method, especially when the try it panel
    // is not rendered immidietly ith the method.
    const label = this._computeToggleActionLabel(item._tryitOpened);
    const iconClass = this._computeToggleIconClass(item._tryitOpened);
    return html`<section class="request-panel">
      <div
        class="section-title-area"
        data-index="${index}"
        @click="${this._toggleRequestPanel}"
        title="Toogle code example details">
        <div class="heading3 table-title" role="heading" aria-level="2">Try the API</div>
        <div class="title-area-actions">
          <anypoint-button class="toggle-button" ?compatibility="${this.compatibility}">
            ${label}
            <span class="icon ${iconClass}">${expandMore}</span>
          </anypoint-button>
        </div>
      </div>
      <iron-collapse .opened="${item._tryitOpened}">
        <api-request-panel
          .amf="${this.amf}"
          .selected="${item['@id']}"
          .narrow="${this.narrow}"
          .noUrlEditor="${this.noUrlEditor}"
          .baseUri="${this.baseUri}"
          .redirectUri="${this.redirectUri}"
          .legacy="${this.compatibility}"
          .outlined="${this.outlined}"
          nodocs></api-request-panel>
      </iron-collapse>
    </section>`;
  }

  _getSnippetsTemplate(item, index) {
    const label = this._computeToggleActionLabel(item._snippetsOpened);
    const iconClass = this._computeToggleIconClass(item._snippetsOpened);
    return html`<section class="snippets">
      <div
        class="section-title-area"
        data-index="${index}"
        @click="${this._toggleSnippets}" title="Toogle code example details">
        <div class="heading3 table-title" role="heading" aria-level="2">Code examples</div>
        <div class="title-area-actions">
          <anypoint-button class="toggle-button" ?compatibility="${this.compatibility}">
            ${label}
            <span class="icon ${iconClass}">${expandMore}</span>
          </anypoint-button>
        </div>
      </div>
      <iron-collapse .opened="${item._snippetsOpened}">
        <http-code-snippets
          scrollable
          .url="${this.endpointUri}"
          .method="${this._computeHttpMethod(item)}"
          .headers="${this._computeSnippetsHeaders(item)}"
          .payload="${this._computeSnippetsPayload(item)}"></http-code-snippets>
      </iron-collapse>
    </section>`;
  }

  _getMethodsListTemplate() {
    const { operations } = this;
    if (!operations || !operations.length) {
      return;
    }
    return html`<section class="methods">
      ${operations.map((item) => html`<div class="method">
        <div class="method-name">
          <a href="#" @click="${this._methodNavigate}" class="method-anchor" data-api-id="${item.id}">
            <span class="method-label" data-method="${item.method}">${item.method}</span>
            <span class="method-value" data-method="${item.name}">${item.name}</span>
          </a>
        </div>
        ${this._getDescriptionTemplate(item.desc)}
      </div>`)}
    </section>`;
  }

  _getNavigationTemplate() {
    const { next, previous } = this;
    if (!next && !previous) {
      return;
    }
    const { compatibility } = this;
    return html`<section class="bottom-nav">
      ${previous ? html`<div class="bottom-link previous" @click="${this._navigatePrevious}">
        <anypoint-icon-button title="${previous.label}" ?compatibility="${compatibility}">
          <span class="icon">${chevronLeft}</span>
        </anypoint-icon-button>
        <span class="nav-label">${previous.label}</span>
      </div>` : ''}
      <div class="nav-separator"></div>
      ${next ? html`<div class="bottom-link next" @click="${this._navigateNext}">
        <span class="nav-label">${next.label}</span>
        <anypoint-icon-button title="${next.label}" ?compatibility="${compatibility}">
          <span class="icon">${chevronRight}</span>
        </anypoint-icon-button>
      </div>` : ''}
    </section>`;
  }
  /**
   * Dispatched when the user requested previous / next
   *
   * @event api-navigation-selection-changed
   * @param {String} selected
   * @param {String} type
   */
}
window.customElements.define('api-endpoint-documentation', ApiEndpointDocumentation);

/**
 * `api-type-documentation`
 *
 * A documentation module for RAML types (resources) using AMF data model.
 *
 * @customElement
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiTypeDocumentation extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      css `:host {
        display: block;
      }

      .title {
        font-size: var(--arc-font-headline-font-size);
        font-weight: var(--arc-font-headline-font-weight);
        letter-spacing: var(--arc-font-headline-letter-spacing);
        line-height: var(--arc-font-headline-line-height);
      }

      :host([narrow]) .title {
        font-size: var(--arc-font-headline-narrow-font-size);
      }

      arc-marked {
        background-color: transparent;
        padding: 0;
      }`
    ];
  }

  render() {
    const {
      aware,
      typeTitle,
      hasCustomProperties,
      amf,
      type,
      isSchema,
      narrow,
      mediaType,
      mediaTypes,
      compatibility,
      graph,
      headerLevel
    } = this;
    return html `
    ${aware ?
      html`<raml-aware @api-changed="${this._apiChangedHandler}" scope="${aware}"></raml-aware>` : undefined}

    ${typeTitle ? html`<div class="title" role="heading" aria-level="${headerLevel}">${typeTitle}</div>` : ''}
    ${hasCustomProperties ?
      html`<api-annotation-document .amf="${amf}" .shape="${type}"></api-annotation-document>` : undefined}

    ${this.description ? html`<arc-marked .markdown="${this.description}">
      <div slot="markdown-html" class="markdown-html" part="markdown-html"></div>
    </arc-marked>` : undefined}

    ${isSchema ?
      html`<api-schema-document
        .shape="${type}"
        .amf="${amf}"
        ?compatibility="${compatibility}"></api-schema-document>` :
      html`<api-type-document
        .amf="${amf}"
        .type="${type}"
        ?narrow="${narrow}"
        .mediaType="${mediaType}"
        .mediaTypes="${mediaTypes}"
        ?graph="${graph}"
        ?compatibility="${compatibility}"></api-type-document>`}`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: {
        type: String
      },
      /**
       * A type definition to render.
       * This should be a one of the following AMF types:
       *
       * - `http://www.w3.org/ns/shacl#NodeShape` (Object)
       * - `http://raml.org/vocabularies/shapes#UnionShape` (Union)
       * - `http://raml.org/vocabularies/shapes#ArrayShape` (Array)
       * - `http://raml.org/vocabularies/shapes#ScalarShape` (single property)
       * @type {Object|Array}
       */
      type: {
        type: Object
      },
      /**
       * Computed value, title of the type.
       */
      typeTitle: {
        type: String
      },
      /**
       * Computed value of method description from `method` property.
       */
      description: {
        type: String
      },
      /**
       * Computed value from current `method`. True if the model contains
       * custom properties (annotations in RAML).
       */
      hasCustomProperties: {
        type: Boolean
      },
      /**
       * Computed value, true when passed model represents a schema
       * (like XML)
       */
      isSchema: {
        type: Boolean
      },
      /**
       * Set to render a mobile friendly view.
       */
      narrow: {
        type: Boolean,
        reflect: true
      },
      /**
       * A media type to use to generate examples.
       */
      mediaType: String,
      /**
       * A list of supported media types for the type.
       * This is used by `api-resource-example-document` to compute examples.
       * In practive it should be value of raml's `mediaType`.
       *
       * Each item in the array is just a name of thr media type.
       *
       * Example:
       *
       * ```json
       * ["application/json", "application/xml"]
       * ```
       *
       * @type {Array<String>}
       */
      mediaTypes: Array,
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * When enabled it renders external types as links and dispatches
       * `api-navigation-selection-changed` when clicked.
       */
      graph: { type: Boolean },
      /**
       * Type of the header in the documentation section.
       * Should be in range of 1 to 6.
       *
       * @default 2
       */
      headerLevel: { type: Number }
    };
  }

  get type() {
    return this._type;
  }

  set type(value) {
    const old = this._type;
    if (old === value) {
      return;
    }
    this._type = value;
    this.requestUpdate('type', old);
    this._typeChanged(value);
  }

  constructor() {
    super();
    this.headerLevel = 2;
  }

  _apiChangedHandler(e) {
    const {
      value
    } = e.detail;
    setTimeout(() => {
      this.amf = value;
    });
  }

  _typeChanged(type) {
    this.isSchema = this._computeIsSchema(type);
    this.hasCustomProperties = this._computeHasCustomProperties(type);
    this.description = this._computeDescription(type);
    this.typeTitle = this._computeTitle(type);
  }
  /**
   * Computes `typeTitle` property
   *
   * @param {Object} shape AMF model for data type
   * @return {String|undefined}
   */
  _computeTitle(shape) {
    if (!shape) {
      return;
    }
    let name = this._getValue(shape, this.ns.schema.schemaName);
    if (!name) {
      name = this._getValue(shape, this.ns.w3.shacl.name + 'name');
    }
    return name;
  }
  /**
   * Computes `description` property
   *
   * @param {Object} shape AMF model for data type
   * @return {String|undefined}
   */
  _computeDescription(shape) {
    return shape && this._getValue(shape, this.ns.schema.desc);
  }
  /**
   * Computes value for `isSchema` property.
   *
   * @param {Object} shape AMF `supportedOperation` model
   * @return {Boolean | undefined}
   */
  _computeIsSchema(shape) {
    if (!shape) {
      return;
    }
    return this._hasType(shape, this.ns.w3.shacl.name + 'SchemaShape');
  }
}
window.customElements.define('api-type-documentation', ApiTypeDocumentation);

/**
 * `api-documentation-document`
 *
 * A component to render documentation node of the AMF model
 *
 * Markdown styles are defined in `advanced-rest-client/markdown-styles`.
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiDocumentationDocument extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      css`:host {
        display: block;
      }

      h1 {
        font-size: var(--arc-font-headline-font-size);
        font-weight: var(--arc-font-headline-font-weight);
        letter-spacing: var(--arc-font-headline-letter-spacing);
        line-height: var(--arc-font-headline-line-height);
      }

      arc-marked {
        background-color: transparent;
        padding: 0;
      }`
    ];
  }

  render() {
    const { _title: title, _content: content } = this;
    const hasTitle = !!title;
    return html`
    <div id="preview">
      ${hasTitle ? html`<h1>${title}</h1>` : undefined}
      <arc-marked .markdown="${content}">
        <div slot="markdown-html" part="markdown-html" class="markdown-html"></div>
      </arc-marked>
    </div>`;
  }

  static get properties() {
    return {
      /**
       * A Document to render.
       * Represents AMF's shape for document.
       */
      shape: { type: Object },
      /**
       * Computed value of the title of the documentation.
       * Might be undefined.
       */
      _title: { type: String },
      /**
       * Computed value of content of documentation.
       */
      _content: { type: String }
    };
  }

  get shape() {
    return this._shape;
  }

  set shape(value) {
    const old = this._shape;
    if (old === value) {
      return;
    }
    this._shape = value;
    this.requestUpdate('shape', old);
    this._shapeChanged(value);
  }

  __amfChanged() {
    this._shapeChanged(this.shape);
  }
  /**
   * Computes `title` and `content` properties when `shape` changes.
   * @param {Object} shape Value of the `shape` attrribute
   */
  _shapeChanged(shape) {
    this._title = this._getValue(shape, this.ns.schema.title);
    this._content = this._getValue(shape, this.ns.schema.desc);
  }
}
window.customElements.define('api-documentation-document', ApiDocumentationDocument);

/**
 * `api-summary`
 *
 * A summary view for an API base on AMF data model
 *
 * ## Styling
 *
 * `<api-summary>` provides the following custom properties and mixins for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--api-summary` | Mixin applied to this elment | `{}`
 * `--api-summary-color` | Color of text labels | ``
 * `--api-summary-url-font-size` | Font size of endpoin URL | `16px`
 * `--api-summary-url-background-color` | Background color of the URL section | `#424242`
 * `--api-summary-url-font-color` | Font color of the URL area | `#fff`
 * `--api-summary-separator-color` | Color of section separator | `rgba(0, 0, 0, 0.12)`
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiSummary extends AmfHelperMixin(LitElement) {
  static get styles() {
    return [
      markdownStyles,
      labelStyles,
      css`
        :host {
          display: block;
          font-size: 1rem;
          color: var(--api-summary-color, inherit);
          font-weight: var(--arc-font-body1-font-weight, initial);
          line-height: var(--arc-font-body1-line-height, initial);
        }

        .api-title {
          font-size: var(--api-summary-title-font-size, 1.5rem);
          font-weight: var(--api-summary-title-font-weight, 200);
          letter-spacing: var(--api-summary-title-letter-spacing);
          line-height: var(--api-summary-title-line-height);
          margin: 12px 0;
        }

        arc-marked {
          padding: 0;
        }

        .marked-description {
          margin: 24px 0;
        }

        .markdown-body {
          margin-bottom: 28px;
        }

        :host([narrow]) h1 {
          font-size: var(--api-summary-title-narrow-font-size, 1.2rem);
          margin: 0;
        }

        .url-area {
          display: flex;
          flex-direction: column;
          font-family: var(--arc-font-code-family);

          margin-bottom: 40px;
          margin-top: 20px;
          background-color: var(--code-background-color);
          color: var(--code-color);
          padding: 8px;
          border-radius: var(--api-endpoint-documentation-url-border-radius, 4px);
        }

        .url-label {
          font-size: 0.75rem;
          font-weight: 700;
        }

        .url-value {
          font-size: var(--api-endpoint-documentation-url-font-size, 16px);
          word-break: break-all;
        }

        .method-value {
          text-transform: uppercase;
          white-space: nowrap;
        }

        label.section {
          font-weight: var(--arc-font-subhead-font-weight);
          line-height: var(--arc-font-subhead-line-height);
          font-size: 18px;
          margin-top: 20px;
          display: block;
        }

        a {
          color: var(--link-color);
        }

        a:hover {
          color: var(--link-hover-color);
        }

        .chip {
          display: inline-block;
          white-space: nowrap;
          padding: 2px 4px;
          margin-right: 8px;
          background-color: var(--api-summary-chip-background-color, #f0f0f0);
          color: var(--api-summary-chip-color, #616161);
          border-radius: var(--api-summary-chip-border-radius, 2px);
        }

        .app-link {
          color: var(--link-color);
        }

        .link-padding {
          margin-left: 8px;
        }

        .inline-description {
          padding: 0;
          margin: 0;
        }

        .docs-section {
          margin-bottom: 40px;
        }

        .separator {
          background-color: var(--api-summary-separator-color, rgba(0, 0, 0, 0.12));
          height: 1px;
          margin: 40px 0;
        }

        .endpoint-item {
          margin-bottom: 32px;
        }

        .method-label {
          margin-right: 8px;
          margin-bottom: 8px;
          text-decoration: none;
          font-size: var(--api-summary-method-font-size, 1.1rem);
          padding: var(--api-summary-method-padding, 4px 6px);
        }

        .method-label:hover,
        .method-label:focus {
          text-decoration: underline;
        }

        .endpoint-path {
          display: block;
          text-decoration: none;
          cursor: pointer;
          margin-bottom: 4px;
          display: inline-block;
          font-weight: 500;
          font-size: var(--api-summary-endpoint-path-font-size, 1.5rem);
          color: var(--link-color, #0277BD);
          margin: 12px 0;
          word-break: break-all;
        }

        .endpoint-path:hover,
        .endpoint-path:focus {
          text-decoration: underline;
          color: var(--link-color, #0277BD);
        }

        .toc .section {
          margin-bottom: 24px;
        }

        .section.endpoints-title {
          font-size: var(--api-summary-endpoints-font-size, 1.5rem);
          font-weight: 500;
        }

        .endpoint-path-name {
          word-break: break-all;
        }
      `
    ];
  }

  _titleTemplate() {
    const { _apiTitle, titleLevel } = this;
    if (!_apiTitle) {
      return '';
    }
    return html`<div class="api-title" role="heading" aria-level="${titleLevel}">${_apiTitle}</div>`;
  }

  _versionTemplate() {
    const { _version } = this;
    if (!_version) {
      return '';
    }
    return html`
    <p class="inline-description version">
      <label>Version:</label>
      <span>${_version}</span>
    </p>`;
  }

  _descriptionTemplate() {
    const { _description } = this;
    if (!_description) {
      return '';
    }
    return html`
    <div role="region" class="marked-description">
      <arc-marked .markdown="${_description}">
        <div slot="markdown-html" class="markdown-body"></div>
      </arc-marked>
    </div>`;
  }

  _baseUriTemplate() {
    const { _apiBaseUri } = this;
    if (!_apiBaseUri) {
      return '';
    }
    return html`
    <div class="url-area">
      <span class="url-label">API base URI</span>
      <div class="url-value">${_apiBaseUri}</div>
    </div>`;
  }

  _protocolsTemplate() {
    const { _protocols } = this;
    if (!_protocols || !_protocols.length) {
      return '';
    }
    const result = _protocols.map((item) => html`<span class="chip">${item}</span>`);

    return html`
    <label class="section">Supported protocols</label>
    <div class="protocol-chips">${result}</div>`;
  }

  _contactInfoTemplate() {
    const { _providerName, _providerEmail, _providerUrl } = this;
    if (!_providerName) {
      return '';
    }
    return html`
    <section role="contentinfo" class="docs-section">
      <label class="section">Contact information</label>
      <p class="inline-description">
        <span class="provider-name">${_providerName}</span>
        ${_providerEmail ? html`<a
            class="app-link link-padding provider-email"
            href="mailto:${_providerEmail}">${_providerEmail}</a>` : ''}
      </p>
      ${_providerUrl ? html`
        <p class="inline-description">
          <a href="${_providerUrl}" target="_blank" class="app-link provider-url">${_providerUrl}</a>
        </p>` : ''}
    </section>`;
  }

  _licenseTemplate() {
    const { _licenseUrl, _licenseName } = this;
    if (!_licenseUrl || !_licenseName) {
      return '';
    }
    return html`
    <section role="region" aria-labelledby="licenseLabel" class="docs-section">
      <label class="section" id="licenseLabel">License</label>
      <p class="inline-description">
        <a href="${_licenseUrl}" target="_blank" class="app-link">${_licenseName}</a>
      </p>
    </section>`;
  }

  _termsOfServiceTemplate() {
    const { _termsOfService } = this;
    if (!_termsOfService || !_termsOfService.length) {
      return '';
    }
    return html`
    <section role="region" aria-labelledby="tocLabel" class="docs-section">
      <label class="section" id="tocLabel">Terms of service</label>
      <arc-marked .markdown="${_termsOfService}">
        <div slot="markdown-html" class="markdown-body"></div>
      </arc-marked>
    </section>`;
  }

  _endpointsTemplate() {
    const { _endpoints } = this;
    if (!_endpoints || !_endpoints.length) {
      return;
    }
    const result = _endpoints.map((item) => this._endpointTemplate(item));
    return html`
    <div class="separator"></div>
    <div class="toc">
      <label class="section endpoints-title">API endpoints</label>
      ${result}
    </div>
    `;
  }

  _endpointTemplate(item) {
    const ops = item.ops && item.ops.length ? item.ops.map((op) => this._methodTemplate(op, item)) : '';
    return html`
    <div class="endpoint-item" @click="${this._navigateItem}">
      ${item.name ? this._endpointNameTemplate(item) : this._endpointPathTemplate(item)}
      <div class="endpoint-header">
        ${ops}
      </div>
    </div>`;
  }

  _endpointPathTemplate(item) {
    return html`
    <a
      class="endpoint-path"
      href="#${item.path}"
      data-id="${item.id}"
      data-shape-type="endpoint"
      title="Open endpoint documentation">${item.path}</a>
    `;
  }

  _endpointNameTemplate(item) {
    if (!item.name) {
      return '';
    }
    return html`
    <a
      class="endpoint-path"
      href="#${item.path}"
      data-id="${item.id}"
      data-shape-type="endpoint"
      title="Open endpoint documentation">${item.name}</a>
    <p class="endpoint-path-name">${item.path}</p>
    `;
  }

  _methodTemplate(item, endpoint) {
    return html`
      <a
        href="#${endpoint.path + '/' + item.method}"
        class="method-label"
        data-method="${item.method}"
        data-id="${item.id}"
        data-shape-type="method"
        title="Open method documentation">${item.method}</a>
    `;
  }

  render() {
    const { aware } = this;
    return html`
      ${aware ?
        html`<raml-aware @api-changed="${this._apiHandler}" .scope="${aware}"></raml-aware>` :
        ''}

      <div>
        ${this._titleTemplate()}
        ${this._versionTemplate()}
        ${this._descriptionTemplate()}
        ${this._baseUriTemplate()}
        ${this._protocolsTemplate()}
        ${this._contactInfoTemplate()}
        ${this._licenseTemplate()}
        ${this._termsOfServiceTemplate()}
      </div>

      ${this._endpointsTemplate()}
    `;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * A property to set to override AMF's model base URI information.
       * When this property is set, the `endpointUri` property is recalculated.
       */
      baseUri: { type: String, value: '' },
      /**
       * API title header level in value range from 1 to 6.
       * This is made for accessibility. It the component is used in a context
       * where headers order matters then this property is to be set to
       * arrange headers in the right order.
       *
       * @default 2
       */
      titleLevel: { type: String },

      _providerName: { type: String },
      _providerEmail: { type: String },
      _providerUrl: { type: String },
      _licenseName: { type: String },
      _licenseUrl: { type: String },
      _endpoints: { type: Array },
      _termsOfService: { type: String },
      _version: { type: String },
      _apiTitle: { type: String },
      _description: { type: String },
      _apiBaseUri: { type: String },
      _protocols: { type: Array }
    };
  }

  get baseUri() {
    return this._baseUri;
  }

  set baseUri(value) {
    const old = this._baseUri;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._baseUri = value;
    this._apiBaseUri = this._computeBaseUri(this.server, value, this.protocols);
    this.requestUpdate('baseUri', old);
  }

  get _protocols() {
    return this.__protocols;
  }

  set _protocols(value) {
    const old = this.__protocols;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this.__protocols = value;
    this._apiBaseUri = this._computeBaseUri(this.server, this.baseUri, value);
    this.requestUpdate('_protocols', old);
  }

  constructor() {
    super();
    this.titleLevel = 2;
  }

  __amfChanged() {
    if (this.__amfProcessingDebouncer) {
      return;
    }
    this.__amfProcessingDebouncer = true;
    setTimeout(() => this._processModelChange());
  }

  _processModelChange() {
    this.__amfProcessingDebouncer = false;
    const { amf } = this;
    if (!amf) {
      return;
    }

    const webApi = this.webApi = this._computeWebApi(amf);
    const server = this.server = this._computeServer(amf);
    const protocols = this._protocols = this._computeProtocols(amf);
    this._apiBaseUri = this._computeBaseUri(server, this.baseUri, protocols);

    this._webApiChanged(webApi);
  }

  _webApiChanged(webApi) {
    if (!webApi) {
      return;
    }

    this._apiTitle = this._computeApiTitle(webApi);
    this._description = this._computeDescription(webApi);
    this._version = this._computeVersion(webApi);
    this._termsOfService = this._computeToS(webApi);
    this._endpoints = this._computeEndpoints(webApi);

    const provider = this._computeProvider(webApi);
    this._providerName = this._computeName(provider);
    this._providerEmail = this._computeEmail(provider);
    this._providerUrl = this._computeUrl(provider);

    const license = this._computeLicense(webApi);
    this._licenseName = this._computeName(license);
    this._licenseUrl = this._computeUrl(license);
  }

  /**
   * Computes value of `apiTitle` property.
   *
   * @param {Object} shape Shape of AMF model.
   * @return {String|undefined} Description if defined.
   */
  _computeApiTitle(shape) {
    return this._getValue(shape, this.ns.schema.schemaName);
  }
  /**
   * Computes value for `version` property
   * @param {Object} webApi AMF's WebApi shape
   * @return {String|undefined}
   */
  _computeVersion(webApi) {
    return this._getValue(webApi, this.ns.schema.name + 'version');
  }
  /**
   * Computes API's URI based on `amf` and `baseUri` property.
   *
   * @param {Object} server Server model of AMF API.
   * @param {?String} baseUri Current value of `baseUri` property
   * @param {?Array<String>} protocols List of supported protocols
   * @return {String} Endpoint's URI
   */
  _computeBaseUri(server, baseUri, protocols) {
    let base = this._getBaseUri(baseUri, server, protocols);
    if (base && base[base.length - 1] === '/') {
      base = base.substr(0, base.length - 1);
    }
    return base;
  }
  /**
   * Computes information about provider of the API.
   *
   * @param {Object} webApi WebApi shape
   * @return {Object|undefined}
   */
  _computeProvider(webApi) {
    if (!webApi) {
      return;
    }
    const key = this._getAmfKey(this.ns.schema.name + 'provider');
    let data = this._ensureArray(webApi[key]);
    if (!data) {
      return;
    }
    data = data[0];
    if (data instanceof Array) {
      data = data[0];
    }
    return data;
  }

  _computeName(provider) {
    return this._getValue(provider, this.ns.schema.schemaName);
  }

  _computeEmail(provider) {
    return this._getValue(provider, this.ns.schema.name + 'email');
  }

  _computeUrl(provider) {
    let value = this._getValue(provider, this.ns.schema.name + 'url');
    if (!value && provider) {
      const key = this._getAmfKey(this.ns.schema.name + 'url');
      const data = provider[key];
      if (data) {
        value = data instanceof Array ? data[0]['@id'] : data['@id'];
      }
    }
    return value;
  }

  _computeToS(webApi) {
    return this._getValue(webApi, this.ns.schema.name + 'termsOfService');
  }

  _computeLicense(webApi) {
    const key = this._getAmfKey(this.ns.schema.name + 'license');
    const data = webApi && webApi[key];
    if (!data) {
      return;
    }
    return data instanceof Array ? data[0] : data;
  }
  /**
   * Computes view model for endpoints list.
   * @param {Object} webApi Web API model
   * @return {Array<Object>|undefined}
   */
  _computeEndpoints(webApi) {
    if (!webApi) {
      return;
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'endpoint');
    const endpoints = this._ensureArray(webApi[key]);
    if (!endpoints || !endpoints.length) {
      return;
    }
    return endpoints.map((item) => {
      const result = {
        name: this._getValue(item, this.ns.schema.schemaName),
        path: this._getValue(item, this.ns.raml.vocabularies.http + 'path'),
        id: item['@id'],
        ops: this._endpointOperations(item)
      };
      return result;
    });
  }
  /**
   * Computes a view model for supported operations for an endpoint.
   * @param {Object} endpoint Endpoint model.
   * @return {Array<Object>|unbdefined}
   */
  _endpointOperations(endpoint) {
    const key = this._getAmfKey(this.ns.w3.hydra.core + 'supportedOperation');
    const so = this._ensureArray(endpoint[key]);
    if (!so || !so.length) {
      return;
    }
    return so.map((item) => {
      return {
        id: item['@id'],
        method: this._getValue(item, this.ns.w3.hydra.core + 'method')
      };
    });
  }

  _navigateItem(e) {
    e.preventDefault();
    const data = e.composedPath()[0].dataset;
    if (!data.id || !data.shapeType) {
      return;
    }
    const ev = new CustomEvent('api-navigation-selection-changed', {
      bubbles: true,
      composed: true,
      detail: {
        selected: data.id,
        type: data.shapeType
      }
    });
    this.dispatchEvent(ev);
  }

  _apiHandler(e) {
    this.amf = e.target.api;
  }
}
window.customElements.define('api-summary', ApiSummary);

/* eslint-disable max-len */
/**
 * `api-documentation`
 *
 * A main documentation view for AMF model.
 *
 * This element works with [AMF](https://github.com/mulesoft/amf) data model.
 *
 * It works well with `api-navigation` component. When `handle-navigation-events`
 * is set it listens for selection events dispatched by the navigation.
 *
 * To manually steare the behavior of the component you have to set both:
 * - selected
 * - selectedType
 *
 * Selected is an `@id` of the AMF data model in json/ld representation.
 * Selected type tells the component where to look for the data and which
 * view to render.
 *
 * The component handles data computation on selection change.
 *
 * ## Updating API's base URI
 *
 * By default the component render the documentation as it is defined
 * in the AMF model. Sometimes, however, you may need to replace the base URI
 * of the API with something else. It is useful when the API does not
 * have base URI property defined (therefore this component render relative
 * paths instead of URIs) or when you want to manage different environments.
 *
 * To update base URI value either update `baseUri` property or use
 * `iron-meta` with key `ApiBaseUri`. First method is easier but the second
 * gives much more flexibility since it use a
 * [monostate pattern](http://wiki.c2.com/?MonostatePattern)
 * to manage base URI property.
 *
 * When the component constructs the funal URI for the endpoint it does the following:
 * - if `baseUri` is set it uses this value as a base uri for the endpoint
 * - else if `iron-meta` with key `ApiBaseUri` exists and contains a value
 * it uses it uses this value as a base uri for the endpoint
 * - else if `amf` is set then it computes base uri value from main
 * model document
 * Then it concatenates computed base URI with `endpoint`'s path property.
 *
 * ### Example
 *
 * ```html
 * <iron-meta key="ApiBaseUri" value="https://domain.com"></iron-meta>
 * ```
 *
 * To update value of the `iron-meta`:
 * ```javascript
 * new Polymer.IronMeta({key: 'ApiBaseUri'}).value = 'https://other.domain';
 * ```
 *
 * Note: The element will not be notified about the change when `iron-meta` value change.
 * The change will be reflected when `amf` or `endpoint` property chnage.
 *
 *
 * @customElement
 * @polymer
 * @demo demo/index.html
 * @memberof ApiElements
 * @appliesMixin AmfHelperMixin
 */
class ApiDocumentation extends AmfHelperMixin(LitElement) {
  static get styles() {
    return css`:host {
      display: block;
    }`;
  }

  render() {
    const {
      aware
    } = this;
    return html`
    ${aware ? html`<raml-aware
      .scope="${aware}"
      @api-changed="${this._apiChanged}"></raml-aware>` : ''}
    ${this._renderView()}`;
  }

  _renderView() {
    switch (this._viewType) {
      case 'summary': return this._summaryTemplate();
      case 'security': return this._securityTemplate();
      case 'documentation': return this._documentationTemplate();
      case 'type': return this._typeTemplate();
      case 'endpoint': return this._endpointTemplate();
      case 'method': return this._methodTemplate();
    }
  }

  _summaryTemplate() {
    const { _docsModel, baseUri } = this;
    return html`<api-summary .amf="${_docsModel}" .baseUri="${baseUri}"></api-summary>`;
  }

  _securityTemplate() {
    const { amf, _docsModel, narrow } = this;
    return html`<api-security-documentation
      .amf="${amf}"
      .security="${_docsModel}"
      .narrow="${narrow}"></api-security-documentation>`;
  }

  _documentationTemplate() {
    const { amf, _docsModel } = this;
    return html`<api-documentation-document
      .amf="${amf}"
      .shape="${_docsModel}"></api-documentation-document>`;
  }

  _typeTemplate() {
    const { amf, _docsModel, narrow, compatibility, graph } = this;
    const mt = this._computeApiMediaTypes(amf);
    return html`<api-type-documentation
      .amf="${amf}"
      .type="${_docsModel}"
      .narrow="${narrow}"
      .mediaTypes="${mt}"
      .compatibility="${compatibility}"
      ?graph="${graph}"></api-type-documentation>`;
  }

  _methodTemplate() {
    const { amf, _docsModel, narrow, compatibility, _endpoint, selected, baseUri, noTryIt, graph } = this;
    const prev = this._computeMethodPrevious(amf, selected);
    const next = this._computeMethodNext(amf, selected);
    return html`<api-method-documentation
      .amf="${amf}"
      .narrow="${narrow}"
      .compatibility="${compatibility}"
      .endpoint="${_endpoint}"
      .method="${_docsModel}"
      .previous="${prev}"
      .next="${next}"
      .baseUri="${baseUri}"
      .noTryIt="${noTryIt}"
      ?graph="${graph}"
      rendersecurity
      rendercodesnippets></api-method-documentation>`;
  }

  _endpointTemplate() {
    return this.inlineMethods ?
      this._inlineEndpointTemplate() :
      this._simpleEndpointTemplate();
  }

  _inlineEndpointTemplate() {
    const { amf, _docsModel, narrow, compatibility, outlined, selected, baseUri, scrollTarget, redirectUri, noUrlEditor, graph } = this;
    const prev = this._computeEndpointPrevious(amf, selected, true);
    const next = this._computeEndpointNext(amf, selected, true);
    return html`<api-endpoint-documentation
      .amf="${amf}"
      .narrow="${narrow}"
      .compatibility="${compatibility}"
      .outlined="${outlined}"
      .selected="${selected}"
      .endpoint="${_docsModel}"
      .previous="${prev}"
      .next="${next}"
      .baseUri="${baseUri}"
      .scrollTarget="${scrollTarget}"
      .redirectUri="${redirectUri}"
      .noUrlEditor="${noUrlEditor}"
      ?graph="${graph}"
      notryit
      inlinemethods></api-endpoint-documentation>`;
  }

  _simpleEndpointTemplate() {
    const { amf, _docsModel, narrow, compatibility, selected, baseUri, graph } = this;
    const prev = this._computeEndpointPrevious(amf, selected);
    const next = this._computeEndpointNext(amf, selected);

    return html`<api-endpoint-documentation
      .amf="${amf}"
      .narrow="${narrow}"
      .compatibility="${compatibility}"
      .selected="${selected}"
      .endpoint="${_docsModel}"
      .previous="${prev}"
      .next="${next}"
      .baseUri="${baseUri}"
      ?graph="${graph}"
      ></api-endpoint-documentation>`;
  }

  static get properties() {
    return {
      /**
       * `raml-aware` scope property to use.
       */
      aware: { type: String },
      /**
       * A model's `@id` of selected documentation part.
       * Special case is for `summary` view. It's not part of an API
       * but most applications has some kind of summary view for the
       * API.
       */
      selected: { type: String },
      /**
       * Type of the selected item.
       * One of `documentation`, `type`, `security`, `endpoint`, `method`
       * or `summary`.
       */
      selectedType: { type: String },
      /**
       * By default application hosting the element must set `selected` and
       * `selectedType` properties. When using `api-navigation` element
       * by setting this property the element listens for navigation events
       * and updates the state
       */
      handleNavigationEvents: { type: Boolean },
      /**
       * A property to set to override AMF's model base URI information.
       */
      baseUri: { type: String },
      /**
       * Passing value of `noTryIt` to the method documentation.
       * Hiddes "Try it" button.
       */
      noTryIt: { type: Boolean },
      /**
       * If set it will renders the view in the narrow layout.
       */
      narrow: { type: Boolean },
      /**
       * If set then it renders methods documentation inline with
       * the endpoint documentation.
       * When it's not set (or value is `false`, default) then it renders
       * just a list of methods with links.
       */
      inlineMethods: { type: Boolean },
      /**
       * Scroll target used to observe `scroll` event.
       * When set the element will observe scroll and inform other components
       * about changes in navigation while scrolling through methods list.
       * The navigation event contains `passive: true` property that
       * determines that it's not user triggered navigation but rather
       * context enforced.
       */
      scrollTarget: { type: Object },
      /**
       * OAuth2 redirect URI.
       * This value **must** be set in order for OAuth 1/2 to work properly.
       * This is only required in inline mode (`inlineMethods`).
       */
      redirectUri: { type: String },
      /**
       * Enables compatibility with Anypoint components.
       */
      compatibility: { type: Boolean },
      /**
       * @deprecated Use `compatibility` instead
       */
      legacy: { type: Boolean },
      /**
       * When enabled it renders external types as links and dispatches
       * `api-navigation-selection-changed` when clicked.
       *
       * This property is experimental.
       */
      graph: { type: Boolean },
      /**
       * Applied outlined theme to the try it panel
       */
      outlined: { type: Boolean },
      /**
       * In inline mode, passes the `noUrlEditor` value on the
       * `api-request-paqnel`
       */
      noUrlEditor: { type: Boolean },

      // Currently rendered view type
      _viewType: { type: String },
      /**
       * Computed value of the final model extracted from the `amf`, `selected`,
       * and `selectedType` properties.
       * @type {Object}
       */
      _docsModel: { type: Object },
      /**
       * Computed value of currently rendered endpoint.
       */
      _endpoint: { type: Object }
    };
  }

  get legacy() {
    return this.compatibility;
  }

  set legacy(value) {
    this.compatibility = value;
  }

  get selected() {
    return this._selected;
  }

  set selected(value) {
    const old = this._selected;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._selected = value;
    this.__amfChanged();
    this.requestUpdate('selected', old);
  }

  get selectedType() {
    return this._selectedType;
  }

  set selectedType(value) {
    const old = this._selectedType;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._selectedType = value;
    this.__amfChanged();
  }

  get inlineMethods() {
    return this._inlineMethods;
  }

  set inlineMethods(value) {
    const old = this._inlineMethods;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._inlineMethods = value;
    this.__amfChanged();
  }

  get handleNavigationEvents() {
    return this._handleNavigationEvents;
  }

  set handleNavigationEvents(value) {
    const old = this._handleNavigationEvents;
    /* istanbul ignore if */
    if (old === value) {
      return;
    }
    this._handleNavigationEvents = value;
    this._handleNavChanged(value);
  }

  constructor() {
    super();
    this._navigationHandler = this._navigationHandler.bind(this);
  }

  disconnectedCallback() {
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
    if (this.__eventsRegistered) {
      this._unregisterNavigationEvents();
    }
  }

  __amfChanged() {
    if (this.__amfProcessingDebouncer) {
      return;
    }
    this.__amfProcessingDebouncer = true;
    setTimeout(() => this._processModelChange());
  }

  _processModelChange() {
    this.__amfProcessingDebouncer = false;

    let { amf } = this;
    if (!amf) {
      return;
    }
    if (amf instanceof Array) {
      amf = amf[0];
    }
    if (this._hasType(amf, this.ns.raml.vocabularies.document + 'Document')) {
      this.__processApiSpecSelection(amf);
      return;
    }
    if (this._isLibrary(amf)) {
      this.__processLibrarySelection(amf);
      return;
    }
    if (this._isSecurityFragment(amf)) {
      this._processSecurityFragment(amf);
      return;
    }
    if (this._isDocumentationFragment(amf)) {
      this._processDocumentationFragment(amf);
      return;
    }
    if (this._isTypeFragment(amf)) {
      this._processTypeFragment(amf);
      return;
    }
    if (this._isDocumentationPartialModel(amf)) {
      this._processDocumentationParial(amf);
      return;
    }
    if (this._isSecurityPartialModel(amf)) {
      this._processSecurityParial(amf);
      return;
    }
    if (this._isTypePartialModel(amf)) {
      this._processTypeParial(amf);
      return;
    }
    if (this._isEndpointPartialModel(amf)) {
      this._processEndpointParial(amf);
      return;
    }
  }

  /**
   * Registers `api-navigation-selection-changed` event listener handler
   * on window object.
   */
  _registerNavigationEvents() {
    this.__eventsRegistered = true;
    window.addEventListener('api-navigation-selection-changed', this._navigationHandler);
  }
  /**
   * Removes event listener from window object for
   * `api-navigation-selection-changed` event.
   */
  _unregisterNavigationEvents() {
    this.__eventsRegistered = false;
    window.removeEventListener('api-navigation-selection-changed', this._navigationHandler);
  }
  /**
   * Registers / unregisters event listeners depending on `state`
   *
   * @param {Boolean} state
   */
  _handleNavChanged(state) {
    if (state) {
      this._registerNavigationEvents();
    } else {
      this._unregisterNavigationEvents();
    }
  }
  /**
   * Handler for `api-navigation-selection-changed` event.
   *
   * @param {CustomEvent} e
   */
  _navigationHandler(e) {
    if (e.detail.passive === true) {
      return;
    }
    this.selected = e.detail.selected;
    this.selectedType = e.detail.type;
  }
  /**
   * Processes selection for the web API data model. It ignores the input if
   * `selected` or `selectedType` is not set.
   * @param {Object} model WebApi AMF model. Do not use an array here.
   */
  __processApiSpecSelection(model) {
    const { selected, inlineMethods } = this;
    let { selectedType } = this;
    if (!selected || !selectedType) {
      // Not all required properties were set.
      return;
    }
    let result;
    switch (selectedType) {
      case 'summary': result = model; break;
      case 'security': result = this._computeSecurityApiModel(model, selected); break;
      case 'type': result = this._computeTypeApiModel(model, selected); break;
      case 'documentation': result = this._computeDocsApiModel(model, selected); break;
      case 'endpoint':
        result = this._computeEndpointApiModel(model, selected);
        // this._endpoint = result;
        break;
      case 'method':
        if (inlineMethods) {
          selectedType = 'endpoint';
          result = this._computeEndpointApiMethodModel(model, selected);
        } else {
          result = this._computeMethodApiModel(model, selected);
          this._endpoint = this._computeEndpointApiMethodModel(model, selected);
        }
        break;
      default:
        return;
    }
    this._docsModel = result;
    this._viewType = selectedType;
  }
  /**
   * Computes security scheme definition model from web API and current selection.
   * It looks for the definition in both `declares` and `references` properties.
   * Returned value is already resolved AMF model (references are resolved).
   *
   * @param {Object} model WebApi AMF model. Do not use an array here.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for the securit scheme.
   */
  _computeSecurityApiModel(model, selected) {
    const declares = this._computeDeclares(model);
    let result;
    if (declares) {
      result = declares.find((item) => item['@id'] === selected);
    }
    if (!result) {
      const references = this._computeReferences(model);
      if (references && references.length) {
        for (let i = 0, len = references.length; i < len; i++) {
          if (!this._hasType(references[i], this.ns.raml.vocabularies.document + 'Module')) {
            continue;
          }
          result = this._computeReferenceSecurity(references[i], selected);
          if (result) {
            break;
          }
        }
      }
    } else {
      result = this._resolve(result);
    }
    return result;
  }
  /**
   * Computes type definition model from web API and current selection.
   * It looks for the definition in both `declares` and `references` properties.
   * Returned value is already resolved AMF model (references are resolved).
   *
   * @param {Object} model WebApi AMF model. Do not use an array here.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for a type.
   */
  _computeTypeApiModel(model, selected) {
    const declares = this._computeDeclares(model);
    const references = this._computeReferences(model);
    return this._computeType(declares, references, selected);
  }
  /**
   * Computes documentation definition model from web API and current selection.
   *
   * @param {Object} model WebApi AMF model. Do not use an array here.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for a documentation fragment.
   */
  _computeDocsApiModel(model, selected) {
    const webApi = this._computeWebApi(model);
    return this._computeDocument(webApi, selected);
  }
  /**
   * Computes Endpoint definition model from web API and current selection.
   *
   * @param {Object} model WebApi AMF model. Do not use an array here.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for an endpoint fragment.
   */
  _computeEndpointApiModel(model, selected) {
    const webApi = this._computeWebApi(model);
    return this._computeEndpointModel(webApi, selected);
  }
  /**
   * Computes Method definition model from web API and current selection.
   *
   * @param {Object} model WebApi AMF model. Do not use an array here.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for an endpoint fragment.
   */
  _computeMethodApiModel(model, selected) {
    const webApi = this._computeWebApi(model);
    return this._computeMethodModel(webApi, selected);
  }

  _computeEndpointApiMethodModel(model, selected) {
    const webApi = this._computeWebApi(model);
    return this._computeMethodEndpoint(webApi, selected);
  }
  /**
   * Processes selection for a library data model. It ignores the input if
   * `selected` or `selectedType` is not set.
   * @param {Object} model Library AMF model. Do not use an array here.
   */
  __processLibrarySelection(model) {
    const { selected, selectedType } = this;
    if (!selected || !selectedType) {
      // Not all required properties were set.
      return;
    }
    let result;
    switch (selectedType) {
      case 'security': result = this._computeSecurityLibraryModel(model, selected); break;
      case 'type': result = this._computeTypeLibraryModel(model, selected); break;
      default:
        return;
    }
    this._docsModel = result;
    this._viewType = selectedType;
  }
  /**
   * Computes Security scheme from a Library model.
   * @param {Object} model Library AMF model.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for a security.
   */
  _computeSecurityLibraryModel(model, selected) {
    return this._computeDeclById(model, selected);
  }
  /**
   * Computes Type definition from a Library model.
   * @param {Object} model Library AMF model.
   * @param {String} selected Currently selected `@id`.
   * @return {Object|undefined} Model definition for a type.
   */
  _computeTypeLibraryModel(model, selected) {
    return this._computeDeclById(model, selected);
  }
  /**
   * Extracts security model from security scheme fragment and sets current selection
   * and the model.
   * @param {Object} model Security scheme fragment model
   */
  _processSecurityFragment(model) {
    this.__processFragment(model, 'security');
  }
  /**
   * Extracts documentation model from documentation fragment and sets current selection
   * and the model.
   * @param {Object} model Documentation fragment model
   */
  _processDocumentationFragment(model) {
    this.__processFragment(model, 'documentation');
  }
  /**
   * Extracts Type model from Type fragment and sets current selection
   * and the model.
   * @param {Object} model Type fragment model
   */
  _processTypeFragment(model) {
    this.__processFragment(model, 'type');
  }
  /**
   * Processes fragment model and sets current selection and the model.
   * @param {Object} model RAML fragment model
   * @param {String} selectedType Currently selected type.
   */
  __processFragment(model, selectedType) {
    const result = this._computeEncodes(model);
    this._docsModel = result;
    this._viewType = selectedType;
  }

  _processDocumentationParial(model) {
    this._docsModel = model;
    this._viewType = 'documentation';
  }

  _processSecurityParial(model) {
    this._docsModel = model;
    this._viewType = 'security';
  }

  _processTypeParial(model) {
    this._docsModel = model;
    this._viewType = 'type';
  }
  /**
   * Processes endpoint data from partial model definitnion.
   * It sets models that are used by the docs.
   *
   * If `selected` or `selectedType` is not set then it automatically selects
   * an endpoint.
   * @param {Object} model Partial model for endpoints
   */
  _processEndpointParial(model) {
    let { selected, selectedType, inlineMethods } = this;
    if (!selectedType || inlineMethods) {
      selectedType = 'endpoint';
    }
    this._endpoint = model;
    if (!inlineMethods && selectedType === 'method') {
      model = this._computeMethodPartialEndpoint(model, selected);
    }
    this._docsModel = model;
    this._viewType = selectedType;
  }
  /**
   * Creates a link model that is accepted by the endpoint documentation
   * view.
   * @param {?Object} item An AMF shape to use to get the data from.
   * @return {Object|undefined} Object with `label` and `id` or `undefined`
   * if no item.
   */
  _computeEndpointLink(item) {
    if (!item) {
      return;
    }
    let name = this._getValue(item, this.ns.schema.schemaName);
    if (!name) {
      name = this._getValue(item, this.ns.raml.vocabularies.http + 'path');
    }
    return {
      id: item['@id'],
      label: name
    };
  }
  /**
   * Computes link model for previous endpoint, if any exists relative to
   * current selection.
   * @param {Object} model Web API AMF model
   * @param {String} selected Currently selected endpoint
   * @return {Object|undefined} Object with `label` and `id` or `undefined`
   * if no previous item.
   * @param {?Boolean} lookupMethods When set it looks for the ID in methods array.
   */
  _computeEndpointPrevious(model, selected, lookupMethods) {
    if (!model || !selected) {
      return;
    }
    if (this._hasType(model, this.ns.raml.vocabularies.http + 'EndPoint')) {
      return;
    }
    const webApi = this._computeWebApi(model);
    if (!webApi) {
      return;
    }
    const ekey = this._getAmfKey(this.ns.raml.vocabularies.http + 'endpoint');
    const endpoints = this._ensureArray(webApi[ekey]);
    if (!endpoints) {
      return;
    }
    for (let i = 0; i < endpoints.length; i++) {
      const endpoint = endpoints[i];
      if (endpoint['@id'] === selected) {
        return this._computeEndpointLink(endpoints[i - 1]);
      }
      if (!lookupMethods) {
        continue;
      }
      const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
      const methods = this._ensureArray(endpoint[key]);
      if (!methods) {
        continue;
      }
      for (let j = 0; j < methods.length; j++) {
        if (methods[j]['@id'] === selected) {
          return this._computeEndpointLink(endpoints[i - 1]);
        }
      }
    }
  }
  /**
   * Computes link model for next endpoint, if any exists relative to
   * current selection.
   * @param {Object} model WebApi shape object of AMF
   * @param {String} selected Currently selected endpoint
   * @return {Object|undefined} Object with `label` and `id` or `undefined`
   * if no next item.
   * @param {?Boolean} lookupMethods When set it looks for the ID in methods array.
   */
  _computeEndpointNext(model, selected, lookupMethods) {
    if (!model || !selected) {
      return;
    }
    if (this._hasType(model, this.ns.raml.vocabularies.http + 'EndPoint')) {
      return;
    }
    const webApi = this._computeWebApi(model);
    if (!webApi) {
      return;
    }
    const ekey = this._getAmfKey(this.ns.raml.vocabularies.http + 'endpoint');
    const endpoints = this._ensureArray(webApi[ekey]);
    if (!endpoints) {
      return;
    }
    for (let i = 0; i < endpoints.length; i++) {
      const endpoint = endpoints[i];
      if (endpoint['@id'] === selected) {
        return this._computeEndpointLink(endpoints[i + 1]);
      }
      if (!lookupMethods) {
        continue;
      }
      const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
      const methods = this._ensureArray(endpoint[key]);
      if (!methods) {
        continue;
      }
      for (let j = 0; j < methods.length; j++) {
        if (methods[j]['@id'] === selected) {
          return this._computeEndpointLink(endpoints[i + 1]);
        }
      }
    }
  }
  /**
   * Creates a link model that is accepted by the method documentation
   * view.
   * @param {?Object} item An AMF shape to use to get the data from.
   * @return {Object|undefined} Object with `label` and `id` or `undefined`
   * if no item.
   */
  _computeMethodLink(item) {
    if (!item) {
      return;
    }
    let name = this._getValue(item, this.ns.schema.schemaName);
    if (!name) {
      name = this._getValue(item, this.ns.w3.hydra.core + 'method');
    }
    return {
      id: item['@id'],
      label: name
    };
  }
  /**
   * Computes link for the previous method.
   * This is used by the method documentation panel to render previous
   * nethod link.
   * @param {Object} model WebApi shape object of AMF
   * @param {String} selected Currently selected method
   * @return {Object|undefined} Object with `label` and `id` or `undefined`
   * if no previous item.
   */
  _computeMethodPrevious(model, selected) {
    let methods;
    if (this._hasType(model, this.ns.raml.vocabularies.http + 'EndPoint')) {
      const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
      methods = this._ensureArray(model[key]);
    } else {
      const webApi = this._computeWebApi(model);
      methods = this.__computeMethodsListForMethod(webApi, selected);
    }
    if (!methods) {
      return;
    }
    for (let i = 0; i < methods.length; i++) {
      if (methods[i]['@id'] === selected) {
        return this._computeMethodLink(methods[i - 1]);
      }
    }
  }
  /**
   * Computes link for the next method.
   * This is used by the method documentation panel to render next
   * nethod link.
   * @param {Object} model WebApi shape object of AMF
   * @param {String} selected Currently selected method
   * @return {Object|undefined} Object with `label` and `id` or `undefined`
   * if no next item.
   */
  _computeMethodNext(model, selected) {
    let methods;
    if (this._hasType(model, this.ns.raml.vocabularies.http + 'EndPoint')) {
      const key = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
      methods = this._ensureArray(model[key]);
    } else {
      const webApi = this._computeWebApi(model);
      methods = this.__computeMethodsListForMethod(webApi, selected);
    }
    if (!methods) {
      return;
    }
    for (let i = 0; i < methods.length; i++) {
      if (methods[i]['@id'] === selected) {
        return this._computeMethodLink(methods[i + 1]);
      }
    }
  }
  /**
   * Computes method definition from an endpoint partial model.
   * @param {Object} api Endpoint partial model
   * @param {String} selected Currently selected ID.
   * @return {Object|undefined} Method model.
   */
  _computeMethodPartialEndpoint(api, selected) {
    const opKey = this._getAmfKey(this.ns.w3.hydra.supportedOperation);
    const ops = this._ensureArray(api[opKey]);
    if (!ops) {
      return;
    }
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      if (op['@id'] === selected) {
        return op;
      }
    }
  }
  /**
   * Tests if `model` is of a RAML library model.
   * @param {Object|Array} model A shape to test
   * @return {Boolean}
   */
  _isLibrary(model) {
    if (!model) {
      return false;
    }
    if (model instanceof Array) {
      model = model[0];
    }
    if (!model['@type']) {
      return;
    }
    const moduleKey = this._getAmfKey(this.ns.raml.vocabularies.document + 'Module');
    return moduleKey === model['@type'][0];
  }
  /**
   * Computes a security model from a reference (library for example).
   * @param {Object|Array} reference AMF model for a reference to extract the data from
   * @param {String} selected Node ID to look for
   * @return {Object|undefined} Type definition or undefined if not found.
   */
  _computeReferenceSecurity(reference, selected) {
    const declare = this._computeDeclares(reference);
    if (!declare) {
      return;
    }
    let result = declare.find((item) => {
      if (item instanceof Array) {
        item = item[0];
      }
      return item['@id'] === selected;
    });
    if (result instanceof Array) {
      result = result[0];
    }
    return this._resolve(result);
  }
  /**
   * Computes model of a shape defined ni `declares` list
   * @param {Object} model AMF model
   * @param {String} selected Current selection
   * @return {Object|undefined}
   */
  _computeDeclById(model, selected) {
    const declares = this._computeDeclares(model);
    if (!declares) {
      return;
    }
    return declares.find((item) => item['@id'] === selected);
  }

  _isTypeFragment(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.raml.vocabularies.document + 'DataType');
  }

  _isTypePartialModel(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.raml.vocabularies.document + 'DomainElement');
  }

  _isSecurityFragment(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.raml.vocabularies.document + 'SecuritySchemeFragment');
  }

  _isSecurityPartialModel(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.raml.vocabularies.security + 'SecurityScheme');
  }

  _isDocumentationFragment(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.raml.vocabularies.document + 'UserDocumentation');
  }

  _isDocumentationPartialModel(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.schema.creativeWork);
  }

  _isEndpointPartialModel(model) {
    /* istanbul ignore if */
    if (model instanceof Array) {
      model = model[0];
    }
    return this._hasType(model, this.ns.raml.vocabularies.http + 'EndPoint');
  }
  /**
   * Computes API's media types when requesting type documentation view.
   * This is passed to the type documentation to render examples in the type
   * according to API's defined media type.
   *
   * @param {Object} model API model.
   * @return {Array<String>|undefined} List of supported media types or undefined.
   */
  _computeApiMediaTypes(model) {
    if (model instanceof Array) {
      model = model[0];
    }
    let webApi = this._computeWebApi(model);
    if (!webApi) {
      return;
    }
    if (webApi instanceof Array) {
      webApi = webApi[0];
    }
    const key = this._getAmfKey(this.ns.raml.vocabularies.http + 'accepts');
    const value = this._ensureArray(webApi[key]);
    if (value) {
      return value.map((item) => item['@value']);
    }
  }

  _apiChanged(e) {
    this.amf = e.detail.value;
  }
}
window.customElements.define('api-documentation', ApiDocumentation);
