<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
    <title>api-body-editor test</title>
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../iron-test-helpers/mock-interactions.html">
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <link rel="import" href="../api-body-editor.html">
  </head>
  <body>
    <test-fixture id="Basic">
      <template>
        <api-body-editor></api-body-editor>
      </template>
    </test-fixture>
    <script>
      /* global MockInteractions */
      suite('Initialization', () => {
        let element;
        suiteSetup((done) => {
          element = fixture('Basic');
          flush(() => done());
        });

        test('Default selection is raw panel', () => {
          assert.equal(element.selected, 0);
        });

        test('Initializes RAW editor when no data', () => {
          const current = element.currentPanel;
          assert.equal(current.nodeName, 'RAW-PAYLOAD-EDITOR');
        });

        test('Value is empty', () => {
          assert.equal(element.value, '');
        });

        test('Content type is not set', () => {
          assert.isUndefined(element.contentType);
        });

        test('hasAmfBody is false', () => {
          assert.isFalse(element.hasAmfBody);
        });

        test('editorSelectorHidden is true', () => {
          assert.isTrue(element.editorSelectorHidden);
        });

        test('Editor type selector is rendered', () => {
          const selector = element.shadowRoot.querySelector('paper-dropdown-menu.type');
          assert.ok(selector);
        });

        ['raw', 'urlencode', 'multipart', 'file'].forEach((type) => {
          test(`Editor type "${type}" is rendered`, () => {
            const node = element.shadowRoot.querySelector(`paper-item[data-source="${type}"]`);
            assert.ok(node);
          });
        });

        test('content-type-selector is rendered', () => {
          const node = element.shadowRoot.querySelector('content-type-selector');
          assert.ok(node);
        });

        test('AMF types selector is not renered', () => {
          const node = element.shadowRoot.querySelector('.amf-types');
          assert.notOk(node);
        });
      });

      suite('_renderAllEditors()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          element.noTextInput = true;
          element.noFormData = true;
          element.noMultipart = true;
          element.noFile = true;
          flush(() => done());
        });

        ['noTextInput', 'noFormData', 'noMultipart', 'noFile']
        .forEach((key) => {
          test(`Sets ${key} true`, () => {
            assert.isTrue(element[key]);
          });
        });
      });

      suite('_copyToClipboard()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          element.selected = 0;
          element.value = 'test';
          flush(() => done());
        });

        test('Calls _copyToClipboard()', () => {
          const button = element.shadowRoot.querySelector('.copy-action');
          const spy = sinon.spy(element, '_copyToClipboard');
          MockInteractions.tap(button);
          assert.isTrue(spy.called);
        });

        test('Changes the icon', () => {
          const button = element.shadowRoot.querySelector('.copy-action');
          MockInteractions.tap(button);
          assert.notEqual(button.icon, 'arc:content-copy');
        });

        test('Restores the icon', (done) => {
          const button = element.shadowRoot.querySelector('.copy-action');
          MockInteractions.tap(button);
          setTimeout(() => {
            assert.equal(button.icon, 'arc:content-copy');
            done();
          }, 1001);
        });
      });

      suite('_typeSelectedChanged()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          element.selected = 0;
          element.value = 'test';
          flush(() => done());
        });

        test('Calls _notifyContentTypeChange()', () => {
          const spy = sinon.spy(element, '_notifyContentTypeChange');
          element._typeSelectedChanged({
            detail: {
              value: 'application/json'
            }
          });
          assert.isTrue(spy.called);
        });

        test('Does nothing when no value', () => {
          const spy = sinon.spy(element, '_notifyContentTypeChange');
          element._typeSelectedChanged({
            detail: {}
          });
          assert.isFalse(spy.called);
        });
      });

      suite('_notifyContentTypeChange()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          element.selected = 0;
          element.value = 'test';
          flush(() => done());
        });

        test('Dispatches "content-type-changed" event', () => {
          const spy = sinon.spy();
          element.addEventListener('content-type-changed', spy);
          element._notifyContentTypeChange('test-ct');
          assert.isTrue(spy.called);
          assert.equal(spy.args[0][0].detail.value, 'test-ct');
        });

        test('Does nothing when readony', () => {
          const spy = sinon.spy();
          element.readonly = true;
          element.addEventListener('content-type-changed', spy);
          element._notifyContentTypeChange('test-ct');
          assert.isFalse(spy.called);
        });
      });

      suite('refreshPanel()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          element.selected = 1;
          element.value = 'a=b';
          flush(() => done());
        });

        test('Refreshes state of raw panel', (done) => {
          element.selected = 0;
          flush(() => {
            element.refreshPanel();
            const panel = element.currentPanel;
            const cm = panel.shadowRoot.querySelector('code-mirror');
            const v = cm.editor.getValue();
            assert.equal(v, 'a=b');
            done();
          });
        });

        test('Does nothing for other panels', () => {
          element.refreshPanel();
          // no error by calling `.refresh()` on the panel.
        });
      });
    </script>
  </body>
</html>
